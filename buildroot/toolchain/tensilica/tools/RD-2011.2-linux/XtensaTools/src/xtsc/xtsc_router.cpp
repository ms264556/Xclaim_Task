// Copyright (c) 2005-2010 by Tensilica Inc.  ALL RIGHTS RESERVED.
// These coded instructions, statements, and computer programs are the
// copyrighted works and confidential proprietary information of Tensilica Inc.
// They may not be modified, copied, reproduced, distributed, or disclosed to
// third parties in any manner, medium, or form, in whole or in part, without
// the prior written consent of Tensilica Inc.


#include <cerrno>
#include <algorithm>
#include <ostream>
#include <string>
#include <xtsc/xtsc_router.h>
#include <xtsc/xtsc_arbiter.h>
#include <xtsc/xtsc_core.h>
#include <xtsc/xtsc_dma_engine.h>
#include <xtsc/xtsc_master.h>
#include <xtsc/xtsc_memory_trace.h>
#include <xtsc/xtsc_pin2tlm_memory_transactor.h>
#include <xtsc/xtsc_logging.h>

/*
 *  Theory of Operation
 *  
 *  Incoming requests are received in the nb_request() method.  Typically a copy is made
 *  of the request which is then added to m_request_fifo and m_router_thread_event is
 *  notified.  When not operating as a PIF width converter (PWC), this event is handled
 *  by router_thread and when operating as a PWC it is handled by router_pwc_thread.
 *
 *  Incoming responses are received in the nb_respond() method.  Typically a copy is
 *  made of the response which is then added to the appropriate FIFO (base on port) in
 *  the m_response_fifos array and the m_response_arbiter_thread_event is notified.
 *  When not operating as a PWC, this event is handled by response_arbiter_thread and
 *  when operating as a PWC it is handled by response_arbiter_pwc_thread.
 *
 *  When "immediate_timing" is true, the threads are not used ("immediate_timing" must
 *  be false when operating as a PWC)
 *
 *  PWC Operation
 *
 *  If a request is received whose downstream PIF has the same width as the upstream
 *  PIF, then the request is passed downstream unchanged.  Otherwise, the
 *  convert_request() method is called to perform all required conversions, including
 *  combining multiple requests into a single request, converting a single request into
 *  multiple requests, and changing the request type (i.e from a block request to a
 *  non-block request or vice-versa) and various other fields of the request.
 *
 *  If a response is received from a downstream PIF which has the same width as the
 *  upstream PIF, then the response is passed upstream unchanged.  Otherwise, the
 *  convert_response() method is called to perform all required conversions, including
 *  combining multiple responses into a single response and converting a single response
 *  into multiple responses.
 *
 *  When a response comes in on a PIF interface that is not the same width as the master
 *  PIF, then the response has to be match up to the original request so that the
 *  necessary conversions can be made to the response.  The router uses the request and
 *  response ID fields to enable this match-up and so has to reassign the request ID in
 *  requests sent downstream to ensure uniqueness (of course, the original request ID
 *  has to be used for the responses sent back upstream).
 *
 *  The main structures associated with PWC operation are:
 *
 *  1) class req_rsp_info: This class holds the state information necessary for the
 *     entire sequence from the receipt of the request (or the first transfer of a
 *     BLOCK_WRITE or RCW request) until the response (or last response if BLOCK_READ)
 *     is sent back upstream.  
 *
 *  2) m_req_rsp_table[]: This array holds all outstanding req_rsp_info objects.  It is
 *     indexed by the downstream request ID.  The downstream request ID is assigned by
 *     the get_empty_slot() method which is called for all first requests handled by the
 *     convert_request() method.
 *
 *  3) m_requests[]: This array holds all ready-to-send-downstream requests generated by
 *     the call from router_pwc_thread() to convert_request().  The array is empty when
 *     convert_request() is called and may or may not be empty when convert_request()
 *     returns.  If it is not empty, the router_pwc_thread() sends each of the requests
 *     in it downstream before clearing it and calling convert_request() again for the
 *     next incoming request.  If the array is empty, then m_p_nascent_request in
 *     req_rsp_info will point to the partially formed converted request.
 *
 *  4) m_responses[]: This array holds all ready-to-send-upstream responses generated by
 *     the call from response_arbiter_pwc_thread() to convert_response().  The array is
 *     empty when convert_response() is called and may or may not be empty when
 *     convert_response() returns.  If it is not empty, the response_arbiter_pwc_thread()
 *     sends each of the responses in it upstream before clearing it and calling
 *     convert_response() again for the next incoming response.  If the array is empty,
 *     then m_p_nascent_response in req_rsp_info will point to the partially formed
 *     converted response.
 *
 */


using namespace std;
#if SYSTEMC_VERSION >= 20050601
using namespace sc_core;
#endif
using namespace xtsc;
using log4xtensa::INFO_LOG_LEVEL;
using log4xtensa::VERBOSE_LOG_LEVEL;




xtsc_component::xtsc_router::xtsc_router(sc_module_name module_name, const xtsc_router_parms& router_parms) :
  sc_module           (module_name),
  m_request_export    ("m_request_export"),
  m_respond_port      ("m_respond_port"),
  m_request_impl      ("m_request_impl", *this),
  m_request_fifo      ("m_request_fifo", router_parms.get_non_zero_u32("request_fifo_depth")),
  m_use_block_requests(router_parms.get_bool("use_block_requests")),
  m_master_byte_width (router_parms.get_u32("master_byte_width")),
  m_read_only         (router_parms.get_bool("read_only")),
  m_write_only        (router_parms.get_bool("write_only")),
  m_num_bit_fields    (0),
  m_text              (log4xtensa::TextLogger::getInstance(name())),
  m_binary            (log4xtensa::BinaryLogger::getInstance(name()))
{

  m_words.clear();
  m_line                        = "";
  m_line_count                  = 0;
  m_next_slot                   = 0;
  m_num_slaves                  = router_parms.get_u32("num_slaves");
  m_default_port_num            = router_parms.get_u32("default_port_num");
  m_default_delta               = router_parms.get_u32("default_delta");

  m_log_data_binary             = true;

  m_delay_from_receipt          = router_parms.get_bool("delay_from_receipt");
  m_immediate_timing            = router_parms.get_bool("immediate_timing");

  // Get clock period 
  u32 clock_period = router_parms.get_u32("clock_period");
  if (clock_period == 0xFFFFFFFF) {
    m_clock_period = xtsc_get_system_clock_period();
  }
  else {
    m_clock_period = sc_get_time_resolution() * clock_period;
  }

  u32 nacc_wait_time    = router_parms.get_u32("nacc_wait_time");
  if (nacc_wait_time == 0xFFFFFFFF) {
    m_nacc_wait_time = m_clock_period;
  }
  else {
    m_nacc_wait_time = sc_get_time_resolution() * nacc_wait_time;
    if (m_nacc_wait_time > m_clock_period) {
      ostringstream oss;
      oss << "xtsc_router '" << name() << "': \"nacc_wait_time\" of " << m_nacc_wait_time << " exceeds clock period of "
          << m_clock_period;
      throw xtsc_exception(oss.str());
    }
  }

  m_request_delay       = m_clock_period * router_parms.get_u32("request_delay");
  m_response_delay      = m_clock_period * router_parms.get_u32("response_delay");
  m_response_repeat     = m_clock_period * router_parms.get_u32("response_repeat");
  m_recovery_time       = m_clock_period * router_parms.get_u32("recovery_time");

  u32 read_delay        = router_parms.get_u32("read_delay");
  u32 write_delay       = router_parms.get_u32("write_delay");

  m_read_delay          = ((read_delay  == 0xFFFFFFFF) ? m_request_delay : (m_clock_period * read_delay));
  m_write_delay         = ((write_delay == 0xFFFFFFFF) ? m_request_delay : (m_clock_period * write_delay));

  m_slave_byte_widths = router_parms.get_u32_vector("slave_byte_widths");
  m_is_pwc = (m_slave_byte_widths.size() != 0);
  if (m_is_pwc) {
    if (m_immediate_timing) {
      ostringstream oss;
      oss << "xtsc_router '" << name() << "': \"immediate_timing\" must be false if \"slave_byte_widths\" is set";
      throw xtsc_exception(oss.str());
    }
    if (m_slave_byte_widths.size() != m_num_slaves) {
      ostringstream oss;
      oss << "xtsc_router '" << name() << "': size of \"slave_byte_widths\" (" << m_slave_byte_widths.size()
          << ") != \"num_slaves\" (" << m_num_slaves << ")";
      throw xtsc_exception(oss.str());
    }
    for (u32 i=0; i<m_num_slaves; ++i) {
      if ((m_slave_byte_widths[i] != 4) && (m_slave_byte_widths[i] != 8) && (m_slave_byte_widths[i] != 16)) {
        ostringstream oss;
        oss << "xtsc_router '" << name() << "': slave_byte_widths[" << i << "]=" << m_slave_byte_widths[i]
            << " which is not one of the valid values of 4|8|16.";
        throw xtsc_exception(oss.str());
      }
    }
    if ((m_master_byte_width != 4) && (m_master_byte_width != 8) && (m_master_byte_width != 16)) {
      ostringstream oss;
      oss << "xtsc_router '" << name() << "': master_byte_width=" << m_master_byte_width 
          << " which is not one of the valid non-default values of 4|8|16.";
      throw xtsc_exception(oss.str());
    }

  }

  m_request_ports = new sc_port<xtsc_request_if>*[m_num_slaves];
  for (u32 i=0; i<m_num_slaves; i++) {
    ostringstream oss;
    oss << "m_request_ports[" << i << "]";
    m_request_ports[i] = new sc_port<xtsc_request_if>(oss.str().c_str());
  }

  m_respond_exports     = new sc_export<xtsc_respond_if>*[m_num_slaves];
  m_respond_impl        = new xtsc_respond_if_impl*      [m_num_slaves];
  for (u32 i=0; i<m_num_slaves; i++) {
    ostringstream oss1;
    oss1 << "m_respond_exports[" << i << "]";
    m_respond_exports[i] = new sc_export<xtsc_respond_if>(oss1.str().c_str());
    ostringstream oss2;
    oss2 << "m_respond_impl[" << i << "]";
    m_respond_impl[i] = new xtsc_respond_if_impl(oss2.str().c_str(), *this, i);
    (*m_respond_exports[i])(*m_respond_impl[i]);
  }

  m_response_fifos = new sc_fifo<response_info*>*[m_num_slaves];
  vector<u32> response_fifo_depths = router_parms.get_u32_vector("response_fifo_depths");
  if ((response_fifo_depths.size() != 0) && (response_fifo_depths.size() != m_num_slaves)) {
    ostringstream oss;
    oss << "xtsc_router '" << name() << "': size of \"response_fifo_depths\" (" << response_fifo_depths.size()
        << ") != \"num_slaves\" (" << m_num_slaves << ")";
    throw xtsc_exception(oss.str());
  }
  u32 response_fifo_depth = router_parms.get_u32("response_fifo_depth");
  for (u32 i=0; i<m_num_slaves; i++) {
    ostringstream oss;
    oss << "m_response_fifos[" << i << "]";
    u32 depth = (response_fifo_depths.size() ? response_fifo_depths[i] : response_fifo_depth);
    if (depth == 0) {
      ostringstream oss;
      oss << "xtsc_router '" << name() << "': depth from \"response_fifo_depths\" or \"response_fifo_depth\" cannot be 0";
      throw xtsc_exception(oss.str());
    }
    m_response_fifos[i] = new sc_fifo<response_info*>(oss.str().c_str(), depth);
  }

  m_request_export(m_request_impl);

  bool default_routing = router_parms.get_bool("default_routing");
  const char *routing_table = router_parms.get_c_str("routing_table");
  m_address_routing_bits = router_parms.get_u32_vector("address_routing_bits");
  m_address_routing = (m_address_routing_bits.size() != 0);

  if (!m_address_routing && !m_is_pwc && (m_master_byte_width != 0)) {
    ostringstream oss;
    oss << "xtsc_router '" << name() << "': master_byte_width=" << m_master_byte_width 
        << " should be left at its default value of 0 unless \"address_routing_bits\" or \"slave_byte_widths\" is set";
    throw xtsc_exception(oss.str());
  }

  if (m_address_routing) {
    if ((m_master_byte_width !=  4) &&
        (m_master_byte_width !=  8) &&
        (m_master_byte_width != 16) &&
        (m_master_byte_width != 32) &&
        (m_master_byte_width != 64))
    {
      ostringstream oss;
      oss << "xtsc_router '" << name() << "': master_byte_width=" << m_master_byte_width 
          << " which is not one of the valid non-default values of 4|8|16|32|64 which may be used when also"
          << " using \"address_routing_bits\".";
      throw xtsc_exception(oss.str());
    }
    if (m_slave_byte_widths.size() != 0) {
      ostringstream oss;
      oss << "xtsc_router '" << name()
          << "' has conflicting parameters:  \"address_routing_bits\" and \"slave_byte_widths\" cannot both be set";
      throw xtsc_exception(oss.str());
    }
    if (m_use_block_requests) {
      ostringstream oss;
      oss << "xtsc_router '" << name()
          << "' has conflicting parameters:  \"address_routing_bits\" and \"use_block_requests\" cannot both be set";
      throw xtsc_exception(oss.str());
    }
    if (!default_routing) {
      ostringstream oss;
      oss << "xtsc_router '" << name()
          << "' has conflicting parameters:  If \"address_routing_bits\" is set then \"default_routing\" must be false";
      throw xtsc_exception(oss.str());
    }
    if (routing_table && routing_table[0]) {
      ostringstream oss;
      oss << "xtsc_router '" << name()
          << "' has conflicting parameters:  \"address_routing_bits\" and \"routing_table\" cannot both be set";
      throw xtsc_exception(oss.str());
    }
    if (m_default_delta != 0) {
      ostringstream oss;
      oss << "xtsc_router '" << name()
          << "' has conflicting parameters:  \"address_routing_bits\" and \"default_delta\" cannot both be set";
      throw xtsc_exception(oss.str());
    }
    if (m_default_port_num != ADDRESS_ERROR) {
      ostringstream oss;
      oss << "xtsc_router '" << name()
          << "' has conflicting parameters:  \"address_routing_bits\" and \"default_port_num\" cannot both be set";
      throw xtsc_exception(oss.str());
    }
    if ((m_address_routing_bits.size() & 0x1) != 0) {
      ostringstream oss;
      oss << "xtsc_router '" << name() << "' parameter \"address_routing_bits\" has " << m_address_routing_bits.size()
          << " entries which is not an even number as is required.";
      throw xtsc_exception(oss.str());
    }
    u32 num_slaves_log2 = 0;
    u32 mask = 1;
    for (u32 i=0; i<32; ++i) {
      if (m_num_slaves & mask) num_slaves_log2 = i;
      mask <<= 1;
    }
    if ((m_num_slaves <= 1) || ((u32) (1 << num_slaves_log2) != m_num_slaves)) {
      ostringstream oss;
      oss << "xtsc_router '" << name() << "': when parameter \"address_routing_bits\" is set then \"num_slaves\"=" << m_num_slaves
          << " must be a power of 2 greater than 1";
      throw xtsc_exception(oss.str());
    }
    u32 byte_lane_bits = (m_master_byte_width ==  4) ? 2 :
                         (m_master_byte_width ==  8) ? 3 :
                         (m_master_byte_width == 16) ? 4 :
                         (m_master_byte_width == 32) ? 5 :
                         (m_master_byte_width == 64) ? 6 : 0;
    if (byte_lane_bits == 0) {
      ostringstream oss;
      oss << "PROGRAM ERROR:  unhandled xtsc_router_parms value for \"master_byte_width\"=" << m_master_byte_width << " in "
          << __FILE__ << ":" << __LINE__;
      throw xtsc_exception(oss.str());
    }
    u32 routing_bits = 0;
    XTSC_DEBUG(m_text, "Address routing bit fields:");
    for (u32 i=0; i<m_address_routing_bits.size(); ++i) {
      if (m_address_routing_bits[i] < byte_lane_bits) {
        ostringstream oss;
        oss << "xtsc_router '" << name() << "' parameter \"address_routing_bits\" values must all be greater than or equal to " 
            << byte_lane_bits << " (= log2(\"master_byte_width\"))";
        throw xtsc_exception(oss.str());
      }
      if (m_address_routing_bits[i] >= 32) {
        ostringstream oss;
        oss << "xtsc_router '" << name() << "': values specified in the \"address_routing_bits\" parameter must all be less than 32";
        throw xtsc_exception(oss.str());
      }
      if ((i & 1) == 0) {
        u32 bit_field_bits = m_address_routing_bits[i] - m_address_routing_bits[i+1] + 1;
        routing_bits += bit_field_bits;
        u32 pre_shift = m_address_routing_bits[i+1];
        u32 mask = ((1 << bit_field_bits) - 1);
        bit_field_info *p_info = new bit_field_info(pre_shift, mask, num_slaves_log2-routing_bits);
        m_address_routing_info.push_back(p_info);
        XTSC_DEBUG(m_text, " address[" << m_address_routing_bits[i] << ":" << m_address_routing_bits[i+1] <<
                           "] => pre_shift=" << p_info->m_pre_shift <<
                           " mask=0x" << hex << setfill('0') << setw(8) << p_info->m_mask << dec <<
                           " post_shift=" << p_info->m_post_shift);
      }
    }
    if (routing_bits != num_slaves_log2) {
      ostringstream oss;
      oss << "xtsc_router '" << name() << "': the number of routing bits (=" << routing_bits
          << ") implied by the \"address_routing_bits\" parameter does not equal " << num_slaves_log2
          << " (from log2(\"num_slaves\") with \"num_slaves\"=" << m_num_slaves << ")";
      throw xtsc_exception(oss.str());
    }
    m_num_bit_fields = m_address_routing_info.size();
  }
  else if (default_routing) {

    if (routing_table && routing_table[0]) {
      // Treat routing_table as a char * file name
      m_file_name = routing_table;

      // Open the file
      m_file = new xtsc_script_file(m_file_name.c_str(), "routing_table", name(), kind(), false);

      XTSC_LOG(m_text, xtsc_get_constructor_log_level(), "Loading routing table from file '" << m_file_name << "'.");

      while ((m_line_count = m_file->get_words(m_words, m_line, true))) {

        if ((m_words.size() != 3) && (m_words.size() != 4)) {
          ostringstream oss;
          oss << "Found invalid number of words (expected 3 or 4):" << endl;
          oss << m_line;
          oss << m_file->info_for_exception();
          throw xtsc_exception(oss.str());
        }

        u32 port_num = get_u32(0);
        xtsc_address start_address8 = get_u32(1);
        xtsc_address end_address8 = get_u32(2);
        u32 delta = 0;
        if (m_words.size() == 4) {
          u32 new_base_address8 = get_u32(3);
          delta = new_base_address8 - start_address8;
        }
        if (port_num >= m_num_slaves) {
          ostringstream oss;
          if (m_num_slaves) {
            oss << "port_num=" << port_num << " is too large (max port_num=" << (m_num_slaves-1) << ")";
          }
          else {
            oss << "port_num=" << port_num << " is invalid for this null router (which has no output ports).";
          }
          oss << endl << m_line;
          oss << m_file->info_for_exception();
          throw xtsc_exception(oss.str());
        }
        vector<xtsc_address_range_entry>::const_iterator irt;
        for (irt = m_routing_table.begin(); irt != m_routing_table.end(); ++irt) {
          if ((((irt->m_start_address8 >= start_address8) && (irt->m_start_address8 <= end_address8)) ||
               ((irt->m_end_address8   >= start_address8) && (irt->m_end_address8   <= end_address8))) &&
              ((irt->m_port_num != port_num) || (irt->m_delta != delta)))
          {
            ostringstream oss;
            oss << "Routing table entry overlaps earlier routing table entry but port numbers or address translations do not match."
                << endl;
            oss << "Earlier entry:  " << irt->m_port_num << " 0x" << hex << irt->m_start_address8 << " 0x"
                << irt->m_end_address8 << " 0x" << (irt->m_start_address8 + irt->m_delta) << endl;
            oss << "Current entry:  " <<        port_num << " 0x" << hex <<        start_address8 << " 0x"
                <<        end_address8 << " 0x" << (       start_address8 +        delta) << endl;
            oss << m_line;
            oss << m_file->info_for_exception();
            throw xtsc_exception(oss.str());
          }
        }
        XTSC_LOG(m_text, xtsc_get_constructor_log_level(), "0x" << hex << port_num << ": 0x" << start_address8 <<
                                                           "-0x" << end_address8 << " delta=0x" << delta);
        xtsc_address_range_entry entry(start_address8, end_address8, port_num, delta);
        m_routing_table.push_back(entry);
      }

    }
    else {
      if (m_num_slaves) {
        u64 max_memory_size = 0x100000000LL;
        u64 aperture_size = max_memory_size / m_num_slaves;
        if ((aperture_size * m_num_slaves) != max_memory_size) {
          ostringstream oss;
          oss << "xtsc_router '" << name()
              << "': To use default routing requires that the number of slaves be a power of 2: m_num_slaves=" << m_num_slaves;
          throw xtsc_exception(oss.str());
        }
        XTSC_LOG(m_text, xtsc_get_constructor_log_level(), "Creating routing table with " << m_num_slaves <<
                                                            " equally sized memory apertures of 0x" << hex <<
                                                            aperture_size << " bytes");
        xtsc_address smallest_next_address = 0;
        for (u32 i=0; i< m_num_slaves; i++) {
          xtsc_address_range_entry entry(smallest_next_address, (xtsc_address)(smallest_next_address+aperture_size-1), i,
                                         m_default_delta);
          m_routing_table.push_back(entry);
          smallest_next_address = (xtsc_address) (smallest_next_address + aperture_size);
        }
      }
    }

  }

  if (!m_immediate_timing) {
    if (m_is_pwc) {
      SC_THREAD(router_pwc_thread);
    }
    else {
      SC_THREAD(router_thread);
    }
  }

  if (!m_immediate_timing && m_num_slaves) {
    if (m_is_pwc) {
      SC_THREAD(response_arbiter_pwc_thread);
    }
    else {
      SC_THREAD(response_arbiter_thread);
    }
  }

  log4xtensa::LogLevel ll = xtsc_get_constructor_log_level();
  XTSC_LOG(m_text, ll,        "Constructed xtsc_router '" << name() << "':");
  XTSC_LOG(m_text, ll,        " num_slaves              = "   << m_num_slaves);
  { ostringstream oss; if (m_is_pwc) for (u32 i=0; i<m_num_slaves; ++i) oss << (i ? "," : "") << m_slave_byte_widths[i];
  XTSC_LOG(m_text, ll,        " slave_byte_widths       = "   << oss.str());
  }
  if (m_is_pwc || m_address_routing) {
  XTSC_LOG(m_text, ll,        " master_byte_width       = "   << m_master_byte_width);
  }
  if (m_is_pwc) {
  XTSC_LOG(m_text, ll,        " use_block_requests      = "   << boolalpha << m_use_block_requests);
  }
  XTSC_LOG(m_text, ll,        " default_routing         = "   << boolalpha << default_routing);
  XTSC_LOG(m_text, ll,        " routing_table           = "   << (routing_table ? routing_table : ""));
  XTSC_LOG(m_text, ll, hex << " default_port_num        = 0x" << m_default_port_num);
  XTSC_LOG(m_text, ll, hex << " default_delta           = 0x" << m_default_delta);
  { ostringstream oss; for (u32 i=0; i<m_address_routing_bits.size(); ++i) oss << (i ? "," : "") << m_address_routing_bits[i];
  XTSC_LOG(m_text, ll,        " address_routing_bits    = "   << oss.str());
  }
  XTSC_LOG(m_text, ll,        " read_only               = "   << boolalpha << m_read_only);
  XTSC_LOG(m_text, ll,        " write_only              = "   << boolalpha << m_write_only);
  XTSC_LOG(m_text, ll,        " immediate_timing        = "   << boolalpha << m_immediate_timing);
  if (!m_immediate_timing) {
  if (clock_period == 0xFFFFFFFF) {
  XTSC_LOG(m_text, ll, hex << " clock_period            = 0x" << clock_period << " (" << m_clock_period << ")");
  } else {
  XTSC_LOG(m_text, ll,        " clock_period            = "   << clock_period << " (" << m_clock_period << ")");
  }
  XTSC_LOG(m_text, ll,        " delay_from_receipt      = "   << boolalpha << m_delay_from_receipt);
  XTSC_LOG(m_text, ll,        " request_delay           = "   << router_parms.get_u32("request_delay"));
  if (read_delay == 0xFFFFFFFF) {
  XTSC_LOG(m_text, ll, hex << " read_delay              = 0x" << read_delay << " (" << m_read_delay << ")");
  } else {
  XTSC_LOG(m_text, ll,        " read_delay              = "   << read_delay << " (" << m_read_delay << ")");
  }
  if (write_delay == 0xFFFFFFFF) {
  XTSC_LOG(m_text, ll, hex << " write_delay             = 0x" << write_delay << " (" << m_write_delay << ")");
  } else {
  XTSC_LOG(m_text, ll,        " write_delay             = "   << write_delay << " (" << m_write_delay << ")");
  }
  if (nacc_wait_time == 0xFFFFFFFF) {
  XTSC_LOG(m_text, ll, hex << " nacc_wait_time          = 0x" << nacc_wait_time << " (" << m_nacc_wait_time << ")");
  } else {
  XTSC_LOG(m_text, ll,        " nacc_wait_time          = "   << nacc_wait_time << " (" << m_nacc_wait_time << ")");
  }
  XTSC_LOG(m_text, ll,        " response_delay          = "   << router_parms.get_u32("response_delay"));
  XTSC_LOG(m_text, ll,        " response_repeat         = "   << router_parms.get_u32("response_repeat"));
  XTSC_LOG(m_text, ll,        " recovery_time           = "   << router_parms.get_u32("recovery_time"));
  XTSC_LOG(m_text, ll,        " request_fifo_depth      = "   << router_parms.get_u32("request_fifo_depth"));
  XTSC_LOG(m_text, ll,        " response_fifo_depth     = "   << router_parms.get_u32("response_fifo_depth"));
  { ostringstream oss; for (u32 i=0; i<response_fifo_depths.size(); i++) { oss << (i ? "," : "") << response_fifo_depths[i]; }
  XTSC_LOG(m_text, ll,        " response_fifo_depths    = "   << oss.str());
  }
  }

  if (m_is_pwc) {
    for (u32 i=0; i<4; ++i) {
      m_requests[i] = NULL;
      m_responses[i] = NULL;
    }
  }

  reset(true);

}



xtsc_component::xtsc_router::~xtsc_router(void) {

  if (m_request_ports) {
    for (u32 i=0; i<m_num_slaves; i++) {
      if (m_request_ports[i]) {
        delete m_request_ports[i];
        m_request_ports[i] = 0;
      }
    }
    delete [] m_request_ports;
    m_request_ports = 0;
  }

  if (m_respond_exports) {
    for (u32 i=0; i<m_num_slaves; i++) {
      if (m_respond_exports[i]) {
        delete m_respond_exports[i];
        m_respond_exports[i] = 0;
      }
    }
    delete [] m_respond_exports;
    m_respond_exports = 0;
  }

  if (m_response_fifos) {
    for (u32 i=0; i<m_num_slaves; i++) {
      if (m_response_fifos[i]) {
        delete m_response_fifos[i];
        m_response_fifos[i] = 0;
      }
    }
    delete [] m_response_fifos;
    m_response_fifos = 0;
  }


}



void xtsc_component::xtsc_router::reset(bool /*hard_reset*/) {
  XTSC_INFO(m_text, "xtsc_router::reset()");

  m_lock                        = false;
  m_token                       = m_num_slaves - 1;
  m_waiting_for_nacc            = false;
  m_request_got_nacc            = false;
  m_last_request_time_stamp     = SC_ZERO_TIME - (m_delay_from_receipt ? m_recovery_time : m_request_delay);
  m_last_response_time_stamp    = SC_ZERO_TIME - (m_delay_from_receipt ? m_recovery_time : m_request_delay);

  if (m_is_pwc) {
    m_pending_request_id        = m_num_slots;  // Indicates there is no pending request
    m_active_block_read_id      = m_num_slots;  // Indicates no BLOCK_READ response is in progress
    for (u8 i=0; i<m_num_slots; ++i) {
      m_req_rsp_table[i] = NULL;
    }
    for (u32 i=0; (m_requests[i] != NULL) && (i<4); ++i) {
      delete_request_info(m_requests[i]);
    }
    for (u32 i=0; (m_responses[i] != NULL) && (i<4); ++i) {
      delete_response_info(m_responses[i]);
    }
  }
}



void xtsc_component::xtsc_router::connect(xtsc_arbiter& arbiter) {
  arbiter.m_request_port(m_request_export);
  m_respond_port(arbiter.m_respond_export);
}



void xtsc_component::xtsc_router::connect(xtsc_cohctrl& cohctrl, xtsc_cohctrl::port_type type, u32 cohctrl_port, u32 router_port) {
  u32 num_clients = cohctrl.get_num_clients();
  if ((type == xtsc_cohctrl::PT_CLIENT) && (router_port >= m_num_slaves)) {
    ostringstream oss;
    oss << kind() << " '" << name() << "':  Invalid router_port specified to xtsc_router::connect():  router_port=" << router_port;
    oss << ".  Valid range is 0 to " << (m_num_slaves - 1) << ".";
    throw xtsc_exception(oss.str());
  }
  if ((type != xtsc_cohctrl::PT_MEMORY) && (cohctrl_port >= num_clients)) {
    ostringstream oss;
    oss << "Invalid cohctrl_port=" << cohctrl_port << " in connect(): " << endl;
    oss << cohctrl.kind() << " '" << cohctrl.name() << "' has " << num_clients
        << " ports numbered from 0 to " << num_clients-1 << endl;
    throw xtsc_exception(oss.str());
  }
  if (type == xtsc_cohctrl::PT_SNOOP) {
    (*cohctrl.m_snoop_ports[cohctrl_port])(m_request_export);
    m_respond_port(*cohctrl.m_snoop_exports[cohctrl_port]);
  }
  else if (type == xtsc_cohctrl::PT_MEMORY) {
    cohctrl.m_request_port(m_request_export);
    m_respond_port(cohctrl.m_respond_export);
  }
  else if (type == xtsc_cohctrl::PT_CLIENT) {
    (*m_request_ports[router_port])(*cohctrl.m_client_exports[cohctrl_port]);
    (*cohctrl.m_client_ports[cohctrl_port])((*m_respond_exports[router_port]));
  }
  else {
    ostringstream oss;
    oss << kind() << " '" << name() << "':  Invalid xtsc_cohctrl::port_type specified to xtsc_router::connect()";
    throw xtsc_exception(oss.str());
  }
}



void xtsc_component::xtsc_router::connect(xtsc_core& core, const char *memory_port_name, u32 port_num) {
  string lc = (memory_port_name ? memory_port_name : "");
  transform(lc.begin(), lc.end(), lc.begin(), ::tolower);
  if (lc == "inbound_pif" || lc == "snoop") {
    if (port_num >= m_num_slaves) {
      ostringstream oss;
      oss << "xtsc_router '" << name() << "':  Invalid port_num specified to xtsc_router::connect():  port_num=" << port_num;
      if (m_num_slaves) {
        oss << ".  Valid range is 0 to " << (m_num_slaves - 1) << ".";
      }
      else {
        oss << ".  This router has no slave ports.";
      }
      throw xtsc_exception(oss.str());
    }
    (*m_request_ports[port_num])(core.get_request_export(memory_port_name));
    core.get_respond_port(memory_port_name)(*m_respond_exports[port_num]);
  }
  else {
    core.get_request_port(memory_port_name)(m_request_export);
    m_respond_port(core.get_respond_export(memory_port_name));
  }
}



void xtsc_component::xtsc_router::connect(xtsc_dma_engine& dma_engine) {
  dma_engine.m_request_port(m_request_export);
  m_respond_port(dma_engine.m_respond_export);
}



void xtsc_component::xtsc_router::connect(xtsc_master& master) {
  master.m_request_port(m_request_export);
  m_respond_port(master.m_respond_export);
}



void xtsc_component::xtsc_router::connect(xtsc_memory_trace& memory_trace, u32 port_num) {
  u32 num_ports = memory_trace.get_num_ports();
  if (port_num >= num_ports) {
    ostringstream oss;
    oss << "Invalid port_num=" << port_num << " in connect(): " << endl;
    oss << memory_trace.kind() << " '" << memory_trace.name() << "' has " << num_ports << " ports numbered from 0 to "
        << num_ports-1 << endl;
    throw xtsc_exception(oss.str());
  }
  (*memory_trace.m_request_ports[port_num])(m_request_export);
  m_respond_port(*memory_trace.m_respond_exports[port_num]);
}



void xtsc_component::xtsc_router::connect(xtsc_router& router, u32 port_num) {
  u32 num_slaves = router.get_num_slaves();
  if (port_num >= num_slaves) {
    ostringstream oss;
    oss << "Invalid port_num=" << port_num << " in connect(): " << endl;
    oss << router.kind() << " '" << router.name() << "' has " << num_slaves << " ports numbered from 0 to " << num_slaves-1 << endl;
    throw xtsc_exception(oss.str());
  }
  (*router.m_request_ports[port_num])(m_request_export);
  m_respond_port(*router.m_respond_exports[port_num]);
}



void xtsc_component::xtsc_router::connect(xtsc_pin2tlm_memory_transactor& pin2tlm, u32 port_num) {
  u32 num_slaves = pin2tlm.get_num_ports();
  if (port_num >= num_slaves) {
    ostringstream oss;
    oss << "Invalid port_num=" << port_num << " in connect(): " << endl;
    oss << pin2tlm.kind() << " '" << pin2tlm.name() << "' has " << num_slaves << " ports numbered from 0 to " << num_slaves-1 << endl;
    throw xtsc_exception(oss.str());
  }
  (*pin2tlm.m_request_ports[port_num])(m_request_export);
  m_respond_port(*pin2tlm.m_respond_exports[port_num]);
}



void xtsc_component::xtsc_router::router_thread(void) {
  request_info *p_request_info = NULL;

  try {

    while (true) {
      wait(m_router_thread_event);
      XTSC_DEBUG(m_text, "router_thread woke up.");
      while (m_request_fifo.num_available()) {
        // Get our current transaction
        m_request_fifo.nb_read(p_request_info);
        XTSC_DEBUG(m_text, "router_thread() got: " << p_request_info->m_request);
        // Calculate delay (net => No Earlier Than time)
        xtsc_request::type_t type = p_request_info->m_request.get_type();
        sc_time req_delay         = ((type == xtsc_request::READ) ||
                                     (type == xtsc_request::BLOCK_READ) ||
                                     (type == xtsc_request::BURST_READ) ||
                                     (type == xtsc_request::SNOOP)) ? m_read_delay : m_write_delay;
        sc_time receipt_net       = p_request_info->m_time_stamp + req_delay;
        sc_time last_request_net  = m_last_request_time_stamp + (m_delay_from_receipt ? m_recovery_time : req_delay);
        sc_time latest_net        = (receipt_net > last_request_net) ? receipt_net : last_request_net;
        sc_time now               = sc_time_stamp();
        sc_time delay = (latest_net <= now) ? SC_ZERO_TIME : (latest_net - now);
        XTSC_DEBUG(m_text, "router_thread() doing wait for " << delay);
        wait(delay);
        handle_request(p_request_info);
        delete_request_info(p_request_info);
      }
    }

  }
  catch (const exception& error) {
    ostringstream oss;
    oss << "std::exception caught in router_thread of " << kind() << " '" << name() << "'." << endl;
    oss << "what(): " << error.what() << endl;
    xtsc_log_multiline(m_text, log4xtensa::FATAL_LOG_LEVEL, oss.str(), 2);
    throw;
  }

}



// When acting as PIF width converter (pwc)
void xtsc_component::xtsc_router::router_pwc_thread(void) {

  try {

    while (true) {
      wait(m_router_thread_event);
      XTSC_DEBUG(m_text, "router_pwc_thread woke up.");
      while (m_request_fifo.num_available()) {
        // Get our current transaction
        request_info *p_request_info = NULL;
        m_request_fifo.nb_read(p_request_info);
        XTSC_DEBUG(m_text, "router_pwc_thread() got: " << p_request_info->m_request);

        xtsc_address    dummy            = p_request_info->m_request.get_byte_address();
        u32             port_num         = get_port_and_apply_address_translation(dummy);
        u32             slave_byte_width = (port_num >= m_num_slaves) ? m_master_byte_width : m_slave_byte_widths[port_num];

        if (m_master_byte_width == slave_byte_width) {
          m_requests[0] = p_request_info;
        }
        else {
          convert_request(p_request_info, slave_byte_width);
        }

        for (u32 i=0; (m_requests[i] != NULL) && (i<4); ++i) {
          // Calculate delay (net => No Earlier Than time)
          xtsc_request::type_t type = m_requests[i]->m_request.get_type();
          sc_time req_delay         = ((type == xtsc_request::READ) ||
                                       (type == xtsc_request::BLOCK_READ) ||
                                       (type == xtsc_request::BURST_READ) ||
                                       (type == xtsc_request::SNOOP)) ? m_read_delay : m_write_delay;
          sc_time receipt_net       = m_requests[i]->m_time_stamp + req_delay;
          sc_time last_request_net  = m_last_request_time_stamp + (m_delay_from_receipt ? m_recovery_time : req_delay);
          sc_time latest_net        = (receipt_net > last_request_net) ? receipt_net : last_request_net;
          sc_time now               = sc_time_stamp();
          sc_time delay = (latest_net <= now) ? SC_ZERO_TIME : (latest_net - now);
          XTSC_DEBUG(m_text, "router_pwc_thread() doing wait for " << delay);
          wait(delay);
          handle_request(m_requests[i]);
          delete_request_info(m_requests[i]);
        }

      }
    }

  }
  catch (const exception& error) {
    ostringstream oss;
    oss << "std::exception caught in router_pwc_thread of " << kind() << " '" << name() << "'." << endl;
    oss << "what(): " << error.what() << endl;
    xtsc_log_multiline(m_text, log4xtensa::FATAL_LOG_LEVEL, oss.str(), 2);
    throw;
  }

}



void xtsc_component::xtsc_router::convert_request(request_info*& p_request_info, u32 slave_byte_width) {
  req_rsp_info         *p_req_rsp_info  = NULL;
  bool                  first_transfer  = (m_pending_request_id == m_num_slots);
  xtsc_request::type_t  type            = p_request_info->m_request.get_type();
  u32                   size            = p_request_info->m_request.get_byte_size();

  XTSC_DEBUG(m_text, "Converting to " << slave_byte_width << "-byte PIF: " << p_request_info->m_request);

  if ((type != xtsc_request::READ       ) &&
      (type != xtsc_request::BLOCK_READ ) &&
      (type != xtsc_request::WRITE      ) &&
      (type != xtsc_request::BLOCK_WRITE) &&
      (type != xtsc_request::RCW        ))
  {
    ostringstream oss;
    oss << kind() << " '" << name() << "' received a " << xtsc_request::get_type_name(type)
        << " request which is not supported for PIF width conversion: " << p_request_info->m_request;
    throw xtsc_exception(oss.str());
  }

  if ((type == xtsc_request::RCW) && (size > slave_byte_width)) {
    ostringstream oss;
    oss << kind() << " '" << name() << "' received a RCW request with a size greater than downstream PIF width ("
        << slave_byte_width << "): " << p_request_info->m_request;
    throw xtsc_exception(oss.str());
  }

  if (first_transfer) {
    u8 request_id = get_empty_slot();
    XTSC_DEBUG(m_text, "convert_request() changing id=" << (u32) p_request_info->m_request.get_id() << " to id=" << (u32) request_id);
    p_req_rsp_info = new_req_rsp_info(p_request_info);
    m_req_rsp_table[request_id] = p_req_rsp_info;
    p_req_rsp_info->m_slot = request_id;
    request_info *p_req_info = new_request_info(*p_request_info);
    p_req_info->m_request.set_id(request_id);

    p_req_rsp_info->m_num_last_xfer_rsp_expected = 1;   // Overrides below

    if (!p_request_info->m_request.get_last_transfer()) {
      m_pending_request_id = request_id;
    }
    if (m_master_byte_width > slave_byte_width) {
      // Master is wider than slave
      m_requests[0] = p_req_info;
      if (type == xtsc_request::READ) {
        if (size > slave_byte_width) {
          p_req_info->m_request.set_byte_size(slave_byte_width);
          xtsc_byte_enables     mask    = ((size == 8) ? 0xFF : 0xFFFF);
          xtsc_byte_enables     be      = p_request_info->m_request.get_byte_enables();
          u32                   reps    = size / slave_byte_width;
          // Optionally use BLOCK_READ if all bytes are enabled
          if (m_use_block_requests && ((be & mask) == mask)) {
            p_req_info->m_request.set_type(xtsc_request::BLOCK_READ);
            p_req_info->m_request.set_num_transfers(reps);
            p_req_info->m_request.set_byte_enables((slave_byte_width == 4) ? 0xF : 0xFF);
          }
          else {
            xtsc_byte_enables slave_mask = ((slave_byte_width == 4) ? 0xF : 0xFF);
            p_req_info->m_request.set_byte_enables(be & slave_mask);
            xtsc_address address8 = p_req_info->m_request.get_byte_address();
            p_req_rsp_info->m_num_last_xfer_rsp_expected = reps;
            for (u32 i=1; i < reps; ++i) {
              m_requests[i] = new_request_info(*p_req_info);
              be >>= slave_byte_width;
              address8 += slave_byte_width;
              m_requests[i]->m_request.set_byte_address(address8);
              m_requests[i]->m_request.set_byte_enables(be & slave_mask);
            }
          }
        }
      }
      else if (type == xtsc_request::BLOCK_READ) {
        u32 total_bytes   = m_master_byte_width * p_request_info->m_request.get_num_transfers();
        u32 num_transfers = total_bytes / slave_byte_width;
        u32 reps          = (num_transfers + 15) / 16;
        p_req_info->m_request.set_byte_size(slave_byte_width);
        p_req_info->m_request.set_num_transfers(num_transfers < 16 ? num_transfers : 16);
        p_req_info->m_request.set_byte_enables((slave_byte_width == 4) ? 0xF : 0xFF);
        xtsc_address address8 = p_req_info->m_request.get_byte_address();
        p_req_rsp_info->m_num_last_xfer_rsp_expected = reps;
        for (u32 i=1; i < reps; ++i) {
          m_requests[i] = new_request_info(*p_req_info);
          address8 += slave_byte_width * 16;
          m_requests[i]->m_request.set_byte_address(address8);
        }
      }
      else if (type == xtsc_request::WRITE) {
        if (size > slave_byte_width) {
          p_req_info->m_request.set_byte_size(slave_byte_width);
          xtsc_byte_enables     mask    = ((size == 8) ? 0xFF : 0xFFFF);
          xtsc_byte_enables     be      = p_request_info->m_request.get_byte_enables();
          const u8             *p_src   = p_request_info->m_request.get_buffer();
          u32                   reps    = size / slave_byte_width;
          // Optionally use BLOCK_WRITE if all bytes are enabled
          if (m_use_block_requests && ((be & mask) == mask)) {
            p_req_info->m_request.set_type(xtsc_request::BLOCK_WRITE);
            p_req_info->m_request.set_last_transfer(false);
            p_req_info->m_request.set_num_transfers(reps);
            p_req_info->m_request.set_byte_enables((slave_byte_width == 4) ? 0xF : 0xFF);
            xtsc_address address8 = p_req_info->m_request.get_byte_address();
            for (u32 i=1; i < reps; ++i) {
              m_requests[i] = new_request_info(*p_req_info);
              p_src += slave_byte_width;
              m_requests[i]->m_request.set_buffer(slave_byte_width, p_src);
              address8 += slave_byte_width;
              m_requests[i]->m_request.set_byte_address(address8);
            }
            m_requests[reps-1]->m_request.set_last_transfer(true);
          }
          else {
            xtsc_byte_enables slave_mask = ((slave_byte_width == 4) ? 0xF : 0xFF);
            p_req_info->m_request.set_byte_enables(be & slave_mask);
            xtsc_address address8 = p_req_info->m_request.get_byte_address();
            p_req_rsp_info->m_num_last_xfer_rsp_expected = reps;
            for (u32 i=1; i < reps; ++i) {
              m_requests[i] = new_request_info(*p_req_info);
              be >>= slave_byte_width;
              address8 += slave_byte_width;
              p_src += slave_byte_width;
              m_requests[i]->m_request.set_byte_address(address8);
              m_requests[i]->m_request.set_buffer(slave_byte_width, p_src);
              m_requests[i]->m_request.set_byte_enables(be & slave_mask);
            }
          }
        }
      }
      else if (type == xtsc_request::BLOCK_WRITE) {
        u32             total_bytes     = m_master_byte_width * p_request_info->m_request.get_num_transfers();
        u32             num_transfers   = total_bytes / slave_byte_width;
        u32             reps            = m_master_byte_width / slave_byte_width;
        const u8       *p_src           = p_request_info->m_request.get_buffer();
        p_req_info->m_request.set_byte_size(slave_byte_width);
        p_req_info->m_request.set_num_transfers(num_transfers < 16 ? num_transfers : 16);
        p_req_info->m_request.set_byte_enables((slave_byte_width == 4) ? 0xF : 0xFF);
        p_req_rsp_info->m_num_last_xfer_rsp_expected = (num_transfers <= 16 ? 1 : (num_transfers / 16));
        p_req_rsp_info->m_block_write_address = p_req_info->m_request.get_byte_address() + slave_byte_width;
        for (u32 i=1; i < reps; ++i) {
          m_requests[i] = new_request_info(*p_req_info);
          p_src += slave_byte_width;
          m_requests[i]->m_request.set_buffer(slave_byte_width, p_src);
          m_requests[i]->m_request.set_byte_address(p_req_rsp_info->m_block_write_address);
          p_req_rsp_info->m_block_write_address += slave_byte_width;
        }
        p_req_rsp_info->m_num_block_write_requests = reps;
      }
      else if (type == xtsc_request::RCW) {
        xtsc_byte_enables be         = p_request_info->m_request.get_byte_enables();
        xtsc_byte_enables slave_mask = ((slave_byte_width == 4) ? 0xF : 0xFF);
        p_req_info->m_request.set_byte_enables(be & slave_mask);
      }
    }
    else {
      // Slave is wider than master
      if ((type == xtsc_request::READ) || (type == xtsc_request::WRITE) || (type == xtsc_request::RCW)) {
        m_requests[0] = p_req_info;
      }
      else if (type == xtsc_request::BLOCK_READ) {
        m_requests[0] = p_req_info;
        u32 total_bytes = m_master_byte_width * p_request_info->m_request.get_num_transfers();
        if (total_bytes <= slave_byte_width) {
          p_req_info->m_request.set_byte_size(total_bytes);
          p_req_info->m_request.set_type(xtsc_request::READ);
          p_req_info->m_request.set_num_transfers(1);
          p_req_info->m_request.set_byte_enables((total_bytes == 16) ? 0xFFFF : 0xFF);
        }
        else {
          p_req_info->m_request.set_byte_size(slave_byte_width);
          p_req_info->m_request.set_num_transfers(total_bytes / slave_byte_width);
          p_req_info->m_request.set_byte_enables((slave_byte_width == 16) ? 0xFFFF : 0xFF);
        }
      }
      else if (type == xtsc_request::BLOCK_WRITE) {
        p_req_rsp_info->m_p_nascent_request = p_req_info;
        u32 total_bytes = m_master_byte_width * p_request_info->m_request.get_num_transfers();
        p_req_rsp_info->m_block_write_address = p_req_info->m_request.get_byte_address();
        if (total_bytes <= slave_byte_width) {
          p_req_info->m_request.set_byte_size(total_bytes);
          p_req_info->m_request.set_type(xtsc_request::WRITE);
          p_req_info->m_request.set_num_transfers(1);
          p_req_info->m_request.set_byte_enables((total_bytes == 16) ? 0xFFFF : 0xFF);
        }
        else {
          p_req_info->m_request.set_byte_size(slave_byte_width);
          p_req_info->m_request.set_num_transfers(total_bytes / slave_byte_width);
          p_req_info->m_request.set_byte_enables((slave_byte_width == 16) ? 0xFFFF : 0xFF);
        }
        p_req_rsp_info->m_num_block_write_requests = 1;
      }
    }
  }
  else {
    // Non-first transfer (BLOCK_WRITE or RCW)
    p_req_rsp_info = m_req_rsp_table[m_pending_request_id];
    xtsc_request::type_t original_type = p_req_rsp_info->m_p_first_request_info->m_request.get_type();
    if (type != original_type) {
      ostringstream oss;
      oss << "Expected " << xtsc_request::get_type_name(original_type) << " request but received: " << p_request_info->m_request;
      throw xtsc_exception(oss.str());
    }

    if (type == xtsc_request::RCW) {
      request_info *p_req_info = new_request_info(*p_request_info);
      p_req_info->m_request.set_id(m_pending_request_id);
      m_requests[0] = p_req_info;
    }
    else if (type == xtsc_request::BLOCK_WRITE) {
      u32 total_bytes = m_master_byte_width * p_request_info->m_request.get_num_transfers();
      if (m_master_byte_width > slave_byte_width) {
        // Master is wider than slave
        request_info *p_req_info = new_request_info(*p_request_info);
        p_req_info->m_request.set_id(m_pending_request_id);
        m_requests[0] = p_req_info;
        u32             num_transfers   = total_bytes / slave_byte_width;
        u32             reps            = m_master_byte_width / slave_byte_width;
        const u8       *p_src           = p_request_info->m_request.get_buffer();
        p_req_info->m_request.set_byte_address(p_req_rsp_info->m_block_write_address);
        p_req_rsp_info->m_block_write_address += slave_byte_width;
        p_req_info->m_request.set_byte_size(slave_byte_width);
        p_req_info->m_request.set_num_transfers(num_transfers < 16 ? num_transfers : 16);
        p_req_info->m_request.set_byte_enables((slave_byte_width == 4) ? 0xF : 0xFF);
        p_req_info->m_request.set_last_transfer(false);
        for (u32 i=1; i < reps; ++i) {
          m_requests[i] = new_request_info(*p_req_info);
          p_src += slave_byte_width;
          m_requests[i]->m_request.set_buffer(slave_byte_width, p_src);
          m_requests[i]->m_request.set_byte_address(p_req_rsp_info->m_block_write_address);
          p_req_rsp_info->m_block_write_address += slave_byte_width;
        }
        p_req_rsp_info->m_num_block_write_requests += reps;
        if (p_request_info->m_request.get_last_transfer() || ((p_req_rsp_info->m_num_block_write_requests % 16) == 0)) {
          m_requests[reps-1]->m_request.set_last_transfer(true);
        }
      }
      else {
        // Slave is wider than master
        request_info   *p_req_info      = p_req_rsp_info->m_p_nascent_request;
        u32             ratio           = slave_byte_width / m_master_byte_width ;
        u32             offset          = (p_req_rsp_info->m_num_block_write_requests % ratio) * m_master_byte_width;
        u32             next_offset     = offset + m_master_byte_width;
        u8             *p_dst           = p_req_info->m_request.get_buffer();
        const u8       *p_src           = p_request_info->m_request.get_buffer();
        bool            last            = p_request_info->m_request.get_last_transfer();
        memcpy(p_dst + offset, p_src, m_master_byte_width);
        if (last) {
          p_req_info->m_request.set_last_transfer(true);
        }
        p_req_rsp_info->m_num_block_write_requests += 1;
        if ((next_offset == slave_byte_width) || (next_offset == total_bytes)) {
          p_req_info->m_request.set_byte_address(p_req_rsp_info->m_block_write_address);
          p_req_rsp_info->m_block_write_address += slave_byte_width;
          m_requests[0] = p_req_rsp_info->m_p_nascent_request;
          p_req_rsp_info->m_p_nascent_request = (last ? NULL : new_request_info(*p_req_rsp_info->m_p_nascent_request));
          m_requests[0]->m_time_stamp = p_request_info->m_time_stamp;  // Base timing off this latest request which completes the bus
        }
      }
    }
    else {
      ostringstream oss;
      oss << "Program Bug: Only RCW|BLOCK_WRITE expected at line " << __LINE__ << " of " << __FILE__;
      throw xtsc_exception(oss.str());
    }

    if (p_request_info->m_request.get_last_transfer()) {
      m_pending_request_id = m_num_slots;
    }

    // Note: When first_transfer is true p_request_info is deleted (as m_p_first_request_info) in delete_req_rsp_info()
    delete_request_info(p_request_info);
  }

}



u8 xtsc_component::xtsc_router::get_empty_slot() {
  bool found = false;
  u8 empty_slot = m_next_slot;
  for (; empty_slot < m_next_slot + m_num_slots; ++empty_slot) {
    if (m_req_rsp_table[empty_slot % m_num_slots] == NULL) {
      found = true;
      break;
    }
  }
  if (!found) {
    ostringstream oss;
    oss << "ERROR: " << kind() << " '" << name() << "' has run out of request ID's";
    throw xtsc_exception(oss.str());
  }
  m_next_slot = (empty_slot + 1) % m_num_slots;
  XTSC_DEBUG(m_text, "get_empty_slot() returning " << (u32) empty_slot << " m_next_slot=" << (u32) m_next_slot);
  return empty_slot;
}



void xtsc_component::xtsc_router::handle_request(request_info *p_request_info) {
  xtsc_address address8 = p_request_info->m_request.get_byte_address();
  u32 port_num = get_port_and_apply_address_translation(address8);
  if (port_num == DISCARD_REQUEST) {
    XTSC_INFO(m_text, p_request_info->m_request << " DISCARD_REQUEST");
  }
  else if (port_num == ADDRESS_ERROR) {
    xtsc_response response(p_request_info->m_request, xtsc_response::RSP_ADDRESS_ERROR);
    u32 tries = 0;
    while (true) {
      tries += 1;
      XTSC_INFO(m_text, response << " Try #" << tries);
      xtsc_log_memory_response_event(m_binary, INFO_LOG_LEVEL, false, 0, m_log_data_binary, response);
      if (m_respond_port->nb_respond(response) || m_immediate_timing) {
        break;
      }
      wait(m_response_repeat);
    }
  }
  else if (port_num >= m_num_slaves) {
    ostringstream oss;
    oss << "xtsc_router '" << name() << "': Invalid port (0x" << hex << port_num << ") returned for address 0x" << hex << address8;
    throw xtsc_exception(oss.str());
  }
  else {
    p_request_info->m_request.set_byte_address(address8);
    u32 tries = 0;
    do {
      m_request_got_nacc = false;
      tries += 1;
      XTSC_INFO(m_text, p_request_info->m_request << " Port #" << port_num << " Try #" << tries);
      xtsc_log_memory_request_event(m_binary, INFO_LOG_LEVEL, false, port_num, m_log_data_binary,
                                    p_request_info->m_request);
      m_waiting_for_nacc = true;
      (*m_request_ports[port_num])->nb_request(p_request_info->m_request);
      if (!m_immediate_timing) {
        m_last_request_time_stamp = sc_time_stamp();
        wait(m_nacc_wait_time);
      }
      m_waiting_for_nacc = false;
    } while (m_request_got_nacc);
  }
}



void xtsc_component::xtsc_router::response_arbiter_thread(void) {

  try {

    while (true) {
      XTSC_DEBUG(m_text, "response_arbiter_thread going to sleep.  m_lock=" << m_lock << " m_token=" << m_token);
      wait(m_response_arbiter_thread_event);
      XTSC_DEBUG(m_text, "response_arbiter_thread woke up.");
      bool response_found;
      do {
        u32 next_token = m_token;
        response_found = false;
        do {
          if (!m_lock) {
            next_token = (next_token + 1) % m_num_slaves;
          }
          if (m_response_fifos[next_token]->num_available()) {
            response_found = true;
            response_info *p_response_info;
            m_response_fifos[next_token]->nb_read(p_response_info);
            XTSC_DEBUG(m_text, "response_arbiter_thread got: " << p_response_info->m_response);
            // Calculate delay (net => No Earlier Than time)
            sc_time receipt_net       = p_response_info->m_time_stamp + m_response_delay;
            sc_time last_response_net = m_last_response_time_stamp + (m_delay_from_receipt ? m_recovery_time : m_response_delay);
            sc_time latest_net        = (receipt_net > last_response_net) ? receipt_net : last_response_net;
            sc_time now               = sc_time_stamp();
            sc_time delay = (latest_net <= now) ? SC_ZERO_TIME : (latest_net - now);
            XTSC_DEBUG(m_text, "response_arbiter_thread() doing wait for " << delay);
            wait(delay);
            m_lock = (p_response_info->m_response.get_last_transfer() == false);
            // Forward the response
            u32 tries = 0;
            while (true) {
              tries += 1;
              XTSC_INFO(m_text, p_response_info->m_response << " Port #" << next_token << " Try #" << tries);
              xtsc_log_memory_response_event(m_binary, INFO_LOG_LEVEL, false, 0, m_log_data_binary, p_response_info->m_response);
              if (m_respond_port->nb_respond(p_response_info->m_response)) {
                break;
              }
              wait(m_response_repeat);
            };
            m_last_response_time_stamp = sc_time_stamp();
            delete_response_info(p_response_info);
            m_token = next_token;
          }
        } while (next_token != m_token);
      } while (response_found);
    }

  }
  catch (const exception& error) {
    ostringstream oss;
    oss << "std::exception caught in response_arbiter_thread of " << kind() << " '" << name() << "'." << endl;
    oss << "what(): " << error.what() << endl;
    xtsc_log_multiline(m_text, log4xtensa::FATAL_LOG_LEVEL, oss.str(), 2);
    throw;
  }

}




// When acting as PIF width converter (pwc)
void xtsc_component::xtsc_router::response_arbiter_pwc_thread(void) {

  try {

    while (true) {
      wait(m_response_arbiter_thread_event);
      XTSC_DEBUG(m_text, "response_arbiter_pwc_thread woke up.");
      bool response_found;
      do {
        u32 next_token = m_token;
        response_found = false;
        do {
          if (!m_lock) {
            next_token = (next_token + 1) % m_num_slaves;
          }
          if (m_response_fifos[next_token]->num_available()) {
            response_found = true;
            response_info *p_response_info = NULL;
            m_response_fifos[next_token]->nb_read(p_response_info);
            XTSC_DEBUG(m_text, "response_arbiter_pwc_thread got: " << p_response_info->m_response);

            req_rsp_info       *p_req_rsp_info   = NULL;
            u32                 slave_byte_width = m_slave_byte_widths[next_token];

            if (m_master_byte_width == slave_byte_width) {
              m_responses[0] = p_response_info;
              m_lock = (p_response_info->m_response.get_last_transfer() == false);
            }
            else {
              m_lock = convert_response(p_response_info, slave_byte_width, p_req_rsp_info);
              delete_response_info(p_response_info);
            }

            for (u32 i=0; (m_responses[i] != NULL) && (i<4); ++i) {
              // Calculate delay (net => No Earlier Than time)
              sc_time receipt_net       = m_responses[i]->m_time_stamp + m_response_delay;
              sc_time last_response_net = m_last_response_time_stamp + (m_delay_from_receipt ? m_recovery_time : m_response_delay);
              sc_time latest_net        = (receipt_net > last_response_net) ? receipt_net : last_response_net;
              sc_time now               = sc_time_stamp();
              sc_time delay = (latest_net <= now) ? SC_ZERO_TIME : (latest_net - now);
              XTSC_DEBUG(m_text, "response_arbiter_pwc_thread() doing wait for " << delay);
              wait(delay);
              // Forward the response
              u32 tries = 0;
              while (true) {
                tries += 1;
                XTSC_INFO(m_text, m_responses[i]->m_response << " Port #" << next_token << " Try #" << tries);
                xtsc_log_memory_response_event(m_binary, INFO_LOG_LEVEL, false, 0, m_log_data_binary, m_responses[i]->m_response);
                if (m_respond_port->nb_respond(m_responses[i]->m_response)) {
                  break;
                }
                wait(m_response_repeat);
              };
              m_last_response_time_stamp = sc_time_stamp();
              delete_response_info(m_responses[i]);
            }
            if (p_req_rsp_info && !m_lock) {
              m_req_rsp_table[p_req_rsp_info->m_slot] = NULL;
              delete_req_rsp_info(p_req_rsp_info);
            }
            m_token = next_token;
          }
        } while (next_token != m_token);
      } while (response_found);
    }

  }
  catch (const exception& error) {
    ostringstream oss;
    oss << "std::exception caught in response_arbiter_pwc_thread of " << kind() << " '" << name() << "'." << endl;
    oss << "what(): " << error.what() << endl;
    xtsc_log_multiline(m_text, log4xtensa::FATAL_LOG_LEVEL, oss.str(), 2);
    throw;
  }

}



bool xtsc_component::xtsc_router::convert_response(response_info*&      p_response_info,
                                                   u32                  slave_byte_width,
                                                   req_rsp_info*&       p_req_rsp_info)
{
  u8 id = p_response_info->m_response.get_id();
  if ((id >= m_num_slots) || (m_req_rsp_table[id] == NULL)) {
    ostringstream oss;
    oss << "Received response with " << ((id >= m_num_slots) ? "invalid" : "inactive") << " transaction id=" << (u32) id << ": "
        << p_response_info->m_response;
    throw xtsc_exception(oss.str());
  }
  if ((m_active_block_read_id != m_num_slots) && (m_active_block_read_id != id)) {
    ostringstream oss;
    oss << "While BLOCK_READ responses (tag=" << m_req_rsp_table[m_active_block_read_id]->m_p_first_request_info->m_request.get_tag()
        << ") are in progress, received unexpected response: " << p_response_info->m_response;
    throw xtsc_exception(oss.str());
  }
  p_req_rsp_info = m_req_rsp_table[id];
  bool last_transfer = p_response_info->m_response.get_last_transfer();
  bool fini = false;
  if (last_transfer) {
    p_req_rsp_info->m_num_last_xfer_rsp_received += 1;
    fini = (p_req_rsp_info->m_num_last_xfer_rsp_received == p_req_rsp_info->m_num_last_xfer_rsp_expected);
  }

  response_info *p_rsp_info = p_req_rsp_info->m_p_nascent_response ?
                              p_req_rsp_info->m_p_nascent_response :
                              new_response_info(p_req_rsp_info->m_p_first_request_info->m_request);

  if (!fini) {
    p_req_rsp_info->m_p_nascent_response = p_rsp_info;
  }

  /*
   * Handle single-response error responses
   *   RSP_ADDRESS_ERROR           single response
   *   RSP_ADDRESS_DATA_ERROR:     single response
   *   RSP_DATA_ERROR              normal number of responses
   */
  xtsc_response::status_t status = p_response_info->m_response.get_status();
  if (p_req_rsp_info->m_single_rsp_error_received ||
      ((status != xtsc_response::RSP_OK) && (status != xtsc_response::RSP_DATA_ERROR)))
  {
    if (p_req_rsp_info->m_single_rsp_error_received ||
        ((status == xtsc_response::RSP_ADDRESS_ERROR) || (status == xtsc_response::RSP_ADDRESS_DATA_ERROR)))
    {
      if (p_req_rsp_info->m_responses_sent) {
        ostringstream oss;
        oss << "Received address error response after some responses have already been sent upstream: " << p_response_info->m_response;
        throw xtsc_exception(oss.str());
      }
      if (!p_req_rsp_info->m_single_rsp_error_received) {
        p_req_rsp_info->m_single_rsp_error_received = true;
        p_rsp_info->m_response.set_status(status);
        p_rsp_info->m_response.set_last_transfer(true);
      }
      if (fini) {
        m_responses[0] = p_rsp_info;
        m_responses[0]->m_time_stamp = p_response_info->m_time_stamp;
      }
    }
    else {
      ostringstream oss;
      oss << "Received response with unsupported status: " << p_response_info->m_response;
      throw xtsc_exception(oss.str());
    }
  }
  else {
    if ((status == xtsc_response::RSP_DATA_ERROR) && (p_rsp_info->m_response.get_status() == xtsc_response::RSP_OK)) {
      p_rsp_info->m_response.set_status(xtsc_response::RSP_DATA_ERROR);
    }
    xtsc_request::type_t type = p_req_rsp_info->m_p_first_request_info->m_request.get_type();
    if ((type == xtsc_request::WRITE) || (type == xtsc_request::BLOCK_WRITE) || (type == xtsc_request::RCW)) {
      if (type == xtsc_request::RCW) {
        p_rsp_info->m_response.set_buffer(p_response_info->m_response.get_buffer());
      }
      if (fini) {
        m_responses[0] = p_rsp_info;
        m_responses[0]->m_time_stamp = p_response_info->m_time_stamp;
      }
    }
    else if ((type == xtsc_request::READ) || (type == xtsc_request::BLOCK_READ)) {
      const u8 *p_src = p_response_info->m_response.get_buffer();
      u32       size  = p_response_info->m_response.get_byte_size();
      if (m_master_byte_width > slave_byte_width) {
        // Master is wider than slave
        u8 *p_dst = p_rsp_info->m_response.get_buffer();
        u32 offset = (p_req_rsp_info->m_num_rsp_received * slave_byte_width) % m_master_byte_width;
        memcpy(p_dst+offset, p_src, size);
        if (fini || ((offset + size) == m_master_byte_width)) {
          m_responses[0] = p_rsp_info;
          m_responses[0]->m_response.set_last_transfer(fini);
          m_responses[0]->m_time_stamp = p_response_info->m_time_stamp; // Base timing off this latest response which completes the bus
        }
      }
      else {
        // Slave is wider than master
        p_rsp_info->m_response.set_buffer(p_src);
        m_responses[0] = p_rsp_info;
        if (type == xtsc_request::BLOCK_READ) {
          m_responses[0]->m_response.set_last_transfer(false);
          u32 reps = min(slave_byte_width, size) / m_master_byte_width;
          for (u32 i=1; i < reps; ++i) {
            m_responses[i] = new_response_info(p_rsp_info->m_response);
            m_responses[i]->m_response.set_buffer(p_src + m_master_byte_width*i);
            m_responses[i]->m_response.set_last_transfer(false);
          }
          if (fini) {
            m_responses[reps-1]->m_response.set_last_transfer(true);
          }
        }
      }
      if (type == xtsc_request::BLOCK_READ) {
        m_active_block_read_id = fini ? m_num_slots : id;
      }
    }
    else {
      ostringstream oss;
      oss << "Program Bug: " << xtsc_request::get_type_name(type) << " is not supported at line " << __LINE__ << " of " << __FILE__;
      throw xtsc_exception(oss.str());
    }
  }

  p_req_rsp_info->m_num_rsp_received += 1;
  if (m_responses[0] != NULL) {
    p_req_rsp_info->m_responses_sent     = true;
    p_req_rsp_info->m_p_nascent_response = NULL;
  }
  bool lock = !fini;
  return lock;
}



u32 xtsc_component::xtsc_router::get_port_and_apply_address_translation(xtsc_address& address8) {
  if (m_address_routing) {
    u32 port_num = 0;
    for (u32 i=0; i<m_num_bit_fields; ++i) {
      u32 bit_field = address8;
      bit_field >>= m_address_routing_info[i]->m_pre_shift;
      bit_field  &= m_address_routing_info[i]->m_mask;
      bit_field <<= m_address_routing_info[i]->m_post_shift;
      port_num |= bit_field;
    }
    return port_num;
  }
  vector<xtsc_address_range_entry>::iterator i_table = m_routing_table.begin();
  for (i_table=m_routing_table.begin(); i_table != m_routing_table.end(); ++i_table) {
    if ((address8 >= i_table->m_start_address8) && (address8 <= i_table->m_end_address8)) {
      address8 += i_table->m_delta;
      return i_table->m_port_num;
    }
  }
  // Not in routing table
  address8 += m_default_delta;
  return m_default_port_num;
}



xtsc_component::xtsc_router::request_info *xtsc_component::xtsc_router::new_request_info(const xtsc_request& request) {
  if (m_request_pool.empty()) {
    request_info *p_request_info = new request_info(request);
    XTSC_DEBUG(m_text, "Creating a new request_info " << p_request_info << " for " << request);
    return p_request_info;
  }
  else {
    request_info *p_request_info = m_request_pool.back();
    XTSC_DEBUG(m_text, "Reusing request_info " << p_request_info << " for " << request);
    m_request_pool.pop_back();
    p_request_info->m_request = request;
    p_request_info->m_time_stamp = sc_time_stamp();
    return p_request_info;
  }
}



xtsc_component::xtsc_router::request_info *xtsc_component::xtsc_router::new_request_info(const request_info& info) {
  if (m_request_pool.empty()) {
    request_info *p_request_info = new request_info(info);
    XTSC_DEBUG(m_text, "Creating a new request_info " << p_request_info << " for " << info.m_request);
    return p_request_info;
  }
  else {
    request_info *p_request_info = m_request_pool.back();
    XTSC_DEBUG(m_text, "Reusing request_info " << p_request_info << " for " << info.m_request);
    m_request_pool.pop_back();
    *p_request_info = info;
    return p_request_info;
  }
}



void xtsc_component::xtsc_router::delete_request_info(request_info*& p_request_info) {
  XTSC_DEBUG(m_text, "Recycling request_info " << p_request_info);
  m_request_pool.push_back(p_request_info);
  p_request_info = 0;
}



xtsc_component::xtsc_router::response_info *xtsc_component::xtsc_router::new_response_info(const xtsc_response& response) {
  if (m_response_pool.empty()) {
    response_info *p_response_info = new response_info(response);
    XTSC_DEBUG(m_text, "Creating a new response_info " << p_response_info << " for " << response);
    return p_response_info;
  }
  else {
    response_info *p_response_info = m_response_pool.back();
    XTSC_DEBUG(m_text, "Reusing response_info " << p_response_info << " for " << response);
    m_response_pool.pop_back();
    p_response_info->m_response = response;
    p_response_info->m_time_stamp = sc_time_stamp();
    return p_response_info;
  }
}



xtsc_component::xtsc_router::response_info *xtsc_component::xtsc_router::new_response_info(const xtsc_request& request) {
  if (m_response_pool.empty()) {
    response_info *p_response_info = new response_info(request);
    XTSC_DEBUG(m_text, "Creating a new response_info " << p_response_info << " for " << request);
    return p_response_info;
  }
  else {
    response_info *p_response_info = m_response_pool.back();
    XTSC_DEBUG(m_text, "Reusing response_info " << p_response_info << " for " << request);
    m_response_pool.pop_back();
    p_response_info->m_response = request;
    p_response_info->m_time_stamp = sc_time_stamp();
    return p_response_info;
  }
}



void xtsc_component::xtsc_router::delete_response_info(response_info*& p_response_info) {
  XTSC_DEBUG(m_text, "Recycling response_info " << p_response_info);
  m_response_pool.push_back(p_response_info);
  p_response_info = 0;
}



u32 xtsc_component::xtsc_router::get_u32(u32 index) {
  u32 value = 0;
  try {
    value = xtsc_strtou32(m_words[index]);
  }
  catch (const xtsc_exception&) {
    ostringstream oss;
    oss << "Cannot convert argument #" << index+1 << " '" << m_words[index] << "' to number:" << endl;
    oss << m_line;
    oss << m_file->info_for_exception();
    throw xtsc_exception(oss.str());
  }
  return value;
}



xtsc_component::xtsc_router::req_rsp_info *xtsc_component::xtsc_router::new_req_rsp_info(request_info  *p_first_request_info) {
  req_rsp_info *p_req_rsp_info;
  if (m_req_rsp_info_pool.empty()) {
    p_req_rsp_info = new req_rsp_info();
    XTSC_DEBUG(m_text, "Creating a new req_rsp_info " << p_req_rsp_info);
  }
  else {
    p_req_rsp_info = m_req_rsp_info_pool.back();
    XTSC_DEBUG(m_text, "Reusing req_rsp_info " << p_req_rsp_info);
    m_req_rsp_info_pool.pop_back();
  }
  p_req_rsp_info->m_p_first_request_info = p_first_request_info;
  return p_req_rsp_info;
}



void xtsc_component::xtsc_router::delete_req_rsp_info(req_rsp_info*& p_req_rsp_info) {
  XTSC_DEBUG(m_text, "Recycling req_rsp_info " << p_req_rsp_info);
  delete_request_info(p_req_rsp_info->m_p_first_request_info);
  memset(p_req_rsp_info, 0, sizeof(req_rsp_info));
  m_req_rsp_info_pool.push_back(p_req_rsp_info);
  p_req_rsp_info = 0;
}



void xtsc_component::xtsc_router::xtsc_request_if_impl::nb_peek(xtsc_address address8, u32 size8, u8 *buffer) {
  u32 port_num = m_router.get_port_and_apply_address_translation(address8);
  if (port_num == ADDRESS_ERROR) {
    ostringstream oss;
    oss << "xtsc_router '" << m_router.name() << "': nb_peek() called with invalid address: 0x" << hex << address8;
    throw xtsc_exception(oss.str());
  }
  if (port_num == DISCARD_REQUEST) {
    memset(buffer, 0xba, size8);
    XTSC_INFO(m_router.m_text, "Discarding nb_peek() called with invalid address: 0x" << hex << address8);
    return;
  }
  if ((port_num < 0) || (port_num >= m_router.m_num_slaves)) {
    ostringstream oss;
    oss << "xtsc_router '" << m_router.name() << "' in nb_peek: Invalid port (0x" << hex << port_num << ") returned for address 0x"
        << hex << address8;
    throw xtsc_exception(oss.str());
  }
  (*m_router.m_request_ports[port_num])->nb_peek(address8, size8, buffer);
}



void xtsc_component::xtsc_router::xtsc_request_if_impl::nb_poke(xtsc_address address8, u32 size8, const u8 *buffer) {
  u32 port_num = m_router.get_port_and_apply_address_translation(address8);
  if (port_num == ADDRESS_ERROR) {
    ostringstream oss;
    oss << "xtsc_router '" << m_router.name() << "': nb_poke() called with invalid address: 0x" << hex << address8;
    throw xtsc_exception(oss.str());
  }
  if (port_num == DISCARD_REQUEST) {
    XTSC_INFO(m_router.m_text, "Discarding nb_poke() called with invalid address: 0x" << hex << address8);
    return;
  }
  if ((port_num < 0) || (port_num >= m_router.m_num_slaves)) {
    ostringstream oss;
    oss << "xtsc_router '" << m_router.name() << "' in nb_poke: Invalid port (0x" << hex << port_num << ") returned for address 0x"
        << hex << address8;
    throw xtsc_exception(oss.str());
  }
  (*m_router.m_request_ports[port_num])->nb_poke(address8, size8, buffer);
}



bool xtsc_component::xtsc_router::xtsc_request_if_impl::nb_peek_coherent(xtsc_address   virtual_address8,
                                                                         xtsc_address   physical_address8,
                                                                         u32            size8,
                                                                         u8            *buffer)
{
  xtsc_address paddr = physical_address8;
  u32 port_num = m_router.get_port_and_apply_address_translation(paddr);
  if (port_num == ADDRESS_ERROR) {
    ostringstream oss;
    oss << "xtsc_router '" << m_router.name() << "': nb_peek_coherent() called with invalid address: 0x" << hex << paddr;
    throw xtsc_exception(oss.str());
  }
  if (port_num == DISCARD_REQUEST) {
    memset(buffer, 0xba, size8);
    XTSC_INFO(m_router.m_text, "Discarding nb_peek_coherent() called with invalid address: 0x" << hex << paddr);
    return false;
  }
  if ((port_num < 0) || (port_num >= m_router.m_num_slaves)) {
    ostringstream oss;
    oss << "xtsc_router '" << m_router.name() << "' in nb_peek_coherent: Invalid port (0x" << hex << port_num
        << ") returned for address 0x" << hex << paddr;
    throw xtsc_exception(oss.str());
  }
  xtsc_address vaddr = virtual_address8 + (paddr - physical_address8);
  return (*m_router.m_request_ports[port_num])->nb_peek_coherent(vaddr, paddr, size8, buffer);
}



bool xtsc_component::xtsc_router::xtsc_request_if_impl::nb_poke_coherent(xtsc_address   virtual_address8,
                                                                         xtsc_address   physical_address8,
                                                                         u32            size8,
                                                                         const u8      *buffer)
{
  xtsc_address paddr = physical_address8;
  u32 port_num = m_router.get_port_and_apply_address_translation(paddr);
  if (port_num == ADDRESS_ERROR) {
    ostringstream oss;
    oss << "xtsc_router '" << m_router.name() << "': nb_poke_coherent() called with invalid address: 0x" << hex << paddr;
    throw xtsc_exception(oss.str());
  }
  if (port_num == DISCARD_REQUEST) {
    XTSC_INFO(m_router.m_text, "Discarding nb_poke_coherent() called with invalid address: 0x" << hex << paddr);
    return false;
  }
  if ((port_num < 0) || (port_num >= m_router.m_num_slaves)) {
    ostringstream oss;
    oss << "xtsc_router '" << m_router.name() << "' in nb_poke_coherent: Invalid port (0x" << hex << port_num
        << ") returned for address 0x" << hex << paddr;
    throw xtsc_exception(oss.str());
  }
  xtsc_address vaddr = virtual_address8 + (paddr - physical_address8);
  return (*m_router.m_request_ports[port_num])->nb_poke_coherent(vaddr, paddr, size8, buffer);
}



bool xtsc_component::xtsc_router::xtsc_request_if_impl::nb_fast_access(xtsc_fast_access_request &request) {
  xtsc_address address8 = request.get_translated_request_address();
  u32 orig_address8 = address8;
  u32 port_num = m_router.get_port_and_apply_address_translation(address8);
  request.translate_request_address(address8);
  
  if ((port_num == ADDRESS_ERROR) || (port_num == DISCARD_REQUEST) || (port_num < 0) || (port_num >= m_router.m_num_slaves)) {
    request.deny_access();
    for (unsigned i = 0; i < m_router.m_num_slaves; i++) {
      u32 block_start = m_router.m_routing_table[i].m_start_address8;
      u32 block_end = m_router.m_routing_table[i].m_end_address8;
      request.remove_address_range(orig_address8, block_start, block_end);
    }
    return true;
  }

  if (!(*m_router.m_request_ports[port_num])->nb_fast_access(request)) { return false; }


  /* remove anything mapped before this address hits. When the address
     hits, remove anything outside of its range */
  for (unsigned i = 0; i < m_router.m_routing_table.size(); ++i) {
    xtsc_address end_address8 = m_router.m_routing_table[i].m_end_address8;
    xtsc_address start_address8 = m_router.m_routing_table[i].m_start_address8;
    if (orig_address8 >= start_address8 && orig_address8 <= end_address8) {
      xtsc_fast_access_block min_block(orig_address8, start_address8, end_address8);
      if (!request.restrict_to_block(min_block)) { return false; }
      break;
    }
    if (!request.remove_address_range(orig_address8, start_address8, end_address8)) { return false; }
  }

  return true;
}



void xtsc_component::xtsc_router::xtsc_request_if_impl::nb_request(const xtsc_request& request) {
  XTSC_VERBOSE(m_router.m_text, request);
  xtsc_log_memory_request_event(m_router.m_binary, VERBOSE_LOG_LEVEL, true, 0, m_router.m_log_data_binary, request);
  if (m_router.m_read_only) {
    xtsc_request::type_t type = request.get_type();
    if ((type == xtsc_request::WRITE)       ||
        (type == xtsc_request::BLOCK_WRITE) ||
        (type == xtsc_request::BURST_WRITE) ||
        (type == xtsc_request::RCW))
    {
      ostringstream oss;
      oss << "read_only xtsc_router '" << m_router.name() << "' received request: " << request; 
      throw xtsc_exception(oss.str());
    }
  }
  if (m_router.m_write_only) {
    xtsc_request::type_t type = request.get_type();
    if ((type == xtsc_request::READ)       ||
        (type == xtsc_request::BLOCK_READ) ||
        (type == xtsc_request::BURST_READ) ||
        (type == xtsc_request::RCW))
    {
      ostringstream oss;
      oss << "write_only xtsc_router '" << m_router.name() << "' received request: " << request; 
      throw xtsc_exception(oss.str());
    }
  }
  // Check if we've got room for this request
  if (!m_router.m_immediate_timing && (m_router.m_request_fifo.num_free() == 0)) {
    xtsc_response response(request, xtsc_response::RSP_NACC);
    XTSC_VERBOSE(m_router.m_text, response << " (Request fifo full)");
    xtsc_log_memory_response_event(m_router.m_binary, VERBOSE_LOG_LEVEL, false, 0, false, response);
    m_router.m_respond_port->nb_respond(response);
    return;
  }
  // Create our copy of the request
  request_info *p_request_info = m_router.new_request_info(request);
  if (m_router.m_immediate_timing) {
    // Handle this one as our current request
    m_router.handle_request(p_request_info);
    m_router.delete_request_info(p_request_info);
  }
  else {
    // Add request to fifo
    m_router.m_request_fifo.nb_write(p_request_info);
    m_router.m_router_thread_event.notify(SC_ZERO_TIME);
  }
}



void xtsc_component::xtsc_router::xtsc_request_if_impl::nb_load_retired(xtsc_address address8) {
  u32 port_num = m_router.get_port_and_apply_address_translation(address8);
  if ((port_num != m_router.DISCARD_REQUEST) && (port_num != m_router.ADDRESS_ERROR)) {
    if (port_num >= m_router.m_num_slaves) {
      ostringstream oss;
      oss << "xtsc_router '" << m_router.name() << "': Invalid port (0x" << hex << port_num << ") returned for address 0x" << hex
          << address8;
      throw xtsc_exception(oss.str());
    }
    else {
      (*m_router.m_request_ports[port_num])->nb_load_retired(address8);
    }
  }
}



void xtsc_component::xtsc_router::xtsc_request_if_impl::nb_retire_flush() {
  // Broadcast to all slaves
  for (u32 i=0; i<m_router.m_num_slaves; ++i) {
    (*m_router.m_request_ports[i])->nb_retire_flush();
  }
}



void xtsc_component::xtsc_router::xtsc_request_if_impl::nb_lock(bool lock) {
  // Broadcast to all slaves
  for (u32 i=0; i<m_router.m_num_slaves; ++i) {
    (*m_router.m_request_ports[i])->nb_lock(lock);
  }
}



void xtsc_component::xtsc_router::xtsc_request_if_impl::register_port(sc_port_base& port, const char *if_typename) {
  if (m_p_port) {
    ostringstream oss;
    oss << "Illegal multiple binding detected to xtsc_router '" << m_router.name() << "' m_request_export: " << endl;
    oss << "  " << port.name() << endl;
    oss << "  " << m_p_port->name();
    throw xtsc_exception(oss.str());
  }
  XTSC_INFO(m_router.m_text, "Binding '" << port.name() << "' to xtsc_router::m_request_export");
  m_p_port = &port;
}



bool xtsc_component::xtsc_router::xtsc_respond_if_impl::nb_respond(const xtsc_response& response) {
  XTSC_VERBOSE(m_router.m_text, response << " Port #" << m_port_num);
  xtsc_log_memory_response_event(m_router.m_binary, VERBOSE_LOG_LEVEL, true, m_port_num, m_router.m_log_data_binary, response);
  if (m_router.m_immediate_timing) {
    if (response.get_status() != xtsc_response::RSP_NACC) {
      if (m_router.m_lock && (m_router.m_token != m_port_num)) {
        XTSC_VERBOSE(m_router.m_text, response << " Port #" << m_port_num << " (Rejected: Locked to port #" << m_router.m_token << ")");
        return false;
      }
      m_router.m_lock = (response.get_last_transfer() == false);
      m_router.m_token = m_port_num;
    }
    return m_router.m_respond_port->nb_respond(response);
  }
  else {
    if (response.get_status() == xtsc_response::RSP_NACC) {
      if (m_router.m_waiting_for_nacc) {
        m_router.m_request_got_nacc = true;
        return true;
      }
      else {
        ostringstream oss;
        oss << "xtsc_router '" << m_router.name() << "' received nacc too late: " << response << endl;
        oss << " - Possibly something is wrong with the downstream device" << endl;
        oss << " - Possibly this router's \"nacc_wait_time\" needs to be adjusted";
        throw xtsc_exception(oss.str());
      }
    }
    if (!m_router.m_response_fifos[m_port_num]->num_free()) {
      XTSC_VERBOSE(m_router.m_text, response << " Port #" << m_port_num << " (Rejected: Response fifo full)");
      return false;
    }
    response_info *p_response_info = m_router.new_response_info(response);
    m_router.m_response_fifos[m_port_num]->nb_write(p_response_info);
    m_router.m_response_arbiter_thread_event.notify(SC_ZERO_TIME);
    return true;
  }
}



void xtsc_component::xtsc_router::xtsc_respond_if_impl::register_port(sc_port_base& port, const char *if_typename) {
  if (m_p_port) {
    ostringstream oss;
    oss << "Illegal multiple binding detected to xtsc_router '" << m_router.name() << "' m_respond_export[" << m_port_num
        << "]: " << endl;
    oss << "  " << port.name() << endl;
    oss << "  " << m_p_port->name();
    throw xtsc_exception(oss.str());
  }
  XTSC_INFO(m_router.m_text, "Binding '" << port.name() << "' to xtsc_router::m_respond_export[" << m_port_num << "]");
  m_p_port = &port;
}




