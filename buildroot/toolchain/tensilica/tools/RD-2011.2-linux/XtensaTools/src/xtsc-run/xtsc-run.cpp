// Copyright (c) 2005-2010 by Tensilica Inc.  ALL RIGHTS RESERVED.
// 
// These coded instructions, statements, and computer programs are
// the copyrighted works and confidential proprietary information of
// Tensilica Inc.  They may be adapted and modified by bona fide
// purchasers for internal use, but no adapted or modified version
// may be disclosed or distributed to third parties in any manner,
// medium, or form, in whole or in part, without the prior written
// consent of Tensilica Inc.

// ^\/\/ Step



/*
 * Note to Developers:
 *
 * This program can be modified to support new components.
 * 
 * To add support for a new component, grep for the "Step" comments and
 * follow the instructions they give.  The instructions are written assuming
 * a new component called xtsc_widget is being added.
 *
 * If you have a different version of an already present component it may be
 * simpler to modify the code that is already here to support the different 
 * version in place of the original version instead of adding a new component.
 * For example, to use a router class called, for example, priority_router instead
 * of xtsc_router, simply change all occurances of "xtsc_router" to
 * "priority_router".  If priority_router uses different names for its sc_ports
 * and sc_exports then xtsc_router does then you will also have to change the 
 * port names here.  The compiler will call these types of things to your attention.
 *
 * Tip:  To help "see" how the command processing is done, set logging to DEBUG_LOG_LEVEL
 *       when running xtsc-run with various commands of interest.
 *       To see the complete calling sequence, set logging to TRACE_LOG_LEVEL.
 */

/*
 * Maxim:  Regularity enhances productivity.
 *   The code in this program is highly repetitive.  Placing new functions
 *   in the same relative order and using consistent naming schemes and 
 *   coding sequences helps reduce the cost of maintenance and further
 *   enhancements.  
 *
 */

#include <algorithm>
#include <cerrno>
#include <iostream>
#include <string>
#include <map>
#include <vector>
#include <set>
#include <cstdlib>
#include <ctime>
#include <xtsc/xtsc.h>


// Step 1:  Add the header file for the xtsc_widget class.

#include <xtsc/xtsc_arbiter.h>
#include <xtsc/xtsc_cohctrl.h>
#include <xtsc/xtsc_core.h>
#include <xtsc/xtsc_dma_engine.h>
#include <xtsc/xtsc_interrupt_distributor.h>
#include <xtsc/xtsc_lookup.h>
#include <xtsc/xtsc_lookup_pin.h>
#include <xtsc/xtsc_lookup_driver.h>
#include <xtsc/xtsc_master.h>
#include <xtsc/xtsc_memory.h>
#include <xtsc/xtsc_memory_pin.h>
#include <xtsc/xtsc_memory_trace.h>
#include <xtsc/xtsc_pin2tlm_memory_transactor.h>
#include <xtsc/xtsc_tlm2pin_memory_transactor.h>
#include <xtsc/xtsc_mmio.h>
#include <xtsc/xtsc_queue_producer.h>
#include <xtsc/xtsc_queue_consumer.h>
#include <xtsc/xtsc_queue.h>
#include <xtsc/xtsc_queue_pin.h>
#include <xtsc/xtsc_router.h>
#include <xtsc/xtsc_slave.h>
#include <xtsc/xtsc_tx_loader.h>
#include <xtsc/xtsc_wire.h>
#include <xtsc/xtsc_wire_logic.h>
#include <xtsc/xtsc_wire_source.h>

#if defined(_WIN32)
#include <direct.h>
#define mkdir(path, mode) _mkdir(path)
#else
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#define _getcwd getcwd
int mkdir(const char *pathname, mode_t mode);
#endif


using namespace std;
using namespace sc_core;
using namespace xtsc;
using namespace xtsc_component;



typedef set<string>                     set_string;
typedef map<string,bool>                connect_map;
typedef connect_map::iterator           icmap;
typedef vector<pair<string,string> >    pair_table;



// Step 2:  Add a forward reference to class widget_info.

class arbiter_info;
class clock_info;
class consumer_info;
class cohctrl_info;
class core_info;
class distributor_info;
class dma_info;
class driver_info;
class loader_info;
class logic_info;
class lookup_info;
class lookup_pin_info;
class master_info;
class memory_info;
class memory_pin_info;
class memory_trace_info;
class mmio_info;
class pin2tlm_info;
class producer_info;
class proxy_info;
class queue_info;
class queue_pin_info;
class router_info;
class signal_info;
class slave_info;
class source_info;
class tlm2pin_info;
class vcd_info;
class wire_info;
class wrapper_info;



enum enum_wrapper_state { DEFINING_WRAPPER, BUILDING_SYSTEM}
                                wrapper_state           = BUILDING_SYSTEM;

xtsc_initialize_parms          *p_initialize_parms;                     // For xtsc_initialize()
wrapper_info                   *p_current_wrapper       = NULL;
ostringstream                  *p_oss_parms             = NULL;         // Must be defined before calling add_parm
string                         *p_name_module_parms     = NULL;         // Must be defined before calling add_parm

string                          memory_parms_args       = "";
string                          memory_pin_parms_args   = "";
string                          memory_trace_parms_args = "";
string                          tlm2pin_parms_args      = "";
string                          pin2tlm_parms_args      = "";

string                          isslibdir               = "iss";
string                          vendor                  = "<Vendor>";   // Will be <Vendor> from --cosim command
string                          vendor_version          = "";           // Will be <VendorVersion> from --cosim command
string                          gcc_version             = "";           // Will be <GccVersion> from --cosim command (6 characters)
string                          gcc_minor_version       = "";           // Will be 1st 3 characters of gcc_version

string                          top_env                 = "";           // From environment variable XTSC_RUN_COSIM_TOP_LANGUAGE
string                          vendor_env              = "";           // From environment variable XTSC_RUN_COSIM_VENDOR
string                          vendor_version_env      = "";           // From environment variable XTSC_RUN_COSIM_VENDOR_VERSION
string                          gcc_env                 = "g++";        // From environment variable XTSC_RUN_COSIM_GCC
string                          gcc_version_env         = "";           // From environment variable XTSC_RUN_COSIM_GCC_VERSION

u32                             cosimi                  = 0xFFFFFFFF;   // Index in commands of --cosim command
bool                            cosim                   = false;
bool                            verilog_on_top          = false;
bool                            systemc_on_top          = false;
bool                            no_check                = false;        // set using environment variable XTSC_RUN_COSIM_NO_CHECK
bool                            xtsc_64bit              = false;        // set using environment variable XTSC_RUN_COSIM_64BIT

#if defined(_WIN32)
string                          sep                     = "\\";         // Path separator for MS Windows
#else
string                          sep                     = "/";          // Path separator for Linux
#endif
string                          dot                     = ".";          

string                          path                    = dot;          // Path to generated directory
string                          dir                     = "";           // Name of generated directory

u32                             object_number           = 0;

u32                             w                       = 0xFFFFFFFF;   // wrapper index (0 if not doing wrappers)
vector<ostringstream*>          oss_main;                               // one for each wrapper/sc_main
vector<pair_table*>             modules;                                // pair<type,name>, pair_table for each wrapper/sc_main

string                          tab1                    = "  ";
string                          tab2                    = tab1 + tab1;
string                          tab3                    = tab2 + tab1;
string                          tab4                    = tab3 + tab1;

vector<map<string,void*>*>      identifier_map;                         // Support void* parameter values
map<string,vector<proxy_info*>*>verilog_proxy_vector_map;               // Map Verilog proxy module name to each proxy of that type

vector<string>                  commands;                               // All commands from argv or --include in order
vector<string>                  command_files;                          // --include file where command came from (or "" if argv)
vector<u32>                     command_line_numbers;                   // Commands line number (or argv index) in --include file 
vector<string>                  info_for_exceptions;                    // From xtsc_script_file

bool                            sc_main_command         = false;        // An --sc_main command was encountered
bool                            do_generate_sc_main     = false;
string                          sc_main_name_default    = "sc_main.gen.cpp";
string                          sc_main_name            = sc_main_name_default;
bool                            found_program_name      = false;        // Found first command which does not start with hyphen 
string                          xtsc_run_name           = "xtsc-run";   // To be updated by argv[0] in main
string                          logging                 = "";           // log4xtensa::TextLogger configuration file
string                          binary                  = "";           // log4xtensa::BinaryLogger configuration file
string                          cmd                     = "";           // The current command being parsed
string                          command_file            = "";           // --include file where current command came from 
u32                             command_line_number     = 0;            // Current commands line number (or argv index) 
string                          info_for_exception      = "";           // Info from xtsc_script_file
string                          rem                     = "";           // The remainder of this cmd to parse
string                          rem_lc                  = "";           // Lower-case version of rem
string                          command_name            = "";           // Portion before equal sign excluding --
string                          parm_name               = "";
xtsc_parms::xtsc_parameter_type parm_type;
string                          parm_value              = "";
string                          string_array_separator  = ",";
string                          parm_value_lc           = "";
bool                            parm_value_bool         = false;
double                          parm_value_double       = 0;
u32                             parm_value_u32          = 0;
vector<u32>                     parm_value_u32_vector;
char                          **parm_value_c_str_array  = 0;
void                           *parm_value_void_pointer = 0;
string                          void_pointer_name       = "";
string                          lookup_name             = "";
string                          csv                     = "";           // csv = comma separated value
bool                            more_csv                = false;

bool                            command_is_assignment   = false;        // cmd has format:  --command_name=[value]

const char                     *XTENSA_CORE             = NULL;
const char                     *XTENSA_SYSTEM           = NULL;
const char                     *XTENSA_PARAMS           = NULL;

xtsc_core::memory_port          use_memport             = xtsc_core::MEM_PIF;  // From the -memory_port command
bool                            use_memport_had_ls      = false;       // true if the memory_port command arg had a ls0/ls1 suffix
xtsc_core::memory_port          use_memport_pin         = xtsc_core::MEM_PIF;  // From the -memory_pin_port command
bool                            use_memport_pin_had_ls  = false;       // true if the memory_pin_port command arg had ls0/ls1 suffix
bool                            show_memory_parms_called= false;
bool                            add_memory_parm_called  = false;

bool                            summary                 = false;
bool                            summary_verbose         = false;
u32                             cycle_limit             = 0xFFFFFFFF;
bool                            no_simulation           = false;
bool                            no_default_mem          = false;
bool                            no_default_local_mem    = false;
bool                            core_summary            = false;
bool                            logging_elab_only       = false;
string                          last_core_created       = "";
bool                            redo_core_parms_called  = false;

bool                            explicit_core_parm_set  = false;       // Either a parameter or the following core_xxx objects

bool                            debug_wait              = true;
bool                            debug_sync              = false;
u32                             debug_start_port        = 0;

bool                            core_debug              = false;
bool                            core_debug_wait         = true;
bool                            core_debug_sync         = false;
u32                             core_debug_start_port   = 0;

bool                            multi_core_debug        = false;
bool                            multi_core_debug_wait   = true;
bool                            multi_core_debug_sync   = false;
u32                             multi_core_debug_start_port = 0;

bool                            multi_core_profile      = false;

string                          core_program            = "";          // Comma separated list of ELF files
const char                    **core_program_argv       = NULL;
vector<string>                  core_client;
bool                            explicit_no_program     = false;       // --core_program=

log4xtensa::TextLogger&         logger                  = log4xtensa::TextLogger::getInstance("xtsc-run");
bool                            logging_is_configured   = false;
string                          data_dir                = "readmemh.data";

const size_t                    work_buffer_size        = 4096;
u8                              work_buffer[work_buffer_size];


void             add_identifier(const string& name, void *p_void);
void            *get_identifier(const string& name);



// Step 3:  Instantiate: vector<map<string,widget_info*>*> widget_map;

vector<map<string,arbiter_info*>*>              arbiter_map;
vector<map<string,clock_info*>*>                clock_map;
vector<map<string,cohctrl_info*>*>              cohctrl_map;
vector<map<string,consumer_info*>*>             consumer_map;
vector<map<string,core_info*>*>                 core_map;
vector<map<string,distributor_info*>*>          distributor_map;
vector<map<string,dma_info*>*>                  dma_map;
vector<map<string,driver_info*>*>               driver_map;
vector<map<string,loader_info*>*>               loader_map;
vector<map<string,logic_info*>*>                logic_map;
vector<map<string,lookup_info*>*>               lookup_map;
vector<map<string,lookup_pin_info*>*>           lookup_pin_map;
vector<map<string,master_info*>*>               master_map;
vector<map<string,memory_info*>*>               memory_map;
vector<map<string,memory_pin_info*>*>           memory_pin_map;
vector<map<string,memory_trace_info*>*>         memory_trace_map;
vector<map<string,mmio_info*>*>                 mmio_map;
vector<map<string,pin2tlm_info*>*>              pin2tlm_map;
vector<map<string,producer_info*>*>             producer_map;
vector<map<string,proxy_info*>*>                proxy_map;
vector<map<string,queue_info*>*>                queue_map;
vector<map<string,queue_pin_info*>*>            queue_pin_map;
vector<map<string,router_info*>*>               router_map;
vector<map<string,signal_info*>*>               signal_map;
vector<map<string,slave_info*>*>                slave_map;
vector<map<string,source_info*>*>               source_map;
vector<map<string,tlm2pin_info*>*>              tlm2pin_map;
vector<map<string,vcd_info*>*>                  vcd_map;
vector<map<string,wire_info*>*>                 wire_map;
map<string,wrapper_info*>                       wrapper_map;
vector<string>                                  wrapper_list;



class clock_parms : public xtsc_parms {
public:
  clock_parms() {
    add("start_time",           0);
    add("posedge_first",        true);
    add("high_duty_cycle",      0.5);
    add("period",               (u32) (xtsc_get_system_clock_period().value() & 0xFFFFFFFFULL));
    add("vcd_handle",           (void*) NULL);
  }
  virtual const char* kind() const { return "clock_parms"; }
};



class make_parms : public xtsc_parms {
public:
  make_parms() {

    if (systemc_on_top) {
      ;  // No common parms
    }
    else if (verilog_on_top) {
      const char *c_str_array[] = { NULL };
      add("testbench_name",             "testbench");
      add("generate_testbench",         false);
      add("verilog_files",              c_str_array);
    }
    else {
      ostringstream oss;
      oss << "Error:  You must use the --cosim command if you want to use the --set_make_parm or --show_make_parms commands";
      throw xtsc_exception(oss.str());
    }

    string arch_flag(xtsc_64bit ? "-fPIC" : "-m32");

    if (vendor == "cadence") {
      ostringstream ncshell_args;
      ncshell_args << "-scopts \"-CFLAGS " << arch_flag << "\"";
      if (systemc_on_top) {
        add("argv_space",               "@");
        add("cxx",                      gcc_env.c_str());
        add("cxx_args",                 (arch_flag + " -U NDEBUG -D DEBUG -g -O0").c_str());
        add("ld_args",                  arch_flag.c_str());
        add("ncvlog_args",              "");
        add("ncshell_args",             ncshell_args.str().c_str());
        add("ncelab_args",              "");
        add("ncsim_args",               "");
      }
      else if (verilog_on_top) {
        add("cxx",                      gcc_env.c_str());
        add("cxx_args",                 (arch_flag + " -U NDEBUG -D DEBUG -g -O0").c_str());
        add("ld_args",                  arch_flag.c_str());
        add("ncsc_args",                "");
        add("ncshell_args",             ncshell_args.str().c_str());
        add("ncverilog_args",           "");
        add("ncsim_args",               "");
        add("readmemh_use_prefix",      false);
      }
    }
    else if (vendor == "mentor") {
      if (systemc_on_top) {
        add("argv_space",               (char*) NULL);
        add("modelsim_ini",             "");
        add("vlog_args",                "");
        add("scgenmod_args",            "");
        add("sccom_args",               (arch_flag + " -U NDEBUG -D DEBUG -g -O0").c_str());
        add("sccom_link_args",          arch_flag.c_str());
        add("vsim_args",                "");
      }
      else if (verilog_on_top) {
        add("modelsim_ini",             "");
        add("vlog_args",                "");
        add("sccom_args",               (arch_flag + " -U NDEBUG -D DEBUG -g -O0").c_str());
        add("sccom_link_args",          arch_flag.c_str());
        add("vsim_args",                "");
        add("readmemh_use_prefix",      false);
      }
    }
    else if (vendor == "synopsys") {
      ostringstream syscan_args, syscsim_args;
      syscan_args << "-debug_all -V -cflags \"" << arch_flag << " -UNDEBUG -DDEBUG -g -O0\"";
      syscsim_args << "-debug_all -cflags \"-g " << arch_flag << "\"";
      if (systemc_on_top) {
        add("argv_space",               (char*) NULL);
        add("cxx",                      gcc_env.c_str());
        add("vlogan_args",              "");
        add("syscan_args",              syscan_args.str().c_str());
        add("syscsim_args",             syscsim_args.str().c_str());
        add("simv_args",                "");
      }
      else if (verilog_on_top) {
        add("cxx",                      gcc_env.c_str());
        add("syscan_args",              syscan_args.str().c_str());
        add("vcs_args",                 (syscsim_args.str() + " +v2k").c_str());
        add("vcs_ld_args",              "");
        add("simv_args",                "");
        add("readmemh_use_prefix",      false);
      }
    }
  }


  virtual const char* kind() const { return "make_parms"; }
};



class proxy_parms : public xtsc_parms {
public:
  proxy_parms() {
    string readmemh_interface = xtsc_core::get_memory_port_name(use_memport_pin, true);
    transform(readmemh_interface.begin(), readmemh_interface.end(), readmemh_interface.begin(), ::tolower);
    add("extra_inputs",         (char**) NULL);
    add("extra_outputs",        (char**) NULL);
    add("module_name",          (char*)  NULL);
    add("readmemh_cores",       (char**) NULL);
    add("verilog_file",         (char*)  NULL);
    add("verilog_files",        (char*)  NULL);
    add("vcd_handle",           (void*)  NULL);
    add("readmemh_interface",   readmemh_interface.c_str());
    add("readmemh_file_name",   (char*)  NULL);
    add("fully_connect_cores",  (char**) NULL);
  }
  virtual const char* kind() const { return "proxy_parms"; }
};



class signal_parms : public xtsc_parms {
public:
  signal_parms() {
    add("bit_width",            1);
    add("vcd_handle",           (void*) NULL);
  }
  virtual const char* kind() const { return "signal_parms"; }
};



class vcd_parms : public xtsc_parms {
public:
  vcd_parms() {
    add("file_name",            (char*) NULL);
  }
  virtual const char* kind() const { return "vcd_parms"; }
};



class wrapper_parms : public xtsc_parms {
public:
  wrapper_parms() {
    add("argv_space",           ((vendor == "cadence") ? "@" : (char*) NULL));
    add("extra_inputs",         (char**) NULL);
    add("extra_outputs",        (char**) NULL);
    add("readmemh_cores",       (char**) NULL);
    add("fully_connect_cores",  (char**) NULL);
    add("vcd_handle",           (char*)  NULL);
    add("shadow_memory",        false);
  }
  virtual const char* kind() const { return "wrapper_parms"; }
};



// Step 4:  Define: xtsc_widget_parms *p_widget_parms = NULL;
clock_parms                            *p_clock_parms           = NULL;
make_parms                             *p_make_parms            = NULL;
proxy_parms                            *p_proxy_parms           = NULL;
signal_parms                           *p_signal_parms          = NULL;
vcd_parms                              *p_vcd_parms             = NULL;
wrapper_parms                          *p_wrapper_parms         = NULL;
xtsc_arbiter_parms                     *p_arbiter_parms         = NULL;
xtsc_queue_consumer_parms              *p_consumer_parms        = NULL;
xtsc_cohctrl_parms                     *p_cohctrl_parms         = NULL;
xtsc_core_parms                        *p_core_parms            = NULL;
xtsc_dma_engine_parms                  *p_dma_parms             = NULL;
xtsc_interrupt_distributor_parms       *p_distributor_parms     = NULL;
xtsc_tx_loader_parms                   *p_loader_parms          = NULL;
xtsc_wire_logic_parms                  *p_logic_parms           = NULL;
xtsc_lookup_parms                      *p_lookup_parms          = NULL;
xtsc_lookup_pin_parms                  *p_lookup_pin_parms      = NULL;
xtsc_lookup_driver_parms               *p_driver_parms          = NULL;
xtsc_master_parms                      *p_master_parms          = NULL;
xtsc_memory_parms                      *p_memory_parms          = NULL;
xtsc_memory_pin_parms                  *p_memory_pin_parms      = NULL;
xtsc_memory_trace_parms                *p_memory_trace_parms    = NULL;
xtsc_mmio_parms                        *p_mmio_parms            = NULL;
xtsc_pin2tlm_memory_transactor_parms   *p_pin2tlm_parms         = NULL;
xtsc_queue_producer_parms              *p_producer_parms        = NULL;
xtsc_queue_parms                       *p_queue_parms           = NULL;
xtsc_queue_pin_parms                   *p_queue_pin_parms       = NULL;
xtsc_router_parms                      *p_router_parms          = NULL;
xtsc_slave_parms                       *p_slave_parms           = NULL;
xtsc_wire_source_parms                 *p_source_parms          = NULL;
xtsc_tlm2pin_memory_transactor_parms   *p_tlm2pin_parms         = NULL;
xtsc_wire_parms                        *p_wire_parms            = NULL;



// Step 5:  Define  ostringstream oss_widget_parms;
ostringstream oss_arbiter_parms;
ostringstream oss_clock_parms;
ostringstream oss_consumer_parms;
ostringstream oss_cohctrl_parms;
ostringstream oss_core_parms;
ostringstream oss_distributor_parms;
ostringstream oss_dma_parms;
ostringstream oss_loader_parms;
ostringstream oss_logic_parms;
ostringstream oss_lookup_parms;
ostringstream oss_lookup_pin_parms;
ostringstream oss_driver_parms;
ostringstream oss_make_parms;
ostringstream oss_master_parms;
ostringstream oss_memory_parms;
ostringstream oss_memory_pin_parms;
ostringstream oss_memory_trace_parms;
ostringstream oss_mmio_parms;
ostringstream oss_pin2tlm_parms;
ostringstream oss_producer_parms;
ostringstream oss_proxy_parms;
ostringstream oss_queue_parms;
ostringstream oss_queue_pin_parms;
ostringstream oss_router_parms;
ostringstream oss_signal_parms;
ostringstream oss_slave_parms;
ostringstream oss_source_parms;
ostringstream oss_tlm2pin_parms;
ostringstream oss_vcd_parms;
ostringstream oss_wire_parms;
ostringstream oss_wrapper_parms;
ostringstream oss_xtsc_parms;



// Step 6:  Define  string name_widget_parms;
string name_arbiter_parms;
string name_clock_parms;
string name_consumer_parms;
string name_cohctrl_parms;
string name_core_parms;
string name_distributor_parms;
string name_dma_parms;
string name_loader_parms;
string name_logic_parms;
string name_lookup_parms;
string name_lookup_pin_parms;
string name_driver_parms;
string name_make_parms;
string name_master_parms;
string name_memory_parms;
string name_memory_pin_parms;
string name_memory_trace_parms;
string name_mmio_parms;
string name_pin2tlm_parms;
string name_producer_parms;
string name_proxy_parms;
string name_queue_parms;
string name_queue_pin_parms;
string name_router_parms;
string name_signal_parms;
string name_slave_parms;
string name_source_parms;
string name_tlm2pin_parms;
string name_vcd_parms;
string name_wire_parms;
string name_wrapper_parms;
string name_xtsc_parms = "xtsc_parms__@";



#if defined(__x86_64__)
u32 min(u32 a, size_t b) { return min(a, (u32)b); }
u32 max(u32 a, size_t b) { return max(a, (u32)b); }
#endif



void dump_parms(const ostringstream& oss_xxx_parms, const string& old_parms_name, const string& module_instance_name) {
  string parm_instance_name(module_instance_name+"__parms");
  string parms(oss_xxx_parms.str());
  string::size_type pos;
  while ((pos = parms.find(old_parms_name)) != string::npos) {
    parms.replace(pos, old_parms_name.length(), parm_instance_name);
  }
  *oss_main[w] << parms;
  *oss_main[w] << tab2 << parm_instance_name << ".extract_parms(argc, argv, \"" << module_instance_name << "\");" << endl;
}



// So generated sc_main/wrapper can take care of declaring and deleting the sc_module derived objects.
void register_sc_module(const string& type, const string& name) {
  modules[w]->push_back(make_pair(type, name));
}



// For literal strings generated to C++ code (e.g. --sc_main)
string escape_backslashes(const string& in) {
  string out;
  for (size_t i=0; i<in.length(); ++i) {
    char c = in[i];
    if (c == '\\') {
      out += c;
    }
    out += c;
  }
  return out;
}



// Step 7:  Define: class widget_info
//          Follow the pattern of the other xxx_info classes.
//          Basically class widget_info should have a constuctor,
//          a destructor, and the following three data members:
//            1) string                 name;
//            2) xtsc_widget_parms      parms;
//            3) xtsc_widget           *p_widget;
//          It should also have data members to keep track of
//          what has been connected to it.  The constructor
//          should call register_sc_module() for the underlying
//          sc_module sub-class so that it can be deleted in
//          any generated sc_main.cpp file.

class arbiter_info {
public:
  arbiter_info(const string& name, const xtsc_arbiter_parms& parms) :
    name                (name),
    parms               (parms),
    slave_connected     (false),
    num_master_connected(0)
  {
    XTSC_DEBUG(logger, "Creating arbiter '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure arbiter " << name << endl;
    *oss_main[w] << tab2 << "xtsc_arbiter_parms " << name << "__parms;" << endl;
    dump_parms(oss_arbiter_parms, name_arbiter_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create arbiter " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_arbiter(\"" << name << "\", " << name << "__parms);" << endl;
    p_arbiter = new xtsc_arbiter(name.c_str(), parms);
    register_sc_module("xtsc_arbiter", name);
  }
  ~arbiter_info() {
    delete p_arbiter;
  }
  string                name;
  xtsc_arbiter_parms    parms;
  xtsc_arbiter         *p_arbiter;
  bool                  slave_connected;
  int                   num_master_connected;
};



class clock_info {
public:
  clock_info(const string& name, const clock_parms& parms) :
    name                (name),
    parms               (parms),
    trace_identifier    (""),
    num_sink_connected  (0)
  {
    XTSC_DEBUG(logger, "Creating clock '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create clock " << name << endl;
    *oss_main[w] << tab2 << (verilog_on_top ? "" : "sc_clock *")
                         << name << " = new sc_clock(\"" << name << "\", " 
                         << parms.get_u32   ("period")          << "*sc_get_time_resolution(), "
                         << parms.get_double("high_duty_cycle") << ", "
                         << parms.get_u32   ("start_time")      << "*sc_get_time_resolution(), " << boolalpha
                         << parms.get_bool  ("posedge_first")   << ");" << endl;
    if (verilog_on_top) {
      *oss_main[w] << tab2 << "SC_METHOD(" << name << "_method);" << endl;
      *oss_main[w] << tab2 << "sensitive << *" << name << ";" << endl;
    }
    p_clock = new sc_clock(name.c_str(),
                           parms.get_u32   ("period")         *sc_get_time_resolution(),
                           parms.get_double("high_duty_cycle"),
                           parms.get_u32   ("start_time")     *sc_get_time_resolution(),
                           parms.get_bool  ("posedge_first"));
    XTSC_DEBUG(logger, "clock '" << name << "' has period of " << p_clock->period());
    const void *p_tf = parms.get_void_pointer("vcd_handle");
    if (p_tf) {
      for (map<string, void*>::const_iterator ii = identifier_map[w]->begin(); ii != identifier_map[w]->end(); ++ii) {
        if (ii->second == p_tf) {
          trace_identifier = ii->first;
          break;
        }
      }
      sc_trace((sc_trace_file*)p_tf, *p_clock, p_clock->name());
      *oss_main[w] << tab2 << "sc_trace(" << trace_identifier << ", *" << p_clock->name() << ", \"" << p_clock->name() << "\");"
                           << endl;
    }
  }
  ~clock_info() {
  }
  string                name;
  clock_parms           parms;
  string                trace_identifier;
  sc_clock             *p_clock;
  int                   num_sink_connected;
};



class consumer_info {
public:
  consumer_info(const string& name, const xtsc_queue_consumer_parms& parms) :
    name                (name),
    parms               (parms),
    queue_connected     (false)
  {
    XTSC_DEBUG(logger, "Creating consumer '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure consumer " << name << endl;
    *oss_main[w] << tab2 << "xtsc_queue_consumer_parms " << name << "__parms;" << endl;
    dump_parms(oss_consumer_parms, name_consumer_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create consumer " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_queue_consumer(\"" << name << "\", " << name << "__parms);" << endl;
    p_consumer = new xtsc_queue_consumer(name.c_str(), parms);
    register_sc_module("xtsc_queue_consumer", name);
  }
  ~consumer_info() {
    delete p_consumer;
  }
  string                        name;
  xtsc_queue_consumer_parms     parms;
  xtsc_queue_consumer          *p_consumer;
  bool                          queue_connected;
};



class cohctrl_info {
public:
  cohctrl_info(const string& name, const xtsc_cohctrl_parms& parms) :
    name                (name),
    parms               (parms),
    num_clients         (parms.get_non_zero_u32("num_clients")),
    slave_connected     (false)
  {
    XTSC_DEBUG(logger, "Creating cohctrl '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure cohctrl " << name << endl;
    *oss_main[w] << tab2 << "xtsc_cohctrl_parms " << name << "__parms(" << parms.get_u32("num_transfers") << ");" << endl;
    dump_parms(oss_cohctrl_parms, name_cohctrl_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create cohctrl " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_cohctrl(\"" << name << "\", " << name << "__parms);" << endl;
    p_cohctrl = new xtsc_cohctrl(name.c_str(), parms);
    register_sc_module("xtsc_cohctrl", name);
    master_connected = new bool[num_clients];
    snoop_connected  = new bool[num_clients];
    ccon_connected   = new bool[num_clients];
    for (u32 i=0; i<num_clients; ++i) {
      master_connected[i] = false;
      snoop_connected[i]  = false;
      ccon_connected[i]   = false;
    }
  }
  ~cohctrl_info() {
    delete p_cohctrl;
  }
  u32 get_first_free_master_port() {
    for (u32 i=0; i<num_clients; ++i) {
      if (!master_connected[i]) return i;
    }
    ostringstream oss;
    oss << "Cohctrl '" << name << "' has no free master ports";
    void command_info(ostream& os);
    command_info(oss);
    throw xtsc_exception(oss.str());
    return 0;
  }
  string                name;
  xtsc_cohctrl_parms    parms;
  xtsc_cohctrl         *p_cohctrl;
  u32                   num_clients;
  bool                  slave_connected;
  bool                 *master_connected;
  bool                 *snoop_connected;
  bool                 *ccon_connected;
};



class core_info {
public:
  core_info(const string& name, const xtsc_core_parms& parms) :
    name                        (name),
    parms                       (parms),
    inbound_connected           (false),
    snoop_connected             (false),
    tx_xfer_in_connected        (false),
    tx_xfer_out_connected       (false),
    core_summary                (::core_summary),
    has_program_loaded          (false),
    explicit_no_program         (::explicit_no_program),
    no_default_mem              (::no_default_mem),
    no_default_local_mem        (::no_default_local_mem),
    program_name                ("")
  {
    XTSC_DEBUG(logger, "Creating core '" << name << "'");
    ::explicit_no_program = false;
    p_core = new xtsc_core(name.c_str(), parms);
    register_sc_module("xtsc_core", name);
    for (xtsc_core::memory_port p=xtsc_core::MEM_FIRST; p<=xtsc_core::MEM_LAST; ++p) {
      memory_connected[p] = false;
    }
    string xtensa_core  (XTENSA_CORE   ? XTENSA_CORE   : "");
    string xtensa_system(XTENSA_SYSTEM ? XTENSA_SYSTEM : "");
    string xtensa_params(XTENSA_PARAMS ? XTENSA_PARAMS : "");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure core " << name << endl;
    *oss_main[w] << tab2 << "xtsc_core_parms " << name << "__parms(" << endl;
    *oss_main[w] << tab3 << "\"" << xtensa_core   << "\", " << endl;
    *oss_main[w] << tab3 << "\"" << escape_backslashes(xtensa_system) << "\", " << endl;
    *oss_main[w] << tab3 << "\"" << escape_backslashes(xtensa_params) << "\"" << endl;
    *oss_main[w] << tab2 << ");" << endl;
    dump_parms(oss_core_parms, name_core_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create core " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_core(\"" << name << "\", " << name << "__parms);" << endl;
    if (core_program != "") {
      load_program();
    }
    if (multi_core_profile || (core_client.begin() != core_client.end())) {
      *oss_main[w] << endl;
      *oss_main[w] << tab2 << "// Load clients " << endl;
      if (multi_core_profile) {
        p_core->load_client("profile --all");
        *oss_main[w] << tab2 << name << "->load_client(\"profile --all\");" << endl;
      }
      vector<string>::iterator is = core_client.begin();
      for (;is != core_client.end(); ++is) {
        p_core->load_client((*is).c_str());
        *oss_main[w] << tab2 << name << "->load_client(\"" << escape_backslashes(*is) << "\");" << endl;
      }
      core_client.clear();
    }
    if (core_debug) {
      u32 port_num = 0;
      port_num = p_core->enable_debug(core_debug_wait, core_debug_sync, true, core_debug_start_port);
      XTSC_NOTE(logger, "Debug of core '" << name << "' enabled on port #" << port_num);
      *oss_main[w] << endl;
      *oss_main[w] << tab2 << "// Set-up debugging for core " << name << endl;
      *oss_main[w] << tab2 << "u32 " << name << "__port = " << name << "->enable_debug(" << boolalpha << core_debug_wait
                           << ", " << core_debug_sync << ", true, " << core_debug_start_port << ");" << endl;
      *oss_main[w] << tab2 << "XTSC_NOTE(logger, \"Debug of core '" << name << "' enabled on port #\" << "
                           << name << "__port);" << endl;
    }
    init_connected_map(lookup_connected,        p_core->get_lookup_set(),             p_core->get_pin_level_lookup_set());
    init_connected_map(input_queue_connected,   p_core->get_input_queue_set(),        p_core->get_pin_level_input_queue_set());
    init_connected_map(output_queue_connected,  p_core->get_output_queue_set(),       p_core->get_pin_level_output_queue_set());
    init_connected_map(import_wire_connected,   p_core->get_import_wire_set(),        p_core->get_pin_level_import_wire_set());
    init_connected_map(export_state_connected,  p_core->get_export_state_set(),       p_core->get_pin_level_export_state_set());
    init_connected_map(system_input_connected,  p_core->get_system_input_wire_set(),  p_core->get_pin_level_system_input_set());
    init_connected_map(system_output_connected, p_core->get_system_output_wire_set(), p_core->get_pin_level_system_output_set());
  }
  ~core_info() {
    delete p_core;
  }
  void load_program() {
    XTSC_DEBUG(logger, "Loading core '" << name << "' with program(s): " << core_program);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Load core program" << endl;
    *oss_main[w] << tab2 << "const char *" << name << "__argv[] = {";
    if (core_program_argv) {
      for (int i = 0; core_program_argv[i] != NULL; ++i) {
        *oss_main[w] << endl;
        *oss_main[w] << tab3 << "\"" << escape_backslashes(core_program_argv[i]) << "\",";
      }
      *oss_main[w] << endl << tab3 << "NULL";
      *oss_main[w] << endl << tab2  << "};" << endl;
    }
    else {
      *oss_main[w] << " NULL };" << endl;
    }
    *oss_main[w] << tab2 << name << "->load_program(\"" << escape_backslashes(core_program) << "\", " << name << "__argv);" << endl;
    p_core->load_program(core_program.c_str(), core_program_argv);
    program_name = core_program;
    has_program_loaded = true;
    core_program = "";
    if (core_program_argv != NULL) {
      delete [] core_program_argv;
      core_program_argv = NULL;
    }
  }
  static void init_connected_map(map<string,bool>& connected_map, const set<string>& tlm_set, const set<string>& pin_set) {
    for (set<string>::const_iterator i=tlm_set.begin(); i!=tlm_set.end(); ++i) { connected_map[*i] = false; }
    for (set<string>::const_iterator i=pin_set.begin(); i!=pin_set.end(); ++i) { connected_map[*i] = false; }
  }
  string                name;
  xtsc_core_parms       parms;
  xtsc_core            *p_core;
  bool                  memory_connected[xtsc_core::MEM_COUNT];
  bool                  inbound_connected;      // Inbound PIF
  bool                  snoop_connected;        // Snoop port for cache coherence
  bool                  tx_xfer_in_connected;   // Input TX XFER interface 
  bool                  tx_xfer_out_connected;  // Output TX XFER interface
  bool                  core_summary;
  bool                  has_program_loaded;
  bool                  explicit_no_program;
  bool                  no_default_mem;
  bool                  no_default_local_mem;
  string                program_name;           // Comma separated list of programs loaded to this core
  map<string,bool>      lookup_connected;
  map<string,bool>      input_queue_connected;
  map<string,bool>      output_queue_connected;
  map<string,bool>      import_wire_connected;
  map<string,bool>      export_state_connected;
  map<string,bool>      system_input_connected;
  map<string,bool>      system_output_connected;
};



class distributor_info {
public:
  distributor_info(const string& name, const xtsc_interrupt_distributor_parms& parms) :
    name                (name),
    parms               (parms)
  {
    XTSC_DEBUG(logger, "Creating distributor '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure distributor " << name << endl;
    *oss_main[w] << tab2 << "xtsc_interrupt_distributor_parms " << name << "__parms(0, 0);" << endl;
    dump_parms(oss_distributor_parms, name_distributor_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create distributor " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_interrupt_distributor(\"" << name << "\", " << name << "__parms);" << endl;
    p_distributor = new xtsc_interrupt_distributor(name.c_str(), parms);
    register_sc_module("xtsc_interrupt_distributor", name);
    set<string> inputs = p_distributor->get_input_set();
    for (set<string>::iterator ii = inputs.begin(); ii != inputs.end(); ++ii) {
      inputs_connected.insert(map<string,bool>::value_type(*ii, false));
    }
    set<string> lookups = p_distributor->get_lookup_set();
    for (set<string>::iterator il = lookups.begin(); il != lookups.end(); ++il) {
      lookups_connected.insert(map<string,bool>::value_type(*il, false));
    }
    set<string> outputs = p_distributor->get_output_set();
    for (set<string>::iterator io = outputs.begin(); io != outputs.end(); ++io) {
      outputs_connected.insert(map<string,bool>::value_type(*io, false));
    }
  }
  ~distributor_info() {
    delete p_distributor;
  }
  string                                name;
  xtsc_interrupt_distributor_parms      parms;
  xtsc_interrupt_distributor           *p_distributor;
  map<string,bool>                      inputs_connected;
  map<string,bool>                      lookups_connected;
  map<string,bool>                      outputs_connected;
};



class dma_info {
public:
  dma_info(const string& name, const xtsc_dma_engine_parms& parms) :
    name                (name),
    parms               (parms),
    slave_connected     (false),
    num_ports           (parms.get_non_zero_u32("num_ports"))
  {
    XTSC_DEBUG(logger, "Creating dma '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure dma " << name << endl;
    *oss_main[w] << tab2 << "xtsc_dma_engine_parms " << name << "__parms(0x00000000);" << endl;
    dump_parms(oss_dma_parms, name_dma_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create dma " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_dma_engine(\"" << name << "\", " << name << "__parms);" << endl;
    p_dma = new xtsc_dma_engine(name.c_str(), parms);
    register_sc_module("xtsc_dma_engine", name);
    master_connected = new bool[num_ports];
    for (u32 i=0; i<num_ports; ++i) {
      master_connected[i] = false;
    }
  }
  ~dma_info() {
    delete p_dma;
  }
  string                        name;
  xtsc_dma_engine_parms         parms;
  xtsc_dma_engine              *p_dma;
  bool                          slave_connected;
  u32                           num_ports;
  bool                         *master_connected;
};



class loader_info {
public:
  loader_info(const string& name, const xtsc_tx_loader_parms& parms) :
    name                (name),
    parms               (parms),
    first_tx_connected  (false),
    last_tx_connected   (false),
    producer_connected  (false),
    consumer_connected  (false),
    push                (NULL),
    data_in             (NULL),
    full                (NULL),
    pop                 (NULL),
    data_out            (NULL),
    empty               (NULL)
  {
    XTSC_DEBUG(logger, "Creating loader '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure loader " << name << endl;
    *oss_main[w] << tab2 << "xtsc_tx_loader_parms " << name << "__parms;" << endl;
    dump_parms(oss_loader_parms, name_loader_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create loader " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_tx_loader(\"" << name << "\", " << name << "__parms);" << endl;
    p_loader = new xtsc_tx_loader(name.c_str(), parms);
    register_sc_module("xtsc_tx_loader", name);
    outputs_connected.insert(map<string,bool>::value_type("Mode", false));
    outputs_connected.insert(map<string,bool>::value_type("Done", false));
  }
  ~loader_info() {
    delete p_loader;
  }
  void create_and_bind_producer_signals() {
    XTSC_TRACE(logger, "loader_info::create_and_bind_producer_signals() for '" << name << "'");
    push        = new xtsc_signal_sc_bv_base((name+"__push"    ).c_str(), 1);
    data_in     = new xtsc_signal_sc_bv_base((name+"__data_in" ).c_str(), 32);
    full        = new xtsc_signal_sc_bv_base((name+"__full"    ).c_str(), 1);
    (*p_loader->m_push    )(*push);
    (*p_loader->m_full    )(*full);
    (*p_loader->m_data_in )(*data_in);
  }
  void create_and_bind_consumer_signals() {
    XTSC_TRACE(logger, "loader_info::create_and_bind_consumer_signals() for '" << name << "'");
    pop         = new xtsc_signal_sc_bv_base((name+"__pop"     ).c_str(), 1);
    data_out    = new xtsc_signal_sc_bv_base((name+"__data_out").c_str(), 32);
    empty       = new xtsc_signal_sc_bv_base((name+"__empty"   ).c_str(), 1);
    (*p_loader->m_pop     )(*pop);
    (*p_loader->m_empty   )(*empty);
    (*p_loader->m_data_out)(*data_out);
  }
  string                        name;
  xtsc_tx_loader_parms          parms;
  xtsc_tx_loader               *p_loader;
  bool                          first_tx_connected;
  bool                          last_tx_connected;
  bool                          producer_connected;
  bool                          consumer_connected;
  xtsc_signal_sc_bv_base       *push;
  xtsc_signal_sc_bv_base       *data_in;
  xtsc_signal_sc_bv_base       *full;
  xtsc_signal_sc_bv_base       *pop;
  xtsc_signal_sc_bv_base       *data_out;
  xtsc_signal_sc_bv_base       *empty;
  map<string,bool>              outputs_connected;
};



class logic_info {
public:
  logic_info(const string& name, const xtsc_wire_logic_parms& parms) :
    name                (name),
    parms               (parms)
  {
    XTSC_DEBUG(logger, "Creating logic '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure logic " << name << endl;
    *oss_main[w] << tab2 << "xtsc_wire_logic_parms " << name << "__parms(\"\");" << endl;
    dump_parms(oss_logic_parms, name_logic_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create logic " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_wire_logic(\"" << name << "\", " << name << "__parms);" << endl;
    p_logic = new xtsc_wire_logic(name.c_str(), parms);
    register_sc_module("xtsc_wire_logic", name);
    set<string> inputs = p_logic->get_input_set();
    for (set<string>::iterator ii = inputs.begin(); ii != inputs.end(); ++ii) {
      inputs_connected.insert(map<string,bool>::value_type(*ii, false));
    }
    set<string> outputs = p_logic->get_output_set();
    for (set<string>::iterator io = outputs.begin(); io != outputs.end(); ++io) {
      outputs_connected.insert(map<string,bool>::value_type(*io, false));
    }
  }
  ~logic_info() {
    delete p_logic;
  }
  string                        name;
  xtsc_wire_logic_parms         parms;
  xtsc_wire_logic              *p_logic;
  map<string,bool>              inputs_connected;
  map<string,bool>              outputs_connected;
};



class lookup_info {
public:
  lookup_info(const string& name, const xtsc_lookup_parms& parms) :
    name                (name),
    parms               (parms),
    master_connected    (false)
  {
    XTSC_DEBUG(logger, "Creating lookup '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure lookup " << name << endl;
    *oss_main[w] << tab2 << "xtsc_lookup_parms " << name << "__parms(0, 0, false);" << endl;
    dump_parms(oss_lookup_parms, name_lookup_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create lookup " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_lookup(\"" << name << "\", " << name << "__parms);" << endl;
    p_lookup = new xtsc_lookup(name.c_str(), parms);
    register_sc_module("xtsc_lookup", name);
  }
  ~lookup_info() {
    delete p_lookup;
  }
  string                name;
  xtsc_lookup_parms     parms;
  xtsc_lookup          *p_lookup;
  bool                  master_connected;
};



class lookup_pin_info {
public:
  lookup_pin_info(const string& name, const xtsc_lookup_pin_parms& parms) :
    name                (name),
    parms               (parms),
    address_width1      (parms.get_u32("address_bit_width")),
    data_width1         (parms.get_u32("data_bit_width")),
    address             ((name+"__address").c_str(), address_width1),
    req                 ((name+"__req"    ).c_str(), 1),
    data                ((name+"__data"   ).c_str(), data_width1),
    ready               ((name+"__ready"  ).c_str(), 1),
    master_connected    (false)
  {
    XTSC_DEBUG(logger, "Creating lookup_pin '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure lookup_pin " << name << endl;
    *oss_main[w] << tab2 << "xtsc_lookup_pin_parms " << name << "__parms(0, 0, false);" << endl;
    dump_parms(oss_lookup_pin_parms, name_lookup_pin_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create lookup_pin " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_lookup_pin(\"" << name << "\", " << name << "__parms);" << endl;
    p_lookup_pin = new xtsc_lookup_pin(name.c_str(), parms);
    register_sc_module("xtsc_lookup_pin", name);
    // Connect the wires
    p_lookup_pin->m_address  (address);
    p_lookup_pin->m_req  (req);
    p_lookup_pin->m_data(data);
    if (parms.get_bool("has_ready")) {
    p_lookup_pin->m_ready(ready);
    }


  }
  ~lookup_pin_info() {
    delete p_lookup_pin;
  }
  string                        name;
  xtsc_lookup_pin_parms         parms;
  u32                           address_width1;
  u32                           data_width1;
  xtsc_signal_sc_bv_base        address;
  xtsc_signal_sc_bv_base        req;
  xtsc_signal_sc_bv_base        data;
  xtsc_signal_sc_bv_base        ready;
  xtsc_lookup_pin              *p_lookup_pin;
  bool                          master_connected;
};



class driver_info {
public:
  driver_info(const string& name, const xtsc_lookup_driver_parms& parms) :
    name                (name),
    parms               (parms),
    lookup_connected    (false)
  {
    XTSC_DEBUG(logger, "Creating lookup_driver '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure driver " << name << endl;
    *oss_main[w] << tab2 << "xtsc_lookup_driver_parms " << name << "__parms(0, 0, false);" << endl;
    dump_parms(oss_driver_parms, name_driver_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create driver " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_lookup_driver(\"" << name << "\", " << name << "__parms);" << endl;
    p_driver = new xtsc_lookup_driver(name.c_str(), parms);
    register_sc_module("xtsc_lookup_driver", name);
  }
  ~driver_info() {
    delete p_driver;
  }
  string                        name;
  xtsc_lookup_driver_parms      parms;
  xtsc_lookup_driver           *p_driver;
  bool                          lookup_connected;
};



class master_info {
public:
  master_info(const string& name, const xtsc_master_parms& parms) :
    name                (name),
    parms               (parms),
    slave_connected     (false),
    has_control         (parms.get_bool("control")),
    control_connected   (false)
  {
    XTSC_DEBUG(logger, "Creating master '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure master " << name << endl;
    *oss_main[w] << tab2 << "xtsc_master_parms " << name << "__parms(\"\");" << endl;
    dump_parms(oss_master_parms, name_master_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create master " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_master(\"" << name << "\", " << name << "__parms);" << endl;
    p_master = new xtsc_master(name.c_str(), parms);
    register_sc_module("xtsc_master", name);
  }
  ~master_info() {
    delete p_master;
  }
  string                name;
  xtsc_master_parms     parms;
  xtsc_master          *p_master;
  bool                  slave_connected;
  bool                  has_control;
  bool                  control_connected;
};



class memory_info {
public:
  memory_info(const string& name, const xtsc_memory_parms& parms, xtsc_core::memory_port mem_port) :
    name                (name),
    parms               (parms),
    mem_port            (mem_port),
    num_ports           (parms.get_non_zero_u32("num_ports"))
  {
    XTSC_DEBUG(logger, "Creating memory '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure memory " << name << endl;
    *oss_main[w] << tab2 << "xtsc_memory_parms " << name << "__parms" << memory_parms_args << ";" << endl;
    dump_parms(oss_memory_parms, name_memory_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create memory " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_memory(\"" << name << "\", " << name << "__parms);" << endl;
    p_memory = new xtsc_memory(name.c_str(), parms);
    register_sc_module("xtsc_memory", name);
    master_connected = new bool[num_ports];
    for (u32 i=0; i<num_ports; ++i) {
      master_connected[i] = false;
    }
  }
  ~memory_info() {
    delete p_memory;
    delete [] master_connected;
  }
  string                        name;
  xtsc_memory_parms             parms;
  xtsc_memory                  *p_memory;
  xtsc_core::memory_port        mem_port;
  u32                           num_ports;
  bool                         *master_connected;
};



class memory_pin_info {
public:
  memory_pin_info(const string& name, const xtsc_memory_pin_parms& parms) :
    name                (name),
    parms               (parms),
    num_ports           (parms.get_non_zero_u32("num_ports"))
  {
    XTSC_DEBUG(logger, "Creating memory_pin '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure memory_pin " << name << endl;
    *oss_main[w] << tab2 << "xtsc_memory_pin_parms " << name << "__parms" << memory_pin_parms_args << ";" << endl;
    dump_parms(oss_memory_pin_parms, name_memory_pin_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create memory_pin " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_memory_pin(\"" << name << "\", " << name << "__parms);" << endl;
    p_memory_pin = new xtsc_memory_pin(name.c_str(), parms);
    register_sc_module("xtsc_memory_pin", name);
    master_connected = new bool[num_ports];
    for (u32 i=0; i<num_ports; ++i) {
      master_connected[i] = false;
    }
  }
  ~memory_pin_info() {
    delete p_memory_pin;
    delete [] master_connected;
  }
  string                        name;
  xtsc_memory_pin_parms         parms;
  xtsc_memory_pin              *p_memory_pin;
  u32                           num_ports;
  bool                         *master_connected;
};



class memory_trace_info {
public:
  memory_trace_info(const string& name, const xtsc_memory_trace_parms& parms) :
    name                (name),
    parms               (parms),
    num_ports           (parms.get_non_zero_u32("num_ports"))
  {
    XTSC_DEBUG(logger, "Creating memory_trace '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure memory_trace " << name << endl;
    *oss_main[w] << tab2 << "xtsc_memory_trace_parms " << name << "__parms" << memory_trace_parms_args << ";" << endl;
    dump_parms(oss_memory_trace_parms, name_memory_trace_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create memory_trace " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_memory_trace(\"" << name << "\", " << name << "__parms);" << endl;
    p_memory_trace = new xtsc_memory_trace(name.c_str(), parms);
    register_sc_module("xtsc_memory_trace", name);
    master_connected = new bool[num_ports];
    slave_connected  = new bool[num_ports];
    for (u32 i=0; i<num_ports; ++i) {
      master_connected[i] = false;
      slave_connected [i] = false;
    }
  }
  ~memory_trace_info() {
    delete p_memory_trace;
    delete [] master_connected;
    delete [] slave_connected;
  }
  string                        name;
  xtsc_memory_trace_parms       parms;
  xtsc_memory_trace            *p_memory_trace;
  u32                           num_ports;
  bool                         *master_connected;
  bool                         *slave_connected;
};



class mmio_info {
public:
  mmio_info(const string& name, const xtsc_mmio_parms& parms) :
    name                (name),
    parms               (parms),
    master_connected    (false)
  {
    XTSC_DEBUG(logger, "Creating mmio '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure mmio " << name << endl;
    *oss_main[w] << tab2 << "xtsc_mmio_parms " << name << "__parms(\"\");" << endl;
    dump_parms(oss_mmio_parms, name_mmio_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create mmio " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_mmio(\"" << name << "\", " << name << "__parms);" << endl;
    p_mmio = new xtsc_mmio(name.c_str(), parms);
    register_sc_module("xtsc_mmio", name);
    set<string> inputs = p_mmio->get_input_set();
    for (set<string>::iterator ii = inputs.begin(); ii != inputs.end(); ++ii) {
      inputs_connected.insert(map<string,bool>::value_type(*ii, false));
    }
    set<string> outputs = p_mmio->get_output_set();
    for (set<string>::iterator io = outputs.begin(); io != outputs.end(); ++io) {
      outputs_connected.insert(map<string,bool>::value_type(*io, false));
    }
  }
  ~mmio_info() {
    delete p_mmio;
  }
  string                        name;
  xtsc_mmio_parms               parms;
  xtsc_mmio                    *p_mmio;
  bool                          master_connected;
  map<string,bool>              inputs_connected;
  map<string,bool>              outputs_connected;
};



class pin2tlm_info {
public:
  pin2tlm_info(const string& name, const xtsc_pin2tlm_memory_transactor_parms& parms) :
    name                (name),
    parms               (parms),
    num_ports           (parms.get_non_zero_u32("num_ports"))
  {
    XTSC_DEBUG(logger, "Creating pin2tlm '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure pin2tlm " << name << endl;
    *oss_main[w] << tab2 << "xtsc_pin2tlm_memory_transactor_parms " << name << "__parms" << pin2tlm_parms_args << ";" << endl;
    dump_parms(oss_pin2tlm_parms, name_pin2tlm_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create pin2tlm " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_pin2tlm_memory_transactor(\"" << name << "\", " << name << "__parms);" << endl;
    p_pin2tlm = new xtsc_pin2tlm_memory_transactor(name.c_str(), parms);
    register_sc_module("xtsc_pin2tlm_memory_transactor", name);
    master_connected = new bool[num_ports];
    slave_connected = new bool[num_ports];
    for (u32 i=0; i<num_ports; ++i) {
      master_connected[i] = false;
      slave_connected[i] = false;
    }
  }
  ~pin2tlm_info() {
    delete p_pin2tlm;
  }
  string                                name;
  xtsc_pin2tlm_memory_transactor_parms  parms;
  xtsc_pin2tlm_memory_transactor       *p_pin2tlm;
  u32                                   num_ports;
  bool                                 *master_connected;
  bool                                 *slave_connected;
};



class producer_info {
public:
  producer_info(const string& name, const xtsc_queue_producer_parms& parms) :
    name                (name),
    parms               (parms),
    queue_connected     (false),
    has_control         (parms.get_bool("control")),
    control_connected   (false)
  {
    XTSC_DEBUG(logger, "Creating producer '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure producer " << name << endl;
    *oss_main[w] << tab2 << "xtsc_queue_producer_parms " << name << "__parms;" << endl;
    dump_parms(oss_producer_parms, name_producer_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create producer " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_queue_producer(\"" << name << "\", " << name << "__parms);" << endl;
    p_producer = new xtsc_queue_producer(name.c_str(), parms);
    register_sc_module("xtsc_queue_producer", name);
  }
  ~producer_info() {
    delete p_producer;
  }
  string                        name;
  xtsc_queue_producer_parms     parms;
  xtsc_queue_producer          *p_producer;
  bool                          queue_connected;
  bool                          has_control;
  bool                          control_connected;
};



class proxy_info {
public:
  proxy_info(const string& name, const proxy_parms& parms) :
    name                (name),
    module_name         (parms.get_non_empty_c_str("module_name")),
    parms               (parms),
    trace_identifier    (""),
    verilog_file        (module_name + ".v"),
    readmemh_file_name  (""),
    readmemh_interface  (""),
    readmemh_cores      (this->parms.get_c_str_array("readmemh_cores")),
    fully_connect_cores (this->parms.get_c_str_array("fully_connect_cores")),
    generate_verilog    (true),
    generate_data_files (readmemh_cores && readmemh_cores[0])
  {
    const char *rfn = parms.get_c_str("readmemh_file_name");
    if (rfn) {
      if (generate_data_files) {
        ostringstream oss;
        oss << module_name << " proxy " << name << " has both \"readmemh_cores\" and \"readmemh_file_name\" parameters specified.";
        throw xtsc_exception(oss.str());
      }
      this->readmemh_file_name = rfn;
    }
    xtsc_core::memory_port mem_port=xtsc_core::get_memory_port(parms.get_c_str("readmemh_interface"));
    readmemh_interface  = xtsc_core::get_memory_port_name(mem_port, true);
    transform(readmemh_interface.begin(), readmemh_interface.end(), readmemh_interface.begin(), ::tolower);
    readmemh_interface_v = ((readmemh_interface == "xlmi0") ? "dport0" : readmemh_interface);
    XTSC_DEBUG(logger, "Creating " << module_name << " proxy '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create " << module_name << " proxy '" << name << "'" << endl;
    ostringstream extra_args;
    if (vendor == "mentor") {
      extra_args << ", \"" << module_name << "\"";
    }
    if ((vendor == "cadence") && generate_data_files) {
      extra_args << ", \"" << data_dir << "/" << name << "." << readmemh_interface_v << ".data\"";
    }
    else if ((vendor == "cadence") && (readmemh_file_name != "")) {
      extra_args << ", \"" << readmemh_file_name << "\"";
    }
    else if ((vendor == "mentor") && generate_data_files) {
      *oss_main[w] << tab2 << "const char *" << name << "_verilog_parameters[1] = { \"file_name=\\\"" << data_dir << "/"
                           << name << "." << readmemh_interface_v << ".data\\\"\" };" << endl;
      extra_args << ", 1, " << name << "_verilog_parameters";
    }
    else if ((vendor == "mentor") && (readmemh_file_name != "")) {
      *oss_main[w] << tab2 << "const char *" << name << "_verilog_parameters[1] = { \"file_name=\\\"" << readmemh_file_name
                           << "\\\"\" };" << endl;
      extra_args << ", 1, " << name << "_verilog_parameters";
    }
    *oss_main[w] << tab2 << module_name << " " << name << "(\"" << name << "\"" << extra_args.str() << ");" << endl;
    const char *v_file  = parms.get_c_str("verilog_file" );
    const char *v_files = parms.get_c_str("verilog_files");
    map<string,vector<proxy_info*>*>::const_iterator ip = verilog_proxy_vector_map.find(module_name);
    if (ip == verilog_proxy_vector_map.end()) {
      vector<proxy_info*> *p_vector = new vector<proxy_info*>;
      p_vector->push_back(this);
      verilog_proxy_vector_map[module_name] = p_vector;
      if (v_file && v_file[0]) {
        verilog_file = v_file;
        generate_verilog = false;
      }
    }
    else {
      vector<proxy_info*> *p_vector = ip->second;
      proxy_info& first_proxy = *p_vector->at(0);
      p_vector->push_back(this);
      if ((v_file  && v_file [0] && strcmp(v_file , first_proxy.parms.get_c_str("verilog_file" ))) ||
          (v_files && v_files[0] && strcmp(v_files, first_proxy.parms.get_c_str("verilog_files"))))
      {
        ostringstream oss;
        oss << "Error: attempt to create " << module_name << " proxy " << name << " with a different set of values for the " 
            << "\"verilog_file\" and \"verilog_files\" parameters then an already existing " << module_name << " proxy (" 
            << first_proxy.name << ")";
        throw xtsc_exception(oss.str());
      }
      verilog_file = first_proxy.verilog_file;
      generate_verilog = first_proxy.generate_verilog;
    }
    const void *p_tf = parms.get_void_pointer("vcd_handle");
    if (p_tf) {
      for (map<string, void*>::const_iterator ii = identifier_map[w]->begin(); ii != identifier_map[w]->end(); ++ii) {
        if (ii->second == p_tf) {
          trace_identifier = ii->first;
          break;
        }
      }
    }
  }
  ~proxy_info() {
  }
  string                                name;
  string                                module_name;
  proxy_parms                           parms;
  string                                trace_identifier;
  string                                verilog_file;
  string                                readmemh_file_name;     // From "readmemh_file_name" in proxy_parms
  string                                readmemh_interface;     // Lower-case version of canonical memory interface name
  string                                readmemh_interface_v;   // Same as readmemh_interface except has dport0 instead of xlmi0
  const char * const                   *readmemh_cores;         // From "readmemh_cores" in proxy_parms
  const char * const                   *fully_connect_cores;    // From "fully_connect_cores" in proxy_parms
  bool                                  generate_verilog;       // Should we generate a Verilog template?
  bool                                  generate_data_files;    // Should we generate readmemh data files?
  vector<clock_info*>                   connected_clock_list;
  vector<pair<tlm2pin_info*,u32> >      connected_tlm2pin_list;
  vector<pair<pin2tlm_info*,u32> >      connected_pin2tlm_list;
  vector<pair<memory_pin_info*,u32> >   connected_memory_pin_list;
  vector<pair<string,u32> >             sc_bv_list;
  vector<pair<string,u32> >             sc_uint_list;
  ostringstream                         ports;
  ostringstream                         inputs;
  ostringstream                         outputs;
  ostringstream                         regs;
  vector<string>                        displays;
};



class queue_info {
public:
  queue_info(const string& name, const xtsc_queue_parms& parms) :
    name                (name),
    parms               (parms),
    producer_connected  (NULL),
    consumer_connected  (NULL)
  {
    XTSC_DEBUG(logger, "Creating queue '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure queue " << name << endl;
    *oss_main[w] << tab2 << "xtsc_queue_parms " << name << "__parms;" << endl;
    dump_parms(oss_queue_parms, name_queue_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create queue " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_queue(\"" << name << "\", " << name << "__parms);" << endl;
    p_queue = new xtsc_queue(name.c_str(), parms);
    register_sc_module("xtsc_queue", name);
    num_producers = p_queue->get_num_producers();
    producer_connected = new bool[num_producers];
    for (u32 i=0; i<num_producers; ++i) {
      producer_connected[i] = false;
    }
    num_consumers = p_queue->get_num_consumers();
    consumer_connected = new bool[num_consumers];
    for (u32 i=0; i<num_consumers; ++i) {
      consumer_connected[i] = false;
    }
  }
  ~queue_info() {
    delete p_queue;
  }
  string                name;
  xtsc_queue_parms      parms;
  xtsc_queue           *p_queue;
  u32                   num_producers;
  u32                   num_consumers;
  bool                 *producer_connected;
  bool                 *consumer_connected;
};



class queue_pin_info {
public:
  queue_pin_info(const string& name, const xtsc_queue_pin_parms& parms) :
    name                (name),
    parms               (parms),
    width1              (parms.get_u32("bit_width")),
    push                ((name+"__push"    ).c_str(), 1),
    full                ((name+"__full"    ).c_str(), 1),
    data_in             ((name+"__data_in" ).c_str(), width1),
    pop                 ((name+"__pop"     ).c_str(), 1),
    empty               ((name+"__empty"   ).c_str(), 1),
    data_out            ((name+"__data_out").c_str(), width1),
    producer_connected  (false),
    consumer_connected  (false)
  {
    XTSC_DEBUG(logger, "Creating queue_pin '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure queue_pin " << name << endl;
    *oss_main[w] << tab2 << "xtsc_queue_pin_parms " << name << "__parms;" << endl;
    dump_parms(oss_queue_pin_parms, name_queue_pin_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create queue_pin " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_queue_pin(\"" << name << "\", " << name << "__parms);" << endl;
    p_queue_pin = new xtsc_queue_pin(name.c_str(), parms);
    register_sc_module("xtsc_queue_pin", name);
  }
  ~queue_pin_info() {
    delete p_queue_pin;
  }
  void bind_producer_signals() {
    XTSC_TRACE(logger, "queue_pin_info::bind_producer_signals() for '" << name << "'");
    p_queue_pin->m_push         (push);
    p_queue_pin->m_full         (full);
    p_queue_pin->m_data_in      (data_in);
  }
  void bind_consumer_signals() {
    XTSC_TRACE(logger, "queue_pin_info::bind_consumer_signals() for '" << name << "'");
    p_queue_pin->m_pop          (pop);
    p_queue_pin->m_empty        (empty);
    p_queue_pin->m_data_out     (data_out);
  }
  string                        name;
  xtsc_queue_pin_parms          parms;
  u32                           width1;
  xtsc_signal_sc_bv_base        push;
  xtsc_signal_sc_bv_base        full;
  xtsc_signal_sc_bv_base        data_in;
  xtsc_signal_sc_bv_base        pop;
  xtsc_signal_sc_bv_base        empty;
  xtsc_signal_sc_bv_base        data_out;
  xtsc_queue_pin               *p_queue_pin;
  bool                          producer_connected;
  bool                          consumer_connected;
};



class router_info {
public:
  router_info(const string& name, const xtsc_router_parms& parms) :
    name                (name),
    parms               (parms),
    master_connected    (false),
    num_slave_connected (0)
  {
    XTSC_DEBUG(logger, "Creating router '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure router " << name << endl;
    *oss_main[w] << tab2 << "xtsc_router_parms " << name << "__parms;" << endl;
    dump_parms(oss_router_parms, name_router_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create router " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_router(\"" << name << "\", " << name << "__parms);" << endl;
    p_router = new xtsc_router(name.c_str(), parms);
    register_sc_module("xtsc_router", name);
  }
  ~router_info() {
    delete p_router;
  }
  string                name;
  xtsc_router_parms     parms;
  xtsc_router          *p_router;
  bool                  master_connected;
  int                   num_slave_connected;
};



class signal_info {
public:
  signal_info(const string& name, const signal_parms& parms) :
    name                (name),
    parms               (parms),
    trace_identifier    (""),
    bit_width           (parms.get_non_zero_u32("bit_width")),
    source_connected    (false),
    sink_connected      (false)
  {
    XTSC_DEBUG(logger, "Creating signal '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create signal " << name << endl;
    *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << name << " = new xtsc_signal_sc_bv_base(\"" << name << "\", " << bit_width
                         << ");" << endl;
    p_signal = new xtsc_signal_sc_bv_base(name.c_str(), bit_width);
    const void *p_tf = parms.get_void_pointer("vcd_handle");
    if (p_tf) {
      for (map<string, void*>::const_iterator ii = identifier_map[w]->begin(); ii != identifier_map[w]->end(); ++ii) {
        if (ii->second == p_tf) {
          trace_identifier = ii->first;
          break;
        }
      }
      sc_trace((sc_trace_file*)p_tf, *p_signal, p_signal->name());
      *oss_main[w] << tab2 << "sc_trace(" << trace_identifier << ", *" << p_signal->name() << ", \"" << p_signal->name() << "\");"
                           << endl;
    }
  }
  ~signal_info() {
    delete p_signal;
  }
  string                        name;
  signal_parms                  parms;
  string                        trace_identifier;
  u32                           bit_width;
  xtsc_signal_sc_bv_base       *p_signal;
  bool                          source_connected;
  bool                          sink_connected;
};



class slave_info {
public:
  slave_info(const string& name, const xtsc_slave_parms& parms) :
    name                (name),
    parms               (parms),
    master_connected    (false)
  {
    XTSC_DEBUG(logger, "Creating slave '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure slave " << name << endl;
    *oss_main[w] << tab2 << "xtsc_slave_parms " << name << "__parms;" << endl;
    dump_parms(oss_slave_parms, name_slave_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create slave " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_slave(\"" << name << "\", " << name << "__parms);" << endl;
    p_slave = new xtsc_slave(name.c_str(), parms);
    register_sc_module("xtsc_slave", name);
  }
  ~slave_info() {
    delete p_slave;
  }
  string                name;
  xtsc_slave_parms      parms;
  xtsc_slave           *p_slave;
  bool                  master_connected;
};



class source_info {
public:
  source_info(const string& name, const xtsc_wire_source_parms& parms) :
    name                (name),
    parms               (parms),
    has_control         (parms.get_bool("control")),
    control_connected   (false)
  {
    XTSC_DEBUG(logger, "Creating source '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure source " << name << endl;
    *oss_main[w] << tab2 << "xtsc_wire_source_parms " << name << "__parms(1, \"\");" << endl;
    dump_parms(oss_source_parms, name_source_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create source " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_wire_source(\"" << name << "\", " << name << "__parms);" << endl;
    p_source = new xtsc_wire_source(name.c_str(), parms);
    register_sc_module("xtsc_wire_source", name);
    set<string> outputs = p_source->get_output_set();
    for (set<string>::iterator io = outputs.begin(); io != outputs.end(); ++io) {
      outputs_connected.insert(map<string,bool>::value_type(*io, false));
    }
  }
  ~source_info() {
    delete p_source;
  }
  string                        name;
  xtsc_wire_source_parms        parms;
  xtsc_wire_source             *p_source;
  map<string,bool>              outputs_connected;
  bool                          has_control;
  bool                          control_connected;
};



class tlm2pin_info {
public:
  tlm2pin_info(const string& name, const xtsc_tlm2pin_memory_transactor_parms& parms) :
    name                (name),
    parms               (parms),
    num_ports           (parms.get_non_zero_u32("num_ports"))
  {
    XTSC_DEBUG(logger, "Creating tlm2pin '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure tlm2pin " << name << endl;
    *oss_main[w] << tab2 << "xtsc_tlm2pin_memory_transactor_parms " << name << "__parms" << tlm2pin_parms_args << ";" << endl;
    dump_parms(oss_tlm2pin_parms, name_tlm2pin_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create tlm2pin " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_tlm2pin_memory_transactor(\"" << name << "\", " << name << "__parms);" << endl;
    p_tlm2pin = new xtsc_tlm2pin_memory_transactor(name.c_str(), parms);
    register_sc_module("xtsc_tlm2pin_memory_transactor", name);
    master_connected = new bool[num_ports];
    slave_connected = new bool[num_ports];
    for (u32 i=0; i<num_ports; ++i) {
      master_connected[i] = false;
      slave_connected[i] = false;
    }
  }
  ~tlm2pin_info() {
    delete p_tlm2pin;
  }
  string                                name;
  xtsc_tlm2pin_memory_transactor_parms  parms;
  xtsc_tlm2pin_memory_transactor       *p_tlm2pin;
  u32                                   num_ports;
  bool                                 *master_connected;
  bool                                 *slave_connected;
};



clock_info& find_or_infer_clock(const string& clock_name);

class vcd_info {
public:
  vcd_info(const string& identifier, const vcd_parms& parms) :
    identifier          (identifier),
    parms               (parms),
    p_tf                (0)
  {
    string file(identifier);
    const char *file_name = parms.get_c_str("file_name");
    if (file_name && *file_name) {
      file = file_name;
    }
    XTSC_DEBUG(logger, "Creating vcd '" << identifier << "' => " << file << ".vcd");
    p_tf = sc_create_vcd_trace_file(file.c_str());
    add_identifier(identifier, p_tf);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create VCD file \"" << file << ".vcd\"" << endl;
    *oss_main[w] << tab2 << "sc_trace_file *" << identifier << " = sc_create_vcd_trace_file(\"" << escape_backslashes(file)
                         << "\");" << endl;
  }
  ~vcd_info() {
  }
  string                identifier;
  vcd_parms             parms;
  sc_trace_file        *p_tf;
};



class wire_info {
public:
  wire_info(const string& name, const xtsc_wire_parms& parms) :
    name                (name),
    parms               (parms),
    source_connected    (false),
    sink_connected      (false)
  {
    XTSC_DEBUG(logger, "Creating wire '" << name << "'");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Configure wire " << name << endl;
    *oss_main[w] << tab2 << "xtsc_wire_parms " << name << "__parms;" << endl;
    dump_parms(oss_wire_parms, name_wire_parms, name);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create wire " << name << endl;
    *oss_main[w] << tab2 << name << " = new xtsc_wire(\"" << name << "\", " << name << "__parms);" << endl;
    p_wire = new xtsc_wire(name.c_str(), parms);
    register_sc_module("xtsc_wire", name);
  }
  ~wire_info() {
    delete p_wire;
  }
  string                name;
  xtsc_wire_parms       parms;
  xtsc_wire            *p_wire;
  bool                  source_connected;
  bool                  sink_connected;
};



class wrapper_info {
public:
  wrapper_info(const string& name, const wrapper_parms& parms) :
    name                (name),
    parms               (parms),
    index               (w),
    readmemh_cores      (this->parms.get_c_str_array("readmemh_cores")),
    fully_connect_cores (this->parms.get_c_str_array("fully_connect_cores")),
    generate_data_files (readmemh_cores && readmemh_cores[0]),
    shadow_memory       (this->parms.get_bool("shadow_memory")),
    vcd_handle          ("")
  {
    XTSC_DEBUG(logger, "Creating wrapper '" << name << "'");
    const char *p_vcd_handle = parms.get_c_str("vcd_handle");
    if (p_vcd_handle && p_vcd_handle[0]) { vcd_handle = p_vcd_handle; }
  }
  ~wrapper_info() {
  }
  string                                name;
  wrapper_parms                         parms;
  u32                                   index;                  // 1st wrapper is 0, 2nd wrapper is 1, etc
  const char * const                   *readmemh_cores;         // From "readmemh_cores" in wrapper_parms
  const char * const                   *fully_connect_cores;    // From "fully_connect_cores" in wrapper_parms
  bool                                  generate_data_files;    // Should we generate readmemh data files?
  bool                                  shadow_memory;          // From "shadow_memory" in wrapper_parms
  string                                vcd_handle;             // From "vcd_handle" in wrapper_parms
  vector<pair<string,string> >          connected_clock_list;
  vector<pair<tlm2pin_info*,u32> >      connected_tlm2pin_list;
  vector<pair<pin2tlm_info*,u32> >      connected_pin2tlm_list;
  vector<pair<memory_pin_info*,u32> >   connected_memory_pin_list;
  ostringstream                         ports;
  vector<pair<string,u32> >             connected_input_list;
  vector<pair<string,u32> >             connected_output_list;
  vector<string>                        ctor_init_list;
};




void             usage(bool brief);
void             usage_and_exit(bool brief, int exit_code);
void             dump_commands();
void             command_info(ostream& os);
const char*      space(u32 num_spaces);
bool             is_identifier(const string& name);

void             initialize_processing();
void             slurp(int argc, char *argv[], vector<string> *p_file_names, vector<u32> *p_line_numbers, vector<string> *p_infos);
void             initialize_sc_main_generation();
void             check_for_special_commands();
void             create_per_wrapper_stuff();
int              sc_main(int argc, char *argv[]);
void             process();
void             process_command(int argi);
void             finalize_system_or_wrapper();
void             infer_connect_core_wrapper(const string& core_name, const set<string>& iface_set,
                                            const map<string,bool>& connected_map, const string& name_prefix);
void             infer_connect_wrapper_core(const string& core_name, const set<string>& iface_set,
                                            const map<string,bool>& connected_map, const string& name_prefix);
void             infer_connect_core_proxy(const string& core_name, const set<string>& iface_set,
                                          const map<string,bool>& connected_map, const string& name_prefix, const string& proxy_name);
void             infer_connect_proxy_core(const string& core_name, const set<string>& iface_set,
                                          const map<string,bool>& connected_map, const string& name_prefix, const string& proxy_name);
void             do_inferred_command(const string& command);
void             final_processing();
void             log_summary(bool verbose);
void             generate_sc_main();
void             add_library_check_and_info(ofstream& mak);
void             optionally_copy_modelsim_ini();
void             dump_wire(ostream& os, const string& name, u32 bits);
void             add_base_arguments(ostringstream &oss, xtsc_core& core, xtsc_address address8, u32 size8);
void             show_modules(bool verbose, bool is_manual);

void             setup_command_variables(const string& command, const string& file, u32 line, const string& info);
void             arg_split(int argi);                           // Split based on <Command>=<Text>
void             parm_split(xtsc_parms& parms);                 // Split based on <Name>=<ValueText>
void             add_parm(xtsc_parms& parms);
void             update_parm_u32(xtsc_parms& parms, const string& name, u32 value, ostringstream& oss_parms,
                                 const string& name_module_parms);
void             update_parm_bool(xtsc_parms& parms, const string& name, bool value, ostringstream& oss_parms,
                                 const string& name_module_parms);
xtsc_core_parms *get_newest_core_parms();       // Get nascent core parms, else most recent core parms, else NULL
u32              compute_address_bits(u32 byte_size, u32 byte_width);
u32              strtou32(const string& str, const string& msg = "");
double           strtodouble(const string& str);
void             validate_name(const string& name, const string& type);
void             connect_module_to_proxy(const string& module_type, xtsc_module_pin_base& module, const string& module_name,
                                         u32 set_id, const string& name_prefix, proxy_info& proxy);
void             connect_wide_input(const string& module_type, const string& module_name, proxy_info& proxy,
                                    const string& name_prefix, const string& port_name, u32 bit_width);
void             connect_wide_output(const string& module_type, const string& module_name, proxy_info& proxy,
                                     const string& name_prefix, const string& port_name, u32 bit_width);
void             connect_uint_input(const string& module_type, const string& module_name, proxy_info& proxy,
                                    const string& name_prefix, const string& port_name, u32 bit_width);
void             connect_uint_output(const string& module_type, const string& module_name, proxy_info& proxy,
                                     const string& name_prefix, const string& port_name, u32 bit_width);
void             connect_bool_input(const string& module_type, const string& module_name, proxy_info& proxy,
                                    const string& name_prefix, const string& port_name);
void             connect_bool_output(const string& module_type, const string& module_name, proxy_info& proxy,
                                     const string& name_prefix, const string& port_name);
void             connect_module_to_wrapper(const string& module_type, xtsc_module_pin_base& module, const string& module_name,
                                           const string& name_prefix, u32 set_id);
void             connect_wide_input(const string& module_type, const string& module_name, const string& module_input_name, 
                                    const string& wrapper_input_name, u32 bit_width);
void             connect_wide_output(const string& module_type, const string& module_name, const string& module_output_name, 
                                     const string& wrapper_output_name, u32 bit_width);
void             connect_uint_input(const string& module_type, const string& module_name, const string& module_input_name, 
                                    const string& wrapper_input_name, u32 bit_width);
void             connect_uint_output(const string& module_type, const string& module_name, const string& module_output_name, 
                                     const string& wrapper_output_name, u32 bit_width);
void             connect_bool_input(const string& module_type, const string& module_name, const string& module_input_name,
                                    const string& wrapper_input_name);
void             connect_bool_output(const string& module_type, const string& module_name, const string& module_output_name,
                                     const string& wrapper_output_name);
void             add_adapter(ostringstream& oss, const string& name, u32 bits, bool in, u32 nc);
void             add_signal(ostringstream& oss, const string& name, u32 bits, u32 nc);
void             add_bit_field(ostream& os, u32 bits);
void             add_template_args(ostream& os, u32 bits, bool bv, bool justify);
void             add_proxy_io(proxy_info& proxy, const string& name, u32 bits, bool input, bool bv, bool clock);
void             add_extra_io_to_proxy(proxy_info& proxy, bool input);
void             add_wrapper_io(const string& name, u32 bits, bool input, bool bv);
void             add_extra_io_to_wrapper(const char * const *extra_io, bool input);

void             confirm_no_core_parameter_lookups();
void             confirm_assignment();
void             confirm_non_empty_assignment();
void             confirm_identifier(const string& name);
void             confirm_no_more_csv();

// Step 8:  Declare confirm_no_XXX_connected() methods as appropriate for xtsc_widget

void             confirm_no_consumer_connected(const queue_info& qi, u32 consumer_port);
void             confirm_no_consumer_connected(const loader_info& li);
void             confirm_no_consumer_connected(const queue_pin_info& qi);
void             confirm_no_export_state_connected(const core_info& ci, const string& export_state_name);
void             confirm_no_first_tx_connected(const loader_info& li);
void             confirm_no_import_wire_connected(const core_info& ci, const string& import_wire_name);
void             confirm_no_inbound_connected(const core_info& ci);
void             confirm_no_input_queue_connected(const core_info& ci, const string& input_queue_name);
void             confirm_no_last_tx_connected(const loader_info& li);
void             confirm_no_lookup_connected(const core_info& ci, const string& lookup_name);
void             confirm_no_lookup_connected(const driver_info& di);
void             confirm_no_master_connected(const cohctrl_info& ci, u32 cohctrl_port);
void             confirm_no_master_connected(const dma_info& di, u32 dma_port);
void             confirm_no_master_connected(const lookup_pin_info& li);
void             confirm_no_master_connected(const memory_info& mi, u32 memory_port);
void             confirm_no_master_connected(const memory_pin_info& mi, u32 memory_port);
void             confirm_no_master_connected(const memory_trace_info& mi, u32 memory_port);
void             confirm_no_master_connected(const mmio_info& mi);
void             confirm_no_master_connected(const pin2tlm_info& pi, u32 memory_port);
void             confirm_no_master_connected(const router_info& ri);
void             confirm_no_master_connected(const slave_info& si);
void             confirm_no_master_connected(const tlm2pin_info& ti, u32 memory_port);
void             confirm_no_memory_connected(const core_info& ci, xtsc_core::memory_port mem_port);
void             confirm_no_output_queue_connected(const core_info& ci, const string& output_queue_name);
void             confirm_no_producer_connected(const queue_info& qi, u32 producer_port);
void             confirm_no_producer_connected(const loader_info& li);
void             confirm_no_producer_connected(const queue_pin_info& qi);
void             confirm_no_queue_connected(const producer_info& pi);
void             confirm_no_queue_connected(const consumer_info& ci);
void             confirm_no_slave_connected(const arbiter_info& ai);
void             confirm_no_slave_connected(const cohctrl_info& ci);
void             confirm_no_slave_connected(const dma_info& di);
void             confirm_no_slave_connected(const master_info& mi);
void             confirm_no_slave_connected(const memory_trace_info& ti, u32 memory_port);
void             confirm_no_slave_connected(const pin2tlm_info& pi, u32 memory_port);
void             confirm_no_slave_connected(const tlm2pin_info& ti, u32 memory_port);
void             confirm_no_ccon_connected(const cohctrl_info& ci, u32 cohctrl_port);
void             confirm_no_snoop_connected(const cohctrl_info& ci, u32 cohctrl_port);
void             confirm_no_snoop_connected(const core_info& ci);
void             confirm_no_system_input_connected(const core_info& ci, const string& system_input_name);
void             confirm_no_system_output_connected(const core_info& ci, const string& system_output_name);
void             confirm_no_xfer_in_connected(const core_info& ci);
void             confirm_no_xfer_out_connected(const core_info& ci);

void             confirm_control_exists_and_is_not_connected(const master_info& mi);
void             confirm_control_exists_and_is_not_connected(const producer_info& pi);
void             confirm_control_exists_and_is_not_connected(const source_info& si);
void             confirm_input_exists_and_is_not_connected(const distributor_info& di, const string& input_name);
void             confirm_lookup_exists_and_is_not_connected(const distributor_info& di, const string& lookup_name);
void             confirm_output_exists_and_is_not_connected(const distributor_info& di, const string& output_name);
void             confirm_input_exists_and_is_not_connected(const logic_info& li, const string& input_name);
void             confirm_output_exists_and_is_not_connected(const loader_info& li, const string& output_name);
void             confirm_output_exists_and_is_not_connected(const logic_info& li, const string& output_name);
void             confirm_input_exists_and_is_not_connected(const mmio_info& mi, const string& input_name);
void             confirm_output_exists_and_is_not_connected(const mmio_info& mi, const string& output_name);
void             confirm_output_exists_and_is_not_connected(const source_info& si, const string& output_name);

void             confirm_coherent_core(const core_info& ci);
void             confirm_valid_port(const arbiter_info& ai, u32 port);
void             confirm_valid_port(const cohctrl_info& ci, u32 port);
void             confirm_valid_port(const router_info& ri, u32 port);
void             confirm_valid_inbound_name(const string& port_name);
void             confirm_systemc_on_top();
void             confirm_verilog_on_top();
void             confirm_a_wrapper_is_defined();
void             confirm_building_system();

void             confirm_pin_level(const consumer_info& ci);
void             confirm_pin_level(const driver_info& di);
void             confirm_pin_level(const loader_info& li);
void             confirm_pin_level(const producer_info& pi);
void             confirm_pin_level(const source_info& si);

bool             get_pin_level_and_confirm_match(const producer_info& pi, const loader_info& li);
bool             get_pin_level_and_confirm_match(const loader_info& li, const consumer_info& ci);

void             do_final_program_name_and_args(int argc, int argi);
void             do_default_mem(core_info& ci);

void             parse_cosim();
void             parse_show_modules();
void             parse_cycle_limit();
bool             parse_boolean_assignment();
void             parse_no_sim();
void             parse_no_default_mem();
void             parse_no_default_local_mem();
void             parse_squelch_ctor();
void             parse_summary();
void             parse_memory_pin_port();
void             parse_memory_port();
void             parse_core_args();
void             parse_core_summary();
void             parse_multi_core_debug();
void             parse_multi_core_profile();
void             parse_core_debug();
void             parse_core_debug_helper();
void             parse_core_client();
void             parse_core_program();
void             parse_csv();
void             parse_non_empty_csv();
void             parse_identifier_csv();
void             parse_string_array_separator();


// Step 9:  Declare parse_create_widget() if required for xtsc_widget

void             parse_create_lookup();
void             parse_create_lookup_pin();
void             parse_create_queue();
void             parse_create_queue_pin();
void             parse_create_signal();
void             parse_create_wire();


// Step 10:  Declare parse_connect_XXX_widget() and parse_connect_widget_XXX() methods as required.
//           The rule-of-thumb for the order of components (XXX and widget) in the method name is
//           that dataflow is from left-to-right if the dataflow concept applies.  If the dataflow
//           concept does not apply, then put the master on the left and the slave on the right.
//           If the master-slave concept does not apply, then do whatever makes sense to you.

void             parse_connect_arbiter_arbiter();
void             parse_connect_arbiter_cohctrl();
void             parse_connect_arbiter_core();
void             parse_connect_arbiter_memory();
void             parse_connect_arbiter_dma();
void             parse_connect_arbiter_memory_trace();
void             parse_connect_arbiter_mmio();
void             parse_connect_arbiter_router();
void             parse_connect_arbiter_slave();
void             parse_connect_arbiter_tlm2pin();
void             parse_connect_clock_proxy();
void             parse_connect_clock_wrapper();
void             parse_connect_cohctrl_arbiter();
void             parse_connect_cohctrl_memory();
void             parse_connect_cohctrl_memory_trace();
void             parse_connect_cohctrl_router();
void             parse_connect_cohctrl_slave();
void             parse_connect_cohctrl_tlm2pin();
void             parse_connect_core_arbiter();
void             parse_connect_core_cohctrl();
void             parse_connect_core_core();
void             parse_connect_core_loader();
void             parse_connect_core_logic();
void             parse_connect_core_lookup();
void             parse_connect_core_lookup_pin();
void             parse_connect_core_memory();
void             parse_connect_core_memory_trace();
void             parse_connect_core_mmio();
void             parse_connect_core_proxy();
void             parse_connect_core_wrapper();
void             parse_connect_core_queue();
void             parse_connect_core_queue_pin();
void             parse_connect_core_router();
void             parse_connect_core_signal();
void             parse_connect_core_tlm2pin();
void             parse_connect_core_wire();
void             parse_connect_core_slave();
void             parse_connect_distributor_wire();
void             parse_connect_dma_arbiter();
void             parse_connect_dma_memory();
void             parse_connect_dma_memory_trace();
void             parse_connect_dma_router();
void             parse_connect_driver_distributor();
void             parse_connect_driver_lookup();
void             parse_connect_driver_lookup_pin();
void             parse_connect_driver_proxy();
void             parse_connect_driver_wrapper();
void             parse_connect_loader_consumer();
void             parse_connect_loader_core();
void             parse_connect_loader_logic();
void             parse_connect_loader_wire();
void             parse_connect_logic_cohctrl();
void             parse_connect_logic_core();
void             parse_connect_logic_logic();
void             parse_connect_logic_master();
void             parse_connect_logic_mmio();
void             parse_connect_logic_producer();
void             parse_connect_logic_proxy();
void             parse_connect_logic_source();
void             parse_connect_logic_wire();
void             parse_connect_logic_wrapper();
void             parse_connect_master_arbiter();
void             parse_connect_master_cohctrl();
void             parse_connect_master_core();
void             parse_connect_master_dma();
void             parse_connect_master_memory();
void             parse_connect_master_memory_trace();
void             parse_connect_master_mmio();
void             parse_connect_master_router();
void             parse_connect_master_slave();
void             parse_connect_master_tlm2pin();
void             parse_connect_memory_trace_arbiter();
void             parse_connect_memory_trace_cohctrl();
void             parse_connect_memory_trace_core();
void             parse_connect_memory_trace_memory();
void             parse_connect_memory_trace_dma();
void             parse_connect_memory_trace_mmio();
void             parse_connect_memory_trace_router();
void             parse_connect_memory_trace_slave();
void             parse_connect_memory_trace_tlm2pin();
void             parse_connect_mmio_core();
void             parse_connect_mmio_logic();
void             parse_connect_mmio_master();
void             parse_connect_mmio_mmio();
void             parse_connect_mmio_producer();
void             parse_connect_mmio_proxy();
void             parse_connect_mmio_source();
void             parse_connect_mmio_wire();
void             parse_connect_mmio_wrapper();
void             parse_connect_pin2tlm_arbiter();
void             parse_connect_pin2tlm_cohctrl();
void             parse_connect_pin2tlm_core();
void             parse_connect_pin2tlm_memory();
void             parse_connect_pin2tlm_memory_trace();
void             parse_connect_pin2tlm_mmio();
void             parse_connect_pin2tlm_router();
void             parse_connect_pin2tlm_slave();
void             parse_connect_producer_loader();
void             parse_connect_producer_proxy();
void             parse_connect_producer_queue();
void             parse_connect_producer_queue_pin();
void             parse_connect_producer_wrapper();
void             parse_connect_proxy_cohctrl();
void             parse_connect_proxy_consumer();
void             parse_connect_proxy_core();
void             parse_connect_proxy_loader();
void             parse_connect_proxy_logic();
void             parse_connect_proxy_lookup_pin();
void             parse_connect_proxy_memory_pin();
void             parse_connect_proxy_mmio();
void             parse_connect_proxy_pin2tlm();
void             parse_connect_proxy_queue_pin();
void             parse_connect_proxy_wire();
void             parse_connect_queue_consumer();
void             parse_connect_queue_pin_consumer();
void             parse_connect_queue_pin_proxy();
void             parse_connect_queue_pin_wrapper();
void             parse_connect_queue_core();
void             parse_connect_queue_pin_core();
void             parse_connect_router_arbiter();
void             parse_connect_router_cohctrl();
void             parse_connect_router_core();
void             parse_connect_router_memory();
void             parse_connect_router_dma();
void             parse_connect_router_memory_trace();
void             parse_connect_router_mmio();
void             parse_connect_router_router();
void             parse_connect_router_slave();
void             parse_connect_router_tlm2pin();
void             parse_connect_signal_core();
void             parse_connect_source_cohctrl();
void             parse_connect_source_core();
void             parse_connect_source_distributor();
void             parse_connect_source_logic();
void             parse_connect_source_mmio();
void             parse_connect_source_proxy();
void             parse_connect_source_wrapper();
void             parse_connect_source_signal();
void             parse_connect_source_wire();
void             parse_connect_tlm2pin_memory_pin();
void             parse_connect_tlm2pin_pin2tlm();
void             parse_connect_tlm2pin_proxy();
void             parse_connect_tlm2pin_wrapper();
void             parse_connect_wire_core();
void             parse_connect_wrapper_cohctrl();
void             parse_connect_wrapper_consumer();
void             parse_connect_wrapper_core();
void             parse_connect_wrapper_loader();
void             parse_connect_wrapper_logic();
void             parse_connect_wrapper_lookup_pin();
void             parse_connect_wrapper_memory_pin();
void             parse_connect_wrapper_mmio();
void             parse_connect_wrapper_pin2tlm();
void             parse_connect_wrapper_queue_pin();
void             parse_connect_wrapper_wire();


// Step 11:  Declare connect_XXX_widget() and connect_widget_XXX() methods to match the parse_connect* methods in Step 10.

void             connect_arbiter_arbiter(const string& master_name, u32 port, const string& slave_name);
void             connect_arbiter_cohctrl(const string& arbiter_name, u32 cohctrl_port, const string& cohctrl_name);
void             connect_arbiter_core(const string& arbiter_name, const string& port_name, const string& core_name);
void             connect_arbiter_dma(const string& arbiter_name, u32 dma_port, const string& dma_name);
void             connect_arbiter_memory(const string& arbiter_name, u32 memory_port, const string& memory_name);
void             connect_arbiter_memory_trace(const string& arbiter_name, u32 trace_port, const string& trace_name);
void             connect_arbiter_mmio(const string& arbiter_name, const string& mmio_name);
void             connect_arbiter_router(const string& arbiter_name, const string& router_name);
void             connect_arbiter_slave(const string& arbiter_name, const string& slave_name);
void             connect_arbiter_tlm2pin(const string& arbiter_name, u32 tlm2pin_port, const string& tlm2pin_name);
void             connect_clock_proxy(const string& clock_name, const string& input_name, const string& proxy_name);
void             connect_clock_wrapper(const string& clock_name, const string& wrapper_output_name);
void             connect_cohctrl_arbiter(const string& cohctrl_name, u32 snoop_port, u32 arbiter_port, const string& arbiter_name);
void             connect_cohctrl_memory(const string& cohctrl_name, u32 memory_port, const string& memory_name);
void             connect_cohctrl_memory_trace(const string& cohctrl_name, u32 snoop_port, u32 trace_port, const string& trace_name);
void             connect_cohctrl_router(const string& cohctrl_name, u32 snoop_port, const string& router_name);
void             connect_cohctrl_slave(const string& cohctrl_name, u32 snoop_port,  const string& slave_name);
void             connect_cohctrl_tlm2pin(const string& cohctrl_name, u32 port, const string& tlm2pin_name);
void             connect_core_arbiter(const string& core_name, xtsc_core::memory_port mem_port, u32 port,
                                      const string& arbiter_name);
void             connect_core_cohctrl(const string& core_name, u32 cohctrl_port, const string& cohctrl_name);
void             connect_core_core(const string& source_name, const string& output_name, const string& input_name,
                                   const string& sink_name);
void             connect_core_distributor(const string& core_name, u32 port, const string& distributor_name);
void             connect_core_distributor(const string& core_name, const string& output_name, const string& input_name,
                                          const string& distributor_name);
void             connect_core_loader(const string& core_name, const string& iface, const string& loader_name);
void             connect_core_logic(const string& core_name, const string& output_name, const string& input_name,
                                    const string& logic_name);
void             connect_core_lookup(const string& core_name, const string& tie_name, const string& lookup_name);
void             connect_core_lookup_pin(const string& core_name, const string& tie_name, const string& lookup_pin_name);
void             connect_core_memory(const string& core_name, u32 memory_port, const string& memory_name);
void             connect_core_memory_trace(const string& core_name, xtsc_core::memory_port mem_port, u32 trace_port,
                                           const string& trace_name);
void             connect_core_mmio(const string& core_name, xtsc_core::memory_port mem_port, const string& mmio_name);
void             connect_core_mmio(const string& core_name, const string& output_name, const string& input_name,
                                   const string& mmio_name);
void             connect_core_proxy(const string& core_name, const string& iface, const string& name_prefix,
                                    const string& proxy_name);
void             connect_core_queue(const string& core_name, const string& tie_name, u32 producer_port, const string& queue_name);
void             connect_core_queue_pin(const string& core_name, const string& tie_name, const string& queue_pin_name);
void             connect_core_router(const string& core_name, xtsc_core::memory_port mem_port, const string& router_name);
void             connect_core_signal(const string& core_name, const string& output_pin_name, const string& signal_name);
void             connect_core_slave(const string& core_name, xtsc_core::memory_port mem_port, const string& slave_name);
void             connect_core_tlm2pin(const string& core_name, xtsc_core::memory_port mem_port, u32 tlm2pin_port,
                                      const string& tlm2pin_name);
void             connect_core_wire(const string& core_name, const string& output_name, const string& wire_name);
void             connect_core_wrapper(const string& core_name, const string& iface, const string& name_prefix);
void             connect_distributor_core(const string& distributor_name, u32 port, const string& input_name,
                                          const string& core_name);
void             connect_distributor_logic(const string& distributor_name, const string& output_name, const string& input_name,
                                           const string& logic_name);
void             connect_distributor_mmio(const string& distributor_name, const string& output_name, const string& input_name,
                                          const string& mmio_name);
void             connect_distributor_wire(const string& distributor_name, const string& output_name, const string& wire_name);
void             connect_dma_arbiter(const string& dma_name, u32 arbiter_port, const string& arbiter_name);
void             connect_dma_memory(const string& dma_name, u32 memory_port, const string& memory_name);
void             connect_dma_memory_trace(const string& dma_name, u32 trace_port, const string& trace_name);
void             connect_dma_router(const string& dma_name, const string& router_name);
void             connect_driver_distributor(const string& driver_name, const string& lookup_name, const string& distributor_name);
void             connect_driver_lookup(const string& driver_name, const string& lookup_name);
void             connect_driver_lookup_pin(const string& driver_name, const string& lookup_pin_name);
void             connect_driver_proxy(const string& driver_name, const string& name_prefix, const string& proxy_name);
void             connect_driver_wrapper(const string& driver_name, const string& name_prefix);
void             connect_loader_consumer(const string& loader_name, const string& consumer_name);
void             connect_loader_core(const string& loader_name, const string& iface, const string& core_name);
void             connect_loader_logic(const string& loader_name, const string& output_name, const string& input_name,
                                      const string& logic_name);
void             connect_loader_wire(const string& loader_name, const string& output_name, const string& wire_name);
void             connect_logic_cohctrl(const string& logic_name, const string& output_name, u32 port, const string& cohctrl_name);
void             connect_logic_core(const string& logic_name, const string& output_name, const string& input_name,
                                    const string& core_name);
void             connect_logic_distributor(const string& logic_name, const string& output_name, const string& input_name,
                                           const string& distributor_name);
void             connect_logic_logic(const string& source_name, const string& output_name, const string& input_name,
                                    const string& sink_name);
void             connect_logic_master(const string& logic_name, const string& output_name, const string& master_name);
void             connect_logic_mmio(const string& logic_name, const string& output_name, const string& input_name,
                                    const string& mmio_name);
void             connect_logic_producer(const string& logic_name, const string& output_name, const string& producer_name);
void             connect_logic_proxy(const string& logic_name, const string& output_name, const string& input_name,
                                     const string& proxy_name);
void             connect_logic_source(const string& logic_name, const string& output_name, const string& source_name);
void             connect_logic_wire(const string& logic_name, const string& output_name, const string& wire_name);
void             connect_logic_wrapper(const string& logic_name, const string& logic_output_name, const string& wrapper_output_name);
void             connect_master_arbiter(const string& master_name, u32 port, const string& arbiter_name);
void             connect_master_cohctrl(const string& master_name, u32 cohctrl_port, const string& cohctrl_name);
void             connect_master_core(const string& master_name, const string& port_name, const string& core_name);
void             connect_master_dma(const string& master_name, u32 dma_port, const string& dma_name);
void             connect_master_memory(const string& master_name, u32 memory_port, const string& memory_name);
void             connect_master_memory_trace(const string& master_name, u32 trace_port, const string& trace_name);
void             connect_master_mmio(const string& master_name, const string& mmio_name);
void             connect_master_router(const string& master_name, const string& router_name);
void             connect_master_slave(const string& master_name, const string& slave_name);
void             connect_master_tlm2pin(const string& master_name, u32 tlm2pin_port, const string& tlm2pin_name);
void             connect_memory_trace_arbiter(const string& trace_name, u32 trace_port, u32 arbiter_port, const string& arbiter_name);
void             connect_memory_trace_cohctrl(const string& trace_name, u32 trace_port, u32 cohctrl_port, const string& cohctrl_name);
void             connect_memory_trace_core(const string& trace_name, u32 trace_port, const string& port_name,
                                           const string& core_name);
void             connect_memory_trace_dma(const string& trace_name, u32 trace_port, u32 dma_port, const string& dma_name);
void             connect_memory_trace_memory(const string& trace_name, u32 trace_port, u32 memory_port, const string& memory_name);
void             connect_memory_trace_mmio(const string& trace_name, u32 trace_port, const string& mmio_name);
void             connect_memory_trace_router(const string& trace_name, u32 trace_port, const string& router_name);
void             connect_memory_trace_slave(const string& trace_name, u32 trace_port, const string& slave_name);
void             connect_memory_trace_tlm2pin(const string& trace_name, u32 trace_port, u32 tlm2pin_port, const string& tlm2pin_name);
void             connect_mmio_core(const string& mmio_name, const string& output_name, const string& input_name,
                                   const string& core_name);
void             connect_mmio_distributor(const string& mmio_name, const string& output_name, const string& input_name,
                                          const string& distributor_name);
void             connect_mmio_logic(const string& mmio_name, const string& output_name, const string& input_name,
                                    const string& logic_name);
void             connect_mmio_master(const string& mmio_name, const string& output_name, const string& master_name);
void             connect_mmio_mmio(const string& source_name, const string& output_name, const string& input_name,
                                   const string& sink_name);
void             connect_mmio_producer(const string& mmio_name, const string& output_name, const string& producer_name);
void             connect_mmio_proxy(const string& mmio_name, const string& output_name, const string& input_name,
                                   const string& proxy_name);
void             connect_mmio_source(const string& mmio_name, const string& output_name, const string& source_name);
void             connect_mmio_wire(const string& mmio_name, const string& output_name, const string& wire_name);
void             connect_mmio_wrapper(const string& mmio_name, const string& mmio_output_name, const string& wrapper_output_name);
void             connect_pin2tlm_arbiter(const string& pin2tlm_name, u32 pin2tlm_port, u32 arbiter_port,
                                         const string& arbiter_name);
void             connect_pin2tlm_cohctrl(const string& pin2tlm_name, u32 pin2tlm_port, u32 cohctrl_port,
                                         const string& cohctrl_name);
void             connect_pin2tlm_core(const string& pin2tlm_name, u32 pin2tlm_port, const string& core_name);
void             connect_pin2tlm_memory(const string& pin2tlm_name, u32 pin2tlm_port, u32 memory_port, const string& memory_name);
void             connect_pin2tlm_memory_trace(const string& pin2tlm_name, u32 pin2tlm_port, u32 trace_port, const string& trace_name);
void             connect_pin2tlm_mmio(const string& pin2tlm_name, u32 pin2tlm_port, const string& mmio_name);
void             connect_pin2tlm_router(const string& pin2tlm_name, u32 pin2tlm_port, const string& router_name);
void             connect_pin2tlm_slave(const string& pin2tlm_name, u32 pin2tlm_port, const string& slave_name);
void             connect_producer_loader(const string& producer_name, const string& loader_name);
void             connect_producer_proxy(const string& producer_name, const string& name_prefix, const string& proxy_name);
void             connect_producer_queue(const string& producer_name, u32 producer_port, const string& queue_name);
void             connect_producer_queue_pin(const string& producer_name, const string& queue_pin_name);
void             connect_producer_wrapper(const string& producer_name, const string& name_prefix);
void             connect_proxy_cohctrl(const string& proxy_name, const string& output_name, u32 cohctrl_port,
                                       const string& cohctrl_name);
void             connect_proxy_consumer(const string& proxy_name, const string& name_prefix, const string& consumer_name);
void             connect_proxy_core(const string& proxy_name, const string& name_prefix, const string& iface,
                                    const string& core_name);
void             connect_proxy_loader(const string& proxy_name, const string& name_prefix, const string& loader_name);
void             connect_proxy_logic(const string& proxy_name, const string& output_name, const string& input_name,
                                     const string& logic_name);
void             connect_proxy_lookup_pin(const string& proxy_name, const string& name_prefix, const string& lookup_pin_name);
void             connect_proxy_memory_pin(const string& proxy_name, const string& name_prefix, u32 port,
                                          const string& memory_pin_name);
void             connect_proxy_mmio(const string& proxy_name, const string& output_name, const string& input_name,
                                    const string& mmio_name);
void             connect_proxy_pin2tlm(const string& proxy_name, const string& name_prefix, u32 port, const string& pin2tlm_name);
void             connect_proxy_queue_pin(const string& proxy_name, const string& name_prefix, const string& queue_pin_name);
void             connect_proxy_wire(const string& proxy_name, const string& output_name, const string& wire_name);
void             connect_queue_consumer(const string& queue_name, u32 consumer_port, const string& consumer_name);
void             connect_queue_core(const string& queue_name, u32 consumer_port, const string& tie_name, const string& core_name);
void             connect_queue_pin_consumer(const string& queue_pin_name, const string& consumer_name);
void             connect_queue_pin_core(const string& queue_pin_name, const string& tie_name, const string& core_name);
void             connect_queue_pin_proxy(const string& queue_pin_name, const string& name_prefix, const string& proxy_name);
void             connect_queue_pin_wrapper(const string& queue_pin_name, const string& name_prefix);
void             connect_router_arbiter(const string& router_name, u32 router_port, u32 arbiter_port,
                                        const string& arbiter_name);
void             connect_router_cohctrl(const string& router_name, u32 router_port, u32 cohctrl_port, const string& cohctrl_name);
void             connect_router_core(const string& router_name, u32 port, const string& port_name, const string& core_name);
void             connect_router_dma(const string& router_name, u32 router_port, u32 dma_port, const string& dma_name);
void             connect_router_memory(const string& router_name, u32 router_port, u32 memory_port, const string& memory_name);
void             connect_router_memory_trace(const string& router_name, u32 router_port, u32 trace_port, const string& trace_name);
void             connect_router_mmio(const string& router_name, u32 port, const string& mmio_name);
void             connect_router_router(const string& master_name, u32 port, const string& slave_name);
void             connect_router_slave(const string& router_name, u32 port, const string& slave_name);
void             connect_router_tlm2pin(const string& router_name, u32 router_port, u32 tlm2pin_port,
                                           const string& tlm2pin_name);
void             connect_signal_core(const string& signal_name, const string& input_pin_name, const string& core_name);
void             connect_source_cohctrl(const string& source_name, const string& output_name, u32 port, const string& core_name);
void             connect_source_core(const string& source_name, const string& output_name, const string& input_name,
                                     const string& core_name);
void             connect_source_distributor(const string& source_name, const string& output_name, const string& input_name,
                                            const string& distributor_name);
void             connect_source_logic(const string& source_name, const string& output_name, const string& input_name,
                                      const string& logic);
void             connect_source_mmio(const string& source_name, const string& output_name, const string& input_name,
                                     const string& mmio);
void             connect_source_proxy(const string& source_name, const string& output_name, const string& port_name,
                                      const string& proxy_name);
void             connect_source_signal(const string& source_name, const string& output_name, const string& signal_name);
void             connect_source_wire(const string& source_name, const string& output_name, const string& wire_name);
void             connect_source_wrapper(const string& source_name, const string& output_name, const string& wrapper_output_name);
void             connect_tlm2pin_memory_pin(const string& tlm2pin_name, u32 tlm2pin_port, u32 memory_port,
                                            const string& memory_pin_name);
void             connect_tlm2pin_pin2tlm(const string& tlm2pin_name, u32 tlm2pin_port, u32 pin2tlm_port, const string& pin2tlm_name);
void             connect_tlm2pin_proxy(const string& tlm2pin_name, u32 port, const string& name_prefix, const string& proxy_name);
void             connect_tlm2pin_wrapper(const string& tlm2pin_name, u32 port, const string& name_prefix);
void             connect_wire_core(const string& wire_name, const string& tie_name, const string& core_name);
void             connect_wrapper_cohctrl(const string& input_name, u32 cohctrl_port, const string& cohctrl_name);
void             connect_wrapper_consumer(const string& name_prefix, const string& consumer_name);
void             connect_wrapper_core(const string& name_prefix, const string& iface, const string& core_name);
void             connect_wrapper_logic(const string& wrapper_input_name, const string& logic_input_name, const string& logic_name);
void             connect_wrapper_loader(const string& name_prefix, const string& loader_name);
void             connect_wrapper_lookup_pin(const string& name_prefix, const string& lookup_pin_name);
void             connect_wrapper_memory_pin(const string& name_prefix, u32 port, const string& memory_pin_name);
void             connect_wrapper_mmio(const string& wrapper_input_name, const string& mmio_input_name, const string& mmio_name);
void             connect_wrapper_pin2tlm(const string& name_prefix, u32 port, const string& pin2tlm_name);
void             connect_wrapper_queue_pin(const string& name_prefix, const string& queue_pin_name);
void             connect_wrapper_wire(const string& wrapper_input_name, const string& wire_name);


// Step 12:  Declare the 6 standard methods (in some cases you may need some additional methods):
//            void             init_widget_parms();
//            void             show_widget_parms();
//            void             add_widget_parm();
//            void             create_widget(const string& name);
//            void             fini_widget_parms();
//            widget_info&     find_or_infer_widget(const string& widget_name);

void             init_arbiter_parms();
void             show_arbiter_parms();
void             add_arbiter_parm();
void             create_arbiter(const string& name);
void             fini_arbiter_parms();
arbiter_info&    find_or_infer_arbiter(const string& arbiter_name);

void             init_clock_parms();
void             show_clock_parms();
void             add_clock_parm();
void             create_clock(const string& name);
void             fini_clock_parms();
clock_info&      find_or_infer_clock(const string& clock_name);

void             init_consumer_parms();
void             show_consumer_parms();
void             add_consumer_parm();
void             create_consumer(const string& name);
void             fini_consumer_parms();
consumer_info&   find_or_infer_consumer(const string& consumer_name);

void             init_cohctrl_parms();
void             show_cohctrl_parms();
void             add_cohctrl_parm();
void             create_cohctrl(const string& name);
void             fini_cohctrl_parms();
cohctrl_info&    find_or_infer_cohctrl(const string& cohctrl_name);

void             redo_core_parms_if_able();
void             infer_create_core(const string& core_name);
void             init_core_parms(bool redefine_use_memport = true);
void             show_core_parms();
void             add_core_parm();
void             create_core(const string& name, const string& memory_name);
void             fini_core_parms();
core_info&       find_or_infer_core(const string& core_name, const string& memory_name);

void             init_distributor_parms();
void             show_distributor_parms();
void             add_distributor_parm();
void             create_distributor(const string& name);
void             fini_distributor_parms();
distributor_info& find_or_infer_distributor(const string& distributor_name);

void             init_dma_parms();
void             show_dma_parms();
void             add_dma_parm();
void             create_dma(const string& name);
void             fini_dma_parms();
dma_info&        find_or_infer_dma(const string& dma_name);

void             init_driver_parms();
void             show_driver_parms();
void             add_driver_parm();
void             create_driver(const string& name);
void             fini_driver_parms();
driver_info&     find_or_infer_driver(const string& driver_name);

void             init_loader_parms();
void             show_loader_parms();
void             add_loader_parm();
void             create_loader(const string& name);
void             fini_loader_parms();
loader_info&     find_or_infer_loader(const string& loader_name);

void             init_logic_parms();
void             show_logic_parms();
void             add_logic_parm();
void             create_logic(const string& name);
void             fini_logic_parms();
logic_info&      find_or_infer_logic(const string& logic_name);

void             init_lookup_parms();
void             show_lookup_parms();
void             add_lookup_parm();
void             create_lookup(const string& name, const string& tie_name);
void             fini_lookup_parms();
lookup_info&     find_or_infer_lookup(const string& lookup_name);

void             init_lookup_pin_parms();
void             show_lookup_pin_parms();
void             add_lookup_pin_parm();
void             create_lookup_pin(const string& name, const string& tie_name);
void             fini_lookup_pin_parms();
lookup_pin_info& find_or_infer_lookup_pin(const string& lookup_pin_name);

void             init_make_parms();
void             show_make_parms();
void             add_make_parm();

void             init_master_parms();
void             show_master_parms();
void             add_master_parm();
void             create_master(const string& name);
void             fini_master_parms();
master_info&     find_or_infer_master(const string& master_name);

void             throw_no_such_memory_port();
void             init_memory_parms(xtsc_core_parms *p_cp = 0, bool redefine_use_memport = true);
void             show_memory_parms();
void             add_memory_parm();
void             create_memory(const string& name, xtsc_core_parms *p_cp = 0);
void             fini_memory_parms();
memory_info&     find_or_infer_memory(const string& memory_name, xtsc_core_parms *p_cp = 0);

void             throw_no_such_memory_port_pin();
void             init_memory_pin_parms();
void             show_memory_pin_parms();
void             add_memory_pin_parm();
void             create_memory_pin(const string& name);
void             fini_memory_pin_parms();
memory_pin_info& find_or_infer_memory_pin(const string& memory_pin_name);

void             init_memory_trace_parms();
void             show_memory_trace_parms();
void             add_memory_trace_parm();
void             create_memory_trace(const string& name);
void             fini_memory_trace_parms();
memory_trace_info& find_or_infer_memory_trace(const string& trace_name);

void             init_mmio_parms();
void             show_mmio_parms();
void             add_mmio_parm();
void             create_mmio(const string& name);
void             fini_mmio_parms();
mmio_info&       find_or_infer_mmio(const string& mmio_name);

void             init_pin2tlm_parms();
void             show_pin2tlm_parms();
void             add_pin2tlm_parm();
void             create_pin2tlm(const string& name);
void             fini_pin2tlm_parms();
pin2tlm_info&    find_or_infer_pin2tlm(const string& pin2tlm_name);

void             init_producer_parms();
void             show_producer_parms();
void             add_producer_parm();
void             create_producer(const string& name);
void             fini_producer_parms();
producer_info&   find_or_infer_producer(const string& producer_name);

void             init_proxy_parms(bool require_cosim);
void             show_proxy_parms();
void             add_proxy_parm();
void             create_proxy(const string& name);
void             fini_proxy_parms();
proxy_info&      find_or_infer_proxy(const string& proxy_name);

void             init_queue_parms();
void             show_queue_parms();
void             add_queue_parm();
void             create_queue(const string& name, const string& tie_name);
void             fini_queue_parms();
queue_info&      find_or_infer_queue(const string& queue_name);

void             init_queue_pin_parms();
void             show_queue_pin_parms();
void             add_queue_pin_parm();
void             create_queue_pin(const string& name, const string& tie_name);
void             fini_queue_pin_parms();
queue_pin_info&  find_or_infer_queue_pin(const string& queue_pin_name);

void             init_router_parms();
void             show_router_parms();
void             add_router_parm();
void             create_router(const string& name);
void             fini_router_parms();
router_info&     find_or_infer_router(const string& router_name);

void             init_signal_parms();
void             show_signal_parms();
void             add_signal_parm();
void             create_signal(const string& name);
void             fini_signal_parms();
signal_info&     find_or_infer_signal(const string& signal_name, u32 bit_width);

void             init_slave_parms();
void             show_slave_parms();
void             add_slave_parm();
void             create_slave(const string& name);
void             fini_slave_parms();
slave_info&      find_or_infer_slave(const string& slave_name);

void             init_source_parms();
void             show_source_parms();
void             add_source_parm();
void             create_source(const string& name);
void             fini_source_parms();
source_info&     find_or_infer_source(const string& source_name);

void             init_tlm2pin_parms();
void             show_tlm2pin_parms();
void             add_tlm2pin_parm();
void             create_tlm2pin(const string& name);
void             fini_tlm2pin_parms();
tlm2pin_info&    find_or_infer_tlm2pin(const string& tlm2pin_name);

void             init_vcd_parms();
void             show_vcd_parms();
void             add_vcd_parm();
void             create_vcd(const string& name);
void             fini_vcd_parms();
vcd_info&        find_or_infer_vcd(const string& vcd_name);

void             init_wire_parms();
void             show_wire_parms();
void             add_wire_parm();
void             create_wire(const string& name, const string& tie_name);
void             fini_wire_parms();
wire_info&       find_or_infer_wire(const string& wire_name);

void             init_wrapper_parms(bool require_cosim);
void             show_wrapper_parms();
void             add_wrapper_parm();
void             create_wrapper(const string& name);
void             fini_wrapper_parms();
wrapper_info&    find_or_infer_wrapper(const string& wrapper_name);

void             show_xtsc_parms();
void             add_xtsc_parm();







int main(int argc, char *argv[]) {

  xtsc_run_name = argv[0];

  // Look ahead for --help and --manual commands
  for (int i=1; i<argc; ++i) {
    string a    = argv[i];
    string a_lc = argv[i];
    transform(a.begin(), a.end(), a_lc.begin(), ::tolower);
    if ((a_lc == "--h") || (a_lc == "-h") || (a_lc == "--help") || (a_lc == "-help") || (a_lc == "?")) {
      usage(true);
      return 0;
    }
    if ((a_lc == "--man") || (a_lc == "-man") || (a_lc == "--manual") || (a_lc == "-manual")) {
      usage(false);
      return 0;
    }
  }

  return sc_elab_and_sim(argc, argv);

}



void initialize_sc_main_generation() {

  path = path + sep;
  if (dir != "") {
    path = path + dir + sep;
  }

  if (!verilog_on_top) {
    // If not doing Verilog on top of SystemC, then create a NULL wrapper that has the sc_main name
    wrapper_info *p_null = NULL;
    wrapper_map[sc_main_name] = p_null;
    wrapper_list.push_back(sc_main_name);
  }

  sc_main_name = path + sc_main_name;

  do_generate_sc_main = true;

}



// Scan for remaining special commands: --logging=<LoggingConfigurationFile>, --binary, --sc_main, --cosim, --path, --dir,
//                                      --show_xtsc_parms, --set_xtsc_parm
// Note: Don't do anything that requires log4xtensa to be initialized.
void check_for_special_commands() {

  bool logging_command = false;

  for (u32 i=0; i<commands.size(); ++i) {

    setup_command_variables(commands[i], command_files[i], command_line_numbers[i], info_for_exceptions[i]);

    // Don't scan beyond any trailing target program name (first non-hyphenated argument on command line)
    if ((command_file == "") && (rem_lc.substr(0,1) != "-")) break;

    // Trim leading hyphens
    string::size_type pos = rem.find_first_not_of("-");
    rem   .erase(0, pos);
    rem_lc.erase(0, pos);

    // Split rem using pattern command_name=rem
    arg_split(i);

    if ((command_name == "logging") || (command_name=="log") || (command_name=="l")) {
      if (!command_is_assignment) {
        ostringstream oss;
        oss << "Malformed --logging command ";
        command_info(oss);
        throw xtsc_exception(oss.str());
      }
      if ((rem_lc == "off") || (rem_lc == "on") || (rem_lc == "elab_only")) {
        // Do nothing here this will be handled during normal processing
      }
      else {
        if (logging_command) {
          ostringstream oss;
          oss << "Only one --logging=<LoggingConfigurationFile> command is allowed: ";
          command_info(oss);
          throw xtsc_exception(oss.str());
        }
        logging_command = true;
        logging = rem;
        p_initialize_parms->set("text_logging_config_file", logging.c_str());
        oss_xtsc_parms << tab2 << name_xtsc_parms << ".set(\"text_logging_config_file\", \"" << escape_backslashes(logging)
                       << "\");" << endl;
      }
    }
    else if ((command_name == "binary") || (command_name=="bin") || (command_name=="b")) {
      if (!command_is_assignment) {
        ostringstream oss;
        oss << "Malformed --binary command ";
        command_info(oss);
        throw xtsc_exception(oss.str());
      }
      if (binary == "") {
        binary = rem;
        p_initialize_parms->set("binary_logging_config_file", binary.c_str());
        oss_xtsc_parms << tab2 << name_xtsc_parms << ".set(\"binary_logging_config_file\", \"" << escape_backslashes(logging)
                       << "\");" << endl;
      }
      else {
        ostringstream oss;
        oss << "Only one --binary command is allowed: ";
        command_info(oss);
        throw xtsc_exception(oss.str());
      }
    }
    else if (command_name == "sc_main") {
      if (sc_main_command) {
        ostringstream oss;
        oss << "Only one --sc_main command is allowed.";
        command_info(oss);
        throw xtsc_exception(oss.str());
      }
      sc_main_command = true;
      sc_main_name = (command_is_assignment ? rem : sc_main_name_default);
    }
    else if ((command_name == "cosim") || (command_name == "co_sim") || (command_name == "co-sim")) {
      if (cosim) {
        ostringstream oss;
        oss << "Only one --cosim command is allowed: ";
        command_info(oss);
        throw xtsc_exception(oss.str());
      }
      cosim             = true;
      no_simulation     = true;
      cosimi            = i;
    }
    else if (command_name == "dir") {
      if (!command_is_assignment) {
        ostringstream oss;
        oss << "Malformed --dir command ";
        command_info(oss);
        throw xtsc_exception(oss.str());
      }
      dir = rem;
      // Ensure dir is "valid": 
      //   - Contains only C++ identifier characters plus space, hyphen, and period.
      //   - Contains at least one character that is not a space or a period.
      //   - Does not end with space.
      string::size_type pos1 = dir.find_first_not_of("_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-. ");
      string::size_type pos2 = dir.find_first_not_of(" .");
      if ((pos1 != string::npos) || (pos2 == string::npos) || (dir.substr(dir.length()-1) == " ")) {
        ostringstream oss;
        oss << "Invalid directory specified: ";
        command_info(oss);
        throw xtsc_exception(oss.str());
      }
    }
    else if (command_name == "path") {
      if (!command_is_assignment) {
        ostringstream oss;
        oss << "Malformed --path command ";
        command_info(oss);
        throw xtsc_exception(oss.str());
      }
      path = rem;
    }
    else if ((command_name == "show_xtsc_parms") || (command_name == "show_xtsc_parm")) {
      show_xtsc_parms();
    }
    else if (command_name == "set_xtsc_parm") {
      add_xtsc_parm();
    }
  }

}



// Step 13:  Add widget_map.push_back(new map<string, widget_info*>);
void create_per_wrapper_stuff() {

  // Finalize previous wrapper if there is one
  if (verilog_on_top && (w != 0xFFFFFFFF)) {
    finalize_system_or_wrapper();
  }

  // Create a new set of module instance maps
  arbiter_map     .push_back(new map<string,arbiter_info*>);
  clock_map       .push_back(new map<string,clock_info*>);
  cohctrl_map     .push_back(new map<string,cohctrl_info*>);
  consumer_map    .push_back(new map<string,consumer_info*>);
  core_map        .push_back(new map<string,core_info*>);
  dma_map         .push_back(new map<string,dma_info*>);
  distributor_map .push_back(new map<string,distributor_info*>);
  driver_map      .push_back(new map<string,driver_info*>);
  loader_map      .push_back(new map<string,loader_info*>);
  logic_map       .push_back(new map<string,logic_info*>);
  lookup_map      .push_back(new map<string,lookup_info*>);
  lookup_pin_map  .push_back(new map<string,lookup_pin_info*>);
  master_map      .push_back(new map<string,master_info*>);
  memory_map      .push_back(new map<string,memory_info*>);
  memory_pin_map  .push_back(new map<string,memory_pin_info*>);
  memory_trace_map.push_back(new map<string,memory_trace_info*>);
  mmio_map        .push_back(new map<string,mmio_info*>);
  pin2tlm_map     .push_back(new map<string,pin2tlm_info*>);
  producer_map    .push_back(new map<string,producer_info*>);
  proxy_map       .push_back(new map<string,proxy_info*>);
  queue_map       .push_back(new map<string,queue_info*>);
  queue_pin_map   .push_back(new map<string,queue_pin_info*>);
  router_map      .push_back(new map<string,router_info*>);
  signal_map      .push_back(new map<string,signal_info*>);
  slave_map       .push_back(new map<string,slave_info*>);
  source_map      .push_back(new map<string,source_info*>);
  tlm2pin_map     .push_back(new map<string,tlm2pin_info*>);
  vcd_map         .push_back(new map<string,vcd_info*>);
  wire_map        .push_back(new map<string,wire_info*>);

  // Create a new set of identifiers
  identifier_map  .push_back(new map<string,void*>);

  // Create a new oss for code generation
  oss_main.push_back(new ostringstream());

  // Create a pair_table for keeping track of which modules get created
  modules.push_back(new pair_table);

  // Increment wrapper index (this will become and stay 0 if not doing wrappers)
  w += 1;

  last_core_created = "";

}



int sc_main(int argc, char *argv[]) {

  try {

    p_initialize_parms = new xtsc_initialize_parms();

    xtsc_set_constructor_log_level(log4xtensa::INFO_LOG_LEVEL);

    create_per_wrapper_stuff();

    slurp(argc-1, argv+1, 0, 0, 0);

    check_for_special_commands();

    xtsc_initialize(*p_initialize_parms);

    logging_is_configured = true;

    initialize_processing();

    process();

    final_processing();

    xtsc_finalize();

  }
  catch (const exception& error) {
    ostringstream oss;
    oss << "std::exception caught: " << endl;
    oss << error.what() << endl;
    if (logging_is_configured) xtsc_log_multiline(logger, log4xtensa::FATAL_LOG_LEVEL, oss.str(), 2);
    cerr << endl;
    cerr << "xtsc-run failed, std::exception caught: " << endl;
    cerr << error.what() << endl;
    cerr << endl;
    cerr << "Use command '" << argv[0] << " --help' to get usage information" << endl;
    return 1;
  }

  return 0;
}

  

void usage(bool brief) {
  XTSC_TRACE(logger, "enter usage()");
  if (!brief) {
  cout << "The xtsc-run Reference Manual is comprised of six sections:" << endl;
  cout << "I:   Usage and Overview" << endl;
  cout << "II:  Command Listing (by category)" << endl;
  cout << "III: XTSC Modules" << endl;
  cout << "IV:  Full Command Documentation (alphabetical)" << endl;
  cout << "V:   Notes on xtsc-run command processing" << endl;
  cout << "VI:  Examples" << endl;
  cout << endl;
  cout << endl;
  cout << "Section I:  Usage and Overview" << endl;
  cout << endl;
  }
  cout << "Usage:  xtsc-run [<Command> ...] [<ProgramName> [<ProgramArgs>]]" << endl;
  if (!brief) {
  cout << "Where:" << endl;
  cout << " <Command>      is one of the commands documented below.  On the DOS/linux" << endl;
  cout << "                command line, each xtsc-run command must begin with at least" << endl;
  cout << "                one hyphen (extra hyphens are ignored).  In an --include file" << endl;
  cout << "                leading hyphens are optional and are all ignored.  Basically" << endl;
  cout << "                these commands are used to configure, construct, connect, and" << endl;
  cout << "                simulate a SystemC system of XTSC components." << endl;
  cout << " <ProgramName>  is an optional program name to be loaded on the last" << endl;
  cout << "                instantiated core.  See --core_program below." << endl;
  cout << "                Note: <ProgramName>, if present, is the first command-line" << endl;
  cout << "                      argument that does not begin with a hyphen." << endl;
  cout << " <ProgramArgs>  Optional arguments to be passed in to the main() function" << endl;
  cout << "                of <ProgramName> using the argv array.  See --core_args below." << endl;
  cout << endl;
  cout << endl;
  cout << "Overview: " << endl;
  cout << endl;
  cout << "xtsc-run is a program to configure, construct, connect, and simulate simple to" << endl;
  cout << "complex systems comprised of cores, memories, arbiters, routers, lookups, queues," << endl;
  cout << "etc. using components from the XTSC libraries.  It can also be used as a code" << endl;
  cout << "generator to create systems for pure a SystemC simulation (see --sc_main) or for" << endl;
  cout << "a SystemC-Verilog cosimulation using user-provided Verilog modules in either a" << endl;
  cout << "SystemC-on-top or a Verilog-on-top scenario (see --cosim)." << endl;
  cout << endl;
  cout << "Command-line arguments up to the first command-line argument that does" << endl;
  cout << "not start with a hyphen are treated as xtsc-run commands.  The first" << endl;
  cout << "command-line argument that does not start with a hyphen, if any, is" << endl;
  cout << "interpretted as <ProgramName> and all subsequent command-line arguments" << endl;
  cout << "are interpretted as <ProgramArgs>.  In most cases, xtsc-run commands are" << endl;
  cout << "executed in order.  For more information, see the notes on xtsc-run command" << endl;
  cout << "processing in Section V below." << endl;
  cout << endl;
  cout << "Section II:  Command Listing" << endl;
  cout << endl;
  }
  cout << "xtsc-run commands can be divided into the following 5 catagories: " << endl;
  cout << "  1. Xtensa environment commands:  " << endl;
  cout << "       --xtensa_system=<InstallationDirectory> " << endl;
  cout << "       --xtensa_core=<ConfigName> " << endl;
  cout << "       --xtensa_params=<TdkDirectory> " << endl;

// Step 14:  a) Add single cout for   --set_widget_parm=<ParmName>=<ParmValue>
//           b) Add single cout for   --show_widget_parms

  cout << "  2. XTSC object parameter setting and showing commands:  " << endl;
  cout << "       --set_arbiter_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_clock_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_consumer_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_cohctrl_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_core_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_distributor_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_dma_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_driver_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_loader_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_logic_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_lookup_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_lookup_pin_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_make_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_master_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_memory_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_memory_pin_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_memory_trace_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_mmio_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_pin2tlm_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_producer_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_proxy_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_queue_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_queue_pin_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_router_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_signal_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_slave_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_source_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_tlm2pin_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_vcd_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_wire_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_wrapper_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --set_xtsc_parm=<ParmName>=<ParmValue> " << endl;
  cout << "       --show_arbiter_parms" << endl;
  cout << "       --show_clock_parms" << endl;
  cout << "       --show_consumer_parms" << endl;
  cout << "       --show_cohctrl_parms" << endl;
  cout << "       --show_core_parms" << endl;
  cout << "       --show_distributor_parms" << endl;
  cout << "       --show_dma_parms" << endl;
  cout << "       --show_driver_parms" << endl;
  cout << "       --show_loader_parms" << endl;
  cout << "       --show_logic_parms" << endl;
  cout << "       --show_lookup_parms" << endl;
  cout << "       --show_lookup_pin_parms" << endl;
  cout << "       --show_make_parms" << endl;
  cout << "       --show_master_parms" << endl;
  cout << "       --show_memory_parms" << endl;
  cout << "       --show_memory_pin_parms" << endl;
  cout << "       --show_memory_trace_parms" << endl;
  cout << "       --show_mmio_parms" << endl;
  cout << "       --show_pin2tlm_parms" << endl;
  cout << "       --show_producer_parms" << endl;
  cout << "       --show_proxy_parms" << endl;
  cout << "       --show_queue_parms" << endl;
  cout << "       --show_queue_pin_parms" << endl;
  cout << "       --show_router_parms" << endl;
  cout << "       --show_signal_parms" << endl;
  cout << "       --show_slave_parms" << endl;
  cout << "       --show_source_parms" << endl;
  cout << "       --show_tlm2pin_parms" << endl;
  cout << "       --show_vcd_parms" << endl;
  cout << "       --show_wire_parms" << endl;
  cout << "       --show_wrapper_parms" << endl;
  cout << "       --show_xtsc_parms" << endl;

// Step 15:  Add single cout for   --create_widget[=<WidgetName>]   (add additional csv's if required)

  cout << "  3. XTSC object creation commands: " << endl;
  cout << "       --create_arbiter[=<ArbiterName>]" << endl;
  cout << "       --create_clock[=<ClockName>]" << endl;
  cout << "       --create_consumer[=<ConsumerName>]" << endl;
  cout << "       --create_cohctrl[=<CohctrlName>]" << endl;
  cout << "       --create_core[=<CoreName>]" << endl;
  cout << "       --create_distributor[=<DistributorName>]" << endl;
  cout << "       --create_dma[=<DmaName>]" << endl;
  cout << "       --create_driver[=<DriverName>]" << endl;
  cout << "       --create_loader[=<LoaderName>]" << endl;
  cout << "       --create_logic[=<LogicName>]" << endl;
  cout << "       --create_lookup[=<LookupName>[,<TiePortName>]]" << endl;
  cout << "       --create_lookup_pin[=<LookupName>[,<TiePortName>]]" << endl;
  cout << "       --create_master[=<MasterName>]" << endl;
  cout << "       --create_memory[=<MemoryName>]" << endl;
  cout << "       --create_memory_pin[=<MemoryName>]" << endl;
  cout << "       --create_memory_trace[=<TraceName>]" << endl;
  cout << "       --create_mmio[=<MmioName>]" << endl;
  cout << "       --create_pin2tlm[=<Pin2tlmName>]" << endl;
  cout << "       --create_producer[=<ProducerName>]" << endl;
  cout << "       --create_proxy[=<ProxyName>]" << endl;
  cout << "       --create_queue[=<QueueName>[,<TiePortName>]]" << endl;
  cout << "       --create_queue_pin[=<QueueName>[,<TiePortName>]]" << endl;
  cout << "       --create_router[=<RouterName>]" << endl;
  cout << "       --create_signal=<SignalName>" << endl;
  cout << "       --create_slave[=<SlaveName>]" << endl;
  cout << "       --create_source[=<SourceName>]" << endl;
  cout << "       --create_tlm2pin[=<Tlm2pinName>]" << endl;
  cout << "       --create_vcd[=<Identifier>]" << endl;
  cout << "       --create_wire[=<WireName>[,<TiePortName>]]" << endl;
  cout << "       --create_wrapper[=<WrapperName>]" << endl;

// Step 16:  Add single cout for each thing that can be connected to a widget
//           (--connect_XXX_widget=<XXXName>,<WidgetName>) and for each thing that
//           a widget can connect to (--connect_widget_XXX=<WidgetName>,<XXXName>).
//           Use additional csv's if required to support port numbers, memory port names, etc.

  cout << "  4. XTSC object connection commands: " << endl;
  cout << "       --connect_arbiter_arbiter=<MasterName>,<SlavePort>,<SlaveName>" << endl;
  cout << "       --connect_arbiter_cohctrl=<ArbiterName>[,<CohctrlPort>],<CohctrlName>" << endl;
  cout << "       --connect_arbiter_core=<ArbiterName>[,<PortName>],<CoreName>" << endl;
  cout << "       --connect_arbiter_dma=<ArbiterName>[,<DmaPort>],<DmaName>" << endl;
  cout << "       --connect_arbiter_memory=<ArbiterName>[,<MemoryPort>],<MemoryName>" << endl;
  cout << "       --connect_arbiter_memory_trace=<ArbiterName>[,<TracePort>],<TraceName>" << endl;
  cout << "       --connect_arbiter_mmio=<ArbiterName>,<MmioName>" << endl;
  cout << "       --connect_arbiter_router=<ArbiterName>,<RouterName>" << endl;
  cout << "       --connect_arbiter_slave=<ArbiterName>,<SlaveName>" << endl;
  cout << "       --connect_arbiter_tlm2pin=<ArbiterName>[,<Tlm2pinPort>],<Tlm2pinName>" << endl;
  cout << "       --connect_clock_proxy=<ClockName>[,<InputName>],<ProxyName>" << endl;
  cout << "       --connect_clock_wrapper=<ClockName>,<WrapperOutputName>" << endl;
  cout << "       --connect_cohctrl_arbiter=<CohctrlName>[[,<SnoopPort],<ArbiterPort>],<ArbiterName>" << endl;
  cout << "       --connect_cohctrl_memory=<CohctrlName>[,<MemoryPort>],<MemoryName>" << endl;
  cout << "       --connect_cohctrl_memory_trace=<CohctrlName>[,<SnoopPort>],<TracePort>,<TraceName>" << endl;
  cout << "       --connect_cohctrl_router=<CohctrlName>[,<SnoopPort>],<RouterName>" << endl;
  cout << "       --connect_cohctrl_slave=<CohctrlName>[,<SnoopPort>],<SlaveName>" << endl;
  cout << "       --connect_cohctrl_tlm2pin=<CohctrlName>[,<PortNumber>],<Tlm2pinName>" << endl;
  cout << "       --connect_core_arbiter=<CoreName>[,<PortName>],<ArbiterPort>,<ArbiterName>" << endl;
  cout << "       --connect_core_cohctrl=<CoreName>[,<CohctrlPort>],<CohctrlName>" << endl;
  cout << "       --connect_core_core=<UpstreamTX>,<DownstreamTX>" << endl;
  cout << "       --connect_core_core=<CoreSource>,<OutputName>,<InputName>,<CoreSink>" << endl;
  cout << "       --connect_core_distributor=<CoreName>,<PortNumber>,<DistributorName>" << endl;
  cout << "       --connect_core_distributor=<CoreName>,<OutputName>,<InputName>,<DistributorName>" << endl;
  cout << "       --connect_core_loader=<CoreName>[,<CoreInterface>],<LoaderName>" << endl;
  cout << "       --connect_core_logic=<CoreName>,<OutputName>[,<InputName>],<LogicName>" << endl;
  cout << "       --connect_core_lookup=<CoreName>,<TiePortName>[,<LookupName>]" << endl;
  cout << "       --connect_core_lookup_pin=<CoreName>,<TiePortName>[,<LookupName>]" << endl;
  cout << "       --connect_core_memory=<CoreName>[,<MemoryPort>],<MemoryName>" << endl;
  cout << "       --connect_core_memory_trace=<CoreName>,<PortName>[,<TracePort>],<TraceName>" << endl;
  cout << "       --connect_core_mmio=<CoreName>[,<MemoryPort>],<MmioName>" << endl;
  cout << "       --connect_core_mmio=<CoreName>,<OutputName>[,<InputName>],<MmioName>" << endl;
  cout << "       --connect_core_proxy=<CoreName>,<Interface>[,<NamePrefix>],<ProxyName>" << endl;
  cout << "       --connect_core_queue=<CoreName>,<TiePortName>[,<ProducerPort>][,<QueueName>]" << endl;
  cout << "       --connect_core_queue_pin=<CoreName>,<TiePortName>[,<QueueName>]" << endl;
  cout << "       --connect_core_router=<CoreName>[,<PortName>],<RouterName>" << endl;
  cout << "       --connect_core_signal=<CoreName>,<OutputPinName>[,<SignalName>]" << endl;
  cout << "       --connect_core_slave=<CoreName>[,<PortName>],<SlaveName>" << endl;
  cout << "       --connect_core_tlm2pin=<CoreName>[,<PortName>][,<Tlm2pinPort>],<Tlm2pinName>" << endl;
  cout << "       --connect_core_wire=<CoreName>,<OutputName>[,<WireName>]" << endl;
  cout << "       --connect_core_wrapper=<CoreName>,<Interface>[,<NamePrefix>]" << endl;
  cout << "       --connect_distributor_core=<DistributorName>,<PortNumber>[,<InputName>],<CoreName>" << endl;
  cout << "       --connect_distributor_logic=<DistributorName>,<OutputName>,<InputName>,<LogicName>" << endl;
  cout << "       --connect_distributor_mmio=<DistributorName>,<OutputName>,<InputName>,<MmioName>" << endl;
  cout << "       --connect_distributor_wire=<DistributorName>,<OutputName>,<WireName>" << endl;
  cout << "       --connect_dma_arbiter=<DmaName>,<ArbiterPort>,<ArbiterName>" << endl;
  cout << "       --connect_dma_memory=<DmaName>[,<MemoryPort>],<MemoryName>" << endl;
  cout << "       --connect_dma_memory_trace=<DmaName>[,<TracePort>],<TraceName>" << endl;
  cout << "       --connect_dma_router=<DmaName>,<RouterName>" << endl;
  cout << "       --connect_driver_distributor=<DriverName>,<LookupName>,<DistributorName>" << endl;
  cout << "       --connect_driver_lookup=<DriverName>,<LookupName>" << endl;
  cout << "       --connect_driver_lookup_pin=<DriverName>,<LookupName>" << endl;
  cout << "       --connect_driver_proxy=<DriverName>[,<NamePrefix>],<ProxyName>" << endl;
  cout << "       --connect_driver_wrapper=<DriverName>,<NamePrefix>" << endl;
  cout << "       --connect_loader_consumer=<LoaderName>,<ConsumerName>" << endl;
  cout << "       --connect_loader_core=<LoaderName>[,<CoreInterface>],<CoreName>" << endl;
  cout << "       --connect_loader_logic=<LoaderName>,<OutputName>[,<InputName>],<LogicName>" << endl;
  cout << "       --connect_loader_wire=<LoaderName>[,<OutputName>],<WireName>" << endl;
  cout << "       --connect_logic_cohctrl=<LogicName>,<OutputName>,<CohctrlPort>,<CohctrlName>" << endl;
  cout << "       --connect_logic_core=<LogicName>[,<OutputName>],<InputName>,<CoreName>" << endl;
  cout << "       --connect_logic_distributor=<LogicName>,<OutputName>,<InputName>,<DistributorName>" << endl;
  cout << "       --connect_logic_logic=<SourceName>[,<OutputName>],<InputName>,<SinkName>" << endl;
  cout << "       --connect_logic_master=<LogicName>,<OutputName>,<MasterName>" << endl;
  cout << "       --connect_logic_mmio=<LogicName>,<OutputName>[,<InputName>],<MmioName>" << endl;
  cout << "       --connect_logic_producer=<LogicName>,<OutputName>,<ProducerName>" << endl;
  cout << "       --connect_logic_proxy=<LogicName>,<OutputName>[,<InputName>],<ProxyName>" << endl;
  cout << "       --connect_logic_source=<LogicName>,<OutputName>,<SourceName>" << endl;
  cout << "       --connect_logic_wire=<LogicName>[,<OutputName>],<WireName>" << endl;
  cout << "       --connect_logic_wrapper=<LogicName>,<LogicOutputName>[,<WrapperOutputName>]" << endl;
  cout << "       --connect_master_arbiter=<MasterName>,<ArbiterPort>,<ArbiterName>" << endl;
  cout << "       --connect_master_cohctrl=<MasterName>[,<CohctrlPort>],<CohctrlName>" << endl;
  cout << "       --connect_master_core=<MasterName>[,<PortName>],<CoreName>" << endl;
  cout << "       --connect_master_dma=<MasterName>[,<DmaPort>],<DmaName>" << endl;
  cout << "       --connect_master_memory=<MasterName>[,<MemoryPort>],<MemoryName>" << endl;
  cout << "       --connect_master_memory_trace=<MasterName>[,<TracePort>],<TraceName>" << endl;
  cout << "       --connect_master_mmio=<MasterName>,<MmioName>" << endl;
  cout << "       --connect_master_router=<MasterName>,<RouterName>" << endl;
  cout << "       --connect_master_slave=<MasterName>,<SlaveName>" << endl;
  cout << "       --connect_master_tlm2pin=<MasterName>[,<Tlm2pinPort>],<Tlm2pinName>" << endl;
  cout << "       --connect_memory_trace_arbiter=<TraceName>[,<TracePort>],<ArbiterPort>,<ArbiterName>" << endl;
  cout << "       --connect_memory_trace_cohctrl=<TraceName>[[,<TracePort>],<CohctrlPort>],<CohctrlName>" << endl;
  cout << "       --connect_memory_trace_core=<TraceName>[[,<TracePort>],<PortName>],<CoreName>" << endl;
  cout << "       --connect_memory_trace_dma=<TraceName>[[,<TracePort>,]<DmaPort>],<DmaName>" << endl;
  cout << "       --connect_memory_trace_memory=<TraceName>[[,<TracePort>,]<MemoryPort>],<MemoryName>" << endl;
  cout << "       --connect_memory_trace_mmio=<TraceName>[,<TracePort>],<MmioName>" << endl;
  cout << "       --connect_memory_trace_router=<TraceName>[,<TracePort>],<RouterName>" << endl;
  cout << "       --connect_memory_trace_slave=<TraceName>[,<TracePort>],<SlaveName>" << endl;
  cout << "       --connect_memory_trace_tlm2pin=<TraceName>[[,<TracePort>],<Tlm2pinPort>],<Tlm2pinName>" << endl;
  cout << "       --connect_mmio_core=<MmioName>[,<OutputName>],<InputName>,<CoreName>" << endl;
  cout << "       --connect_mmio_distributor=<MmioName>,<OutputName>,<InputName>,<DistributorName>" << endl;
  cout << "       --connect_mmio_logic=<MmioName>[,<OutputName>],<InputName>,<LogicName>" << endl;
  cout << "       --connect_mmio_master=<MmioName>,<OutputName>,<MasterName>" << endl;
  cout << "       --connect_mmio_mmio=<SourceName>[,<OutputName>],<InputName>,<SinkName>" << endl;
  cout << "       --connect_mmio_producer=<MmioName>,<OutputName>,<ProducerName>" << endl;
  cout << "       --connect_mmio_proxy=<MmioName>,<OutputName>[,<InputName>],<ProxyName>" << endl;
  cout << "       --connect_mmio_source=<MmioName>,<OutputName>,<SourceName>" << endl;
  cout << "       --connect_mmio_wire=<MmioName>[,<OutputName>],<WireName>" << endl;
  cout << "       --connect_mmio_wrapper=<MmioName>,<MmioOutputName>[,<WrapperOutputName>]" << endl;
  cout << "       --connect_pin2tlm_arbiter=<Pin2tlmName>[,<Pin2tlmPort>],<ArbiterPort>,<ArbiterName>" << endl;
  cout << "       --connect_pin2tlm_cohctrl=<Pin2tlmName>[,<Pin2tlmPort>],<CohctrlPort>,<CohctrlName>" << endl;
  cout << "       --connect_pin2tlm_core=<Pin2tlmName>[,<Pin2tlmPort>],<CoreName>" << endl;
  cout << "       --connect_pin2tlm_memory=<Pin2tlmName>[[,<Pin2tlmPort>],<MemoryPort>],<MemoryName>" << endl;
  cout << "       --connect_pin2tlm_memory_trace=<Pin2tlmName>[[,<Pin2tlmPort>],<TracePort>],<TraceName>" << endl;
  cout << "       --connect_pin2tlm_mmio=<Pin2tlmName>[,<Pin2tlmPort>],<MmioName>" << endl;
  cout << "       --connect_pin2tlm_router=<Pin2tlmName>[,<Pin2tlmPort>],<RouterName>" << endl;
  cout << "       --connect_pin2tlm_slave=<Pin2tlmName>[,<Pin2tlmPort>],<SlaveName>" << endl;
  cout << "       --connect_producer_loader=<ProducerName>,<LoaderName>" << endl;
  cout << "       --connect_producer_proxy=<ProducerName>[,<NamePrefix>],<ProxyName>" << endl;
  cout << "       --connect_producer_wrapper=<ProducerName>,<NamePrefix>" << endl;
  cout << "       --connect_producer_queue=<ProducerName>[,<ProducerPort>],<QueueName>" << endl;
  cout << "       --connect_producer_queue_pin=<ProducerName>,<QueueName>" << endl;
  cout << "       --connect_proxy_cohctrl=<ProxyName>[,<OutputName>],<CohctrlPort>,<CohctrlName>" << endl;
  cout << "       --connect_proxy_consumer=<ProxyName>[,<NamePrefix>],<ConsumerName>" << endl;
  cout << "       --connect_proxy_core=<ProxyName>[,<NamePrefix>],<Interface>,<CoreName>" << endl;
  cout << "       --connect_proxy_loader=<ProxyName>[,<NamePrefix>],<LoaderName>" << endl;
  cout << "       --connect_proxy_logic=<ProxyName>[,<OutputName>],<InputName>,<LogicName>" << endl;
  cout << "       --connect_proxy_lookup_pin=<ProxyName>[,<NamePrefix>],<LookupName>" << endl;
  cout << "       --connect_proxy_memory_pin=<ProxyName>[,<NamePrefix>][,<MemoryPort>],<MemoryName>" << endl;
  cout << "       --connect_proxy_mmio=<ProxyName>[,<OutputName>],<InputName>,<MmioName>" << endl;
  cout << "       --connect_proxy_pin2tlm=<ProxyName>[,<NamePrefix>][,<MemoryPort>],<Pin2tlmName>" << endl;
  cout << "       --connect_proxy_queue_pin=<ProxyName>[,<NamePrefix>],<QueueName>" << endl;
  cout << "       --connect_proxy_wire=<ProxyName>[,<OutputName>],<WireName>" << endl;
  cout << "       --connect_queue_consumer=<QueueName>[,<ConsumerPort>],<ConsumerName>" << endl;
  cout << "       --connect_queue_core=[<QueueName>,][<ConsumerPort>,]<TiePortName>,<CoreName>" << endl;
  cout << "       --connect_queue_pin_consumer=<QueueName>,<ConsumerName>" << endl;
  cout << "       --connect_queue_pin_core=[<QueueName>,]<TiePortName>,<CoreName>" << endl;
  cout << "       --connect_queue_pin_proxy=<QueueName>[,<NamePrefix>],<ProxyName>" << endl;
  cout << "       --connect_queue_pin_wrapper=<QueueName>,<NamePrefix>" << endl;
  cout << "       --connect_router_arbiter=<RouterName>,<RouterPort>,<ArbiterPort>,<ArbiterName>" << endl;
  cout << "       --connect_router_cohctrl=<RouterName>,<RouterPort>[,<CohctrlPort>],<CohctrlName>" << endl;
  cout << "       --connect_router_core=<RouterName>,<RouterPort>[,<PortName>],<CoreName>" << endl;
  cout << "       --connect_router_dma=<RouterName>,<RouterPort>[,<DmaPort>],<DmaName>" << endl;
  cout << "       --connect_router_memory=<RouterName>,<RouterPort>[,<MemoryPort>],<MemoryName>" << endl;
  cout << "       --connect_router_memory_trace=<RouterName>,<RouterPort>[,<TracePort>],<TraceName>" << endl;
  cout << "       --connect_router_mmio=<RouterName>,<RouterPort>,<MmioName>" << endl;
  cout << "       --connect_router_router=<MasterName>,<MasterPort>,<SlaveName>" << endl;
  cout << "       --connect_router_slave=<RouterName>,<RouterPort>,<SlaveName>" << endl;
  cout << "       --connect_router_tlm2pin=<RouterName>,<RouterPort>[,<Tlm2pinPort>],<Tlm2pinName>" << endl;
  cout << "       --connect_signal_core=[<SignalName>,]<InputPinName>,<CoreName>" << endl;
  cout << "       --connect_source_cohctrl=<SourceName>[,<OutputName>],<CohctrlPort>,<CohctrlName>" << endl;
  cout << "       --connect_source_core=[<SourceName>,[<OutputName>,]]<InputName>,<CoreName>" << endl;
  cout << "       --connect_source_distributor=<SourceName>[,<OutputName>],<InputName>,<DistributorName>" << endl;
  cout << "       --connect_source_logic=[<SourceName>,[<OutputName>,]]<InputName>,<LogicName>" << endl;
  cout << "       --connect_source_mmio=[<SourceName>,[<OutputName>,]]<InputName>,<MmioName>" << endl;
  cout << "       --connect_source_proxy=<SourceName>[[,<OutputName>],<PortName>],<ProxyName>" << endl;
  cout << "       --connect_source_signal=<SourceName>[,<OutputName>],<SignalName>" << endl;
  cout << "       --connect_source_wire=<SourceName>[,<OutputName>],<WireName>" << endl;
  cout << "       --connect_source_wrapper=<SourceName>[[,<OutputName>],<WrapperOutputName>]" << endl;
  cout << "       --connect_tlm2pin_memory_pin=<Tlm2pinName>[[,<Tlm2pinPort>],<MemoryPort>],<MemoryName>" << endl;
  cout << "       --connect_tlm2pin_pin2tlm=<Tlm2pinName>[,<Tlm2pinPort>,<Pin2tlmPort>],<Pin2tlmName>" << endl;
  cout << "       --connect_tlm2pin_proxy=<Tlm2pinName>[,<MemoryPort>][,<NamePrefix>],<ProxyName>" << endl;
  cout << "       --connect_tlm2pin_wrapper=<Tlm2pinName>[,<MemoryPort>][,<NamePrefix>]" << endl;
  cout << "       --connect_wire_core=[<WireName>,]<TiePortName>,<CoreName>" << endl;
  cout << "       --connect_wrapper_cohctrl=[<InputName>,]<CohctrlPort>,<CohctrlName>" << endl;
  cout << "       --connect_wrapper_consumer=<NamePrefix>,<ConsumerName>" << endl;
  cout << "       --connect_wrapper_core=[<NamePrefix>,]<Interface>,<CoreName>" << endl;
  cout << "       --connect_wrapper_loader=[<NamePrefix>,]<LoaderName>" << endl;
  cout << "       --connect_wrapper_logic=[<WrapperInputName>,]<LogicInputName>,<LogicName>" << endl;
  cout << "       --connect_wrapper_lookup_pin=<NamePrefix>,<LookupName>" << endl;
  cout << "       --connect_wrapper_memory_pin=[<NamePrefix>,][<MemoryPort>,]<MemoryName>" << endl;
  cout << "       --connect_wrapper_mmio=[<WrapperInputName>,]<MmioInputName>,<MmioName>" << endl;
  cout << "       --connect_wrapper_pin2tlm=[<NamePrefix>,][<MemoryPort>,]<Pin2tlmName>" << endl;
  cout << "       --connect_wrapper_queue_pin=<NamePrefix>,<QueueName>" << endl;
  cout << "       --connect_wrapper_wire=<WrapperInputName>,<WireName>" << endl;
  cout << "  5. Miscellaneous commands: " << endl;
//cout << "       --binary=<LoggingConfigurationFile>" << endl;
  cout << "       --core_args=<ProgramArgsCSV>" << endl;
  cout << "       --core_debug[=[w|WAIT|nowait|n][,synchronized|sync|s|nosynchronized|nosync][,<StartingPort>]]" << endl;
  cout << "       --core_client=<LoadClientCommand>" << endl;
  cout << "       --core_program=[<ProgramName>][,<ProgramName>...]" << endl;
  cout << "       --core_summary" << endl;
  cout << "       --cosim=<TopLanguage>,<Vendor>,<VendorVersion>,<GccVersion>" << endl;
  cout << "       --cycle_limit=<NumCycles>" << endl;
  cout << "       --dir=<DirectoryName>" << endl;
  cout << "       --dump_commands" << endl;
  cout << "       --help" << endl;
  cout << "       --include=<IncludeFileName>" << endl;
  cout << "       --logging=<LoggingConfigurationFile>|off|on|elab_only" << endl;
  cout << "       --manual" << endl;
  cout << "       --memory_pin_port=<PortName>" << endl;
  cout << "       --memory_port=<PortName>" << endl;
  cout << "       --multi_core_debug[=[w|WAIT|nowait|n][,synchronized|sync|s|nosynchronized|nosync][,<StartingPort>]]" << endl;
  cout << "       --multi_core_profile[=TRUE|false]" << endl;
  cout << "       --no_default_mem[=TRUE|false]" << endl;
  cout << "       --no_default_local_mem[=TRUE|false]" << endl;
  cout << "       --no_sim[=TRUE|false]" << endl;
  cout << "       --path=<GeneratedDirectoryParent>" << endl;
  cout << "       --quit" << endl;
  cout << "       --sc_main[=<CppFileName>]" << endl;
  cout << "       --show_modules[=verbose]" << endl;
  cout << "       --squelch_ctor[=off|fatal|error|warn|note|INFO|verbose|debug|trace|all]" << endl;
  cout << "       --string_array_separator=<PrintableCharacter>" << endl;
  cout << "       --summary[=[verbose][,now]]" << endl;
  cout << "       --xxdebug    (See --multi_core_debug)" << endl;
  cout << "       --xxprofile  (See --multi_core_profile)" << endl;
  cout << endl;
  if (!brief) {
  cout << endl;
  cout << "(The commands are fully documented in Section IV below in alphabetical order)" << endl;
  cout << endl;
  cout << "Section III:  XTSC Modules" << endl;
  show_modules(true, true);
  cout << endl;
  cout << "Section IV:  Full Command Documentation" << endl;
  cout << endl;
  cout << "Note: " << endl;
  cout << "<PortName> is one of dram0|dram1|drom0|iram0|iram1|irom0|uram0|xlmi0|PIF." << endl;
  cout << endl;
  cout << "Note: " << endl;
  cout << "In the --set_XXX_parm=<ParmName>=<ParmValue> commands, <ParmValue> is interpreted " << endl;
  cout << "according to the parameter type of <ParmName>:" << endl;
  cout << "  bool               <ParmValue> must be one of 0|f|false|1|t|true (case-insensitive)." << endl;
  cout << "  double             <ParmValue> is converted from a string to a double-precision floating point number." << endl;
  cout << "  u32                <ParmValue> is converted from a string to a 32-bit unsigned integer." << endl;
  cout << "  vector<u32>        <ParmValue> is interpretted as a comma-separated list of numbers," << endl;
  cout << "                     each of which is converted to a 32-bit unsigned integer." << endl;
  cout << "  char*              <ParmValue> is used as is (a null string is allowed)." << endl;
  cout << "  char**             <ParmValue> is interpretted as a comma-separated list of c-strings" << endl;
  cout << "                     (see, the --string_array_separator command)." << endl;
  cout << "  void*              <ParmValue> must match a previously entered <Identifier> (see, for" << endl;
  cout << "                     example, the --create_vcd command)." << endl;
  cout << "If a char* or char** <ParmValue> has any spaces then the command may need to be enclosed in " << endl;
  cout << "quotation marks on the command line.  Quotation marks are not required in an --include file." << endl;
  cout << endl;
  cout << "Note: " << endl;
  cout << "When a command specification has an optional assignment from a list of values, the " << endl;
  cout << "all CAPS value is the value that will be used if the command is found without an" << endl;
  cout << "assignement." << endl;
  cout << endl;
  cout << "Note:" << endl;
  cout << "A tlm2pin transactor (xtsc_tlm2pin_memory_transactor) converts TLM memory requests to" << endl;
  cout << "pin-level request signals and converts pin-level memory response signals to TLM responses." << endl;
  cout << "A pin2tlm transactor (xtsc_pin2tlm_memory_transactor) converts pin-level request signals " << endl;
  cout << "into TLM memory requests and converts TLM responses into pin-level memory response signals." << endl;
  cout << endl;
  cout << "Commands (in alphabetical order): " << endl;
  cout << endl;
#if 0
  cout << "--binary=<LoggingConfigurationFile>" << endl;
  cout << "  Description:" << endl;
  cout << "    Causes <LoggingConfigurationFile> to be passed to xtsc_initialize() to " << endl;
  cout << "    configure the binary logging system.  Only one --binary command is allowed" << endl;
  cout << "    and, if present, it is processed prior to any other command (except --help" << endl;
  cout << "    and --logging)." << endl;
  cout << "  Aliases: --bin  --b" << endl;
  cout << endl;
#endif

// Step 17:  Add a multi-line explanation for each supported --connect_XXX_widget and 
//           --connect_widget_XXX command (maintain alphabetical order)

  cout << "--connect_arbiter_arbiter=<MasterName>,<SlavePort>,<SlaveName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect arbiter <MasterName> to port <SlavePort> of arbiter <SlaveName>." << endl;
  cout << "    If arbiter <MasterName> or arbiter <SlaveName> do not exist, create them." << endl;
  cout << "  Aliases: --arbiter_arbiter " << endl;
  cout << endl;
  cout << "--connect_arbiter_cohctrl=<ArbiterName>[,<CohctrlPort>],<CohctrlName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect arbiter <ArbiterName> to client port <CohctrlPort> of cohctrl <CohctrlName>." << endl;
  cout << "    If arbiter <ArbiterName> or cohctrl <CohctrlName> do not exist, create them." << endl;
  cout << "    Default <CohctrlPort> is the lowest numbered unconnected client port of the cohctrl." << endl;
  cout << "  Aliases: --arbiter_cohctrl" << endl;
  cout << endl;
  cout << "--connect_arbiter_core=<ArbiterName>[,<PortName>],<CoreName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect slave port of arbiter <ArbiterName> to port <PortName> (inbound_pif or " << endl;
  cout << "    snoop) of core <CoreName>.  If arbiter <ArbiterName> or core <CoreName> do not" << endl;
  cout << "    exist, create them." << endl;
  cout << "    Default <PortName> is inbound_pif." << endl;
  cout << "  Aliases: --arbiter_core " << endl;
  cout << endl;
  cout << "--connect_arbiter_dma=<ArbiterName>[,<DmaPort>],<DmaName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect arbiter <ArbiterName> to port <DmaPort> of dma <DmaName>." << endl;
  cout << "    If arbiter <ArbiterName> or dma <DmaName> do not exist, create them." << endl;
  cout << "    Default <DmaPort> is 0." << endl;
  cout << "  Aliases: --arbiter_dma " << endl;
  cout << endl;
  cout << "--connect_arbiter_memory=<ArbiterName>[,<MemoryPort>],<MemoryName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect arbiter <ArbiterName> to port <MemoryPort> of memory <MemoryName>." << endl;
  cout << "    If arbiter <ArbiterName> or memory <MemoryName> do not exist, create them." << endl;
  cout << "    Default <MemoryPort> is 0." << endl;
  cout << "  Aliases: --arbiter_memory " << endl;
  cout << endl;
  cout << "--connect_arbiter_memory_trace=<ArbiterName>[,<TracePort>],<TraceName>" << endl;
  cout << "  Description:" << endl;
  cout << "    Connect the slave port of arbiter <ArbiterName> to master port <TracePort>" << endl;
  cout << "    of memory_trace <TraceName>.  If arbiter <ArbiterName> or memory_trace" << endl;
  cout << "    <TraceName> do not exist, create them." << endl;
  cout << "    Default <TracePort> is 0." << endl;
  cout << "  Aliases: --arbiter_memory_trace" << endl;
  cout << endl;
  cout << "--connect_arbiter_mmio=<ArbiterName>,<MmioName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect arbiter <ArbiterName> to mmio <MmioName>." << endl;
  cout << "    If arbiter <ArbiterName> or mmio <MmioName> do not exist, create them." << endl;
  cout << "  Aliases: --arbiter_mmio " << endl;
  cout << endl;
  cout << "--connect_arbiter_router=<ArbiterName>,<RouterName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect arbiter <ArbiterName> to router <RouterName>.  If" << endl;
  cout << "    arbiter <ArbiterName> or router <RouterName> do not exist, create them." << endl;
  cout << "  Aliases: --arbiter_router " << endl;
  cout << endl;
  cout << "--connect_arbiter_slave=<ArbiterName>,<SlaveName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect arbiter <ArbiterName> to slave <SlaveName>.  If" << endl;
  cout << "    arbiter <ArbiterName> or slave <SlaveName> do not exist, create them." << endl;
  cout << "  Aliases: --arbiter_slave " << endl;
  cout << endl;
  cout << "--connect_arbiter_tlm2pin=<ArbiterName>[,<Tlm2pinPort>],<Tlm2pinName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect arbiter <ArbiterName> to port <Tlm2pinPort> (default 0) of tlm2pin" << endl;
  cout << "    <Tlm2pinName>.  If arbiter <ArbiterName> or tlm2pin <Tlm2pinName> do" << endl;
  cout << "    not exist, create them." << endl;
  cout << "  Aliases: --arbiter_tlm2pin " << endl;
  cout << endl;
  cout << "--connect_clock_proxy=<ClockName>[,<InputName>],<ProxyName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect clock <ClockName> to input <InputName> of Verilog proxy <ProxyName>." << endl;
  cout << "    If clock <ClockName> or proxy <ProxyName> do not exist, create them." << endl;
  cout << "    Default <InputName> is <ClockName>." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --clock_proxy " << endl;
  cout << endl;
  cout << "--connect_clock_wrapper=<ClockName>,<WrapperOutputName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect clock <ClockName> to the current SystemC wrapper using an sc_out<bool>" << endl;
  cout << "    named <WrapperOutputName>.  If clock <ClockName> does not exist, create it." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --clock_wrapper " << endl;
  cout << endl;
  cout << "--connect_cohctrl_arbiter=<CohctrlName>[,<SnoopPort],<ArbiterPort>,<ArbiterName>" << endl;
  cout << "  Description: " << endl;
  cout << "    If <SnoopPort> is not specified, then connect the memory interface of cohctrl" << endl;
  cout << "    <CohctrlName> to port <ArbiterPort> of arbiter <ArbiterName>." << endl;
  cout << "    If <SnoopPort> is specified, then connect the snoop port specified by <SnoopPort>" << endl;
  cout << "    of cohctrl <CohctrlName> to port <ArbiterPort> of arbiter <ArbiterName>." << endl;
  cout << "    If cohctrl <CohctrlName> or arbiter <ArbiterName> do not exist, create them." << endl;
  cout << "  Aliases: --cohctrl_arbiter" << endl;
  cout << endl;
  cout << "--connect_cohctrl_memory=<CohctrlName>[,<MemoryPort>],<MemoryName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect memory interface of cohctrl <CohctrlName> to port <MemoryPort> of" << endl;
  cout << "    memory <MemoryName>.  If cohctrl <CohctrlName> or memory <MemoryName> do" << endl;
  cout << "    not exist, create them." << endl;
  cout << "    Default <MemoryPort> is 0." << endl;
  cout << "  Aliases: --cohctrl_memory" << endl;
  cout << endl;
  cout << "--connect_cohctrl_memory_trace=<CohctrlName>[,<SnoopPort>],<TracePort>,<TraceName>" << endl;
  cout << "  Description:" << endl;
  cout << "    If <SnoopPort> is not specified, then connect the memory interface of cohctrl" << endl;
  cout << "    <CohctrlName> to master port <TracePort> of memory_trace <TraceName>." << endl;
  cout << "    If <SnoopPort> is specified, then connect the snoop port specified by <SnoopPort>" << endl;
  cout << "    of cohctrl <CohctrlName> to master port <TracePort> of memory_trace <TraceName>." << endl;
  cout << "    If cohctrl <CohctrlName> or memory_trace <TraceName> do not exist, create them." << endl;
  cout << "  Aliases: --cohctrl_memory_trace" << endl;
  cout << endl;
  cout << "--connect_cohctrl_router=<CohctrlName>[,<SnoopPort>],<RouterName>" << endl;
  cout << "  Description: " << endl;
  cout << "    If <SnoopPort> is not specified, then connect the memory interface of cohctrl" << endl;
  cout << "    <CohctrlName> to router <RouterName>." << endl;
  cout << "    If <SnoopPort> is specified, then connect the snoop port specified by <SnoopPort>" << endl;
  cout << "    of cohctrl <CohctrlName> to router <RouterName>." << endl;
  cout << "    If cohctrl <CohctrlName> or router <RouterName> do not exist, create them." << endl;
  cout << "  Aliases: --cohctrl_router" << endl;
  cout << endl;
  cout << "--connect_cohctrl_slave=<CohctrlName>[,<SnoopPort>],<SlaveName>" << endl;
  cout << "  Description: " << endl;
  cout << "    If <SnoopPort> is not specified, then connect the memory interface of cohctrl" << endl;
  cout << "    <CohctrlName> to slave <SlaveName>." << endl;
  cout << "    If <SnoopPort> is specified, then connect the snoop port specified by <SnoopPort>" << endl;
  cout << "    of cohctrl <CohctrlName> to slave <SlaveName>." << endl;
  cout << "    If cohctrl <CohctrlName> or slave <SlaveName> do not exist, create them." << endl;
  cout << "  Aliases: --cohctrl_slave" << endl;
  cout << endl;
  cout << "--connect_cohctrl_tlm2pin=<CohctrlName>[,<PortNumber>],<Tlm2pinName>" << endl;
  cout << "  Description: " << endl;
  cout << "    If tlm2pin <Tlm2pinName> is configured for a snoop interface, then connect" << endl;
  cout << "    snoop interface <PortNumber> of cohctrl <CohctrlName> to port 0 of tlm2pin" << endl;
  cout << "    <Tlm2pinName>.  If tlm2pin <Tlm2pinName> is not configured for a snoop interface," << endl;
  cout << "    then connect the memory interface of cohctrl <CohctrlName> to TLM port <PortNumber>" << endl;
  cout << "    of tlm2pin <Tlm2pinName>.  If cohctrl <CohctrlName> or tlm2pin <Tlm2pinName> do" << endl;
  cout << "    not exist, create them." << endl;
  cout << "    Default <PortNumber> is 0." << endl;
  cout << "  Aliases: --cohctrl_tlm2pin" << endl;
  cout << endl;
  cout << "--connect_core_arbiter=<CoreName>[,<PortName>],<ArbiterPort>,<ArbiterName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect core <CoreName> memory port <PortName> to port <ArbiterPort> of " << endl;
  cout << "    arbiter <ArbiterName>.  The default <PortName> is whatever was set by the" << endl;
  cout << "    most recent previous --memory_port command, or PIF if there is no previous" << endl;
  cout << "    --memory_port command.  If core <CoreName> or arbiter <ArbiterName> do not" << endl;
  cout << "    exist, create them." << endl;
  cout << "  Aliases: --core_arbiter " << endl;
  cout << endl;
  cout << "--connect_core_cohctrl=<CoreName>[,<CohctrlPort>],<CohctrlName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect outbound PIF, snoop, and CCON ports of core <CoreName> to client port " << endl;
  cout << "    <CohctrlPort> of cohctrl <CohctrlName>.  If any of the 3 ports (outbound PIF," << endl;
  cout << "    snoop, or CCON) of either the core or the cohctrl has already been connected," << endl;
  cout << "    then just connect the remaining ports or port.  If core <CoreName> or cohctrl" << endl;
  cout << "    <CohctrlName> do not exist, create them." << endl;
  cout << "    Default <CohctrlPort> is the lowest numbered unconnected client port of the cohctrl." << endl;
  cout << "  Aliases: --core_cohctrl" << endl;
  cout << endl;
  cout << "--connect_core_core=<UpstreamTX>,<DownstreamTX>" << endl;
  cout << "  Description: " << endl;
  cout << "    Chain two TX Xtensa cores by connecting the output XFER interface of" << endl;
  cout << "    <UpstreamTX> to the input XFER interface of <DownstreamTX>.  If core" << endl;
  cout << "    <UpstreamTX> or core <DownstreamTX> do not exist, create them." << endl;
  cout << "  Aliases: --core_core" << endl;
  cout << endl;
  cout << "--connect_core_core=<CoreSource>,<OutputName>,<InputName>,<CoreSink>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output wire <OutputName> of core <CoreSource> to input wire" << endl;
  cout << "    <InputName> of core <CoreSink>.  <OutputName> can be either a" << endl;
  cout << "    system-level output or a TIE export state of <CoreSource>." << endl;
  cout << "    <InputName> must be a system-level input of <CoreSink>." << endl;
  cout << "    If core <CoreSource> or core <CoreSink> do not exist, create them." << endl;
  cout << "  Aliases: --core_core" << endl;
  cout << endl;
  cout << "--connect_core_distributor=<CoreName>,<PortNumber>,<DistributorName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect the WMPINT_ADDR, WMPINT_DATA, and WMPINT_TOGGLEEN TIE export states" << endl;
  cout << "    and the RMPINT TIE lookup of core <CoreName> to the corresponding ports of" << endl;
  cout << "    distributor <DistributorName> at port index <PortNumber>.  If core <CoreName>" << endl;
  cout << "    or distributor <DistributorName> do not exist, create them." << endl;
  cout << "  Aliases: --core_distributor" << endl;
  cout << endl;
  cout << "--connect_core_distributor=<CoreName>,<OutputName>,<InputName>,<DistributorName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect system-level output, TIE export state, or TIE lookup <OutputName> of" << endl;
  cout << "    core <CoreName> to input <InputName> of distributor <DistributorName>.  If" << endl;
  cout << "    core <CoreName> or distributor <DistributorName> do not exist, create them." << endl;
  cout << "  Aliases: --core_distributor" << endl;
  cout << endl;
  cout << "--connect_core_logic=<CoreName>,<OutputName>[,<InputName>],<LogicName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output <OutputName> of core <CoreName> to logic <LogicName>." << endl;
  cout << "    <OutputName> can be either an export state or a system-level output." << endl;
  cout << "    If <InputName> is not given, it is assumed to be the same as <OutputName>." << endl;
  cout << "    If core <CoreName> or logic <LogicName> do not exist, create them." << endl;
  cout << "  Aliases: --core_logic " << endl;
  cout << endl;
  cout << "--connect_core_loader=<CoreName>[,<CoreInterface>],<LoaderName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect core <CoreName> to loader <LoaderName>.  <CoreInterface> may be either" << endl;
  cout << "    \"tx_xfer_out\" or the name of a TIE output queue interface.  If <CoreInterface> is" << endl;
  cout << "    \"tx_xfer_out\" then the output XFER interface of core will be connected to the" << endl;
  cout << "    XFER input of the loader and hence the core will be the last core in the TX chain." << endl;
  cout << "    If <CoreInterface> is a TIE output queue then the core will be connected to the" << endl;
  cout << "    optional TLM queue push interface (m_producer) of the loader.  If core <CoreName>" << endl;
  cout << "    or loader <LoaderName> do not exist, create them." << endl;
  cout << "    Default <CoreInterface> is \"tx_xfer_out\"." << endl;
  cout << "  Aliases: --core_loader " << endl;
  cout << endl;
  cout << "--connect_core_lookup=<CoreName>,<TiePortName>[,<LookupName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect core <CoreName> to lookup <LookupName>.  If <LookupName>" << endl;
  cout << "    is not given, it is assumed to be the same as <TiePortName>.  The " << endl;
  cout << "    address and data bit widths of the <LookupName> interface are determined" << endl;
  cout << "    from TIE port lookup of <TiePortName> on core <CoreName>.  If core <CoreName>" << endl;
  cout << "    or lookup <LookupName> do not exist, create them." << endl;
  cout << "  Aliases: --core_lookup " << endl;
  cout << endl;
  cout << "--connect_core_lookup_pin=<CoreName>,<TiePortName>[,<LookupName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect core <CoreName> to lookup_pin <LookupName>.  If <LookupName>" << endl;
  cout << "    is not given, it is assumed to be the same as <TiePortName>.  The " << endl;
  cout << "    address and data bit widths of the <LookupName> interface are determined" << endl;
  cout << "    from TIE port lookup of <TiePortName> on core <CoreName>.  If core <CoreName>" << endl;
  cout << "    or lookup_pin <LookupName> do not exist, create them." << endl;
  cout << "  Aliases: --core_lookup_pin " << endl;
  cout << endl;
  cout << "--connect_core_memory=<CoreName>[,<MemoryPort>],<MemoryName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect core <CoreName> to port <MemoryPort> of memory <MemoryName>.  If core" << endl;
  cout << "    <CoreName> or memory <MemoryName> do not exist, create them.  The memory port" << endl;
  cout << "    of <CoreName> that <MemoryName> is connected to is determined by the " << endl;
  cout << "    --create_memory command used to create memory <MemoryName> and/or the --memory_port " << endl;
  cout << "    command.  If this core memory port is a LD/ST unit 0 port and the core has 2 LD/ST " << endl;
  cout << "    units and no CBox and if <MemoryPort>+1 exists on memory <MemoryName> and is not " << endl;
  cout << "    yet connected, then both LD/ST ports of core <CoreName> will be connected to " << endl;
  cout << "    memory <MemoryName>." << endl;
  cout << "    Default <MemoryPort> is 0." << endl;
  cout << "  Aliases: --core_memory " << endl;
  cout << endl;
  cout << "--connect_core_memory_trace=<CoreName>,<PortName>[,<TracePort>],<TraceName>" << endl;
  cout << "  Description:" << endl;
  cout << "    Connect core <CoreName> memory port <PortName> to master port <TracePort> of " << endl;
  cout << "    memory_trace <TraceName>.  If core <CoreName> or memory_trace <TraceName> do" << endl;
  cout << "    not exist, create them." << endl;
  cout << "    Default <TracePort> is 0." << endl;
  cout << "  Aliases: --core_memory_trace" << endl;
  cout << endl;
  cout << "--connect_core_mmio=<CoreName>[,<MemoryPort>],<MmioName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect core <CoreName> memory port <MemoryPort> to mmio <MmioName>.  The " << endl;
  cout << "    default <MemoryPort> is whatever was set by the most recent previous --memory_port " << endl;
  cout << "    command, or PIF if there is no previous --memory_port command.  If core" << endl;
  cout << "    <CoreName> or mmio <MmioName> do not exist, create them." << endl;
  cout << "  Aliases: --core_mmio " << endl;
  cout << endl;
  cout << "--connect_core_mmio=<CoreName>,<OutputName>[,<InputName>],<MmioName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output <OutputName> of core <CoreName> to mmio <MmioName>." << endl;
  cout << "    <OutputName> can be either an export state or a system-level output." << endl;
  cout << "    If <InputName> is not given, it is assumed to be the same as <OutputName>." << endl;
  cout << "    If core <CoreName> or mmio <MmioName> do not exist, create them." << endl;
  cout << "  Aliases: --core_mmio " << endl;
  cout << endl;
  cout << "--connect_core_proxy=<CoreName>,<Interface>[,<NamePrefix>],<ProxyName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect pin-level TIE output queue, TIE lookup, TIE export state, or system-" << endl;
  cout << "    level output interface <Interface> of core <CoreName> to Verilog proxy" << endl;
  cout << "    <ProxyName>.  <Interface> must have been passed to the " << endl;
  cout << "    --set_core_parm=SimPinLevelInterfaces command.  The proxy port names will" << endl;
  cout << "    be assumed to be the same as the core input/output names with an optional" << endl;
  cout << "    prefix of <NamePrefix>.  If core <CoreName> or proxy <ProxyName> do not" << endl;
  cout << "    exist, create them." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --core_proxy " << endl;
  cout << endl;
  cout << "--connect_core_queue=<CoreName>,<TiePortName>[,<ProducerPort>][,<QueueName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output queue interface <TiePortName> of core <CoreName> to input port" << endl;
  cout << "    <ProducerPort> (default 0) of TLM queue <QueueName>. If <QueueName> is not" << endl;
  cout << "    given, it is assumed to be the same as <TiePortName>. If core <CoreName> or" << endl;
  cout << "    queue <QueueName> do not exist, create them." << endl;
  cout << "  Aliases: --core_queue " << endl;
  cout << endl;
  cout << "--connect_core_queue_pin=<CoreName>,<TiePortName>[,<QueueName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output queue interface <TiePortName> of core <CoreName> to queue_pin." << endl;
  cout << "    <QueueName> If <QueueName> is not given, it is assumed to be the same as." << endl;
  cout << "    <TiePortName> If core <CoreName> or queue <QueueName> do not exist, create them." << endl;
  cout << "  Aliases: --core_queue_pin" << endl;
  cout << endl;
  cout << "--connect_core_router=<CoreName>[,<PortName>],<RouterName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect core <CoreName> memory port <PortName> to router <RouterName>.  The " << endl;
  cout << "    default <PortName> is whatever was set by the most recent previous --memory_port " << endl;
  cout << "    command, or PIF if there is no previous --memory_port command.  If core" << endl;
  cout << "    <CoreName> or router <RouterName> do not exist, create them." << endl;
  cout << "  Aliases: --core_router " << endl;
  cout << endl;
  cout << "--connect_core_signal=<CoreName>,<OutputPinName>[,<SignalName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect TIE or system output pin <OutputPinName> of core <CoreName> to" << endl;
  cout << "    signal <SignalName>.  If <SignalName> is not given, it is assumed to be" << endl;
  cout << "    the same as <OutputPinName>.  If core <CoreName> or signal <SignalName>" << endl;
  cout << "    do not exist, create them.  If <SignalName> does not yet exist, its bit" << endl;
  cout << "    width is determined from looking up <OutputPinName> on core <CoreName>." << endl;
  cout << "    The TIE interface or system-level output corresponding to <OutputPinName>" << endl;
  cout << "    must have been passed to the --set_core_parm=SimPinLevelInterfaces= command." << endl;
  cout << "    If <OutputPinName> is part of a TIE interface name, then the TIE interface" << endl;
  cout << "    name (without the \"TIE_\" prefix) is passed to SimPinLevelInterfaces, but" << endl;
  cout << "    <OutputPinName> itself must be the full pin name (including the \"TIE_\" prefix)." << endl;
  cout << "  Aliases: --core_signal" << endl;
  cout << endl;
  cout << "--connect_core_slave=<CoreName>[,<PortName>],<SlaveName>" << endl;
  cout << "    Connect core <CoreName> memory port <PortName> to slave <SlaveName>.  The " << endl;
  cout << "    default <PortName> is whatever was set by the most recent previous --memory_port " << endl;
  cout << "    command, or PIF if there is no previous --memory_port command.  If core" << endl;
  cout << "    <CoreName> or slave <SlaveName> do not exist, create them." << endl;
  cout << "  Aliases: --core_slave" << endl;
  cout << endl;
  cout << "--connect_core_tlm2pin=<CoreName>[,<PortName>][,<Tlm2pinPort>],<Tlm2pinName>" << endl;
  cout << "    Connect core <CoreName> memory port <PortName> to port <Tlm2pinPort> (default 0)" << endl;
  cout << "    of tlm2pin <Tlm2pinName>.  The default <PortName> is determined by the" << endl;
  cout << "    \"memory_interface\" tlm2pin parameter.  If core <CoreName> or tlm2pin" << endl;
  cout << "    <Tlm2pinName> do not exist, create them." << endl;
  cout << "  Aliases: --core_tlm2pin" << endl;
  cout << endl;
  cout << "--connect_core_wire=<CoreName>,<OutputName>[,<WireName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output <OutputName> of core <CoreName> to TLM wire <WireName>." << endl;
  cout << "    <OutputName> can be either an export state or a system-level output." << endl;
  cout << "    If <WireName> is not given, it is assumed to be the same as <OutputName>." << endl;
  cout << "    If core <CoreName> or wire <WireName> do not exist, create them." << endl;
  cout << "  Aliases: --core_wire " << endl;
  cout << endl;
  cout << "--connect_core_wrapper=<CoreName>,<Interface>[,<NamePrefix>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect pin-level TIE output queue, TIE lookup, TIE export state, or system-" << endl;
  cout << "    level output interface <Interface> of core <CoreName> to the current SystemC" << endl;
  cout << "    wrapper.  If core <CoreName> does not exist, create it.  <Interface> must have" << endl;
  cout << "    been passed to the --set_core_parm=SimPinLevelInterfaces command.  If <NamePrefix>" << endl;
  cout << "    is not specified then the wrapper port names will match the port names of the" << endl;
  cout << "    RTL as specified in the Xtensa Microprocessor Data Book.  If <NamePrefix> is" << endl;
  cout << "    specified then the wrapper port names will include a prefix of <NamePrefix>.  For" << endl;
  cout << "    example, if you have a TIE output queue named OUTQ1 (e.g. \"queue OUTQ1 96 out\"" << endl;
  cout << "    appears in the user TIE code) then the following commands:" << endl;
  cout << "      --set_core_parm=SimPinLevelInterfaces=OUTQ1 ... --connect_core_wrapper=core0,OUTQ1" << endl;
  cout << "    will cause code to be generated which uses the following adapter and wrapper" << endl;
  cout << "    port names: " << endl;
  cout << "      adapter name                 wrapper port name" << endl;
  cout << "      --------------------------   -----------------" << endl;
  cout << "      TIE_OUTQ1_adapter            TIE_OUTQ1" << endl;
  cout << "      TIE_OUTQ1_PushReq_adapter    TIE_OUTQ1_PushReq" << endl;
  cout << "      TIE_OUTQ1_Full_adapter       TIE_OUTQ1_Full" << endl;
  cout << "    On the other hand," << endl;
  cout << "      --set_core_parm=SimPinLevelInterfaces=OUTQ1 ... --connect_core_wrapper=core0,OUTQ1,p0_" << endl;
  cout << "    will cause code to be generated which uses the following adapter and wrapper" << endl;
  cout << "    port names: " << endl;
  cout << "      adapter name                 wrapper port name" << endl;
  cout << "      --------------------------   -----------------" << endl;
  cout << "      p0_TIE_OUTQ1_adapter         p0_TIE_OUTQ1" << endl;
  cout << "      p0_TIE_OUTQ1_PushReq_adapter p0_TIE_OUTQ1_PushReq" << endl;
  cout << "      p0_TIE_OUTQ1_Full_adapter    p0_TIE_OUTQ1_Full" << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --core_wrapper " << endl;
  cout << endl;
  cout << "--connect_distributor_core=<DistributorName>,<PortNumber>[,<InputName>],<CoreName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect PROCINT port <PortNumber> of distributor <DistributorName> to system-level" << endl;
  cout << "    input <InputName> of core <CoreName>.  <PortNumber> must be in the range of 0 to" << endl;
  cout << "    \"num_ports\" minus 1.  The default <InputName> is BInterrupt.  If distributor" << endl;
  cout << "    <DistributorName> or core <CoreName> do not exist, create them." << endl;
  cout << "  Aliases: --distributor_core" << endl;
  cout << endl;
  cout << "--connect_distributor_logic=<DistributorName>,<OutputName>,<InputName>,<LogicName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output <OutputName> of distributor <DistributorName> to input <InputName>" << endl;
  cout << "    of logic <LogicName>.  If distributor <DistributorName> or logic <LogicName> do" << endl;
  cout << "    not exist, create them." << endl;
  cout << "  Aliases: --distributor_logic" << endl;
  cout << endl;
  cout << "--connect_distributor_mmio=<DistributorName>,<OutputName>,<InputName>,<MmioName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output <OutputName> of distributor <DistributorName> to input <InputName>" << endl;
  cout << "    of mmio <MmioName>.  If distributor <DistributorName> or mmio <MmioName> do" << endl;
  cout << "    not exist, create them." << endl;
  cout << "  Aliases: --distributor_mmio" << endl;
  cout << endl;
  cout << "--connect_distributor_wire=<DistributorName>,<OutputName>,<WireName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output <OutputName> of distributor <DistributorName> to wire <WireName>." << endl;
  cout << "    If distributor <DistributorName> or wire <WireName> do not exist, create them." << endl;
  cout << "  Aliases: --distributor_wire" << endl;
  cout << endl;
  cout << "--connect_dma_router=<DmaName>,<RouterName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect dma <DmaName> to router <RouterName>.  If" << endl;
  cout << "    dma <DmaName> or router <RouterName> do not exist, create them." << endl;
  cout << "  Aliases: --dma_router " << endl;
  cout << endl;
  cout << "--connect_dma_arbiter=<DmaName>,<ArbiterPort>,<ArbiterName>" << endl;
  cout << "  Description:" << endl;
  cout << "    Connect the master port of dma <DmaName> to slave port <ArbiterPort>" << endl;
  cout << "    of arbiter <ArbiterName>.  If dma <DmaName> or arbiter" << endl;
  cout << "    <ArbiterName> do not exist, create them." << endl;
  cout << "  Aliases: --dma_arbiter" << endl;
  cout << endl;
  cout << "--connect_dma_memory=<DmaName>[,<MemoryPort>],<MemoryName>" << endl;
  cout << "  Description:" << endl;
  cout << "    Connect the master port of dma <DmaName> to slave port <MemoryPort>" << endl;
  cout << "    of memory <MemoryName>.  If dma <DmaName> or memory" << endl;
  cout << "    <MemoryName> do not exist, create them." << endl;
  cout << "    Default <MemoryPort> is 0." << endl;
  cout << "  Aliases: --dma_memory" << endl;
  cout << endl;
  cout << "--connect_dma_memory_trace=<DmaName>[,<TracePort>],<TraceName>" << endl;
  cout << "  Description:" << endl;
  cout << "    Connect the master port of dma <DmaName> to slave port <TracePort>" << endl;
  cout << "    of memory_trace <TraceName>.  If dma <DmaName> or memory_trace" << endl;
  cout << "    <TraceName> do not exist, create them." << endl;
  cout << "    Default <TracePort> is 0." << endl;
  cout << "  Aliases: --dma_memory_trace" << endl;
  cout << endl;
  cout << "--connect_driver_distributor=<DriverName>,<LookupName>,<DistributorName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect driver <DriverName> to lookup <LookupName> of distributor" << endl;
  cout << "    <DistributorName>.  If driver <DriverName> or distributor <DistributorName>" << endl;
  cout << "    do not exist, create them." << endl;
  cout << "  Aliases: --driver_distributor" << endl;
  cout << endl;
  cout << "--connect_driver_lookup=<DriverName>,<LookupName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect driver <DriverName> to the input of TLM lookup <LookupName>." << endl;
  cout << "    If driver <DriverName> or lookup <LookupName> do not exist, create them." << endl;
  cout << "  Aliases: --driver_lookup" << endl;
  cout << endl;
  cout << "--connect_driver_lookup_pin=<DriverName>,<LookupName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect driver <DriverName> to the input of lookup_pin <LookupName>." << endl;
  cout << "    If driver <DriverName> or lookup_pin <LookupName> do not exist, create them." << endl;
  cout << "  Aliases: --driver_lookup_pin" << endl;
  cout << endl;
  cout << "--connect_driver_proxy=<DriverName>[,<NamePrefix>],<ProxyName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect pin-level driver <DriverName> to Verilog proxy <ProxyName>.  If driver" << endl;
  cout << "    <DriverName> or proxy <ProxyName> do not exist, create them.  <NamePrefix> is" << endl;
  cout << "    used in determining the names of the proxy ports as well as the sc_signal and" << endl;
  cout << "    adapter objects used to connect the driver to the proxy.  The proxy port" << endl;
  cout << "    names will be assumed to be <NamePrefix> plus a suffix of \"_Out\", \"_Out_Req\"," << endl;
  cout << "    \"_In\", and \"_Rdy\".  The sc_signal object names will be the same as the proxy" << endl;
  cout << "    port names plus an additional  prefix of \"<DriverName>_\".  The default" << endl;
  cout << "    <NamePrefix> is \"TIE_<ModuleName>\", where <ModuleName> is from the \"module_name\"" << endl;
  cout << "    parameter of proxy <ProxyName>.  The adapter name will be the same as the signal" << endl;
  cout << "    name plus a suffix of \"_adapter\".  For example," << endl;
  cout << "     --set_proxy_parm=module_name=lut  --create_proxy=lookup  --connect_driver_proxy=dvr,lookup " << endl;
  cout << "    will cause code to be generated which uses the following sc_signal names, adapter" << endl;
  cout << "    names, and proxy port names: " << endl;
  cout << "      sc_signal name        adapter name                  proxy port name" << endl;
  cout << "      -------------------   ---------------------------   ---------------" << endl;
  cout << "      dvr_TIE_lut_Out       dvr_TIE_lut_Out_adapter       TIE_lut_Out" << endl;
  cout << "      dvr_TIE_lut_Out_Req   dvr_TIE_lut_Out_Req_adapter   TIE_lut_Out_Req" << endl;
  cout << "      dvr_TIE_lut_In        dvr_TIE_lut_In_adapter        TIE_lut_In" << endl;
  cout << "    and if driver <DriverName> has a ready signal: " << endl;
  cout << "      dvr_TIE_lut_Rdy       dvr_TIE_lut_Rdy_adapter       TIE_lut_Rdy" << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --driver_proxy " << endl;
  cout << endl;
  cout << "--connect_driver_wrapper=<DriverName>,<NamePrefix>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect pin-level driver <DriverName> to the current SystemC wrapper.  If driver" << endl;
  cout << "    <DriverName> does not exist, create it.  <NamePrefix> is used in determining the" << endl;
  cout << "    names of the wrapper ports as well as the adapter objects used to connect the" << endl;
  cout << "    driver to the wrapper.  The wrapper port names will be <NamePrefix> plus a suffix" << endl;
  cout << "    of \"_Out\", \"_Out_Req\", \"_In\", and \"_Rdy\".  The adapter names will be the" << endl;
  cout << "    same as the wrapper port names plus a suffix of \"_adapter\".  For example," << endl;
  cout << "       --connect_driver_wrapper=dvr,TIE_lut" << endl;
  cout << "    will cause code to be generated which uses the following adapter and wrapper" << endl;
  cout << "    port names: " << endl;
  cout << "      adapter name              wrapper port name" << endl;
  cout << "      -----------------------   -----------------" << endl;
  cout << "      TIE_lut_Out_adapter       TIE_lut_Out" << endl;
  cout << "      TIE_lut_Out_Req_adapter   TIE_lut_Out_Req" << endl;
  cout << "      TIE_lut_In_adapter        TIE_lut_In" << endl;
  cout << "      TIE_lut_Rdy_adapter       TIE_lut_Rdy (if 'drv' has a ready signal)" << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --driver_wrapper " << endl;
  cout << endl;
  cout << "--connect_loader_consumer=<LoaderName>,<ConsumerName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect the optional queue pop interface (m_consumer) of loader <LoaderName>" << endl;
  cout << "    to consumer <ConsumerName>.  If consumer <ConsumerName> or loader <LoaderName>" << endl;
  cout << "    do not exist, create them.  <LoaderName> and <ConsumerName> must have the same" << endl;
  cout << "    setting for their respective \"pin_level\" parameter." << endl;
  cout << "  Aliases: --loader_consumer " << endl;
  cout << endl;
  cout << "--connect_loader_core=<LoaderName>[,<CoreInterface>],<CoreName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect loader <LoaderName> to core <CoreName>.  <CoreInterface> may be either" << endl;
  cout << "    \"tx_xfer_in\" or the name of a TIE input queue interface.  If <CoreInterface> is" << endl;
  cout << "    \"tx_xfer_in\" then the XFER output of the loader will be connected to the input XFER " << endl;
  cout << "    interface of core and hence the core will be the first core in the TX chain.  If" << endl;
  cout << "    <CoreInterface> is a TIE input queue interface of core then the optional TLM queue" << endl;
  cout << "    pop interface (m_consumer) of the loader will be connected to the core. If core" << endl;
  cout << "    <CoreName> or loader <LoaderName> do not exist, create them." << endl;
  cout << "    Default <CoreInterface> is \"tx_xfer_in\"." << endl;
  cout << "  Aliases: --loader_core " << endl;
  cout << endl;
  cout << "--connect_loader_logic=<LoaderName>,<OutputName>[,<InputName>],<LogicName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect TLM wire write output <OutputName> of loader <LoaderName> to input <InputName> of" << endl;
  cout << "    logic <LogicName>.  If <InputName> is not specified, it is assumed to be the same as" << endl;
  cout << "    <OutputName>.  If <LoaderName> or logic <LogicName> do not exist, create them." << endl;
  cout << "  Aliases: --loader_logic " << endl;
  cout << endl;
  cout << "--connect_loader_wire=<LoaderName>[,<OutputName>],<WireName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect TLM wire write output <OutputName> of loader <LoaderName> to wire <WireName>." << endl;
  cout << "    If <OutputName> is not specified, it is assumed to be the same as <WireName>.  If" << endl;
  cout << "    <LoaderName> or wire <WireName> do not exist, create them." << endl;
  cout << "  Aliases: --loader_wire " << endl;
  cout << endl;
  cout << "--connect_logic_cohctrl=<LogicName>,<OutputName>,<CohctrlPort>,<CohctrlName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output <OutputName> of logic <LogicName> to m_ccon_exports port <CohctrlPort>" << endl;
  cout << "    of cohctrl <CohctrlName>.  If logic <LogicName> or cohctrl <CohctrlName> do not" << endl;
  cout << "    exist, create them." << endl;
  cout << "  Aliases: --logic_cohctrl " << endl;
  cout << endl;
  cout << "--connect_logic_core=<LogicName>[,<OutputName>],<InputName>,<CoreName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect logic <LogicName> to system-level input <InputName> of core " << endl;
  cout << "    <CoreName>.  If <OutputName> is not given, it is assumed to be the same" << endl;
  cout << "    as <InputName>.  If logic <LogicName> or core <CoreName> do not exist," << endl;
  cout << "    create them." << endl;
  cout << "  Aliases: --logic_core " << endl;
  cout << endl;
  cout << "--connect_logic_distributor=<LogicName>,<OutputName>,<InputName>,<DistributorName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output <OutputName> of logic <LogicName> to input <InputName> of" << endl;
  cout << "    distributor <DistributorName>.  If logic <LogicName> or distributor" << endl;
  cout << "    <DistributorName> do not exist, create them." << endl;
  cout << "  Aliases: --logic_distributor" << endl;
  cout << endl;
  cout << "--connect_logic_logic=<SourceName>,<OutputName>[,<InputName>],<SinkName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output port <OutputName> of logic <SourceName> to input port" << endl;
  cout << "    <InputName> of logic <SinkName>.  If <InputName> is not given it defaults" << endl;
  cout << "    to <OutputName>.  If logic <SourceName> or logic <SinkName> do not exist," << endl;
  cout << "    create them." << endl;
  cout << "  Aliases: --logic_mmio " << endl;
  cout << endl;
  cout << "--connect_logic_master=<LogicName>,<OutputName>,<MasterName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output port <OutputName> of logic <LogicName> to the control input" << endl;
  cout << "    of master <MasterName> (whose \"control\" parameter must be true).  If logic" << endl;
  cout << "    <LogicName> or master <MasterName> do not exist, create them." << endl;
  cout << "  Aliases: --logic_master " << endl;
  cout << endl;
  cout << "--connect_logic_mmio=<LogicName>,<OutputName>[,<InputName>],<MmioName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output port <OutputName> of logic <LogicName> to input port" << endl;
  cout << "    <InputName> of mmio <MmioName>.  If <InputName> is not given it defaults" << endl;
  cout << "    to <OutputName>.  If logic <LogicName> or mmio <MmioName> do not exist," << endl;
  cout << "    create them." << endl;
  cout << "  Aliases: --logic_mmio " << endl;
  cout << endl;
  cout << "--connect_logic_producer=<LogicName>,<OutputName>,<ProducerName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output port <OutputName> of logic <LogicName> to the control input" << endl;
  cout << "    of producer <ProducerName> (whose \"control\" parameter must be true).  If logic" << endl;
  cout << "    <LogicName> or producer <ProducerName> do not exist, create them." << endl;
  cout << "  Aliases: --logic_producer " << endl;
  cout << endl;
  cout << "--connect_logic_proxy=<LogicName>,<OutputName>[,<InputName>],<ProxyName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output port <OutputName> of logic <LogicName> to input port" << endl;
  cout << "    <InputName> of Verilog proxy <ProxyName>.  If <InputName> is not given it" << endl;
  cout << "    defaults to <OutputName>.  If logic <LogicName> or proxy <ProxyName> do not" << endl;
  cout << "    exist, create them." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --logic_proxy " << endl;
  cout << endl;
  cout << "--connect_logic_source=<LogicName>,<OutputName>,<SourceName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output port <OutputName> of logic <LogicName> to the control input" << endl;
  cout << "    of source <SourceName> (whose \"control\" parameter must be true).  If logic" << endl;
  cout << "    <LogicName> or source <SourceName> do not exist, create them." << endl;
  cout << "  Aliases: --logic_source " << endl;
  cout << endl;
  cout << "--connect_logic_wire=<LogicName>[,<OutputName>],<WireName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output <OutputName> of logic <LogicName> to wire <WireName>." << endl;
  cout << "    If <OutputName> is not given, it is assumed to be the same as <WireName>." << endl;
  cout << "    If <LogicName> or wire <WireName> do not exist, create them." << endl;
  cout << "  Aliases: --logic_wire " << endl;
  cout << endl;
  cout << "--connect_logic_wrapper=<LogicName>,<LogicOutputName>[,<WrapperOutputName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output port <LogicOutputName> of logic <LogicName> to output port" << endl;
  cout << "    <WrapperOutputName> of the current SystemC wrapper.  If <WrapperOutputName>" << endl;
  cout << "    is not given it defaults to <LogicOutputName>.  If logic <LogicName> does not" << endl;
  cout << "    exist, create it." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --logic_wrapper " << endl;
  cout << endl;
  cout << "--connect_master_arbiter=<MasterName>,<ArbiterPort>,<ArbiterName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect master <MasterName> to port <ArbiterPort> of arbiter <ArbiterName>." << endl;
  cout << "    If master <MasterName> or arbiter <ArbiterName> do not exist, create them." << endl;
  cout << "  Aliases: --master_arbiter " << endl;
  cout << endl;
  cout << "--connect_master_cohctrl=<MasterName>[,<CohctrlPort>],<CohctrlName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect master <MasterName> to client port <CohctrlPort> of cohctrl <CohctrlName>." << endl;
  cout << "    If master <MasterName> or cohctrl <CohctrlName> do not exist, create them." << endl;
  cout << "    Default <CohctrlPort> is the lowest numbered unconnected client port of the cohctrl." << endl;
  cout << "  Aliases: --master_cohctrl" << endl;
  cout << endl;
  cout << "--connect_master_core=<MasterName>[,<PortName>],<CoreName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect master <MasterName> to port <PortName> (inbound_pif or snoop) of core <CoreName>." << endl;
  cout << "    If master <MasterName> or core <CoreName> do not exist, create them." << endl;
  cout << "    Default <PortName> is inbound_pif." << endl;
  cout << "  Aliases: --master_core " << endl;
  cout << endl;
  cout << "--connect_master_dma=<MasterName>[,<DmaPort>],<DmaName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect master <MasterName> to slave port <DmaPort> of dma <DmaName>.  If " << endl;
  cout << "    master <MasterName> or dma <DmaName> do not exist, create them." << endl;
  cout << "    Default <DmaPort> is 0." << endl;
  cout << "  Aliases: --master_dma " << endl;
  cout << endl;
  cout << "--connect_master_memory=<MasterName>[,<MemoryPort>],<MemoryName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect master <MasterName> to port <MemoryPort> of memory <MemoryName>.  If " << endl;
  cout << "    master <MasterName> or memory <MemoryName> do not exist, create them." << endl;
  cout << "    Default <MemoryPort> is 0." << endl;
  cout << "  Aliases: --master_memory " << endl;
  cout << endl;
  cout << "--connect_master_memory_trace=<MasterName>[,<TracePort>],<TraceName>" << endl;
  cout << "  Description:" << endl;
  cout << "    Connect master <MasterName> to port <TracePort> of memory_trace <TraceName>.  If " << endl;
  cout << "    master <MasterName> or memory_trace <TraceName> do not exist, create them." << endl;
  cout << "    Default <TracePort> is 0." << endl;
  cout << "  Aliases: --master_memory_trace" << endl;
  cout << endl;
  cout << "--connect_master_mmio=<MasterName>,<MmioName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect master <MasterName> to mmio <MmioName>.  If master" << endl;
  cout << "    <MasterName> or mmio <MmioName> do not exist, create them." << endl;
  cout << "  Aliases: --master_mmio " << endl;
  cout << endl;
  cout << "--connect_master_router=<MasterName>,<RouterName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect master <MasterName> to router <RouterName>.  If master" << endl;
  cout << "    <MasterName> or router <RouterName> do not exist, create them." << endl;
  cout << "  Aliases: --master_router " << endl;
  cout << endl;
  cout << "--connect_master_slave=<MasterName>,<SlaveName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect master <MasterName> to slave <SlaveName>.  If master" << endl;
  cout << "    <MasterName> or slave <SlaveName> do not exist, create them." << endl;
  cout << "  Aliases: --master_slave " << endl;
  cout << endl;
  cout << "--connect_master_tlm2pin=<MasterName>[,<Tlm2pinPort>],<Tlm2pinName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect master <MasterName> to port <Tlm2pinPort> (default 0) of tlm2pin" << endl;
  cout << "    <Tlm2pinName>.  If master <MasterName> or tlm2pin <Tlm2pinName> do" << endl;
  cout << "    not exist, create them." << endl;
  cout << "  Aliases: --master_tlm2pin " << endl;
  cout << endl;
  cout << "--connect_memory_trace_arbiter=<TraceName>[,<TracePort>],<ArbiterPort>,<ArbiterName>" << endl;
  cout << "  Description:" << endl;
  cout << "    Connect slave port <TracePort> of memory_trace <TraceName> to master port " << endl;
  cout << "    <ArbiterPort> of arbiter <ArbiterName>.  If memory_trace <TraceName>" << endl;
  cout << "    or arbiter <ArbiterName> do not exist, create them." << endl;
  cout << "    Default <TracePort> is 0." << endl;
  cout << "  Aliases: --memory_trace_arbiter" << endl;
  cout << endl;
  cout << "--connect_memory_trace_cohctrl=<TraceName>[[,<TracePort>],<CohctrlPort>],<CohctrlName>" << endl;
  cout << "  Description:" << endl;
  cout << "    Connect slave port <TracePort> of memory_trace <TraceName> to client port <CohctrlPort> of" << endl;
  cout << "    cohctrl <CohctrlName>.  If memory_trace <TraceName> or cohctrl <CohctrlName> do" << endl;
  cout << "    not exist, create them." << endl;
  cout << "    Default <TracePort> is 0." << endl;
  cout << "    Default <CohctrlPort> is the lowest numbered unconnected client port of the cohctrl." << endl;
  cout << "  Aliases: --memory_trace_cohctrl" << endl;
  cout << endl;
  cout << "--connect_memory_trace_core=<TraceName>[[,<TracePort>],<PortName>],<CoreName>" << endl;
  cout << "  Description:" << endl;
  cout << "    Connect slave port <TracePort> of memory_trace <TraceName> to port <PortName>" << endl;
  cout << "    (inbound_pif or snoop) of core <CoreName>.  If memory_trace <TraceName> or core" << endl;
  cout << "    <CoreName> do not exist, create them." << endl;
  cout << "    Default <TracePort> is 0." << endl;
  cout << "    Default <PortName> is inbound_pif." << endl;
  cout << "  Aliases: --memory_trace_core" << endl;
  cout << endl;
  cout << "--connect_memory_trace_dma=<TraceName>[[,<TracePort>,]<DmaPort>],<DmaName>" << endl;
  cout << "  Description:" << endl;
  cout << "    Connect master port <TracePort> (default 0) of memory_trace <TraceName> to " << endl;
  cout << "    slave port <DmaPort> (default 0) of dma <DmaName>.  If both <TraceName> " << endl;
  cout << "    and <DmaName> have contiguous, higher-number, unconnected ports, they" << endl;
  cout << "    will also be connected.  If memory_trace <TraceName> or dma <DmaName>" << endl;
  cout << "    do not exist, create them." << endl;
  cout << "  Aliases: --memory_trace_dma" << endl;
  cout << endl;
  cout << "--connect_memory_trace_memory=<TraceName>[[,<TracePort>,]<MemoryPort>],<MemoryName>" << endl;
  cout << "  Description:" << endl;
  cout << "    Connect slave port <TracePort> (default 0) of memory_trace <TraceName> to " << endl;
  cout << "    port <MemoryPort> (default 0) of memory <MemoryName>.  If both <TraceName> " << endl;
  cout << "    and <MemoryName> have contiguous, higher-number, unconnected ports, they" << endl;
  cout << "    will also be connected.  If memory_trace <TraceName> or memory <MemoryName>" << endl;
  cout << "    do not exist, create them." << endl;
  cout << "  Aliases: --memory_trace_memory" << endl;
  cout << endl;
  cout << "--connect_memory_trace_mmio=<TraceName>[,<TracePort>],<MmioName>" << endl;
  cout << "  Description:" << endl;
  cout << "    Connect slave port <TracePort> of memory_trace <TraceName> to mmio" << endl;
  cout << "    <MmioName>.  If memory_trace <TraceName> or mmio <MmioName> do not " << endl;
  cout << "    exist, create them." << endl;
  cout << "    Default <TracePort> is 0." << endl;
  cout << "  Aliases: --memory_trace_mmio" << endl;
  cout << endl;
  cout << "--connect_memory_trace_router=<TraceName>[,<TracePort>],<RouterName>" << endl;
  cout << "  Description:" << endl;
  cout << "    Connect slave port <TracePort> of memory_trace <TraceName> to the master port" << endl;
  cout << "    of router <RouterName>.  If memory_trace <TraceName> or router <RouterName> " << endl;
  cout << "    do not exist, create them." << endl;
  cout << "    Default <TracePort> is 0." << endl;
  cout << "  Aliases: --memory_trace_router" << endl;
  cout << endl;
  cout << "--connect_memory_trace_slave=<TraceName>[,<TracePort>],<SlaveName>" << endl;
  cout << "  Description:" << endl;
  cout << "    Connect slave port <TracePort> of memory_trace <TraceName> to slave" << endl;
  cout << "    <SlaveName>.  If memory_trace <TraceName> or slave <SlaveName> do not " << endl;
  cout << "    exist, create them." << endl;
  cout << "    Default <TracePort> is 0." << endl;
  cout << "  Aliases: --memory_trace_slave" << endl;
  cout << endl;
  cout << "--connect_memory_trace_tlm2pin=<TraceName>[[,<TracePort>],<Tlm2pinPort>],<Tlm2pinName>" << endl;
  cout << "  Description:" << endl;
  cout << "    Connect slave port <TracePort> (default 0) of memory_trace <TraceName> to TLM" << endl;
  cout << "    port <Tlm2pinPort> (default 0) of tlm2pin <Tlm2pinName>.  If both <TraceName> " << endl;
  cout << "    and <Tlm2pinName> have contiguous, higher-number, unconnected ports, they" << endl;
  cout << "    will also be connected.  If memory_trace <TraceName> or tlm2pin <Tlm2pinName>" << endl;
  cout << "    do not exist, create them." << endl;
  cout << "  Aliases: --memory_trace_tlm2pin" << endl;
  cout << endl;
  cout << "--connect_mmio_core=<MmioName>[,<OutputName>],<InputName>,<CoreName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect mmio <MmioName> to system-level input <InputName> of core " << endl;
  cout << "    <CoreName>.  If <OutputName> is not given, it is assumed to be the same" << endl;
  cout << "    as <InputName>.  If mmio <MmioName> or core <CoreName> do not exist," << endl;
  cout << "    create them." << endl;
  cout << "  Aliases: --mmio_core " << endl;
  cout << endl;
  cout << "--connect_mmio_distributor=<MmioName>,<OutputName>,<InputName>,<DistributorName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output <OutputName> of mmio <MmioName> to input <InputName> of" << endl;
  cout << "    distributor <DistributorName>.  If mmio <MmioName> or distributor" << endl;
  cout << "    <DistributorName> do not exist, create them." << endl;
  cout << "  Aliases: --mmio_distributor" << endl;
  cout << endl;
  cout << "--connect_mmio_logic=<MmioName>,<OutputName>[,<InputName>],<LogicName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output port <OutputName> of mmio <MmioName> to input port" << endl;
  cout << "    <InputName> of logic <LogicName>.  If <InputName> is not given it" << endl;
  cout << "    defaults to <OutputName>.  If mmio <MmioName> or logic <LogicName> do not" << endl;
  cout << "    exist, create them." << endl;
  cout << "  Aliases: --mmio_logic " << endl;
  cout << endl;
  cout << "--connect_mmio_master=<MmioName>,<OutputName>,<MasterName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output port <OutputName> of mmio <MmioName> to the control input" << endl;
  cout << "    of master <MasterName> (whose \"control\" parameter must be true).  If mmio" << endl;
  cout << "    <MmioName> or master <MasterName> do not exist, create them." << endl;
  cout << "  Aliases: --mmio_master " << endl;
  cout << endl;
  cout << "--connect_mmio_mmio=<SourceName>,<OutputName>[,<InputName>],<SinkName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output port <OutputName> of mmio <SourceName> to input port" << endl;
  cout << "    <InputName> of mmio <SinkName>.  If <InputName> is not given it" << endl;
  cout << "    defaults to <OutputName>.  If mmio <SourceName> or mmio <SinkName> do not" << endl;
  cout << "    exist, create them." << endl;
  cout << "  Aliases: --mmio_mmio " << endl;
  cout << endl;
  cout << "--connect_mmio_producer=<MmioName>,<OutputName>,<ProducerName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output port <OutputName> of mmio <MmioName> to the control input" << endl;
  cout << "    of producer <ProducerName> (whose \"control\" parameter must be true).  If mmio" << endl;
  cout << "    <MmioName> or producer <ProducerName> do not exist, create them." << endl;
  cout << "  Aliases: --mmio_producer " << endl;
  cout << endl;
  cout << "--connect_mmio_proxy=<MmioName>,<OutputName>[,<InputName>],<ProxyName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output port <OutputName> of mmio <MmioName> to input port" << endl;
  cout << "    <InputName> of Verilog proxy <ProxyName>.  If <InputName> is not given it" << endl;
  cout << "    defaults to <OutputName>.  If mmio <MmioName> or proxy <ProxyName> do not" << endl;
  cout << "    exist, create them." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --mmio_proxy " << endl;
  cout << endl;
  cout << "--connect_mmio_source=<MmioName>,<OutputName>,<SourceName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output port <OutputName> of mmio <MmioName> to the control input" << endl;
  cout << "    of source <SourceName> (whose \"control\" parameter must be true).  If mmio" << endl;
  cout << "    <MmioName> or source <SourceName> do not exist, create them." << endl;
  cout << "  Aliases: --mmio_source " << endl;
  cout << endl;
  cout << "--connect_mmio_wire=<MmioName>[,<OutputName>],<WireName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output <OutputName> of mmio <MmioName> to wire <WireName>." << endl;
  cout << "    If <OutputName> is not given, it is assumed to be the same as <WireName>." << endl;
  cout << "    If <MmioName> or wire <WireName> do not exist, create them." << endl;
  cout << "  Aliases: --mmio_wire " << endl;
  cout << endl;
  cout << "--connect_mmio_wrapper=<MmioName>,<MmioOutputName>[,<WrapperOutputName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output port <MmioOutputName> of mmio <MmioName> to output port" << endl;
  cout << "    <WrapperOutputName> of the current SystemC wrapper.  If <WrapperOutputName>" << endl;
  cout << "    is not given it defaults to <MmioOutputName>.  If mmio <MmioName> does not" << endl;
  cout << "    exist, create it." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --mmio_wrapper " << endl;
  cout << endl;
  cout << "--connect_pin2tlm_arbiter=<Pin2tlmName>[,<Pin2tlmPort>],<ArbiterPort>,<ArbiterName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect port <Pin2tlmPort> (default 0) of pin2tlm <Pin2tlmName> to port " << endl;
  cout << "    <ArbiterPort> of arbiter <ArbiterName>.  If pin2tlm <Pin2tlmName>" << endl;
  cout << "    or arbiter <ArbiterName> do not exist, create them." << endl;
  cout << "  Aliases: --pin2tlm_arbiter " << endl;
  cout << endl;
  cout << "--connect_pin2tlm_cohctrl=<Pin2tlmName>[,<Pin2tlmPort>],<CohctrlPort>,<CohctrlName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect port <Pin2tlmPort> (default 0) of pin2tlm <Pin2tlmName> to port " << endl;
  cout << "    <CohctrlPort> of cohctrl <CohctrlName>.  If pin2tlm <Pin2tlmName>" << endl;
  cout << "    or cohctrl <CohctrlName> do not exist, create them." << endl;
  cout << "  Aliases: --pin2tlm_cohctrl " << endl;
  cout << endl;
  cout << "--connect_pin2tlm_core=<Pin2tlmName>[,<Pin2tlmPort>],<CoreName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect port <Pin2tlmPort> (default 0) of pin2tlm <Pin2tlmName> to inbound " << endl;
  cout << "    PIF (if pin2tlm \"inbound_pif\" is true) or snoop port (if pin2tlm \"snoop\"" << endl;
  cout << "    is true) of core <CoreName>.  If pin2tlm <Pin2tlmName> or core <CoreName> do" << endl;
  cout << "    not exist, create them." << endl;
  cout << "  Aliases: --pin2tlm_core " << endl;
  cout << endl;
  cout << "--connect_pin2tlm_memory=<Pin2tlmName>[[,<Pin2tlmPort>],<MemoryPort>],<MemoryName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect port <Pin2tlmPort> (default 0) of pin2tlm <Pin2tlmName> to port " << endl;
  cout << "    <MemoryPort> (default 0) of memory <MemoryName>.  If both <Pin2tlmName> " << endl;
  cout << "    and <MemoryName> have contiguous, higher-number, unconnected ports, they" << endl;
  cout << "    will also be connected.  If pin2tlm <Pin2tlmName> or memory <MemoryName>" << endl;
  cout << "    do not exist, create them." << endl;
  cout << "  Aliases: --pin2tlm_memory " << endl;
  cout << endl;
  cout << "--connect_pin2tlm_memory_trace=<Pin2tlmName>[[,<Pin2tlmPort>],<TracePort>],<TraceName>" << endl;
  cout << "  Description:" << endl;
  cout << "    Connect port <Pin2tlmPort> (default 0) of pin2tlm <Pin2tlmName> to port " << endl;
  cout << "    <TracePort> (default 0) of memory_trace <TraceName>.  If both <Pin2tlmName> " << endl;
  cout << "    and <TraceName> have contiguous, higher-number, unconnected ports, they" << endl;
  cout << "    will also be connected.  If pin2tlm <Pin2tlmName> or memory_trace <TraceName>" << endl;
  cout << "    do not exist, create them." << endl;
  cout << "  Aliases: --pin2tlm_memory_trace" << endl;
  cout << endl;
  cout << "--connect_pin2tlm_mmio=<Pin2tlmName>[,<Pin2tlmPort>],<MmioName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect port <Pin2tlmPort> (default 0) of pin2tlm <Pin2tlmName> to mmio " << endl;
  cout << "    <MmioName>.  If pin2tlm <Pin2tlmName> or mmio <MmioName> do not exist," << endl;
  cout << "    create them." << endl;
  cout << "  Aliases: --pin2tlm_mmio " << endl;
  cout << endl;
  cout << "--connect_pin2tlm_router=<Pin2tlmName>[,<Pin2tlmPort>],<RouterName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect port <Pin2tlmPort> (default 0) of pin2tlm <Pin2tlmName> to " << endl;
  cout << "    router <RouterName>.  If pin2tlm <Pin2tlmName> or router <RouterName> " << endl;
  cout << "    do not exist, create them." << endl;
  cout << "  Aliases: --pin2tlm_router " << endl;
  cout << endl;
  cout << "--connect_pin2tlm_slave=<Pin2tlmName>[,<Pin2tlmPort>],<SlaveName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect port <Pin2tlmPort> (default 0) of pin2tlm <Pin2tlmName> to " << endl;
  cout << "    slave <SlaveName>.  If pin2tlm <Pin2tlmName> or slave <SlaveName> " << endl;
  cout << "    do not exist, create them." << endl;
  cout << "  Aliases: --pin2tlm_slave " << endl;
  cout << endl;
  cout << "--connect_producer_loader=<ProducerName>,<LoaderName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect producer <ProducerName> to the optional queue input interface of loader" << endl;
  cout << "    <LoaderName>.   If producer <ProducerName> or loader <LoaderName> do not" << endl;
  cout << "    exist, create them.  <ProducerName> and <LoaderName> must have the same" << endl;
  cout << "    setting for their respective \"pin_level\" parameter." << endl;
  cout << "  Aliases: --producer_loader " << endl;
  cout << endl;
  cout << "--connect_producer_proxy=<ProducerName>[,<NamePrefix>],<ProxyName>" << endl;
  cout << "    Connect pin-level producer <ProducerName> to Verilog proxy <ProxyName>.  If producer" << endl;
  cout << "    <ProducerName> or proxy <ProxyName> do not exist, create them.  <NamePrefix>" << endl;
  cout << "    is used in determining the names of the proxy ports as well as the sc_signal and" << endl;
  cout << "    adapter objects used to connect the producer to the proxy.  The proxy port" << endl;
  cout << "    names will be assumed to be <NamePrefix> plus a suffix of \"\" (for the signal" << endl;
  cout << "    containing the push data), \"_PushReq\", and \"_Full\".  The sc_signal object" << endl;
  cout << "    names will be the same as the proxy port names plus an additional prefix of" << endl;
  cout << "    \"<ProducerName>_\".  The default <NamePrefix> is \"TIE_<ModuleName>\"," << endl;
  cout << "    where <ModuleName> is from the \"module_name\" parameter of proxy <ProxyName>." << endl;
  cout << "    The adapter name will be the same as the signal name plus a suffix of" << endl;
  cout << "    \"_adapter\".  For example," << endl;
  cout << "     --set_proxy_parm=module_name=OPQ  --create_proxy=q  --connect_producer_proxy=prod,q " << endl;
  cout << "    will cause code to be generated which uses the following sc_signal names, " << endl;
  cout << "    adapter names, and proxy port names: " << endl;
  cout << "      sc_signal name         adapter name                   proxy port name" << endl;
  cout << "      --------------------   -----------------------------  ---------------" << endl;
  cout << "      prod_TIE_OPQ           prod_TIE_OPQ_adapter           TIE_OPQ" << endl;
  cout << "      prod_TIE_OPQ_PushReq   prod_TIE_OPQ_PushReq_adapter   TIE_OPQ_PushReq" << endl;
  cout << "      prod_TIE_OPQ_Full      prod_TIE_OPQ_Full_adapter      TIE_OPQ_Full" << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --producer_proxy " << endl;
  cout << endl;
  cout << "--connect_producer_wrapper=<ProducerName>,<NamePrefix>" << endl;
  cout << "    Connect pin-level producer <ProducerName> to the current SystemC wrapper.  If" << endl;
  cout << "    producer <ProducerName> does not exist, create it.  <NamePrefix> is used in" << endl;
  cout << "    determining the names of the wrapper ports as well as the adapter objects" << endl;
  cout << "    used to connect the producer to the wrapper.  The wrapper port names will be" << endl;
  cout << "    <NamePrefix> plus a suffix of \"\" (i.e. there is no suffix for the port" << endl;
  cout << "    carrying the push data), \"_PushReq\", and \"_Full\".  The adapter names" << endl;
  cout << "    will be the same as the wrapper port names plus a suffix of \"_adapter\"." << endl;
  cout << "    For example," << endl;
  cout << "      --connect_producer_wrapper=prod,TIE_OPQ " << endl;
  cout << "    will cause code to be generated which uses the following adapter and wrapper" << endl;
  cout << "    port names: " << endl;
  cout << "      adapter name             wrapper port name" << endl;
  cout << "      -----------------------  -----------------" << endl;
  cout << "      TIE_OPQ_adapter          TIE_OPQ" << endl;
  cout << "      TIE_OPQ_PushReq_adapter  TIE_OPQ_PushReq" << endl;
  cout << "      TIE_OPQ_Full_adapter     TIE_OPQ_Full" << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --producer_wrapper " << endl;
  cout << endl;
  cout << "--connect_producer_queue=<ProducerName>[,<ProducerPort>],<QueueName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect producer <ProducerName> to input port <ProducerPort> (default 0) of" << endl;
  cout << "    TLM queue <QueueName>.  If producer <ProducerName> or queue <QueueName> do" << endl;
  cout << "    not exist, create them." << endl;
  cout << "  Aliases: --producer_queue " << endl;
  cout << endl;
  cout << "--connect_producer_queue_pin=<ProducerName>,<QueueName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect producer <ProducerName> to the input of queue_pin <QueueName>. If" << endl;
  cout << "    producer <ProducerName> or queue_pin <QueueName> do not exist, create them." << endl;
  cout << "  Aliases: --producer_queue_pin" << endl;
  cout << endl;
  cout << "--connect_proxy_cohctrl=<ProxyName>[,<OutputName>],<CohctrlPort>,<CohctrlName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output <OutputName> of Verilog proxy <ProxyName> to " << endl;
  cout << "    m_ccon_exports[<CohctrlPort>] of cohctrl <CohctrlName>.  If proxy <ProxyName>" << endl;
  cout << "    or cohctrl <CohctrlName> do not exist, create them.  The default <OutputName>" << endl;
  cout << "    is \"TIE_CCON\"" << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --proxy_cohctrl " << endl;
  cout << endl;
  cout << "--connect_proxy_consumer=<ProxyName>[,<NamePrefix>],<ConsumerName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect Verilog proxy <ProxyName> to consumer <ConsumerName>.  If proxy" << endl;
  cout << "    <ProxyName> or consumer <ConsumerName> do not exist, create them.  <NamePrefix>" << endl;
  cout << "    is used in determining the names of the proxy ports as well as the sc_signal and" << endl;
  cout << "    adapter objects used to connect the proxy to the consumer.  The proxy port" << endl;
  cout << "    names will be assumed to be <NamePrefix> plus a suffix of \"\" (for the signal" << endl;
  cout << "    containing the pop data), \"_PopReq\", and \"_Empty\".  The sc_signal object" << endl;
  cout << "    names will be the same as the proxy port names plus an additional prefix of" << endl;
  cout << "    \"<ConsumerName>_\".  The default <NamePrefix> is \"TIE_<ModuleName>\"," << endl;
  cout << "    where <ModuleName> is from the \"module_name\" parameter of proxy <ProxyName>." << endl;
  cout << "    The adapter name will be the same as the signal name plus a suffix of" << endl;
  cout << "    \"_adapter\".  For example," << endl;
  cout << "     --set_proxy_parm=module_name=IPQ  --create_proxy=q  --connect_proxy_consumer=con,q " << endl;
  cout << "    will cause code to be generated which uses the following sc_signal names, " << endl;
  cout << "    adapter names, and proxy port names: " << endl;
  cout << "      sc_signal name       adapter name                 proxy port name" << endl;
  cout << "      ------------------   ---------------------------  ---------------" << endl;
  cout << "      con_TIE_IPQ          con_TIE_IPQ_adapter          TIE_IPQ" << endl;
  cout << "      con_TIE_IPQ_PopReq   con_TIE_IPQ_PopReq_adapter   TIE_IPQ_PopReq" << endl;
  cout << "      con_TIE_IPQ_Empty    con_TIE_IPQ_Empty_adapter    TIE_IPQ_Empty" << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --proxy_consumer " << endl;
  cout << endl;
  cout << "--connect_proxy_core=<ProxyName>[,<NamePrefix>],<Interface>,<CoreName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect Verilog proxy <ProxyName> to pin-level TIE input queue, TIE import wire," << endl;
  cout << "    or system-level input interface <Interface> of core <CoreName>.  <Interface> must" << endl;
  cout << "    have been passed to the --set_core_parm=SimPinLevelInterfaces command.  The proxy port" << endl;
  cout << "    names will be assumed to be the same as the core input/output names with an" << endl;
  cout << "    optional prefix of <NamePrefix>.  If proxy <ProxyName> or core <CoreName> do" << endl;
  cout << "    not exist, create them." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --proxy_core " << endl;
  cout << endl;
  cout << "--connect_proxy_loader=<ProxyName>[,<NamePrefix>],<LoaderName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect Verilog proxy <ProxyName> to pin-level loader <LoaderName>.  All unconnected" << endl;
  cout << "    non-tx_xfer interfaces will be connected.  Typically, this is the command input queue of" << endl;
  cout << "    the loader, the read output queue of the loader, and the Mode and Done outputs of the" << endl;
  cout << "    loader.  <NamePrefix> is used in determining the names of the proxy ports as well as" << endl;
  cout << "    the sc_signal and adapter objects used to connect the proxy to the loader.  If proxy" << endl;
  cout << "    <ProxyName> or loader <LoaderName> do not exist, create them." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --proxy_loader " << endl;
  cout << endl;
  cout << "--connect_proxy_logic=<ProxyName>[,<OutputName>],<InputName>,<LogicName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output port <OutputName> of Verilog proxy <ProxyName> to input port" << endl;
  cout << "    <InputName> of logic <LogicName>.  If <OutputName> is not given it defaults to" << endl;
  cout << "    <InputName>.  If proxy <ProxyName> or logic <LogicName> do not exist, create them." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --proxy_logic " << endl;
  cout << endl;
  cout << "--connect_proxy_lookup_pin=<ProxyName>[,<NamePrefix>],<LookupName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect Verilog proxy <ProxyName> to lookup <LookupName>.  If proxy" << endl;
  cout << "    <ProxyName> or lookup <LookupName> do not exist, create them.  <NamePrefix>" << endl;
  cout << "    is used in determining the names of the proxy ports as well as the sc_signal and" << endl;
  cout << "    adapter objects used to connect the proxy to the lookup.  The proxy port" << endl;
  cout << "    names will be assumed to be <NamePrefix> plus a suffix of \"_Out\", \"_Out_Req\", " << endl;
  cout << "    \"_In\", and \"_Rdy\".  The sc_signal object names will be the same as the proxy" << endl;
  cout << "    port names plus an additional prefix of \"<LookupName>_\".  The default <NamePrefix>" << endl;
  cout << "    is \"TIE_<ModuleName>\", where <ModuleName> is from the \"module_name\" parameter of" << endl;
  cout << "    proxy <ProxyName>.  The adapter name will be the same as the signal name plus a" << endl;
  cout << "    suffix of \"_adapter\".  For example," << endl;
  cout << "     --set_proxy_parm=module_name=lut  --create_proxy=driver  --connect_proxy_lookup_pin=driver,lu " << endl;
  cout << "    will cause code to be generated which uses the following sc_signal names, " << endl;
  cout << "    adapter names, and proxy port names: " << endl;
  cout << "      sc_signal name       adapter name                 proxy port name" << endl;
  cout << "      ------------------   --------------------------   ---------------" << endl;
  cout << "      lu_TIE_lut_Out       lu_TIE_lut_Out_adapter       TIE_lut_Out" << endl;
  cout << "      lu_TIE_lut_Out_Req   lu_TIE_lut_Out_Req_adapter   TIE_lut_Out_Req" << endl;
  cout << "      lu_TIE_lut_In        lu_TIE_lut_In_adapter        TIE_lut_In" << endl;
  cout << "      lu_TIE_lut_Rdy       lu_TIE_lut_Rdy_adapter       TIE_lut_Rdy (if 'lu' has a ready signal)" << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --proxy_lookup " << endl;
  cout << endl;
  cout << "--connect_proxy_memory_pin=<ProxyName>[,<NamePrefix>][,<MemoryPort>],<MemoryName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect Verilog proxy <ProxyName> to port <MemoryPort> of memory_pin <MemoryName>" << endl;
  cout << "    (this also connects all higher numbered ports of the memory_pin that are both" << endl;
  cout << "    contiguously numbered and unconnected).  If proxy <ProxyName> or memory_pin" << endl;
  cout << "    <MemoryName> do not exist, create them.  <NamePrefix> will be used for the proxy" << endl;
  cout << "    port names only (not the sc_signal and adapter objects)." << endl;
  cout << "    Default <NamePrefix> is \"\"." << endl;
  cout << "    Default <MemoryPort> is 0." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --proxy_memory_pin " << endl;
  cout << endl;
  cout << "--connect_proxy_mmio=<ProxyName>[,<OutputName>],<InputName>,<MmioName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output port <OutputName> of Verilog proxy <ProxyName> to input port" << endl;
  cout << "    <InputName> of mmio <MmioName>.  If <OutputName> is not given it defaults to" << endl;
  cout << "    <InputName>.  If proxy <ProxyName> or mmio <MmioName> do not exist, create them." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --proxy_mmio " << endl;
  cout << endl;
  cout << "--connect_proxy_pin2tlm=<ProxyName>[,<NamePrefix>][,<MemoryPort>],<Pin2tlmName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect Verilog proxy <ProxyName> to port <MemoryPort> of pin2tlm <Pin2tlmName>" << endl;
  cout << "    (this also connects all higher numbered ports of the pin2tlm that are both" << endl;
  cout << "    contiguously numbered and unconnected).  If proxy <ProxyName> or pin2tlm" << endl;
  cout << "    <Pin2tlmName> do not exist, create them.  <NamePrefix> will be used for the" << endl;
  cout << "    proxy port names only (not the sc_signal and adapter objects)." << endl;
  cout << "    Default <NamePrefix> is \"\"." << endl;
  cout << "    Default <MemoryPort> is 0." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --proxy_pin2tlm " << endl;
  cout << endl;
  cout << "--connect_proxy_queue_pin=<ProxyName>[,<NamePrefix>],<QueueName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect Verilog proxy <ProxyName> to queue_pin <QueueName>.  If proxy" << endl;
  cout << "    <ProxyName> or queue_pin <QueueName> do not exist, create them.  <NamePrefix>" << endl;
  cout << "    is used in determining the names of the proxy ports as well as the sc_signal and" << endl;
  cout << "    adapter objects used to connect the proxy to the queue_pin.  The proxy port" << endl;
  cout << "    names will be assumed to be <NamePrefix> plus a suffix of \"\" (i.e. there is no" << endl;
  cout << "    suffix for the port carrying the push data), \"_PushReq\", and \"_Full\".  The" << endl;
  cout << "    sc_signal object names will be the same as the proxy port names plus an additional" << endl;
  cout << "    prefix of \"<QueueName>_\".  The default <NamePrefix> is \"TIE_<ModuleName>\"," << endl;
  cout << "    where <ModuleName> is from the \"module_name\" parameter of proxy <ProxyName>." << endl;
  cout << "    The adapter name will be the same as the signal name plus a suffix of" << endl;
  cout << "    \"_adapter\".  For example," << endl;
  cout << "     --set_proxy_parm=module_name=IPQ  --create_proxy=pro  --connect_proxy_queue_pin=pro,q " << endl;
  cout << "    will cause code to be generated which uses the following sc_signal names, " << endl;
  cout << "    adapter names, and proxy port names: " << endl;
  cout << "      sc_signal name       adapter name                 proxy port name" << endl;
  cout << "      ------------------   --------------------------   ---------------" << endl;
  cout << "      q_TIE_IPQ            q_TIE_IPQ_adapter            TIE_IPQ" << endl;
  cout << "      q_TIE_IPQ_PushReq    q_TIE_IPQ_PushReq_adapter    TIE_IPQ_PushReq" << endl;
  cout << "      q_TIE_IPQ_Full       q_TIE_IPQ_Full_adapter       TIE_IPQ_Full" << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --proxy_queue_pin " << endl;
  cout << endl;
  cout << "--connect_proxy_wire=<ProxyName>[,<OutputName>],<WireName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output port <OutputName> of Verilog proxy <ProxyName> to wire <WireName>." << endl;
  cout << "    If <OutputName> is not given it defaults to <WireName>.  If proxy <ProxyName> or" << endl;
  cout << "    wire <WireName> do not exist, create them." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --proxy_wire " << endl;
  cout << endl;
  cout << "--connect_queue_consumer=<QueueName>[,<ConsumerPort>],<ConsumerName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output port <ConsumerPort> (default 0) of TLM queue <QueueName> to" << endl;
  cout << "    consumer <ConsumerName>.  If queue <QueueName> or consumer <ConsumerName>" << endl;
  cout << "    do not exist, create them." << endl;
  cout << "  Aliases: --queue_consumer" << endl;
  cout << endl;
  cout << "--connect_queue_core=[<QueueName>,][<ConsumerPort>,]<TiePortName>,<CoreName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output port <ConsumerPort> (default 0) of TLM queue <QueueName> to" << endl;
  cout << "    input queue interface <TiePortName> of core <CoreName>. If <QueueName> is" << endl;
  cout << "    not given, it is assumed to be the same as <TiePortName>. If queue <QueueName>" << endl;
  cout << "    or core <CoreName> do not exist, create them." << endl;
  cout << "  Aliases: --queue_core " << endl;
  cout << endl;
  cout << "--connect_queue_pin_consumer=<QueueName>,<ConsumerName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect queue_pin <QueueName> output to consumer <ConsumerName>.  If" << endl;
  cout << "    queue <QueueName> or consumer <ConsumerName> do not exist, create them." << endl;
  cout << "  Aliases: --queue_pin_consumer" << endl;
  cout << endl;
  cout << "--connect_queue_pin_core=[<QueueName>,]<TiePortName>,<CoreName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect queue_pin <QueueName> to input queue interface <TiePortName> of core" << endl;
  cout << "    <CoreName>. If <QueueName> is not given, it is assumed to be the same as" << endl;
  cout << "    <TiePortName>. If queue_pin <QueueName> or core <CoreName> do not exist, create them." << endl;
  cout << "  Aliases: --queue_pin_core" << endl;
  cout << endl;
  cout << "--connect_queue_pin_proxy=<QueueName>[,<NamePrefix>],<ProxyName>" << endl;
  cout << "    Connect pin-level queue_pin <QueueName> to Verilog proxy <ProxyName>.  If queue_pin" << endl;
  cout << "    <QueueName> or proxy <ProxyName> do not exist, create them.  <NamePrefix>" << endl;
  cout << "    is used in determining the names of the proxy ports as well as the sc_signal and" << endl;
  cout << "    adapter objects used to connect the queue_pin to the proxy.  The proxy port" << endl;
  cout << "    names will be assumed to be <NamePrefix> plus a suffix of \"\" (for the signal" << endl;
  cout << "    containing the pop data), \"_PopReq\", and \"_Empty\".  The sc_signal object" << endl;
  cout << "    names will be the same as the proxy port names plus an additional prefix of" << endl;
  cout << "    \"<QueueName>_\".  The default <NamePrefix> is \"TIE_<ModuleName>\"," << endl;
  cout << "    where <ModuleName> is from the \"module_name\" parameter of proxy <ProxyName>." << endl;
  cout << "    The adapter name will be the same as the signal name plus a suffix of" << endl;
  cout << "    \"_adapter\".  For example," << endl;
  cout << "     --set_proxy_parm=module_name=IPQ  --create_proxy=c  --connect_queue_pin_proxy=q,c " << endl;
  cout << "    will cause code to be generated which uses the following sc_signal names, " << endl;
  cout << "    adapter names, and proxy port names: " << endl;
  cout << "      sc_signal name      adapter name                proxy port name" << endl;
  cout << "      -----------------   -------------------------   ---------------" << endl;
  cout << "      q_TIE_IPQ           q_TIE_IPQ_adapter           TIE_IPQ" << endl;
  cout << "      q_TIE_IPQ_PopReq    q_TIE_IPQ_PopReq_adapter    TIE_IPQ_PopReq" << endl;
  cout << "      q_TIE_IPQ_Empty     q_TIE_IPQ_Empty_adapter     TIE_IPQ_Empty" << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --queue_pin_proxy " << endl;
  cout << endl;
  cout << "--connect_queue_pin_wrapper=<QueueName>,<NamePrefix>" << endl;
  cout << "    Connect the pop interface of pin-level queue_pin <QueueName> to the current" << endl;
  cout << "    SystemC wrapper.  If queue_pin <QueueName> does not exist, create it." << endl;
  cout << "    <NamePrefix> is used in determining the names of the wrapper ports as well" << endl;
  cout << "    as the adapter objects used to connect the queue_pin to the wrapper." << endl;
  cout << "    The wrapper port names will be <NamePrefix> plus a suffix of \"\" (i.e. there" << endl;
  cout << "    is no suffix for the port carrying the pop data), \"_PopReq\", and \"_Empty\"." << endl;
  cout << "    The adapter names will be the same as the wrapper port names plus a suffix" << endl;
  cout << "    of \"_adapter\".  For example," << endl;
  cout << "      --connect_queue_pin_wrapper=ipq,TIE_IPQ " << endl;
  cout << "    will cause code to be generated which uses the following adapter and wrapper" << endl;
  cout << "    port names: " << endl;
  cout << "      adapter name             wrapper port name" << endl;
  cout << "      -----------------------  -----------------" << endl;
  cout << "      TIE_IPQ_adapter          TIE_IPQ" << endl;
  cout << "      TIE_IPQ_PopReq_adapter   TIE_IPQ_PopReq" << endl;
  cout << "      TIE_IPQ_Empty_adapter    TIE_IPQ_Empty" << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --queue_pin_wrapper " << endl;
  cout << endl;
  cout << "--connect_router_arbiter=<RouterName>,<RouterPort>,<ArbiterPort>,<ArbiterName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect port <RouterPort> of router <RouterName> to port " << endl;
  cout << "    <ArbiterPort> of arbiter <ArbiterName>.  If router <RouterName>" << endl;
  cout << "    or arbiter <ArbiterName> do not exist, create them." << endl;
  cout << "  Aliases: --router_arbiter " << endl;
  cout << endl;
  cout << "--connect_router_cohctrl=<RouterName>,<RouterPort>[,<CohctrlPort>],<CohctrlName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect port <RouterPort> of router <RouterName> to client port <CohctrlPort> of" << endl;
  cout << "    cohctrl <CohctrlName>.  If router <RouterName> or cohctrl <CohctrlName> do" << endl;
  cout << "    not exist, create them." << endl;
  cout << "    Default <CohctrlPort> is the lowest numbered unconnected client port of the cohctrl." << endl;
  cout << "  Aliases: --router_cohctrl" << endl;
  cout << endl;
  cout << "--connect_router_core=<RouterName>,<RouterPort>[,<PortName>],<CoreName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect port <RouterPort> of router <RouterName> to port <PortName> (inbound_pif" << endl;
  cout << "    or snoop) of core <CoreName>.  If router <RouterName> or core <CoreName> do" << endl;
  cout << "    not exist, create them." << endl;
  cout << "    Default <PortName> is inbound_pif." << endl;
  cout << "  Aliases: --router_core " << endl;
  cout << endl;
  cout << "--connect_router_dma=<RouterName>,<RouterPort>[,<DmaPort>],<DmaName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect master port <RouterPort> of router <RouterName> to slave port <DmaPort>" << endl;
  cout << "    of  dma <DmaName>.  If router <RouterName> or dma <DmaName> do not exist," << endl;
  cout << "    create them." << endl;
  cout << "    Default <DmaPort> is 0." << endl;
  cout << "  Aliases: --router_dma " << endl;
  cout << endl;
  cout << "--connect_router_memory=<RouterName>,<RouterPort>[,<MemoryPort>],<MemoryName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect port <RouterPort> of router <RouterName> to port <MemoryPort> of " << endl;
  cout << "    memory <MemoryName>.  If router <RouterName> or memory <MemoryName> " << endl;
  cout << "    do not exist, create them." << endl;
  cout << "    Default <MemoryPort> is 0." << endl;
  cout << "  Aliases: --router_memory " << endl;
  cout << endl;
  cout << "--connect_router_memory_trace=<RouterName>,<RouterPort>[,<TracePort>],<TraceName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect slave port <RouterPort> of router <RouterName> to master port <TracePort>" << endl;
  cout << "    of memory <TraceName>.  If router <RouterName> or memory <TraceName> do not" << endl;
  cout << "    exist, create them." << endl;
  cout << "    Default <TracePort> is 0." << endl;
  cout << "  Aliases: --router_memory_trace" << endl;
  cout << endl;
  cout << "--connect_router_mmio=<RouterName>,<RouterPort>,<MmioName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect port <RouterPort> of router <RouterName> to mmio " << endl;
  cout << "    <MmioName>.  If router <RouterName> or mmio <MmioName> " << endl;
  cout << "    do not exist, create them." << endl;
  cout << "  Aliases: --router_mmio " << endl;
  cout << endl;
  cout << "--connect_router_router=<MasterName>,<MasterPort>,<SlaveName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect port <MasterPort> of router <MasterName> to router " << endl;
  cout << "    <SlaveName>.  If router <MasterName> or router <SlaveName> " << endl;
  cout << "    do not exist, create them." << endl;
  cout << "  Aliases: --router_router " << endl;
  cout << endl;
  cout << "--connect_router_slave=<RouterName>,<RouterPort>,<SlaveName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect port <RouterPort> of router <RouterName> to slave " << endl;
  cout << "    <SlaveName>.  If router <RouterName> or slave <SlaveName> " << endl;
  cout << "    do not exist, create them." << endl;
  cout << "  Aliases: --router_slave " << endl;
  cout << endl;
  cout << "--connect_router_tlm2pin=<RouterName>,<RouterPort>[,<Tlm2pinPort>],<Tlm2pinName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect port <RouterPort> of router <RouterName> to port <Tlm2pinPort>" << endl;
  cout << "    (default 0) of tlm2pin <Tlm2pinName>.  If router <RouterName> or" << endl;
  cout << "    tlm2pin <Tlm2pinName> do not exist, create them." << endl;
  cout << "  Aliases: --router_tlm2pin " << endl;
  cout << endl;
  cout << "--connect_signal_core=[<SignalName>,]<InputPinName>,<CoreName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect signal <SignalName> to TIE or system input pin <InputPinName>" << endl;
  cout << "    of core <CoreName>.  If <SignalName> is not given, it is assumed to be" << endl;
  cout << "    the same as <InputPinName>.  If core <CoreName> or signal <SignalName>" << endl;
  cout << "    do not exist, create them.  If <SignalName> does not yet exist, its bit" << endl;
  cout << "    width is determined from looking up <InputPinName> on core <CoreName>." << endl;
  cout << "    The TIE interface or system-level input corresponding to <InputPinName>" << endl;
  cout << "    must have been passed to the --set_core_parm=SimPinLevelInterfaces= command." << endl;
  cout << "    If <InputPinName> is part of a TIE interface name, then the TIE interface" << endl;
  cout << "    name (without the \"TIE_\" prefix) is passed to SimPinLevelInterfaces, but" << endl;
  cout << "    <InputPinName> itself must be the full pin name (including the \"TIE_\" prefix)." << endl;
  cout << "  Aliases: --core_signal" << endl;
  cout << endl;
  cout << "--connect_source_cohctrl=<SourceName>[,<OutputName>],<CohctrlPort>,<CohctrlName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output <OutputName> of source <SourceName> to m_ccon_exports port <CohctrlPort>" << endl;
  cout << "    of cohctrl <CohctrlName>.  If <OutputName> is not specified, it is assumed to be the" << endl;
  cout << "    first/only output of the source.  If source <SourceName> or cohctrl <CohctrlName>" << endl;
  cout << "    do not exist, create them." << endl;
  cout << "  Aliases: --source_cohctrl " << endl;
  cout << endl;
  cout << "--connect_source_core=[<SourceName>,[<OutputName>,]]<InputName>,<CoreName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect TLM output <OutputName> of source <SourceName> to a TLM system-level input" << endl;
  cout << "    <InputName> of core <CoreName>.  If <SourceName> is not given, it is assumed to be" << endl;
  cout << "    the same as <InputName>.  If <OutputName> is not specified, it is assumed to be the" << endl;
  cout << "    first/only output of the source.  If source <SourceName> or core <CoreName> do not" << endl;
  cout << "    exist, create them." << endl;
  cout << "  Aliases: --source_core " << endl;
  cout << endl;
  cout << "--connect_source_distributor=<SourceName>[,<OutputName>],<InputName>,<DistributorName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect output <OutputName> of source <SourceName> to input <InputName> of" << endl;
  cout << "    distributor <DistributorName>.  If <OutputName> is not specified, it is" << endl;
  cout << "    assumed to be the first/only output of the source.  If source <SourceName>" << endl;
  cout << "    or distributor <DistributorName> do not exist, create them." << endl;
  cout << "  Aliases: --source_distributor" << endl;
  cout << endl;
  cout << "--connect_source_logic=[<SourceName>,[<OutputName>,]]<InputName>,<LogicName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect TLM output <OutputName> of source <SourceName> to input <InputName> of" << endl;
  cout << "    logic <LogicName>.  If <SourceName> is not given, it is assumed to be the same" << endl;
  cout << "    as <InputName>.  If <OutputName> is not specified, it is assumed to be the first/" << endl;
  cout << "    only output of the source.  If source <SourceName> or logic <LogicName> do not" << endl;
  cout << "    exist, create them." << endl;
  cout << "  Aliases: --source_logic " << endl;
  cout << endl;
  cout << "--connect_source_mmio=[<SourceName>,[<OutputName>,]]<InputName>,<MmioName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect TLM output <OutputName> of source <SourceName> to input <InputName> of" << endl;
  cout << "    mmio <MmioName>.  If <SourceName> is not given, it is assumed to be the same as" << endl;
  cout << "    <InputName>.  If <OutputName> is not specified, it is assumed to be the first/" << endl;
  cout << "    only output of the source.  If source <SourceName> or mmio <MmioName> do not" << endl;
  cout << "    exist, create them." << endl;
  cout << "  Aliases: --source_mmio " << endl;
  cout << endl;
  cout << "--connect_source_proxy=<SourceName>[[,<OutputName>],<PortName>],<ProxyName>" << endl;
  cout << "    Connect pin-level output <OutputName> of source <SourceName> to port <PortName>" << endl;
  cout << "    of Verilog proxy <ProxyName>.  If <OutputName> is not specified, it is assumed to" << endl;
  cout << "    be the first/only output of source <SourceName>.  If <PortName> is not specified" << endl;
  cout << "    then it will be the same name as the first/only output of source <SourceName>." << endl;
  cout << "    If source <SourceName> or proxy <ProxyName> do not exist, create them." << endl;
  cout << "    The name of the sc_signal object used to connect the source and proxy will be" << endl;
  cout << "    the concatenation of all four names:" << endl;
  cout << "      <SourceName>_<OutputName>_<PortName>_<ProxyName>" << endl;
  cout << "    The adapter name will be the same as the signal name plus a suffix of \"_adapter\"." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --source_proxy " << endl;
  cout << endl;
  cout << "--connect_source_signal=<SourceName>[,<OutputName>],<SignalName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect pin-level output <OutputName> of source <SourceName> to signal" << endl;
  cout << "    <SignalName>.  If <OutputName> is not specified, it is assumed to be the first/" << endl;
  cout << "    only output of the source.  If source <SourceName> or signal <SignalName> do" << endl;
  cout << "    not exist, create them." << endl;
  cout << "  Aliases: --source_signal " << endl;
  cout << endl;
  cout << "--connect_source_wire=<SourceName>[,<OutputName>],<WireName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect TLM output <OutputName> of source <SourceName> to wire <WireName>.  If" << endl;
  cout << "    <OutputName> is not specified, it is assumed to be the first/only output of the" << endl;
  cout << "    source.  If <SourceName> or wire <WireName> do not exist, create them." << endl;
  cout << "  Aliases: --source_wire " << endl;
  cout << endl;
  cout << "--connect_source_wrapper=<SourceName>[[,<OutputName>],<WrapperOutputName>]" << endl;
  cout << "    Connect pin-level output <OutputName> of source <SourceName> to the current" << endl;
  cout << "    SystemC wrapper.  If <OutputName> is not specified, it is assumed to be the" << endl;
  cout << "    first/only output of the source.  If source <SourceName> does not exist," << endl;
  cout << "    create it.  <WrapperOutputName> specifies the name of the wrapper port and is" << endl;
  cout << "    also used in determining the name of the adapter object used to connect the" << endl;
  cout << "    source to the wrapper.  The adapter name will be the same as the wrapper" << endl;
  cout << "    port name plus a suffix of \"_adapter\"." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --source_wrapper " << endl;
  cout << endl;
  cout << "--connect_tlm2pin_memory_pin=<Tlm2pinName>[[,<Tlm2pinPort>],<MemoryPort>],<MemoryName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect port <Tlm2pinPort> (default 0) of tlm2pin <Tlm2pinName> to port" << endl;
  cout << "    <MemoryPort> (default 0) of memory_pin <MemoryName> using the xtsc_memory_pin::connect()" << endl;
  cout << "    method (this also connects all higher numbered ports that are both contiguously numbered" << endl;
  cout << "    and unconnected in both modules).  If tlm2pin <Tlm2pinName> or memory_pin <MemoryName>" << endl;
  cout << "    do not exist, create them." << endl;
  cout << "  Aliases: --tlm2pin_memory_pin " << endl;
  cout << endl;
  cout << "--connect_tlm2pin_pin2tlm=<Tlm2pinName>[,<Tlm2pinPort>,<Pin2tlmPort>],<Pin2tlmName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect port <Tlm2pinPort> (default 0) of tlm2pin <Tlm2pinName> to port" << endl;
  cout << "    <Pin2tlmPort> (default 0) of pin2tlm <Pin2tlmName> using the connect() method of" << endl;
  cout << "    xtsc_pin2tlm_memory_transactor (this also connects all higher numbered ports that" << endl;
  cout << "    are both contiguously numbered and unconnected in both modules).  If tlm2pin " << endl;
  cout << "    <Tlm2pinName> or pin2tlm <Pin2tlmName> do not exist, create them." << endl;
  cout << "  Aliases: --tlm2pin_memory_pin " << endl;
  cout << endl;
  cout << "--connect_tlm2pin_proxy=<Tlm2pinName>[,<MemoryPort>][,<NamePrefix>],<ProxyName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect port <MemoryPort> of tlm2pin <Tlm2pinName> to Verilog proxy <ProxyName>" << endl;
  cout << "    (this also connects all higher numbered ports of the tlm2pin that are both" << endl;
  cout << "    contiguously numbered and unconnected).  If tlm2pin <Tlm2pinName> or proxy" << endl;
  cout << "    <ProxyName> do not exist, create them.  <NamePrefix> will be used for the" << endl;
  cout << "    proxy port names only (not the sc_signal and adapter objects)." << endl;
  cout << "    Default <NamePrefix> is \"\"." << endl;
  cout << "    Default <MemoryPort> is 0." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --tlm2pin_proxy " << endl;
  cout << endl;
  cout << "--connect_tlm2pin_wrapper=<Tlm2pinName>[,<MemoryPort>][,<NamePrefix>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect port <MemoryPort> of tlm2pin <Tlm2pinName> to the current SystemC " << endl;
  cout << "    wrapper (this also connects all higher numbered ports of the tlm2pin that are" << endl;
  cout << "    both contiguously numbered and unconnected).  If tlm2pin <Tlm2pinName> does" << endl;
  cout << "    not exist, create it.  If <NamePrefix> is specified then the wrapper port" << endl;
  cout << "    names will all be prefixed by <NamePrefix>.  Default <MemoryPort> is 0." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --tlm2pin_wrapper " << endl;
  cout << endl;
  cout << "--connect_wire_core=[<WireName>,]<TiePortName>,<CoreName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect TLM wire <WireName> to import wire <TiePortName> of core <CoreName>." << endl;
  cout << "    If <WireName> is not given, it is assumed to be the same as <TiePortName>." << endl;
  cout << "    If wire <WireName> or core <CoreName> do not exist, create them." << endl;
  cout << "  Aliases: --wire_core " << endl;
  cout << endl;
  cout << "--connect_wrapper_cohctrl=[<InputName>,]<CohctrlPort>,<CohctrlName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect input <InputName> of the current SystemC wrapper to " << endl;
  cout << "    m_ccon_exports[<CohctrlPort>] of cohctrl <CohctrlName>.  If cohctrl" << endl;
  cout << "    <CohctrlName> does not exist, create it.  The default <InputName>" << endl;
  cout << "    is \"TIE_CCON\"" << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --wrapper_cohctrl " << endl;
  cout << endl;
  cout << "--connect_wrapper_consumer=<NamePrefix>,<ConsumerName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect the current SystemC wrapper to pin-level consumer <ConsumerName>.  If " << endl;
  cout << "    consumer <ConsumerName> does not exist, create it.  <NamePrefix> is used in" << endl;
  cout << "    determining the names of the wrapper ports as well as the adapter objects" << endl;
  cout << "    used to connect the wrapper to the consumer.  The wrapper port names will be" << endl;
  cout << "    <NamePrefix> plus a suffix of \"\" (i.e. there is no suffix for the port" << endl;
  cout << "    carrying the pop data), \"_PopReq\", and \"_Empty\".  The adapter names" << endl;
  cout << "    will be the same as the wrapper port names plus a suffix of \"_adapter\"." << endl;
  cout << "    For example," << endl;
  cout << "      --connect_wrapper_consumer=con,TIE_IPQ " << endl;
  cout << "    will cause code to be generated which uses the following adapter and wrapper" << endl;
  cout << "    port names: " << endl;
  cout << "      adapter name             wrapper port name" << endl;
  cout << "      ----------------------   -----------------" << endl;
  cout << "      TIE_IPQ_adapter          TIE_IPQ" << endl;
  cout << "      TIE_IPQ_PopReq_adapter   TIE_IPQ_PopReq" << endl;
  cout << "      TIE_IPQ_Empty_adapter    TIE_IPQ_Empty" << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --wrapper_consumer " << endl;
  cout << endl;
  cout << "--connect_wrapper_core=[<NamePrefix>,]<Interface>,<CoreName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect the current SystemC wrapper to pin-level TIE input queue, TIE import" << endl;
  cout << "    wire, or system-level input interface <Interface> of core <CoreName>.  If core" << endl;
  cout << "    <CoreName> does not exist, create it.  <Interface> must have been passed to the" << endl;
  cout << "    --set_core_parm=SimPinLevelInterfaces command.  If <NamePrefix> is not specified" << endl;
  cout << "    then the wrapper port names will match the port names of the RTL as specified in" << endl; 
  cout << "    the Xtensa Microprocessor Data Book.  If <NamePrefix> is specified then the wrapper" << endl;
  cout << "    port names will include a prefix of <NamePrefix>.  For example, if you have a TIE" << endl;
  cout << "    intput queue named INQ1 (e.g. \"queue INQ1 96 in\" appears in the user TIE code)" << endl;
  cout << "    then the following commands:" << endl;
  cout << "      --set_core_parm=SimPinLevelInterfaces=INQ1 ... --connect_wrapper_core=INQ1,core1" << endl;
  cout << "    will cause code to be generated which uses the following adapter and wrapper" << endl;
  cout << "    port names: " << endl;
  cout << "      adapter name                 wrapper port name" << endl;
  cout << "      -----------------------      -----------------" << endl;
  cout << "      TIE_INQ1_adapter             TIE_INQ1" << endl;
  cout << "      TIE_INQ1_PopReq_adapter      TIE_INQ1_PopReq" << endl;
  cout << "      TIE_INQ1_Empty_adapter       TIE_INQ1_Empty" << endl;
  cout << "    On the other hand," << endl;
  cout << "      --set_core_parm=SimPinLevelInterfaces=INQ1 ... --connect_wrapper_core=p1_,INQ1,core1" << endl;
  cout << "    will cause code to be generated which uses the following adapter and wrapper" << endl;
  cout << "    port names: " << endl;
  cout << "      adapter name                 wrapper port name" << endl;
  cout << "      -----------------------      -----------------" << endl;
  cout << "      p1_TIE_INQ1_adapter          p1_TIE_INQ1" << endl;
  cout << "      p1_TIE_INQ1_PopReq_adapter   p1_TIE_INQ1_PopReq" << endl;
  cout << "      p1_TIE_INQ1_Empty_adapter    p1_TIE_INQ1_Empty" << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --wrapper_core " << endl;
  cout << endl;
  cout << "--connect_wrapper_loader=[<NamePrefix>,]<LoaderName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect the current SystemC wrapper to pin-level loader <LoaderName>.  All unconnected" << endl;
  cout << "    non-tx_xfer interfaces will be connected.  Typically, this is the command input queue of" << endl;
  cout << "    the loader, the read output queue of the loader, and the Mode and Done outputs of the" << endl;
  cout << "    loader.  <NamePrefix> is used in determining the names of the wrapper ports as well as" << endl;
  cout << "    the sc_signal and adapter objects used to connect the wrapper to the loader.  If loader" << endl;
  cout << "    <LoaderName> does not exist, create it." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --wrapper_loader" << endl;
  cout << endl;
  cout << "--connect_wrapper_logic=[<WrapperInputName>,]<LogicInputName>,<LogicName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect input port <WrapperInputName> of the current SystemC wrapper to input" << endl;
  cout << "    port <LogicInputName> of logic <LogicName>.  If <WrapperInputName> is not given" << endl;
  cout << "    it defaults to <LogicInputName>.  If logic <LogicName> does not exist, create it." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --wrapper_logic " << endl;
  cout << endl;
  cout << "--connect_wrapper_lookup_pin=<NamePrefix>,<LookupName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect the current SystemC wrapper to pin-level lookup_pin <LookupName>.  If " << endl;
  cout << "    lookup_pin <LookupName> does not exist, create it.  <NamePrefix> is used in" << endl;
  cout << "    determining the names of the wrapper ports as well as the adapter objects" << endl;
  cout << "    used to connect the wrapper to the lookup_pin.  The wrapper port names will be" << endl;
  cout << "    <NamePrefix> plus a suffix of \"_Out\", \"_Out_Req\", \"_In\", and \"_Rdy\".  The" << endl;
  cout << "    adapter names will be the same as the wrapper port names plus a suffix of" << endl;
  cout << "    \"_adapter\".  For example," << endl;
  cout << "       --connect_wrapper_lookup_pin=TIE_lut,lut" << endl;
  cout << "    will cause code to be generated which uses the following adapter and wrapper" << endl;
  cout << "    port names: " << endl;
  cout << "      adapter name              wrapper port name" << endl;
  cout << "      -----------------------   -----------------" << endl;
  cout << "      TIE_lut_Out_adapter       TIE_lut_Out" << endl;
  cout << "      TIE_lut_Out_Req_adapter   TIE_lut_Out_Req" << endl;
  cout << "      TIE_lut_In_adapter        TIE_lut_In" << endl;
  cout << "      TIE_lut_Rdy_adapter       TIE_lut_Rdy (if 'lut' has a ready signal)" << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --wrapper_lookup_pin " << endl;
  cout << endl;
  cout << "--connect_wrapper_memory_pin=[<NamePrefix>,][<MemoryPort>,]<MemoryName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect the current SystemC wrapper to port <MemoryPort> of memory_pin <MemoryName>" << endl;
  cout << "    (this also connects all higher numbered ports of the memory_pin that are both" << endl;
  cout << "    contiguously numbered and unconnected).  If memory_pin <MemoryName> does not exist," << endl;
  cout << "    create it.  If <NamePrefix> is specified then the wrapper port names will all be" << endl;
  cout << "    prefixed by <NamePrefix>.  Default <MemoryPort> is 0." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --wrapper_memory_pin " << endl;
  cout << endl;
  cout << "--connect_wrapper_mmio=[<WrapperInputName>,]<MmioInputName>,<MmioName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect input port <WrapperInputName> of the current SystemC wrapper to input" << endl;
  cout << "    port <MmioInputName> of mmio <MmioName>.  If <WrapperInputName> is not given" << endl;
  cout << "    it defaults to <MmioInputName>.  If mmio <MmioName> does not exist, create it." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --wrapper_mmio " << endl;
  cout << endl;
  cout << "--connect_wrapper_pin2tlm=[<NamePrefix>,][<MemoryPort>,]<Pin2tlmName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect the current SystemC wrapper to port <MemoryPort> of pin2tlm <Pin2tlmName>" << endl;
  cout << "    (this also connects all higher numbered ports of the pin2tlm that are both" << endl;
  cout << "    contiguously numbered and unconnected).  If pin2tlm <Pin2tlmName> does not exist," << endl;
  cout << "    create it.  If <NamePrefix> is specified then the wrapper port names will all be" << endl;
  cout << "    prefixed by <NamePrefix>.  Default <MemoryPort> is 0." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --wrapper_pin2tlm " << endl;
  cout << endl;
  cout << "--connect_wrapper_queue_pin=<NamePrefix>,<QueueName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect the current SystemC wrapper to the push interface of pin-level queue_pin" << endl;
  cout << "    <QueueName>.  If queue_pin <QueueName> does not exist, create it.  <NamePrefix>" << endl;
  cout << "    is used in determining the names of the wrapper ports as well as the adapter" << endl;
  cout << "    objects used to connect the wrapper to the queue_pin.  The wrapper port names" << endl;
  cout << "    will be <NamePrefix> plus a suffix of \"\" (i.e. there is no suffix for the port" << endl;
  cout << "    carrying the push data), \"_PushReq\", and \"_Full\".  The adapter names" << endl;
  cout << "    will be the same as the wrapper port names plus a suffix of \"_adapter\"." << endl;
  cout << "    For example," << endl;
  cout << "       --connect_wrapper_queue_pin=TIE_OPQ,opq" << endl;
  cout << "    will cause code to be generated which uses the following adapter and wrapper" << endl;
  cout << "    port names: " << endl;
  cout << "      adapter name             wrapper port name" << endl;
  cout << "      -------------------      -----------------" << endl;
  cout << "      TIE_OPQ_adapter          TIE_OPQ" << endl;
  cout << "      TIE_OPQ_PushReq_adapter  TIE_OPQ_PushReq" << endl;
  cout << "      TIE_OPQ_Full_adapter     TIE_OPQ_Full" << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --wrapper_queue_pin " << endl;
  cout << endl;
  cout << "--connect_wrapper_wire=<WrapperInputName>,<WireName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Connect input port <WrapperInputName> of the current SystemC wrapper to wire" << endl;
  cout << "    <WireName>.  If wire <WireName> does not exist, create it." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --wrapper_wire " << endl;
  cout << endl;
  cout << "--core_args=<ProgramArgsCSV>" << endl;
  cout << "  Description: " << endl;
  cout << "    Parses <ProgramArgsCSV> as a list of comma separated values (CSV) to be passed" << endl;
  cout << "    to the main() function of the target core program (see --core_program) using the" << endl;
  cout << "    argv[] array.  argv[0] will be the program name, argv[1] will be the first CSV," << endl;
  cout << "    argv[2] will be the second CSV, etc." << endl;
  cout << endl;
  cout << "--core_debug[=[w|WAIT|nowait|n][,synchronized|sync|s|nosynchronized|nosync][,<StartingPort>]]" << endl;
  cout << "  Description: " << endl;
  cout << "    Causes debugging to be enabled for the target program on the next core to" << endl;
  cout << "    be instantiated.  If the nowait option is specified, then the core will not wait" << endl;
  cout << "    for the debugger to attach before running the target program.  If the" << endl;
  cout << "    synchronized option is specified, then all other cores in the system will" << endl;
  cout << "    stall when this core is waiting for a debugger to attach or is stopped at" << endl;
  cout << "    a breakpoint.  The options can appear in any order." << endl;
  cout << "    Default is to wait for the debugger to attach but then to operate without" << endl;
  cout << "    synchronization (unless --cosim is specified, then the default is to operate" << endl;
  cout << "    with synchronization)." << endl;
  cout << "  Example: " << endl;
  cout << "    --core_debug=nowait,sync --create_core=mycore" << endl;
  cout << endl;
  cout << "--core_client=<LoadClientCommand>" << endl;
  cout << "  Description: " << endl;
  cout << "    Adds <LoadClientCommand> to the list of client commands to be loaded on" << endl;
  cout << "    the next core to be instantiated.  This command can be invoked multiple times" << endl;
  cout << "    per core." << endl;
  cout << "  Examples: " << endl;
  cout << "    --core_client=summary --create_core=core0" << endl;
  cout << "    --core_client=\"summary sum.log\" --create_core=core0" << endl;
  cout << "    --core_client=\"trace --level=2 c0.trace\"  --core_client=\"profile --all\"  --create_core=c0" << endl;
  cout << "  Note: Do not use quotes when using this command from a --include file." << endl;
  cout << "  Note: Do not use this command for the loadbin client.  Instead use one of the" << endl;
  cout << "        following alternatives." << endl;
  cout << "  Note: As an alternative, you may put multiple client commands in a file (one" << endl;
  cout << "        per line) and pass in the file name using the \"SimClientFile\" parameter." << endl;
  cout << "  Example:" << endl;
  cout << "    --set_core_parm=SimClientFile=c0clientfile  --create_core=c0" << endl;
  cout << "  Note: As yet another alternative, you may use the \"SimClients\" parameter.  For" << endl;
  cout << "        example:" << endl;
  cout << "          --set_core_parm=SimClients=\"loadbin code.bin@0x60000000,profile --all\"" << endl;
  cout << "  Note: See the --multi_core_profile/--xxprofile command." << endl;
  cout << endl;
  cout << "--core_program=[<ProgramName>][,<ProgramName>...]" << endl;
  cout << "  Description: " << endl;
  cout << "    Causes each <ProgramName> to be loaded on the next core to be instantiated." << endl;
  cout << "    If <ProgramName> is missing, this indicates that some other means will be" << endl;
  cout << "    used to load the program (e.g. via the \"initial_value_file\" parameter" << endl;
  cout << "    of xtsc_memory) and that xtsc-run should not throw an exception when it" << endl;
  cout << "    doesn't have a program to load on the next core to be instantiated." << endl;
  cout << "  Aliases: --core_programs" << endl;
  cout << endl;
  cout << "--core_summary[=TRUE|false]" << endl;
  cout << "  Description: " << endl;
  cout << "    Sets the flag which causes the xtsc_core::summary() method to be called " << endl;
  cout << "    when simulation is finished for each core which is instantiated while" << endl;
  cout << "    the flag is true.  This flag keeps its value until explicity changed by" << endl;
  cout << "    another --core_summary command." << endl;
  cout << "  Initial Setting: false" << endl;
  cout << endl;
  cout << "--cosim=<TopLanguage>,<Vendor>,<VendorVersion>,<GccVersion>" << endl;
  cout << "  Description:" << endl;
  cout << "    Enable file generation for SystemC-Verilog cosimulation.  <TopLanguage> must" << endl;
  cout << "    be one of systemc|verilog.  <Vendor> must be one of cadence|mentor|synopsys." << endl;
  cout << "    <VendorVersion> and <GccVersion> are case-sensitive.  Supported combinations" << endl;
  cout << "    of <Vendor>,<VendorVersion>,<GccVersion> are:" << endl;
  cout << "        cadence,IUS62,3.2.3" << endl;
  cout << "        cadence,IUS82,4.1.2" << endl;
  cout << "        mentor,6.3d,4.0.4" << endl;
  cout << "        mentor,6.5,4.1.2" << endl;
  cout << "        synopsys,Y-2006.06-SP1-9,3.3.6" << endl;
  cout << "        synopsys,B-2008.12,4.1.2" << endl;
  cout << "    See --show_make_parms, --dir, and --path." << endl;
  cout << "    Note:  The --cosim command implies the --no_sim command.  That is, when" << endl;
  cout << "           xtsc-run generates files for SystemC-Verilog cosimulation, it exits " << endl;
  cout << "           after generating the files and does not call sc_start().  After" << endl;
  cout << "           xtsc-run exits, the user may go to the generated directory and" << endl;
  cout << "           run make there to build and simulate the system." << endl;
  cout << "    Note:  The options to the --cosim command may be supplied by the following" << endl;
  cout << "           environment variables:" << endl;
  cout << "             XTSC_RUN_COSIM_TOP_LANGUAGE     for <TopLanguage>" << endl;
  cout << "             XTSC_RUN_COSIM_VENDOR           for <Vendor>" << endl;
  cout << "             XTSC_RUN_COSIM_VENDOR_VERSION   for <VendorVersion>" << endl;
  cout << "             XTSC_RUN_COSIM_GCC_VERSION      for <GccVersion>" << endl;
  cout << "           Each of the four options may be supplied either as part of the" << endl;
  cout << "           --cosim command or from the corresponding environment variable." << endl;
  cout << "           When some of the options are specified from the environment and" << endl;
  cout << "           some are specified as part of the --cosim command then leading commas" << endl;
  cout << "           may be required.  For example, to get all the options from the " << endl;
  cout << "           evironment except <VendorVersion>, the command could be entered like" << endl;
  cout << "           this:" << endl;
  cout << "             --cosim=,,IUS82" << endl;
  cout << endl;
  cout << "                            SystemC-on-Top Scenario:" << endl;
  cout << "    If <TopLanguage> is systemc then files are generated for a SystemC on top" << endl;
  cout << "    of Verilog cosimulation.  In this scenario the testbench is sc_main and it" << endl;
  cout << "    is generated by xtsc-run.  This scenario uses the \"proxy\" concept to" << endl;
  cout << "    facilitate system specification.  Each Verilog module that is to be" << endl;
  cout << "    instantiated from sc_main requires that a SystemC proxy be created for it." << endl;
  cout << "    Each supported EDA vendor supplies a mechanism by which a SystemC proxy for" << endl;
  cout << "    a Verilog module can be automatically generated.  xtsc-run knows how to" << endl;
  cout << "    generate a make file that will envoke this mechanism.  When the" << endl;
  cout << "    --cosim=systemc command is present, xtsc-run enables the --set_proxy_parm," << endl;
  cout << "    --create_proxy, --connect_xxx_proxy, and --connect_proxy_xxx commands." << endl;
  cout << "    These commands are used to configure and create proxy objects that the user" << endl;
  cout << "    can connect XTSC pin-level components and certain TLM components to." << endl;
  cout << "    See the proxy entry in Section III and --show_proxy_parms in this section." << endl;
  cout << endl;
  cout << "                            Verilog-on-Top Scenario:" << endl;
  cout << "    If <TopLanguage> is verilog then files are generated for a Verilog on top of" << endl;
  cout << "    SystemC cosimulation.  This scenario uses the \"wrapper\" concept to" << endl;
  cout << "    facilitate system specification.  In this scenario the testbench module" << endl;
  cout << "    (i.e. top module) is a Verilog module which will directly or indirectly" << endl;
  cout << "    instantiate one or more SystemC subsystems.  Each SystemC subsystem must be" << endl;
  cout << "    wrapped inside a SystemC module so that a Verilog proxy for it can be" << endl;
  cout << "    created (these Verilog proxies are created by the EDA vendor tools and they" << endl;
  cout << "    are what the testbench Verilog module directly instantiates).  When the" << endl;
  cout << "    --cosim=verilog command is present, xtsc-run enables the --set_wrapper_parm," << endl;
  cout << "    --create_wrapper, --connect_xxx_wrapper, and --connect_wrapper_xxx" << endl;
  cout << "    commands.  These commands allow SystemC subsystems of XTSC components" << endl;
  cout << "    to be defined and wrapped inside SystemC modules.  Each SystemC" << endl;
  cout << "    wrapper module can contain an XTSC subsystem of arbitrary complexity." << endl;
  cout << "    Pin-level and certain TLM XTSC components can be connected to the wrapper" << endl;
  cout << "    which effectively connects them to Verilog.  In the Verilog-on-top scenario," << endl;
  cout << "    the testbench Verilog module is typically supplied by the user; however, the" << endl;
  cout << "    following command can be used to tell xtsc-run to generate a starter testbench" << endl;
  cout << "    Verilog module for the user to edit:" << endl;
  cout << "      --set_make_parm=generate_testbench=true" << endl;
  cout << "    See the wrapper entry in Section III and --show_wrapper_parms in this section." << endl;
  cout << endl;

// Step 18:  Add a multi-line explanation for the --create_widget command (maintain alphabetical order)

  cout << "--create_arbiter[=<ArbiterName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_arbiter object with the name <ArbiterName> using the " << endl;
  cout << "    currently defined arbiter parms (if there are no arbiter parms defined" << endl;
  cout << "    create a default set).  If <ArbiterName> is not provided, then use" << endl;
  cout << "    'arbiter' as the arbiter name." << endl;
  cout << endl;
  cout << "--create_clock[=<ClockName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an sc_clock object with the name <ClockName> using the " << endl;
  cout << "    currently defined clock parms (if there are no clock parms defined" << endl;
  cout << "    create a default set).  If <ClockName> is not provided, then use" << endl;
  cout << "    'CLK' as the clock name." << endl;
  cout << "    See --show_clock_parms." << endl;
  cout << endl;
  cout << "--create_consumer[=<ConsumerName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_queue_consumer object with the name <ConsumerName> using the " << endl;
  cout << "    currently defined consumer parms (which must exist).  If <ConsumerName>" << endl;
  cout << "    is not provided, then use 'consumer' as the consumer name." << endl;
  cout << endl;
  cout << "--create_cohctrl[=<CohctrlName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_cohctrl object with the name <CohctrlName> using " << endl;
  cout << "    the currently defined cohctrl parms (if there are no cohctrl parms defined," << endl;
  cout << "    create a default set).  If <CohctrlName> is not provided, then use 'cohctrl'" << endl;
  cout << "    as the cohctrl name." << endl;
  cout << endl;
  cout << "--create_core[=<CoreName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_core object with the name <CoreName> using the " << endl;
  cout << "    currently defined core parms (if there are no core parms defined" << endl;
  cout << "    create a default set).  If <CoreName> is not provided then use the" << endl;
  cout << "    config name (from --xtensa_system or XTENSA_SYSTEM environment" << endl;
  cout << "    variable." << endl;
  cout << endl;
  cout << "--create_distributor[=<DistributorName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_interrupt_distributor object with the name <DistributorName> using" << endl;
  cout << "    the currently defined distributor parms (which must exist).  If <DistributorName>" << endl;
  cout << "    is not provided, then use 'distributor' as the distributor name." << endl;
  cout << endl;
  cout << "--create_dma[=<DmaName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_dma_engine object with the name <DmaName> using " << endl;
  cout << "    the currently defined dma parms (if there are no dma parms defined," << endl;
  cout << "    create a default set).  If <DmaName> is not provided, then use 'dma'" << endl;
  cout << "    as the dma name." << endl;
  cout << endl;
  cout << "--create_driver[=<DriverName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_lookup_driver object with the name <DriverName> using the " << endl;
  cout << "    currently defined driver parms (which must exist).  If <DriverName>" << endl;
  cout << "    is not provided, then use 'driver' as the driver name." << endl;
  cout << endl;
  cout << "--create_loader[=<LoaderName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_tx_loader object with the name <LoaderName> using the " << endl;
  cout << "    currently defined loader parms.  If there are no loader parms defined" << endl;
  cout << "    create a default set.  If <LoaderName> is not provided, then use 'loader'" << endl;
  cout << "    as the loader name." << endl;
  cout << endl;
  cout << "--create_logic[=<LogicName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_wire_logic object with the name <LogicName> using the " << endl;
  cout << "    currently defined logic parms (which must exist).  If <LogicName>" << endl;
  cout << "    is not provided, then use 'logic' as the logic name." << endl;
  cout << endl;
  cout << "--create_lookup[=<LookupName>[,<TiePortName>]]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_lookup object with the name <LookupName> using the " << endl;
  cout << "    currently defined lookup parms.  If there are no lookup parms defined" << endl;
  cout << "    create a default set and get the lookup address and data bit widths and " << endl;
  cout << "    \"has_ready\" parameter by TIE port lookup of <TiePortName> in the most " << endl;
  cout << "    recent prevously created core.  If <TiePortName> is not provided, use" << endl;
  cout << "    <LookupName>.  If <LookupName> is not provided, then use 'lookup' as the" << endl;
  cout << "    lookup name." << endl;
  cout << endl;
  cout << "--create_lookup_pin[=<LookupName>[,<TiePortName>]]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_lookup_pin object with the name <LookupName> using the " << endl;
  cout << "    currently defined lookup_pin parms.  If there are no lookup_pin parms defined" << endl;
  cout << "    create a default set and get the lookup_pin address and data bit widths and " << endl;
  cout << "    \"has_ready\" parameter by TIE port lookup_pin of <TiePortName> in the most " << endl;
  cout << "    recent previously created core.  If <TiePortName> is not provided, use" << endl;
  cout << "    <LookupName>.  If <LookupName> is not provided, then use 'lookup_pin' as the" << endl;
  cout << "    lookup_pin name." << endl;
  cout << endl;
  cout << "--create_master[=<MasterName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_master object with the name <MasterName> using the " << endl;
  cout << "    currently defined master parms (if there are no master parms defined" << endl;
  cout << "    create a default set).  If <MasterName> is not provided, then use" << endl;
  cout << "    'master' as the master name." << endl;
  cout << endl;
  cout << "--create_memory[=<MemoryName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_memory object with the name <MemoryName> using the " << endl;
  cout << "    currently defined memory parms (if there are no memory parms defined" << endl;
  cout << "    create a default set).  If <MemoryName> is not provided then use the" << endl;
  cout << "    memory port name from the --memory_port command." << endl;
  cout << endl;
  cout << "--create_memory_pin[=<MemoryName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_memory_pin object with the name <MemoryName> using the " << endl;
  cout << "    currently defined memory_pin parms (if there are no memory_pin parms defined" << endl;
  cout << "    create a default set).  If <MemoryName> is not provided then use the" << endl;
  cout << "    memory interface type name from the \"memory_interface\" parameter." << endl;
  cout << endl;
  cout << "--create_memory_trace[=<TraceName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_memory_trace object with the name <TraceName> using the " << endl;
  cout << "    currently defined memory_trace parms (if there are no memory_trace parms" << endl;
  cout << "    defined create a default set).  If <TraceName> is not provided then use" << endl;
  cout << "    \"memory_trace\"." << endl;
  cout << endl;
  cout << "--create_mmio[=<MmioName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_mmio object with the name <MmioName> using the " << endl;
  cout << "    currently defined mmio parms (which must exist).  If <MmioName>" << endl;
  cout << "    is not provided, then use 'mmio' as the mmio name." << endl;
  cout << endl;
  cout << "--create_pin2tlm[=<Pin2tlmName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_pin2tlm_memory_transactor object with the name <Pin2tlmName>" << endl;
  cout << "    using the currently defined pin2tlm parms (if there are no pin2tlm parms" << endl;
  cout << "    defined create a default set).  If <Pin2tlmName> is not provided, then use" << endl;
  cout << "    the concatenation of the \"memory_interface\" parameter and '_pin2tlm'" << endl;
  cout << "    as the pin2tlm name." << endl;
  cout << endl;
  cout << "--create_producer[=<ProducerName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_queue_producer object with the name <ProducerName> using the " << endl;
  cout << "    currently defined producer parms (which must exist).  If <ProducerName>" << endl;
  cout << "    is not provided, then use 'producer' as the producer name." << endl;
  cout << endl;
  cout << "--create_proxy[=<ProxyName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create a SystemC proxy for a Verilog module with the name <ProxyName> using" << endl;
  cout << "    the currently defined proxy parms.  If <ProxyName> is not provided, then" << endl;
  cout << "    use 'proxy 'as the proxy name.  If there are no proxy parms defined, create" << endl;
  cout << "    a default set with the \"module_name\" parameter value equal to the proxy" << endl;
  cout << "    name (either <ProxyName> or 'proxy')." << endl;
  cout << "    See --show_proxy_parms." << endl;
  cout << "    See --cosim." << endl;
  cout << endl;
  cout << "--create_queue[=<QueueName>[,<TiePortName>]]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_queue object with the name <QueueName> using the " << endl;
  cout << "    currently defined queue parms.  If there are no queue parms defined" << endl;
  cout << "    create a default set.  If <TiePortName> is specified, then get the " << endl;
  cout << "    queue bit width by looking up TIE port <TiePortName> in the most " << endl;
  cout << "    recent previously created core.  If <QueueName> is not provided," << endl;
  cout << "    then use 'queue' as the queue name." << endl;
  cout << endl;
  cout << "--create_queue_pin[=<QueueName>[,<TiePortName>]]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_queue_pin object with the name <QueueName> using the " << endl;
  cout << "    currently defined queue_pin parms.  If there are no queue_pin parms defined" << endl;
  cout << "    create a default set.  If <TiePortName> is specified, then get the " << endl;
  cout << "    queue bit width by looking up TIE port <TiePortName> in the most " << endl;
  cout << "    recent previously created core.  If <QueueName> is not provided, then use" << endl;
  cout << "    'queue' as the queue name." << endl;
  cout << endl;
  cout << "--create_router[=<RouterName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_router object with the name <RouterName> using the " << endl;
  cout << "    currently defined router parms (if there are no router parms defined" << endl;
  cout << "    create a default set).  If <RouterName> is not provided, then use" << endl;
  cout << "    'router' as the router name." << endl;
  cout << endl;
  cout << "--create_signal=<SignalName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_signal_sc_bv_base object with the name <SignalName> using " << endl;
  cout << "    the currently defined signal parms.  If there are no signal parms defined" << endl;
  cout << "    create a default set." << endl;
  cout << endl;
  cout << "--create_slave[=<SlaveName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_slave object with the name <SlaveName> using the " << endl;
  cout << "    currently defined slave parms (if there are no slave parms defined" << endl;
  cout << "    create a default set).  If <SlaveName> is not provided, then use" << endl;
  cout << "    'slave' as the slave name." << endl;
  cout << endl;
  cout << "--create_tlm2pin[=<Tlm2pinName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_tlm2pin_memory_transactor object with the name <Tlm2pinName>" << endl;
  cout << "    using the currently defined tlm2pin parms (if there are no tlm2pin parms" << endl;
  cout << "    defined create a default set; if the --cosim command is present, the" << endl;
  cout << "    \"write_responses\" parameter will be initialized based on the config," << endl;
  cout << "    otherwise it will be left at its default value of false).  If <Tlm2pinName>" << endl;
  cout << "    is not provided, then use the concatenation of the \"memory_interface\"" << endl;
  cout << "    parameter and '_tlm2pin' as the tlm2pin name." << endl;
  cout << endl;
  cout << "--create_source[=<SourceName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_wire_source object with the name <SourceName> using the " << endl;
  cout << "    currently defined source parms.  If there are no source parms defined" << endl;
  cout << "    create a default set.  If <SourceName> is not provided, then use 'source'" << endl;
  cout << "    as the source name." << endl;
  cout << endl;
  cout << "--create_vcd[=<Identifier>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create a a SystemC VCD object with the identifier <Identifier> using the currently" << endl;
  cout << "    defined vcd parms.  If there are no vcd parms defined create a default" << endl;
  cout << "    set.  If <Identifier> is not provided, then use the value of the \"file_name\"" << endl;
  cout << "    parameter as the vcd identifier (which itself defaults to \"waveforms\")." << endl;
  cout << "    The vcd <Identifier> can subsequently be referenced in an XTSC object" << endl;
  cout << "    parameter setting command.  For example:" << endl;
  cout << "      --create_vcd=foo --set_queue_pin_parm=vcd_handle=foo" << endl;
  cout << "    See --show_vcd_parms." << endl;
  cout << endl;
  cout << "--create_wire[=<WireName>[,<TiePortName>]]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create an xtsc_wire object with the name <WireName> using the " << endl;
  cout << "    currently defined wire parms.  If there are no wire parms defined" << endl;
  cout << "    create a default set.  If <TiePortName> is specified, then get the " << endl;
  cout << "    wire bit width by looking up TIE port <TiePortName> in the most " << endl;
  cout << "    recent previously created core.  If <WireName> is not provided, then" << endl;
  cout << "    use 'wire' as the wire name." << endl;
  cout << endl;
  cout << "--create_wrapper[=<WrapperName>]" << endl;
  cout << "  Description: " << endl;
  cout << "    Create a SystemC wrapper named <WrapperName> around an XTSC module or" << endl;
  cout << "    sub-system so that it can be used in a Verilog on top of SystemC cosimulation." << endl;
  cout << "    Create the wrapper using the currently defined wrapper parms.  If there" << endl;
  cout << "    are no wrapper parms defined create a default set.  If <WrapperName> is" << endl;
  cout << "    not provided, then use 'wrapper' as the wrapper name.  The wrapper will" << endl;
  cout << "    contain all XTSC component instances referenced in subsequent --set_xxx_parm," << endl;
  cout << "    --create_xxx, and --connect_xxx_yyy commands up to the next--set_wrapper_parm" << endl;
  cout << "    command.  The wrapper will be placed in files named <WrapperName>.cpp and" << endl;
  cout << "    <WrapperName>.h." << endl;
  cout << "    See --show_wrapper_parms." << endl;
  cout << "    See --cosim." << endl;
  cout << endl;
  cout << "--cycle_limit=<NumCycles>" << endl;
  cout << "  Description: " << endl;
  cout << "    Sets the value to be passed to sc_start() after all commands are processed." << endl;
  cout << "    If <NumCycles> is 0xFFFFFFFF, the sc_start() is called with no argument, " << endl;
  cout << "    which causes simulation to run forever or until an explict call to sc_stop()" << endl;
  cout << "    is made.  If this command appears more than once, only the last command" << endl;
  cout << "    applies.  When the --cosim=verilog command is present, a thread will be" << endl;
  cout << "    added to the first wrapper which will call sc_stop() after <NumCycles> has" << endl;
  cout << "    elapsed." << endl;
  cout << "  Initial Setting: 0xFFFFFFFF" << endl;
  cout << endl;
  cout << "--dir=<DirectoryName>" << endl;
  cout << "  Description: " << endl;
  cout << "    This specifies the directory that files generated from the --sc_main or" << endl;
  cout << "    --cosim command will be put in.  The following directory will be created" << endl;
  cout << "    and the generated files will be placed in it (when the --cosim command " << endl;
  cout << "    is used then this directory must not currently exist):" << endl;
  cout << "        <GeneratedDirectoryParent>/<DirectoryName>" << endl;
  cout << "    See the --path command for a description of <GeneratedDirectoryParent>." << endl;
  cout << "    If the --cosim command is used and the --dir command is not, then" << endl;
  cout << "    <DirectoryName> will be \"cadence\", \"mentor\", or \"synopsys\" (based upon" << endl;
  cout << "    the <Vendor> argument of the --cosim command).  If neither the --cosim nor" << endl;
  cout << "    the --dir command is used then the --path command specifies the full path" << endl;
  cout << "    to the generated sc_main file" << endl;
  cout << "    Note: <DirectoryName> can have any of the characters that a legal C/C++ " << endl;
  cout << "          identifier can have plus space, hyphen, and period." << endl;
  cout << endl;
  cout << "--dump_commands" << endl;
  cout << "  Description: " << endl;
  cout << "    Dump a list of all commands (including --include file contents) for debugging." << endl;
  cout << endl;
  cout << "--help" << endl;
  cout << "  Description:" << endl;
  cout << "    Causes a list of commands to be displayed and xtsc-run to exit.  If a --help " << endl;
  cout << "    command appears on the command line (as opposed to appearing in an --include" << endl;
  cout << "    file), then it is processed prior to any other commands." << endl;
  cout << "    For the full manual instead of just a list of commands, use \"xtsc-run --manual\"." << endl;
  cout << "  Aliases: --h  --?" << endl;
  cout << endl;
  cout << "--include=<IncludeFileName>" << endl;
  cout << "  Description: " << endl;
  cout << "    Causes command processing from the current input source to be temporarily" << endl;
  cout << "    suspended while commands are read from <IncludeFileName>.  Each command in the" << endl;
  cout << "    include file must be on a separate line.  Leading hyphens are optional and" << endl;
  cout << "    ignored.  After all the commands from <IncludeFileName> are processed, " << endl;
  cout << "    command processing resumes with the command after the --include command." << endl;
  cout << "    The include file is processed using the xtsc_script_file utility which" << endl;
  cout << "    means the include file can contain comments, conditional text, etc.  See" << endl;
  cout << "    the XTSC Reference Manual and the XTSC User's Guide for more information" << endl;
  cout << "    on xtsc_script_file." << endl;
  cout << "    Note: Although a --include command can be inside an xtsc-run --include" << endl;
  cout << "    file, it is recommended that you use the #include mechanism of the" << endl;
  cout << "    xtsc_script_file pseudo-preprocessor instead, because doing so will" << endl;
  cout << "    preserve any #define macros in effect." << endl;
  cout << "  Aliases: --inc  --i" << endl;
  cout << endl;
  cout << "--logging=<LoggingConfigurationFile>|off|on|elab_only" << endl;
  cout << "  Description:" << endl;
  cout << "    If assigned value is off, then xtsc_enable_text_logging(false) is called." << endl;
  cout << "    Else if assigned value is on, then xtsc_enable_text_logging(true) is called." << endl;
  cout << "    Else if assigned value is elab_only, then xtsc_enable_text_logging(false) will" << endl;
  cout << "    be called after elaboration completes and before simulation begins." << endl;
  cout << "    Else causes <LoggingConfigurationFile> to be passed to xtsc_initialize_parms to " << endl;
  cout << "    configure the text logging system.  Only one --logging command with " << endl;
  cout << "    <LoggingConfigurationFile> specified is allowed and, if present, it is processed" << endl;
  cout << "    prior to regular commands." << endl;
  cout << "  Aliases: --log  --l" << endl;
  cout << endl;
  cout << "--manual" << endl;
  cout << "  Description:" << endl;
  cout << "    Causes this message to be displayed and xtsc-run to exit.  If a --manual " << endl;
  cout << "    command appears on the command line (as opposed to appearing in an --include" << endl;
  cout << "    file), then it is processed prior to any other commands." << endl;
  cout << "    For abbreviated help (just a list of commands) use \"xtsc-run --help\"." << endl;
  cout << "  Aliases: --man" << endl;
  cout << endl;
  cout << "--memory_pin_port=<PortName>" << endl;
  cout << "  Description:" << endl;
  cout << "    Sets the internal flag which controls what the initial parameter values are" << endl;
  cout << "    when an xtsc_memory_pin_parms, xtsc_tlm2pin_memory_transactor_parms, or " << endl;
  cout << "    xtsc_pin2tlm_memory_transactor_parms object is created.  These initial " << endl;
  cout << "    parameter values can be changed by subsequent --set_XXX_parm commands prior" << endl;
  cout << "    to the next explicit or implied --create_XXX command." << endl;
  cout << "  Initial Setting: pif|dram0|uram0|xlmi0 (first one that the current config has)" << endl;
  cout << endl;
  cout << "--memory_port=<PortName>" << endl;
  cout << "  Description:" << endl;
  cout << "    Sets the internal flag which controls what the initial parameter values" << endl;
  cout << "    are when an xtsc_memory_parms or xtsc_memory_trace_parms object is created." << endl;
  cout << "    These initial parameter values can be changed by subsequent --set_memory_parm/" << endl;
  cout << "    --set_memory_trace_parms commands prior to the next explicit or implied" << endl;
  cout << "    --create_memory/--create_memory_trace command.  The internal flag set by this" << endl;
  cout << "    command also controls the default <PortName> value for the --connect_core_arbiter," << endl;
  cout << "    --connect_core_router, and --connect_core_slave commands and the default" << endl;
  cout << "    <MemoryPort> value for the --connect_core_mmio command.  Valid values for" << endl;
  cout << "    <PortName> are documented under xtsc_core::How_to_do_memory_port_binding in the" << endl;
  cout << "    XTSC Reference Manual." << endl;
  cout << "  Initial Setting: pif|dram0|uram0|xlmi0 (first one that the current config has)" << endl;
  cout << endl;
  cout << "--multi_core_debug[=[w|WAIT|nowait|n][,synchronized|sync|s|nosynchronized|nosync][,<StartingPort>]]" << endl;
  cout << "  Description: " << endl;
  cout << "    Causes debugging to be enabled for the target program on all cores. This command" << endl;
  cout << "    should not be used with the --core_debug command.  If the nowait option is specified," << endl;
  cout << "    then the cores will not wait for the debugger to attach before running the target program." << endl;
  cout << "    If the synchronized option is specified, then all other cores in the system will" << endl;
  cout << "    stall when this core is waiting for a debugger to attach or is stopped at" << endl;
  cout << "    a breakpoint.  The options can appear in any order." << endl;
  cout << "    Default is to wait for the debugger to attach but then to operate without" << endl;
  cout << "    synchronization (unless --cosim is specified, then the default is to operate" << endl;
  cout << "    with synchronization)." << endl;
  cout << "  Aliases: --xxdebug" << endl;
  cout << "  Example: " << endl;
  cout << "    --multi_core_debug=sync --create_core=core0 ... --create_core=core1" << endl;
  cout << endl;
  cout << "--multi_core_profile[=TRUE|false]" << endl;
  cout << "  Description: " << endl;
  cout << "    Sets the flag that controls whether or not automatic profiling will be enabled." << endl;
  cout << "    If this flag is set when a core is instantiated then the load_client() method" << endl;
  cout << "    of that core will be called with a client_package argument of \"profile --all\"." << endl;
  cout << "  Initial Setting: false (i.e. profiling will not be automatically enabled)." << endl;
  cout << "  Aliases: --xxprofile  " << endl;
  cout << endl;
  cout << "--no_default_mem[=TRUE|false]" << endl;
  cout << "  Description: " << endl;
  cout << "    Sets the flag that controls whether or not memories will be created" << endl;
  cout << "    and connected to a core's memory ports that exist but that do not have " << endl;
  cout << "    memories connected to them.  The setting of this flag when a core is " << endl;
  cout << "    instantiated is what matters; however, the actual default memories," << endl;
  cout << "    if any, are not created until after the last command is processed." << endl;
  cout << "  Initial Setting: false (i.e. default memories will be created)." << endl;
  cout << "  Aliases: --ndm  " << endl;
  cout << endl;
  cout << "--no_default_local_mem[=TRUE|false]" << endl;
  cout << "  Description: " << endl;
  cout << "    Sets the flag that controls whether or not local memories will be created" << endl;
  cout << "    and connected to a core's memory ports that exist but that do not have " << endl;
  cout << "    memories connected to them.  The setting of this flag when a core is " << endl;
  cout << "    instantiated is what matters; however, the actual default local memories," << endl;
  cout << "    if any, are not created until after the last command is processed." << endl;
  cout << "    Typically this command is used when you want xtsc-run to infer a PIF memory for you" << endl;
  cout << "    but you want to use the ISS internal memory models for local memories." << endl;
  cout << "    Note:  --no_default_mem of true takes precedence over --no_default_local_mem of false." << endl;
  cout << "  Initial Setting: false (i.e. default local memories will be created)." << endl;
  cout << "  Aliases: --ndlm  " << endl;
  cout << endl;
  cout << "--no_sim[=TRUE|false]" << endl;
  cout << "  Description: " << endl;
  cout << "    Sets the flag that controls whether or not SystemC simulation will occur" << endl;
  cout << "    after the system is constructed.  If this command appears more than once, " << endl;
  cout << "    only the last command applies." << endl;
  cout << "  Initial Setting: false (i.e. SystemC simulation will occur)." << endl;
  cout << endl;
  cout << "--path=<GeneratedDirectoryParent>" << endl;
  cout << "  Description: " << endl;
  cout << "    If either the --cosim or --dir command is used then this specifies the" << endl;
  cout << "    parent directory of the generated directory.  If neither the --cosim nor" << endl;
  cout << "    the --dir command is used then this specifies the path to the directory" << endl;
  cout << "    containing the generated sc_main file.  In either case, the directory" << endl;
  cout << "    specified by --path must already exist in the file system.  The default" << endl;
  cout << "    <GeneratedDirectoryParent> (i.e. if there is no --path command) is the" << endl;
  cout << "    current working directory." << endl;
  cout << endl;
  cout << "--quit" << endl;
  cout << "  Description:" << endl;
  cout << "    Causes xtsc-run to exit at the point the --quit command is processed.  No following " << endl;
  cout << "    commands are processed, no simulation occurs, and no (further) summaries are printed." << endl;
  cout << "  Aliases: --q  " << endl;
  cout << endl;
  cout << "--sc_main[=<CppFileName>]" << endl;
  cout << "  Description:" << endl;
  cout << "    Generate an sc_main program for this system and write it to <CppFileName>." << endl;
  cout << "    If <CppFileName> is not provide, then output will be to " << sc_main_name_default << "." << endl;
  cout << "    CAUTION:  If <CppFileName> or " << sc_main_name_default << " (as applicable) exist, they will" << endl;
  cout << "              be overwritten." << endl;
  cout << endl;

// Step 19:  a) Add a multi-line explanation for the --set_widget_parm command
//           b) Add a multi-line explanation for the --show_widget_parms command 
//           Maintain alphabetical order.
  
  cout << "--set_arbiter_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of arbiter" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set. " << endl;
  cout << "  Aliases: --arbiter_parm " << endl;
  cout << endl;
  cout << "--set_clock_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of clock" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set. " << endl;
  cout << "    See --show_clock_parms." << endl;
  cout << "  Aliases: --clock_parm " << endl;
  cout << endl;
  cout << "--set_consumer_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of consumer" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set. " << endl;
  cout << "  Aliases: --consumer_parm" << endl;
  cout << endl;
  cout << "--set_cohctrl_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of cohctrl" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set. " << endl;
  cout << "  Aliases: --cohctrl_parm" << endl;
  cout << endl;
  cout << "--set_core_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of core" << endl;
  cout << "    parameters.  If no current parameter set exists, create one and populate " << endl;
  cout << "    it with default parameters according to the current xtensa_* values." << endl;
  cout << "  Aliases: --core_parm " << endl;
  cout << endl;
  cout << "--set_distributor_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of distributor" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set." << endl;
  cout << "  Aliases: --distributor_parm " << endl;
  cout << endl;
  cout << "--set_dma_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of dma" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set." << endl;
  cout << "  Aliases: --dma_parm " << endl;
  cout << endl;
  cout << "--set_driver_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of driver" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set." << endl;
  cout << "  Aliases: --driver_parm " << endl;
  cout << endl;
  cout << "--set_loader_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of loader" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set." << endl;
  cout << "  Aliases: --loader_parm " << endl;
  cout << endl;
  cout << "--set_logic_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of logic" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set." << endl;
  cout << "  Aliases: --logic_parm " << endl;
  cout << endl;
  cout << "--set_lookup_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of lookup" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set." << endl;
  cout << "  Aliases: --lookup_parm " << endl;
  cout << endl;
  cout << "--set_lookup_pin_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of lookup_pin" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set." << endl;
  cout << "  Aliases: --lookup_pin_parm" << endl;
  cout << endl;
  cout << "--set_make_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of make" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set." << endl;
  cout << "    See --show_make_parms." << endl;
  cout << "  Aliases: --make_parm  " << endl;
  cout << endl;
  cout << "--set_master_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of master" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set." << endl;
  cout << "  Aliases: --master_parm  " << endl;
  cout << endl;
  cout << "--set_memory_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of memory" << endl;
  cout << "    parameters.  If no current parameter set exists, create one and populate" << endl;
  cout << "    it with default parameters according to the current value of the memory_port" << endl;
  cout << "    flag and the xtensa_* values." << endl;
  cout << "  Aliases: --memory_parm " << endl;
  cout << endl;
  cout << "--set_memory_pin_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of memory_pin" << endl;
  cout << "    parameters.  If no current parameter set exists, create one based on the" << endl;
  cout << "    current --memory_pin_port setting." << endl;
  cout << "  Aliases: --memory_pin_parm " << endl;
  cout << endl;
  cout << "--set_memory_trace_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of memory_trace" << endl;
  cout << "    parameters.  If no current parameter set exists, create one based on the" << endl;
  cout << "    current --memory_port setting." << endl;
  cout << "  Aliases: --memory_trace_parm " << endl;
  cout << endl;
  cout << "--set_mmio_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of mmio" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set." << endl;
  cout << "  Aliases: --mmio_parm  " << endl;
  cout << endl;
  cout << "--set_pin2tlm_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of pin2tlm" << endl;
  cout << "    parameters.  If no current parameter set exists, create one based on the" << endl;
  cout << "    current --memory_pin_port setting." << endl;
  cout << "  Aliases: --pin2tlm_parm " << endl;
  cout << endl;
  cout << "--set_producer_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of producer" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set." << endl;
  cout << "  Aliases: --producer_parm " << endl;
  cout << endl;
  cout << "--set_proxy_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of Verilog proxy" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set." << endl;
  cout << "    See --show_proxy_parms." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --proxy_parm " << endl;
  cout << endl;
  cout << "--set_queue_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of TLM queue" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set." << endl;
  cout << "  Aliases: --queue_parm " << endl;
  cout << endl;
  cout << "--set_queue_pin_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of queue_pin" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set." << endl;
  cout << "  Aliases: --queue_pin_parm" << endl;
  cout << endl;
  cout << "--set_router_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of router" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set." << endl;
  cout << "  Aliases: --router_parm " << endl;
  cout << endl;
  cout << "--set_signal_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of signal" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set." << endl;
  cout << "  Aliases: --signal_parm " << endl;
  cout << endl;
  cout << "--set_slave_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of slave" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set." << endl;
  cout << "  Aliases: --slave_parm " << endl;
  cout << endl;
  cout << "--set_source_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of source" << endl;
  cout << "    (xtsc_wire_source) parameters.  If no current parameter set exists, create a default set." << endl;
  cout << "  Aliases: --source_parm " << endl;
  cout << endl;
  cout << "--set_tlm2pin_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of tlm2pin" << endl;
  cout << "    parameters.  If no current parameter set exists, create one based on the" << endl;
  cout << "    current --memory_pin_port setting (if the --cosim command is present," << endl;
  cout << "    the \"write_responses\" parameter will be initialized based on the config," << endl;
  cout << "    otherwise it will be left at its default value of false)." << endl;
  cout << "  Aliases: --tlm2pin_parm " << endl;
  cout << endl;
  cout << "--set_vcd_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of vcd" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set." << endl;
  cout << "    See --show_vcd_parms." << endl;
  cout << "  Aliases: --vcd_parm " << endl;
  cout << endl;
  cout << "--set_wire_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of TLM wire" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set." << endl;
  cout << "  Aliases: --wire_parm " << endl;
  cout << endl;
  cout << "--set_wrapper_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of SystemC wrapper" << endl;
  cout << "    parameters.  If no current parameter set exists, create a default set." << endl;
  cout << "    See --show_wrapper_parms." << endl;
  cout << "    See --cosim." << endl;
  cout << "  Aliases: --wrapper_parm " << endl;
  cout << endl;
  cout << "--set_xtsc_parm=<ParmName>=<ParmValue> " << endl;
  cout << "  Description: " << endl;
  cout << "    Add <ParmName> with a value of <ParmValue> to the current set of xtsc_initialize()" << endl;
  cout << "    parameters." << endl;
  cout << endl;
  cout << "--show_arbiter_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of arbiter parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_clock_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of clock parameters.  If none exists, create a" << endl;
  cout << "    default set.  The possible clock parameters are:" << endl;
  cout << "       Name                  Type    Description" << endl;
  cout << "      \"start_time\"           u32     The start time expressed in terms of the SystemC" << endl;
  cout << "                                     time resolution." << endl;
  cout << "                                     Default = 0." << endl;
  cout << "      \"posedge_first\"        bool    If true, the clock value starts out false and" << endl;
  cout << "                                     transitions to true at the time defined by" << endl;
  cout << "                                     \"start_time\".  If false, the clock value starts" << endl;
  cout << "                                     out true and transitions to false at the time" << endl;
  cout << "                                     defined by \"start_time\"." << endl;
  cout << "                                     Default = true." << endl;
  cout << "      \"high_duty_cycle\"      double  This specifies the proportion of the clock period" << endl;
  cout << "                                     during which the clock value is true.  Its value" << endl;
  cout << "                                     must be strictly between 0.0 and 1.0, exclusive." << endl;
  cout << "                                     Default = 0.5" << endl;
  cout << "      \"period\"               u32     The clock period expressed in terms of the SystemC" << endl;
  cout << "                                     time resolution." << endl;
  cout << "                                     Default = 1000 (from xtsc_get_system_clock_period())" << endl;
  cout << "      \"vcd_handle\"           void*   A pointer to a a SystemC VCD object to trace this clock" << endl;
  cout << "                                     signal." << endl;
  cout << "                                     Default = NULL (no tracing)." << endl;
  cout << endl;
  cout << "--show_consumer_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of consumer parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_cohctrl_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of cohctrl parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_core_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of core parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_distributor_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of distributor parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_dma_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of dma parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_driver_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of driver parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_loader_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of loader parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_logic_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of logic parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_lookup_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of lookup parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_lookup_pin_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of lookup_pin parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_make_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of make parameters.  Generally, these are used to specify" << endl;
  cout << "    additional arguments to be passed to various vendor tools.  The set of possible" << endl;
  cout << "    make parameters depends upon what is specified by the <Top> and <Vendor>" << endl;
  cout << "    arguments to the --cosim command.  Here are the possiblities:" << endl;
  cout << "    Note: For cadence and synopsys, the \"g++\" default initial value can be overridden" << endl;
  cout << "          by the XTSC_RUN_COSIM_GCC environment variable (for mentor, the compiler" << endl;
  cout << "          is specified using the CppPath variable in the modelsim.ini file)." << endl;
  cout << endl;
  string arch_flag(xtsc_64bit ? "-fPIC" : "-m32");
  cout << "      <Top> is systemc and <Vendor> is cadence:" << endl;
  cout << "       Name                  Type    Description" << endl;
  cout << "      \"argv_space\"           char*   Optional character to be converted to a space where" << endl;
  cout << "                                     ever it occurs in the argv array passed in to sc_main" << endl;
  cout << "                                     (except argv[0])." << endl;
  cout << "                                     Default = \"@\"." << endl;
  cout << "      \"cxx\"                  char*   The path and name of the C++ compiler." << endl;
  cout << "                                     Default = \"g++\" (i.e. g++ on user's path)." << endl;
  cout << "      \"cxx_args\"             char*   Additional arguments to pass to the C++ compiler." << endl;
  cout << "                                     Default = \"" << arch_flag << " -U NDEBUG -D DEBUG -g -O0\"." << endl;
  cout << "      \"ld_args\"              char*   Additional arguments to pass to the linker." << endl;
  cout << "                                     Default = \"" << arch_flag << "\"." << endl;
  cout << "      \"ncvlog_args\"          char*   Additional arguments to pass to the ncvlog command." << endl;
  cout << "                                     Default = \"\"." << endl;
  cout << "      \"ncshell_args\"         char*   Additional arguments to pass to the ncshell command." << endl;
  cout << "                                     Default = \"-scopts \\\"-CFLAGS " << arch_flag << "\\\"\"." << endl;
  cout << "      \"ncelab_args\"          char*   Additional arguments to pass to the ncelab command." << endl;
  cout << "                                     Default = \"\"." << endl;
  cout << "      \"ncsim_args\"           char*   Additional arguments to pass to the ncsim command." << endl;
  cout << "                                     Default = \"\"." << endl;
  cout << endl;
  cout << "      <Top> is verilog and <Vendor> is cadence:" << endl;
  cout << "       Name                  Type    Description" << endl;
  cout << "      \"verilog_files\"        char**  A comma-separated list of extra arguments to pass to" << endl;
  cout << "                                     the ncverilog command (e.g. a list of the verilog files)." << endl;
  cout << "                                     Default = NULL." << endl;
  cout << "      \"testbench_name\"       char*   The name of the top-level Verilog module." << endl;
  cout << "                                     Default = \"testbench\"." << endl;
  cout << "      \"generate_testbench\"   bool    If true a starter testbench module will be generated." << endl;
  cout << "                                     The module name will be as specified by the \"testbench_name\"" << endl;
  cout << "                                     parameter and it will be put in a file with the same name plus" << endl;
  cout << "                                     a .v extension.   This file will need to be hand edited." << endl;
  cout << "                                     Default = false." << endl;
  cout << "      \"cxx\"                  char*   The path and name of the C++ compiler." << endl;
  cout << "                                     Default = \"g++\" (i.e. g++ on user's path)." << endl;
  cout << "      \"cxx_args\"             char*   Additional arguments to pass to the C++ compiler." << endl;
  cout << "                                     Default = \"" << arch_flag << " -U NDEBUG -D DEBUG -g -O0\"." << endl;
  cout << "      \"ld_args\"              char*   Additional arguments to pass to the linker." << endl;
  cout << "                                     Default = \"" << arch_flag << "\"." << endl;
  cout << "      \"ncshell_args\"         char*   Additional arguments to pass to the ncshell command." << endl;
  cout << "                                     Default = \"-scopts \\\"-CFLAGS " << arch_flag << "\\\"\"." << endl;
  cout << "      \"ncsc_args\"            char*   Additional arguments to pass to the ncsc command." << endl;
  cout << "                                     Default = \"\"." << endl;
  cout << "      \"ncsim_args\"           char*   Additional arguments to pass to the ncsim command." << endl;
  cout << "                                     Default = \"\"." << endl;
  cout << "      \"ncverilog_args\"       char*   Additional arguments to pass to the ncverilog command." << endl;
  cout << "                                     Options +elaborate and +loadsc+./systemc are always passed." << endl;
  cout << "                                     Default = \"\"." << endl;
  cout << "      \"readmemh_use_prefix\"  bool    If true, then any generated readmemh files will have" << endl;
  cout << "                                     the wrapper name and core name prefixed to the name of" << endl;
  cout << "                                     the generated readmemh file.  See the \"readmemh_cores\"" << endl;
  cout << "                                     parameter under --show_wrapper_parms." << endl;
  cout << "                                     Default = false." << endl;
  cout << endl;
  cout << "      <Top> is systemc and <Vendor> is mentor:" << endl;
  cout << "       Name                  Type    Description" << endl;
  cout << "      \"argv_space\"           char*   Optional character to be converted to a space where" << endl;
  cout << "                                     ever it occurs in the argv array passed in to sc_main" << endl;
  cout << "                                     (except argv[0])." << endl;
  cout << "                                     Default = NULL (no conversion is performed)." << endl;
  cout << "      \"modelsim_ini\"         char*   The path and name of a modelsim.ini file to copy into" << endl;
  cout << "                                     the generated directory." << endl;
  cout << "                                     Default = \"\"." << endl;
  cout << "      \"vlog_args\"            char*   Additional arguments to pass to the vlog command." << endl;
  cout << "                                     Default = \"\"." << endl;
  cout << "      \"scgenmod_args\"        char*   Additional arguments to pass to the scgenmod command." << endl;
  cout << "                                     Default = \"\"." << endl;
  cout << "      \"sccom_args\"           char*   Additional arguments to pass to the sccom command." << endl;
  cout << "                                     Default = \"" << arch_flag << " -U NDEBUG -D DEBUG -g -O0\"." << endl;
  cout << "      \"sccom_link_args\"      char*   Additional arguments to pass to the sccom -link command." << endl;
  cout << "                                     Default = \"" << arch_flag << "\"." << endl;
  cout << "      \"vsim_args\"            char*   Additional arguments to pass to the vsim command." << endl;
  cout << "                                     Default = \"\"." << endl;
  cout << endl;
  cout << "      <Top> is verilog and <Vendor> is mentor:" << endl;
  cout << "       Name                  Type    Description" << endl;
  cout << "      \"verilog_files\"        char**  A comma-separated list of extra arguments to pass to" << endl;
  cout << "                                     the vlog command (e.g. a list of the verilog files)." << endl;
  cout << "                                     Default = NULL." << endl;
  cout << "      \"testbench_name\"       char*   The name of the top-level Verilog module." << endl;
  cout << "                                     Default = \"testbench\"." << endl;
  cout << "      \"generate_testbench\"   bool    If true a starter testbench module will be generated." << endl;
  cout << "                                     The module name will be as specified by the \"testbench_name\"" << endl;
  cout << "                                     parameter and it will be put in a file with the same name plus" << endl;
  cout << "                                     a .v extension.   This file will need to be hand edited." << endl;
  cout << "                                     Default = false." << endl;
  cout << "      \"modelsim_ini\"         char*   The path and name of a modelsim.ini file to copy into" << endl;
  cout << "                                     the generated directory." << endl;
  cout << "                                     Default = \"\"." << endl;
  cout << "      \"vlog_args\"            char*   Additional arguments to pass to the vlog command." << endl;
  cout << "                                     Default = \"\"." << endl;
  cout << "      \"sccom_args\"           char*   Additional arguments to pass to the sccom command." << endl;
  cout << "                                     Default = \"" << arch_flag << " -U NDEBUG -D DEBUG -g -O0\"." << endl;
  cout << "      \"sccom_link_args\"      char*   Additional arguments to pass to the sccom -link command." << endl;
  cout << "                                     Default = \"" << arch_flag << "\"." << endl;
  cout << "      \"vsim_args\"            char*   Additional arguments to pass to the vsim command." << endl;
  cout << "                                     Default = \"\"." << endl;
  cout << "      \"readmemh_use_prefix\"  bool    If true, then any generated readmemh files will have" << endl;
  cout << "                                     the wrapper name and core name prefixed to the name of" << endl;
  cout << "                                     the generated readmemh file.  See the \"readmemh_cores\"" << endl;
  cout << "                                     parameter under --show_wrapper_parms." << endl;
  cout << "                                     Default = false." << endl;
  cout << endl;
  cout << "      <Top> is systemc and <Vendor> is synopsys:" << endl;
  cout << "       Name                  Type    Description" << endl;
  cout << "      \"argv_space\"           char*   Optional character to be converted to a space where" << endl;
  cout << "                                     ever it occurs in the argv array passed in to sc_main" << endl;
  cout << "                                     (except argv[0])." << endl;
  cout << "                                     Default = NULL (no conversion is performed)." << endl;
  cout << "      \"cxx\"                  char*   The path and name of the C++ compiler." << endl;
  cout << "                                     Default = \"g++\" (i.e. g++ on user's path)." << endl;
  cout << "      \"vlogan_args\"          char*   Additional arguments to pass to the vlogan command." << endl;
  cout << "                                     Default = \"\"." << endl;
  cout << "      \"syscan_args\"          char*   Additional arguments to pass to the syscan command." << endl;
  cout << "                                     Default = \"-debug_all -V -cflags \\\"" << arch_flag <<
                                                          " -U NDEBUG -D DEBUG -g -O0\\\"\"." << endl;
  cout << "      \"syscsim_args\"         char*   Additional arguments to pass to the syscsim command." << endl;
  cout << "                                     Default = \"-debug_all -cflags \\\"-g " << arch_flag << "\\\"." << endl;
  cout << "      \"simv_args\"            char*   Additional arguments to pass to the simv command." << endl;
  cout << "                                     Default = \"\"." << endl;
  cout << endl;
  cout << "      <Top> is verilog and <Vendor> is synopsys:" << endl;
  cout << "       Name                  Type    Description" << endl;
  cout << "      \"verilog_files\"        char**  A comma-separated list of extra arguments to pass to" << endl;
  cout << "                                     the vcs command (e.g. a list of the verilog files)." << endl;
  cout << "                                     Default = NULL." << endl;
  cout << "      \"testbench_name\"       char*   The name of the top-level Verilog module." << endl;
  cout << "                                     Default = \"testbench\"." << endl;
  cout << "      \"generate_testbench\"   bool    If true a starter testbench module will be generated." << endl;
  cout << "                                     The module name will be as specified by the \"testbench_name\"" << endl;
  cout << "                                     parameter and it will be put in a file with the same name plus" << endl;
  cout << "                                     a .v extension.   This file will need to be hand edited." << endl;
  cout << "                                     Default = false." << endl;
  cout << "      \"cxx\"                  char*   The path and name of the C++ compiler." << endl;
  cout << "                                     Default = \"g++\" (i.e. g++ on user's path)." << endl;
  cout << "      \"syscan_args\"          char*   Additional arguments to pass to the syscan command." << endl;
  cout << "                                     Default = \"-debug_all -V -cflags \\\"" << arch_flag <<
                                                          " -UNDEBUG -DDEBUG -g -O0\\\"\"." << endl;
  cout << "      \"vcs_args\"             char*   Additional arguments to pass to the vcs command." << endl;
  cout << "                                     Default = \"+v2k -debug_all -cflags \\\"-g " << arch_flag << "\\\"\"." << endl;
  cout << "      \"vcs_ld_args\"          char*   Additional linker arguments to pass to the vcs command." << endl;
  cout << "                                     Default = \"\"." << endl;
  cout << "      \"simv_args\"            char*   Additional arguments to pass to the simv command." << endl;
  cout << "                                     Default = \"\"." << endl;
  cout << "      \"readmemh_use_prefix\"  bool    If true, then any generated readmemh files will have" << endl;
  cout << "                                     the wrapper name and core name prefixed to the name of" << endl;
  cout << "                                     the generated readmemh file.  See the \"readmemh_cores\"" << endl;
  cout << "                                     parameter under --show_wrapper_parms." << endl;
  cout << "                                     Default = false." << endl;
  cout << endl;
  cout << "--show_master_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of master parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_memory_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of memory parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_memory_pin_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of memory_pin parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_memory_trace_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of memory_trace parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_mmio_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of mmio parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_modules[=verbose]" << endl;
  cout << "  Description: " << endl;
  cout << "    Show a list of all available XTSC modules with their xtsc-run name and their SystemC name." << endl;
  cout << "    If the verbose option is specified then also show a description of the model and list" << endl;
  cout << "    the commands related to each model." << endl;
  cout << "  Aliases: --show_models" << endl;
  cout << endl;
  cout << "--show_pin2tlm_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of pin2tlm parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_producer_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of producer parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_proxy_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of proxy parameters.  If none exists, create a default set." << endl;
  cout << "    The possible proxy parameters are:" << endl;
  cout << "       Name                  Type    Description" << endl;
  cout << "      \"extra_inputs\"         char**  This parameter can be used to specify a list" << endl;
  cout << "                                     of extra input ports that the proxy has that" << endl;
  cout << "                                     should be connected to a dangling sc_signal on" << endl;
  cout << "                                     the SystemC side.  Each input takes two entries" << endl;
  cout << "                                     in the c-string array: the first specifies the" << endl;
  cout << "                                     input name and the second the bit width.  For" << endl;
  cout << "                                     example, the following specifies that the proxy" << endl;
  cout << "                                     has a 32-bit input named \"ICacheWrData\" and a" << endl;
  cout << "                                     1-bit input named \"Strobe\":" << endl;
  cout << "                                     --set_proxy_parm=extra_inputs=ICacheWrData,32,Strobe,1" << endl;
  cout << "      \"extra_outputs\"        char**  This parameter can be used to specify a list" << endl;
  cout << "                                     of extra output ports that the proxy has that" << endl;
  cout << "                                     should be connected to a dangling sc_signal on" << endl;
  cout << "                                     the SystemC side.  For example, the following" << endl;
  cout << "                                     specifies that the proxy has a 1-bit output" << endl;
  cout << "                                     named \"TMode\":" << endl;
  cout << "                                       --set_proxy_parm=extra_outputs=TMode,1" << endl;
  cout << "      \"fully_connect_cores\"  char**  This parameter can be used to specify a list of" << endl;
  cout << "                                     cores (which will not necessarily have been created" << endl;
  cout << "                                     yet) which should have all unconnected memory and" << endl;
  cout << "                                     pin-level TIE and system I/O interfaces connected" << endl;
  cout << "                                     to this proxy automatically." << endl;
  cout << "      \"module_name\"          char*   The name of the Verilog module that this proxy" << endl;
  cout << "                                     is a proxy for." << endl;
  cout << "                                     Default is the proxy name." << endl;
  cout << "      \"readmemh_cores\"       char**  If this proxy is a proxy for a Verilog memory" << endl;
  cout << "                                     model, then this parameter can be used to specify" << endl;
  cout << "                                     a list of cores whose target programs should be" << endl;
  cout << "                                     loaded in the Verilog memory model.  The Verilog" << endl;
  cout << "                                     memory model should use a parameter called file_name" << endl;
  cout << "                                     to specify the path and name of the readmemh file." << endl;
  cout << "                                     The generated Makefile will include a target called" << endl;
  cout << "                                     data_files that will call xt-dumpelf to generate" << endl;
  cout << "                                     readmemh files for the named cores." << endl;
  cout << "                                     Default = NULL." << endl;
  cout << "      \"readmemh_file_name\"   char*   This parameter can be used to specify the file_name" << endl;
  cout << "                                     Verilog parameter used by the example Verilog memory" << endl;
  cout << "                                     models.  This parameter must not be used if the" << endl;
  cout << "                                     \"readmemh_cores\" proxy parameter is being used." << endl;
  cout << "                                     The \"readmemh_cores\" parameter is used when you" << endl;
  cout << "                                     have a target program and you want the generated" << endl;
  cout << "                                     Makefile to create readmemh files from it.  This" << endl;
  cout << "                                     parameter is used when you already have a custom" << endl;
  cout << "                                     readmemh file.  The Verilog memory model should" << endl;
  cout << "                                     use a Verilog parameter called file_name to specify" << endl;
  cout << "                                     the path and name of the readmemh file." << endl;
  cout << "                                     Note:  The example pifmem Verilog model contains" << endl;
  cout << "                                            2 memories (one for sysram and one for " << endl;
  cout << "                                            sysrom) and it's file_name parameter" << endl;
  cout << "                                            specifies the path and initial portion of" << endl;
  cout << "                                            the file name to which a suffix of .sysram" << endl;
  cout << "                                            or .sysrom, as appropriated, will be appended" << endl;
  cout << "                                            to form the complete readmemh file name." << endl;
  cout << "      \"readmemh_interface\"   char*   If either \"readmemh_cores\" or \"readmemh_file_name\"" << endl;
  cout << "                                     is non-null and non-empty then this parameter should" << endl;
  cout << "                                     be used to specify which memory interface will be" << endl;
  cout << "                                     connected to this proxy.  Valid values are \"dram0\"," << endl;
  cout << "                                     \"dram1\", \"drom0\", \"iram0\", \"iram1\", \"irom0\"," << endl;
  cout << "                                     \"uram0\", \"xlmi0\", and \"pif\"." << endl;
  cout << "                                     Default = (As set by --memory_pin_port)." << endl;
  cout << "      \"vcd_handle\"           void*   A pointer to a SystemC VCD object to use for tracing" << endl;
  cout << "                                     all signals connected to the proxy." << endl;
  cout << "                                     Default = NULL (no tracing)." << endl;
  cout << "      \"verilog_file\"         char*   The name of the Verilog file containing the" << endl;
  cout << "                                     Verilog module that this proxy is for.  If NULL" << endl;
  cout << "                                     then a Verilog file will be generated with a name" << endl;
  cout << "                                     of the \"module_name\" parameter plus a \".v\"" << endl;
  cout << "                                     file extension." << endl;
  cout << "                                     Default = NULL." << endl;
  cout << "      \"verilog_files\"        char*   The name of an optional file containing a list of" << endl;
  cout << "                                     other Verilog files to be compiled.  If specified," << endl;
  cout << "                                     this parameter value is passed as the argument of the" << endl;
  cout << "                                     -file option to the ncvlog, vlog, or syscsim command" << endl;
  cout << "                                     (for cadence, mentor, or synopsys, respectively)." << endl;
  cout << "                                     Default = NULL." << endl;
  cout << "    Note: All proxy objects instantiated with the same \"module_name\" parameter are" << endl;
  cout << "          instances of the same Verilog proxy.  If a second proxy object is instantiated" << endl;
  cout << "          with the same \"module_name\" value as an already existing proxy object, then" << endl;
  cout << "          the \"verilog_file\" and \"verilog_files\" parameters of the later proxy object" << endl;
  cout << "          to be instantiated must either be left at their default values (and xtsc-run" << endl;
  cout << "          will obtain the values for these two parameters from the already existing " << endl;
  cout << "          proxy object) or their values must be set to exactly match the already" << endl;
  cout << "          existing proxy object." << endl;
  cout << endl;
  cout << "--show_queue_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of queue parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_queue_pin_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of queue_pin parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_router_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of router parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_signal_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of signal parameters.  If none exists, create a" << endl;
  cout << "    default set.  The possible signal parameters are:" << endl;
  cout << "       Name          Type    Description" << endl;
  cout << "      \"bit_width\"    u32     The number of bits in the signal." << endl;
  cout << "                             Default = 1" << endl;
  cout << "      \"vcd_handle\"   void*   A pointer to a a SystemC VCD object to trace this signal." << endl;
  cout << "                             Default = NULL (no tracing)." << endl;
  cout << endl;
  cout << "--show_slave_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of slave parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_tlm2pin_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of tlm2pin parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_vcd_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of vcd parameters.  If none exists, create a" << endl;
  cout << "    default set.  The possible vcd parameters are:" << endl;
  cout << "       Name          Type    Description" << endl;
  cout << "      \"file_name\"    char*   The name of the VCD dump file (without the .vcd" << endl;
  cout << "                             file extension)." << endl;
  cout << "                             Default = \"waveforms\"" << endl;
  cout << endl;
  cout << "--show_wire_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of wire parameters.  If none exists, create a" << endl;
  cout << "    default set." << endl;
  cout << endl;
  cout << "--show_wrapper_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of wrapper parameters.  If none exists, create a default set." << endl;
  cout << "    The possible wrapper parameters are:" << endl;
  cout << "       Name                  Type    Description" << endl;
  cout << "      \"argv_space\"           char*   Optional character to be converted to a space where" << endl;
  cout << "                                     ever it occurs in the argv array obtained from calling" << endl;
  cout << "                                     sc_argv() in the wrapper constructor (except argv[0])." << endl;
  cout << "                                     Default = \"@\" (if vendor is cadence)." << endl;
  cout << "                                     Default = NULL (if vendor is not cadence)." << endl;
  cout << "      \"extra_inputs\"         char**  This parameter can be used to specify a list of" << endl;
  cout << "                                     extra input ports that the wrapper should have." << endl;
  cout << "                                     This input will exist at the wrapper interface but" << endl;
  cout << "                                     will not be connected to anything on the SystemC" << endl;
  cout << "                                     side.  Each input takes two entries in the c-string" << endl;
  cout << "                                     array: the first specifies the input name and the" << endl;
  cout << "                                     second specifies the bit width.  For example, the" << endl;
  cout << "                                     following will cause the wrapper to have a 1-bit" << endl;
  cout << "                                     input named \"TMode\" and a 4-bit input named \"Status\":" << endl;
  cout << "                                       --set_wrapper_parm=extra_inputs=TMode,1,Status,4" << endl;
  cout << "      \"extra_outputs\"        char**  This parameter can be used to specify a list" << endl;
  cout << "                                     of extra output ports that the wrapper should have." << endl;
  cout << "                                     For example, the following will cause the wrapper to" << endl;
  cout << "                                     have a 32-bit output named \"ICacheWrData\":" << endl;
  cout << "                                       --set_wrapper_parm=extra_outputs=ICacheWrData,32" << endl;
  cout << "      \"fully_connect_cores\"  char**  This parameter can be used to specify a list" << endl;
  cout << "                                     of cores (which will not have been created yet)" << endl;
  cout << "                                     which should have all unconnected memory and" << endl;
  cout << "                                     pin-level TIE and system I/O interfaces connected" << endl;
  cout << "                                     to the wrapper automatically." << endl;
  cout << "      \"readmemh_cores\"       char**  This parameter can be used to specify a list" << endl;
  cout << "                                     of cores (which will not have been created yet)" << endl;
  cout << "                                     whose target programs need to be loaded into" << endl;
  cout << "                                     Verilog memory models.  The generated Makefile will" << endl;
  cout << "                                     include a target called data_files that will call" << endl;
  cout << "                                     xt-dumpelf to generate readmemh files for the named" << endl;
  cout << "                                     cores.   See the \"readmemh_use_prefix\" parameter" << endl;
  cout << "                                     under --show_make_parms." << endl;
  cout << "                                     Default = NULL." << endl;
  cout << "      \"shadow_memory\"        bool    This specifies the \"shadow_memory\" parameter value" << endl;
  cout << "                                     to be used for all inferred tlm2pin objects." << endl;
  cout << "                                     Default = false." << endl;
  cout << "      \"vcd_handle\"           char*   This parameter is used to specify a VCD dump file" << endl;
  cout << "                                     that all signals connected to the wrapper will" << endl;
  cout << "                                     automatically be traced to.  The VCD dump file name" << endl;
  cout << "                                     will be the same as the \"vcd_handle\" plus a \".vcd\"" << endl;
  cout << "                                     extension.  The VCD dump file will automatically be" << endl;
  cout << "                                     created when the wrapper is created.  If desired, you" << endl;
  cout << "                                     may also trace other things inside the wrapper by" << endl;
  cout << "                                     passing this same parameter value to the appropriate" << endl;
  cout << "                                     --set_XXX_parm command.  For example:" << endl;
  cout << "                                       --set_core_parm=SimVcdHandle=<VcdHandle>  // core modules" << endl;
  cout << "                                       --set_XXX_parm=vcd_handle=<VcdHandle>     // other modules" << endl;
  cout << "                                     Default = NULL." << endl;
  cout << "                                     Note:  The vector (non-bool) outputs of tlm2pin and" << endl;
  cout << "                                            pin2tlm modules which are connected to a wrapper" << endl;
  cout << "                                            do not trace properly when done using the" << endl;
  cout << "                                            --set_tlm2pin_parm=vcd_handle=<VcdHandle> or " << endl;
  cout << "                                            --set_pin2tlm_parm=vcd_handle=<VcdHandle> commands;" << endl;
  cout << "                                            however, they will trace fine when done from the" << endl;
  cout << "                                            wrapper (that is, when using this parameter)." << endl;
  cout << "    Note: If the --cosim=verilog,<Vendor>,<VendorVersion>,<GccVersion> command is not also" << endl;
  cout << "          given, then xtsc-run will terminate after processing the --show_wrapper_parms" << endl;
  cout << "          command." << endl;
  cout << endl;
  cout << "--show_xtsc_parms" << endl;
  cout << "  Description: " << endl;
  cout << "    Show the current set of parameters for the call to xtsc_initialize()." << endl;
  cout << endl;
  cout << "--squelch_ctor[=off|fatal|error|warn|note|INFO|verbose|debug|trace|all]" << endl;
  cout << "  Description:" << endl;
  cout << "    Calls the xtsc_set_constructor_log_level() method with the specified" << endl;
  cout << "    value.  " << endl;
  cout << "  Initial Setting: info, i.e. before any commands are processed " << endl;
  cout << "    xtsc_set_constructor_log_level() is called with a value corresponding" << endl;
  cout << "    to info." << endl;
  cout << endl;
  cout << "--string_array_separator=<PrintableCharacter>" << endl;
  cout << "  Description: " << endl;
  cout << "    Specifies that <PrintableCharactor> will be used in lieu of a comma to separate" << endl;
  cout << "    C-strings in a C-string array parameter value list." << endl;
  cout << endl;
  cout << "--summary[=[v|verbose][,n|now]]" << endl;
  cout << "  Description:" << endl;
  cout << "    If the 'now' keyword is present, this command causes a system summary to " << endl;
  cout << "    be printed at the present point of processing." << endl;
  cout << "    If the 'now' keyword is not present, this command sets a flag that will " << endl;
  cout << "    cause a system summary to be printed after all commands are processed but " << endl;
  cout << "    before simulation, if any, begins.  If this command appears more than once" << endl;
  cout << "    without the 'now' keyword, only the last command applies." << endl;
  cout << "    The 'verbose' keyword causes all XTSC objects and their construction " << endl;
  cout << "    parameters to be displayed.  In addition, all the registers and all " << endl;
  cout << "    the TLM and pin-level TIE and system I/O ports of all core modules are" << endl;
  cout << "    displayed.  If the 'verbose' keyword is not specified, only the XTSC" << endl;
  cout << "    object names are displayed." << endl;
  cout << "  Aliases: --sum  --s" << endl;
  cout << endl;
  cout << "--xtensa_system=<InstallationDirectory> " << endl;
  cout << "  Description:" << endl;
  cout << "    Set the value for the Xtensa installation directory.  If this command is" << endl;
  cout << "    not given, then xtsc-run will use the environment variable XTENSA_SYSTEM." << endl;
  cout << "    If this command is not given and the XTENSA_SYSTEM environment variable" << endl;
  cout << "    is not defined then core objects cannot be constructed." << endl;
  cout << endl;
  cout << "--xtensa_core=<ConfigName> " << endl;
  cout << "  Description:" << endl;
  cout << "    Set the value for the Xtensa core configuration to be used for subsequent" << endl;
  cout << "    XTSC object default and look-up parameters.  If this command is" << endl;
  cout << "    not given, then xtsc-run will use the environment variable XTENSA_CORE." << endl;
  cout << "    If this command is not given and the XTENSA_CORE environment variable" << endl;
  cout << "    is not defined then core objects cannot be constructed." << endl;
  cout << endl;
  cout << "--xtensa_params=<TdkDirectory> " << endl;
  cout << "  Description:" << endl;
  cout << "    Set the value for the user TIE directory, if any.  If this command is" << endl;
  cout << "    not given, then xtsc-run will use the environment variable XTENSA_PARAMS." << endl;
  cout << "    If this command is not given and the XTENSA_PARAMS environment variable" << endl;
  cout << "    is not defined then no user TIE will be used when constructing xtsc_core" << endl;
  cout << "    objects." << endl;
  cout << endl;
  cout << "--xtensa_*" << endl;
  cout << "  Description:" << endl;
  cout << "    There is no such command.  The \"--xtensa_*\" string is used in the examples below" << endl;
  cout << "    to indicate the use of the --xtensa_system, the --xtensa_core, and, if applicable," << endl;
  cout << "    the --xtensa_params commands (or their corresponding environment variables:" << endl;
  cout << "    XTENSA_CORE, XTENSA_SYSTEM, and XTENSA_PARAMS)." << endl;
  cout << endl;
  cout << "--xxdebug    (See --multi_core_debug)" << endl;
  cout << endl;
  cout << "--xxprofile  (See --multi_core_profile)" << endl;
  cout << endl;
  cout << "Section V:  Notes on xtsc-run command processing" << endl;
  cout << endl;
  cout << "All command-line arguments prior to the first command-line argument that does" << endl;
  cout << "not start with a hyphen are treated as xtsc-run commands.  Generally, each" << endl;
  cout << "xtsc-run command is executed in order.  The exceptions to this rule are " << endl;
  cout << "referred to as special commands (--help, --manual, --include, --cosim, --dir," << endl;
  cout << "--logging=<LoggingConfigurationFile>, --path, --sc_main, --set_xtsc_parm," << endl;
  cout << "and --show_xtsc_parms) and they are all executed prior to other command processing." << endl;
  cout << "Although each command (except the special commands just listed) is executed at" << endl;
  cout << "the point where it is encountered, in several cases this execution consists of" << endl;
  cout << "simply setting a program flag that controls future action." << endl;
  cout << endl;
  cout << "More exactly, xtsc-run commands are processed in 4 phases: " << endl;
  cout << "  1. The command line is scanned and if any --help or --manual command is found," << endl;
  cout << "     the corresponding help/manual message is printed and xtsc-run exits." << endl;
  cout << "  2. All commands are read into a list.  During this phase the --include" << endl;
  cout << "     command is processed but no other command processing takes place." << endl;
  cout << "  3. The list of commands is scanned for the remaining special commands (--cosim," << endl;
  cout << "     --dir, --logging=<LoggingConfigurationFile>, --path, --sc_main, --set_xtsc_parm," << endl;
  cout << "     and --show_xtsc_parms).  At the end of this phase, the xtsc_initialize()" << endl;
  cout << "     function is called with parameters as specified by any --set_xtsc_parm and" << endl;
  cout << "     --logging=<LoggingConfigurationFile> commands and the --cosim command, if." << endl;
  cout << "     any, is parsed and processed." << endl;
  cout << "  4. The list of regular commands is then processed in sequence." << endl;
  cout << endl;
  cout << "Section VI:  Examples (see --xtensa_* above)" << endl;
  cout << endl;
  cout << "To run program foo.out:" << endl;
  cout << "     xtsc-run --xtensa_* foo.out" << endl;
  cout << endl;
  cout << "To run program foo.out using the fast-functional simulator (Turbo Mode):" << endl;
  cout << "     xtsc-run --xtensa_* --set_xtsc_parm=turbo=true foo.out" << endl;
  cout << endl;
  cout << "To run program foo.out with a PIF memory with a 5 cycle delay for READ:" << endl;
  cout << "     xtsc-run --xtensa_* --set_memory_parm=read_delay=5 foo.out" << endl;
  cout << endl;
  cout << "To see all the parameters for a core: " << endl;
  cout << "     xtsc-run --xtensa_* --show_core_parms" << endl;
  cout << endl;
  cout << "To build and simulate a system with two cores, one using config 'BigICache' and" << endl;
  cout << "running proga.out and the other using config 'BigDCache' and running progb.out: " << endl;
  cout << "     xtsc-run --xtensa_system=/my_registry_path \\" << endl;
  cout << "              --xtensa_core=BigICache --core_program=proga.out \\" << endl;
  cout << "              --xtensa_core=BigDCache --core_program=progb.out " << endl;
  cout << endl;
  cout << "To elaborate (build) a system from include file commands.inc, show lots of" << endl;
  cout << "information about the system, but don't simulate it: " << endl;
  cout << "     xtsc-run --include=commands.inc --summary=verbose --no_sim" << endl;
  cout << endl;
  cout << "To show all commands from the command line and any include files but quit" << endl;
  cout << "before executing the commands (except for the special commands mentioned" << endl;
  cout << "above):" << endl;
  cout << "     xtsc-run --dump_commands --quit --include=commands.inc" << endl;
  cout << endl;
  cout << "To see the effect of a second arbitrary sequence of commands (each sequence " << endl;
  cout << "is denoted with a set of elipses): " << endl;
  cout << "     xtsc-run ... --summary=verbose,now ... --summary=verbose,now " << endl;
  cout << endl;
  }
  if (brief) {
  cout << "[use \"xtsc-run --manual\" to get the full manual]" << endl;
  cout << "[use \"xtsc-run --show_modules[=verbose]\" to get a list of modules]" << endl;
  }
  else {
  cout << "[use \"xtsc-run --help\" to get abbreviated help consisting of just a list of commands]" << endl;
  }
}



void usage_and_exit(bool brief, int exit_code) {
  XTSC_TRACE(logger, "enter usage_and_exit()");
  usage(brief);
  exit(exit_code);
}



void dump_commands() {
  XTSC_TRACE(logger, "enter dump_commands()");
  string cmd_line("<command line argument>");
  for (u32 i=0; i<commands.size(); ++i) {
    bool leading_newline = (info_for_exceptions[i].length() && (info_for_exceptions[i][0] == '\n'));
    string exception_info_msg(leading_newline ? info_for_exceptions[i].substr(1) : info_for_exceptions[i]);
    XTSC_NOTE(logger, "commands[" << i << "]: >" << commands[i] << "<");
    XTSC_NOTE(logger, "     command_file: " << ((command_files[i] == "") ? cmd_line : command_files[i]));
    XTSC_NOTE(logger, "  line/arg number: " << command_line_numbers[i]);
    XTSC_NOTE(logger, "   exception info: " << exception_info_msg);
  }
}



void command_info(ostream& os) {
  os << "'" << cmd << "'";
  if (command_file == "") {
    if (command_line_number != 0xFFFFFFFF) {
      os << " at command-line argument #" << command_line_number;
    }
  }
  else {
    if (command_line_number == 0xFFFFFFFF) {
      os << " " << command_file;
    }
    else {
      os << info_for_exception;
    }
  }
}



const char *space(u32 num_spaces) {
                            //           1         2         3         4         5         6         7
                            // 01234567890123456789012345678901234567890123456789012345678901234567890
  static const char *spaces = "                                                                      ";
  return &spaces[(num_spaces > 70) ? 0 : 70-num_spaces];
}



bool is_identifier(const string& name) {
  string::const_iterator is = name.begin();
  bool ok = (is != name.end());
  bool first = true;
  for (; ok && (is != name.end()); ++is) {
    ok = ((*is == '_') || isalpha(*is) || (!first && isdigit(*is)));
    first = false;
  }
  return ok;
}



void initialize_processing() {
  XTSC_TRACE(logger, "enter initialize_processing()");

  const char *env_var = NULL;

  env_var = getenv("XTENSA_CORE");
  if (env_var) {
    XTENSA_CORE = strdup(env_var);
  }

  env_var = getenv("XTENSA_SYSTEM");
  if (env_var) {
    XTENSA_SYSTEM = strdup(env_var);
  }

  env_var = getenv("XTENSA_PARAMS");
  if (env_var) {
    XTENSA_PARAMS = strdup(env_var);
  }

  env_var = getenv("XTSC_RUN_COSIM_TOP_LANGUAGE");
  if (env_var) {
    top_env = env_var;
  }

  env_var = getenv("XTSC_RUN_COSIM_VENDOR");
  if (env_var) {
    vendor_env = env_var;
  }

  env_var = getenv("XTSC_RUN_COSIM_VENDOR_VERSION");
  if (env_var) {
    vendor_version_env = env_var;
  }

  env_var = getenv("XTSC_RUN_COSIM_GCC");
  if (env_var) {
    gcc_env = env_var;
  }

  env_var = getenv("XTSC_RUN_COSIM_GCC_VERSION");
  if (env_var) {
    gcc_version_env = env_var;
  }

  env_var = getenv("XTSC_RUN_COSIM_NO_CHECK");
  if (env_var) {
    no_check = true;
  }

  env_var = getenv("XTSC_RUN_COSIM_64BIT");
  if (env_var) {
    xtsc_64bit = true;
    if (cosim) {
      XTSC_NOTE(logger, "xtsc-run cosim generation configured for 64-bit executables");
    }
  }

}



void setup_command_variables(const string& command, const string& file, u32 line, const string& info) {

  // Fixed copy for saving 
  cmd = command;
  command_file = file;
  command_line_number = line;
  info_for_exception = info;

  // Working copy
  rem = command;

  // Lower-case working copy 
  rem_lc = command;
  transform(rem.begin(), rem.end(), rem_lc.begin(), ::tolower);

}



void arg_split(int argi) {
  if (logging_is_configured) XTSC_TRACE(logger, "enter arg_split()");
  if (logging_is_configured) XTSC_DEBUG(logger, "arg_split() argi=" << argi << ": >" << rem << "<");
  string::size_type pos = rem.find_first_of("=");
  if (pos == string::npos) {
    command_name = rem_lc;
    command_is_assignment = false;
    more_csv = false;
    rem_lc = rem = "";
  }
  else {
    command_name = rem_lc.substr(0, pos);
    command_is_assignment = true;
    rem   .erase(0, pos+1);
    rem_lc.erase(0, pos+1);
    more_csv = (rem != "");
  }
  if (logging_is_configured) XTSC_DEBUG(logger, "arg_split() command_name: >" << command_name << "<");
  if (logging_is_configured) XTSC_DEBUG(logger, "arg_split() assignment: " << (command_is_assignment ? "YES" : "NO"));
  if (logging_is_configured) XTSC_DEBUG(logger, "arg_split() option_value: >" << rem << "<");
}



void parm_split(xtsc_parms& parms) {
  bool log = xtsc_is_logging_configured();
  if (log) XTSC_TRACE(logger, "enter parm_split()");
  if (log) XTSC_DEBUG(logger, "parm_split() " << parms.kind() << ": >" << rem << "<");
  string::size_type pos = rem.find_first_of("=");
  if (pos == 0) {
    ostringstream oss;
    oss << "'name=value' pair not found after command name in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  else if (pos == string::npos) {
    parm_name = rem;
    rem_lc = rem = "";
  }
  else {
    parm_name = rem.substr(0, pos);
    rem   .erase(0, pos+1);
    rem_lc.erase(0, pos+1);
  }
  if (log) XTSC_DEBUG(logger, "parm_split() parm_name: >" << parm_name << "<");
  if (!parms.exists(parm_name.c_str())) {
    ostringstream oss;
    oss << parms.kind() << " has no parameter named '" << parm_name << "' in command ";
    command_info(oss);
    oss << endl << "Here is a list of " << parms.kind() << " parameters:" << endl;
    parms.dump(oss);
    throw xtsc_exception(oss.str());
  }
  parm_type     = parms.get_parameter_type(parm_name.c_str());
  parm_value    = rem;
  parm_value_lc = rem_lc;
  switch (parm_type) {
    case xtsc_parms::PARM_TYPE_BOOL: {
      if (parm_value_lc == "1" || parm_value_lc == "t" || parm_value_lc == "true") {
        parm_value_bool = true;
      }
      else if (parm_value_lc == "0" || parm_value_lc == "f" || parm_value_lc == "false") {
        parm_value_bool = false;
      }
      else {
        ostringstream oss;
        oss << "Parameter '" << parm_name << "' is of type bool, but value is not one of 0|f|false|1|t|true in command " << endl;
        command_info(oss);
        throw xtsc_exception(oss.str());
      }
      break;
    }
    case xtsc_parms::PARM_TYPE_DOUBLE: {
      parm_value_double = strtodouble(parm_value);
      if (log) XTSC_DEBUG(logger, "parm_split() parm_type=double, value=" << parm_value_double);
      break;
    }
    case xtsc_parms::PARM_TYPE_U32: {
      parm_value_u32 = strtou32(parm_value);
      if (log) XTSC_DEBUG(logger, "parm_split() parm_type=u32, value=0x" << hex << parm_value_u32);
      break;
    }
    case xtsc_parms::PARM_TYPE_U32_VECTOR: {
      string numbers = parm_value;
      if (log) XTSC_DEBUG(logger, "parm_split() parm_type=vector<u32>, numbers=" << numbers);
      parm_value_u32_vector.clear();
      string::size_type pos = string::npos;
      bool bad_one_found = false;
      while ((pos = numbers.find_first_of(string_array_separator)) != string::npos) {
        try {
          u32 value = xtsc_strtou32(numbers.substr(0, pos));
          parm_value_u32_vector.push_back(value);
          numbers.erase(0, pos + 1);
          if (log) XTSC_DEBUG(logger, "parm_split() parm_type=vector<u32>, numbers=" << numbers);
        }
        catch (const xtsc_exception&) {
          bad_one_found = true;
          numbers = numbers.substr(0, pos);
          break;
        }
      }
      if (!bad_one_found && (numbers.size() || parm_value_u32_vector.size())) {
        try {
          u32 value = xtsc_strtou32(numbers);
          parm_value_u32_vector.push_back(value);
          if (log) XTSC_DEBUG(logger, "parm_split() parm_type=vector<u32>, numbers=" << numbers);
        }
        catch (const xtsc_exception&) {
          bad_one_found = true;
        }
      }
      if (bad_one_found) {
        ostringstream oss;
        oss << "Cannot convert string '" << numbers << "' to a u32 in command ";
        command_info(oss);
        throw xtsc_exception(oss.str());
      }
      break;
    }
    case xtsc_parms::PARM_TYPE_C_STR: {
      if (log) XTSC_DEBUG(logger, "parm_split() parm_type=char*, value: >" << parm_value << "<");
      break;
    }
    case xtsc_parms::PARM_TYPE_C_STR_ARRAY: {
      string strings = parm_value;
      if (log) XTSC_DEBUG(logger, "parm_split() parm_type=char**, strings=" << strings);
      vector<string> array;
      string::size_type pos = string::npos;
      bool found_non_empty_one = false;
      while ((pos = strings.find_first_of(string_array_separator)) != string::npos) {
        if (pos) { found_non_empty_one = true; }
        array.push_back(strings.substr(0, pos));
        strings.erase(0, pos + 1);
        if (log) XTSC_DEBUG(logger, "parm_split() parm_type=char**, strings=" << strings);
      }
      if (strings.size() || found_non_empty_one) array.push_back(strings);
      parm_type = xtsc_parms::PARM_TYPE_C_STR_ARRAY;
      parm_value_c_str_array = new char*[array.size()+1];
      for (size_t i=0; i<array.size(); ++i) {
        parm_value_c_str_array[i] = xtsc_copy_c_str(array[i].c_str());
        if (log) XTSC_DEBUG(logger, "parm_split() parm_type=char**, array[" << i << "]=\"" << parm_value_c_str_array[i] << "\"");
      }
      parm_value_c_str_array[array.size()] = NULL;
      if (log) XTSC_DEBUG(logger, "parm_split() parm_type=char**, array[" << array.size() << "]=NULL");
      break;
    }
    case xtsc_parms::PARM_TYPE_VOID_POINTER: {
      void_pointer_name = parm_value;
      parm_value_void_pointer = get_identifier(void_pointer_name);
      if (log) XTSC_DEBUG(logger, "parm_split() parm_type=void*, value=0x" << parm_value_void_pointer);
      break;
    }
    default: {
      ostringstream oss;
      oss << "PROGRAM BUG: xtsc_parameter_type=" << parm_type << " not supported for parm_split().";
      throw xtsc_exception(oss.str());
    }
  }
}



void add_parm(xtsc_parms& parms) {
  bool log = xtsc_is_logging_configured();
  if (log) XTSC_TRACE(logger, "enter add_parm()");
  if (parm_type == xtsc_parms::PARM_TYPE_C_STR_ARRAY) {
    *p_oss_parms << tab2 << "const char *c_str_array__" << object_number << "[] = {" << endl;
    for (u32 i=0; parm_value_c_str_array[i]; ++i) {
      *p_oss_parms << tab3 << "\"" << escape_backslashes(parm_value_c_str_array[i]) << "\"," << endl;
    }
    *p_oss_parms << tab3 << "NULL" << endl;
    *p_oss_parms << tab2 << "};" << endl;
  }
  else if (parm_type == xtsc_parms::PARM_TYPE_U32_VECTOR) {
    *p_oss_parms << tab2 << "vector<u32> u32_vector__" << object_number << ";" << endl;
    for (u32 i=0; i<parm_value_u32_vector.size(); ++i) {
      *p_oss_parms << tab2 << "u32_vector__" << object_number << ".push_back(0x" << hex << parm_value_u32_vector[i] << ");" << endl;
    }
  }
  *p_oss_parms << tab2 << *p_name_module_parms << ".set(\"" << parm_name << "\", ";
  switch (parm_type) {
    case xtsc_parms::PARM_TYPE_BOOL: {
      *p_oss_parms << boolalpha << parm_value_bool;
      parms.set(parm_name.c_str(), parm_value_bool);
      break;
    }
    case xtsc_parms::PARM_TYPE_DOUBLE: {
      *p_oss_parms << parm_value_double;
      parms.set(parm_name.c_str(), parm_value_double);
      break;
    }
    case xtsc_parms::PARM_TYPE_U32: {
      *p_oss_parms << "0x" << hex << parm_value_u32;
      parms.set(parm_name.c_str(), parm_value_u32);
      break;
    }
    case xtsc_parms::PARM_TYPE_U32_VECTOR: {
      *p_oss_parms << "u32_vector__" << object_number++;
      parms.set(parm_name.c_str(), parm_value_u32_vector);
      break;
    }
    case xtsc_parms::PARM_TYPE_C_STR: {
      *p_oss_parms << "\"" << escape_backslashes(parm_value) << "\"";
      parms.set(parm_name.c_str(), parm_value.c_str());
      break;
    }
    case xtsc_parms::PARM_TYPE_C_STR_ARRAY: {
      *p_oss_parms << "c_str_array__" << object_number++;
      parms.set(parm_name.c_str(), parm_value_c_str_array);
      break;
    }
    case xtsc_parms::PARM_TYPE_VOID_POINTER: {
      *p_oss_parms << void_pointer_name;
      parms.set(parm_name.c_str(), parm_value_void_pointer);
      break;
    }
    default: {
      ostringstream oss;
      oss << "PROGRAM BUG: xtsc_parameter_type=" << parm_type << " not supported for add_parm().";
      throw xtsc_exception(oss.str());
    }
  }
  *p_oss_parms << ");" << endl;
}



void update_parm_u32(xtsc_parms& parms, const string& name, u32 value, ostringstream& oss_parms, const string& name_module_parms) {
  XTSC_TRACE(logger, "enter update_parm_u32()");
  parms.set(name.c_str(), value);
  oss_parms << tab2 << name_module_parms << ".set(\"" << name << "\", ";
  oss_parms << "0x" << hex << value;
  oss_parms << ");" << endl;
}



void update_parm_bool(xtsc_parms& parms, const string& name, bool value, ostringstream& oss_parms, const string& name_module_parms) {
  XTSC_TRACE(logger, "enter update_parm_bool()");
  parms.set(name.c_str(), value);
  oss_parms << tab2 << name_module_parms << ".set(\"" << name << "\", ";
  oss_parms << boolalpha << value;
  oss_parms << ");" << endl;
}



xtsc_core_parms *get_newest_core_parms() {
  XTSC_TRACE(logger, "enter get_newest_core_parms()");
  xtsc_core_parms *p_cp = p_core_parms;
  // If we don't have a nascent core, use the last created core (if there is one, if not return NULL)
  if (!p_cp && (last_core_created != "") ) {
    map<string,core_info*>::iterator ic = core_map[w]->find(last_core_created);
    if (ic == core_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find core '" << last_core_created << "'.";
      throw xtsc_exception(oss.str());
    }
    p_cp = &ic->second->parms;
  }
  return p_cp;
}



u32 compute_address_bits(u32 byte_size, u32 byte_width) {
  // Compute address_bits  (size8 must be a power of 2)
  u32 address_bits = 0;
  u32 shift_value = byte_size / byte_width;
  for (u32 i=0; i<32; ++i) {
    if (shift_value & 0x1) address_bits = i;
    shift_value >>= 1;
  }
  return address_bits;
}



u32 strtou32(const string& str, const string& msg) {
  XTSC_TRACE(logger, "enter strtou32()");
  try {
    return xtsc_strtou32(str);
  }
  catch (const xtsc_exception&) {
    ostringstream oss;
    oss << "Cannot convert string '" << str << "' to a number (type u32)";
    if (msg == "") {
      oss << " in command ";
      command_info(oss);
    } 
    else {
      oss << ": " << msg;
    }
    throw xtsc_exception(oss.str());
  }
}



double strtodouble(const string& str) {
  XTSC_TRACE(logger, "enter strtodouble()");
  try {
    return xtsc_strtod(str);
  }
  catch (const xtsc_exception&) {
    ostringstream oss;
    oss << "Cannot convert string '" << str << "' to a number (type double) in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void validate_name(const string& name, const string& type) {
  if (name.length() < 1) {
    ostringstream oss;
    oss << "The " << type << " name is null in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  const char *name_c_str = name.c_str();
  for (const char *pc = name_c_str; *pc; ++pc) {
    char c = *pc;
    if (c>='a' && c<='z') continue;
    if (c>='A' && c<='Z') continue;
    if (c=='_') continue;
    // If not 1st character . . .
    if (pc != name_c_str) {
      // Allow digit
      if (c>='0' && c<='9') continue;
    }
    ostringstream oss;
    oss << "The " << type << " name '" << name << "' contains invalid characters in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void connect_module_to_proxy(const string&         module_type,
                             xtsc_module_pin_base& module,
                             const string&         module_name,
                             u32                   set_id,
                             const string&         name_prefix,
                             proxy_info&           proxy)
{
  XTSC_TRACE(logger, "enter connect_module_to_proxy()");
  for (u32 type=1; type<=6; ++type) {
    set_string ports;
    switch (type) {
      case 1: ports = module.get_wide_input_set (set_id); break;
      case 2: ports = module.get_wide_output_set(set_id); break;
      case 3: ports = module.get_uint_input_set (set_id); break;
      case 4: ports = module.get_uint_output_set(set_id); break;
      case 5: ports = module.get_bool_input_set (set_id); break;
      case 6: ports = module.get_bool_output_set(set_id); break;
    }
    for (set_string::const_iterator ip = ports.begin(); ip != ports.end(); ++ip) {
      u32 bits = module.get_bit_width(*ip);
      add_proxy_io(proxy, name_prefix + *ip, bits, ((type & 0x1) == 0), (type <= 2), false);
      switch (type) {
        case 1: connect_wide_input (module_type, module_name, proxy, name_prefix, *ip, bits); break;
        case 2: connect_wide_output(module_type, module_name, proxy, name_prefix, *ip, bits); break;
        case 3: connect_uint_input (module_type, module_name, proxy, name_prefix, *ip, bits); break;
        case 4: connect_uint_output(module_type, module_name, proxy, name_prefix, *ip, bits); break;
        case 5: connect_bool_input (module_type, module_name, proxy, name_prefix, *ip);       break;
        case 6: connect_bool_output(module_type, module_name, proxy, name_prefix, *ip);       break;
      }
    }
  }
}



void connect_wide_input(const string& module_type,
                        const string& module_name,
                        proxy_info&   proxy,
                        const string& name_prefix,
                        const string& port_name,
                        u32           bit_width)
{
  XTSC_TRACE(logger, "enter connect_wide_input()");
  string signal_name(module_name + "_" + port_name);
  string adapter_name(signal_name + "_adapter");
  ostringstream type;
  if (bit_width > 1) {
    type << "sc_bv<" << setw(4) << bit_width << ">";
  }
  else {
    type << "bool       ";
  }
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << proxy.module_name << " proxy " << proxy.name << " to sc_bv_base input " << port_name
                       << " of " << module_type << " " << module_name << " using adapter:" << endl;
  *oss_main[w] << tab2 << "sc_signal<" << type.str() << " > " << signal_name << "(\"" << signal_name << "\");" << endl;
  if (proxy.trace_identifier != "") {
  *oss_main[w] << tab2 << "sc_trace(" << proxy.trace_identifier << ", " << signal_name << ", \"" << signal_name << "\");" << endl;
  }
  *oss_main[w] << tab2 << proxy.name << "." << name_prefix << port_name << "(" << signal_name << ");" << endl;
  *oss_main[w] << tab2 << "xtsc_sc_in_sc_bv_base_adapter<" << bit_width << ", " << type.str() << " > " << adapter_name
                       << "(\"" << adapter_name << "\");" << endl;
  *oss_main[w] << tab2 << adapter_name << ".m_sc_in(" << signal_name << ");" << endl;
  *oss_main[w] << tab2 << module_name << "->get_wide_input(\"" << port_name << "\")(" << adapter_name << ".m_sc_export);" << endl;
}



void connect_wide_output(const string& module_type,
                         const string& module_name,
                         proxy_info&   proxy,
                         const string& name_prefix,
                         const string& port_name,
                         u32           bit_width)
{
  XTSC_TRACE(logger, "enter connect_wide_output()");
  string signal_name(module_name + "_" + port_name);
  string adapter_name(signal_name + "_adapter");
  ostringstream type;
  if (bit_width > 1) {
    type << "sc_bv<" << setw(4) << bit_width << ">";
  }
  else {
    type << "bool       ";
  }
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect sc_bv_base output " << port_name << " of " << module_type << " " << module_name << " to "
                       << proxy.module_name << " proxy " << proxy.name << " using adapter:" << endl;
  *oss_main[w] << tab2 << "xtsc_sc_out_sc_bv_base_adapter<" << bit_width << ", " << type.str() << " > " << adapter_name
                       << "(\"" << adapter_name << "\");" << endl;
  *oss_main[w] << tab2 << module_name << "->get_wide_output(\"" << port_name << "\")(" << adapter_name << ".m_sc_export);" << endl;
  *oss_main[w] << tab2 << "sc_signal<" << type.str() << " > " << signal_name << "(\"" << signal_name << "\");" << endl;
  if (proxy.trace_identifier != "") {
  *oss_main[w] << tab2 << "sc_trace(" << proxy.trace_identifier << ", " << signal_name << ", \"" << signal_name << "\");" << endl;
  }
  *oss_main[w] << tab2 << adapter_name << ".m_sc_out(" << signal_name << ");" << endl;
  *oss_main[w] << tab2 << proxy.name << "." << name_prefix << port_name << "(" << signal_name << ");" << endl;
}



void connect_uint_input(const string& module_type,
                        const string& module_name,
                        proxy_info&   proxy,
                        const string& name_prefix,
                        const string& port_name,
                        u32           bit_width)
{
  XTSC_TRACE(logger, "enter connect_uint_input()");
  string signal_name(module_name + "_" + port_name);
  string adapter_name(signal_name + "_adapter");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << proxy.module_name << " proxy " << proxy.name << " to sc_uint_base input " << port_name
                       << " of " << module_type << " " << module_name << " using adapter:" << endl;
  *oss_main[w] << tab2 << "sc_signal<sc_uint<" << bit_width << "> > " << signal_name << "(\"" << signal_name << "\");" << endl;
  if (proxy.trace_identifier != "") {
  *oss_main[w] << tab2 << "sc_trace(" << proxy.trace_identifier << ", " << signal_name << ", \"" << signal_name << "\");" << endl;
  }
  *oss_main[w] << tab2 << proxy.name << "." << name_prefix << port_name << "(" << signal_name << ");" << endl;
  *oss_main[w] << tab2 << "xtsc_sc_in_sc_uint_base_adapter<" << bit_width << ", sc_uint<" << bit_width << "> > " << adapter_name
                       << "(\"" << adapter_name << "\");" << endl;
  *oss_main[w] << tab2 << adapter_name << ".m_sc_in(" << signal_name << ");" << endl;
  *oss_main[w] << tab2 << module_name << "->get_uint_input(\"" << port_name << "\")(" << adapter_name << ".m_sc_export);" << endl;
}



void connect_uint_output(const string& module_type,
                         const string& module_name,
                         proxy_info&   proxy,
                         const string& name_prefix,
                         const string& port_name,
                         u32           bit_width)
{
  XTSC_TRACE(logger, "enter connect_uint_output()");
  string signal_name(module_name + "_" + port_name);
  string adapter_name(signal_name + "_adapter");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect sc_uint_base output " << port_name << " of " << module_type << " " << module_name << " to "
                       << proxy.module_name << " proxy " << proxy.name << " using adapter:" << endl;
  *oss_main[w] << tab2 << "xtsc_sc_out_sc_uint_base_adapter<" << bit_width << ", sc_uint<" << bit_width << "> > "
                       << adapter_name << "(\"" << adapter_name << "\");" << endl;
  *oss_main[w] << tab2 << module_name << "->get_uint_output(\"" << port_name << "\")(" << adapter_name << ".m_sc_export);" << endl;
  *oss_main[w] << tab2 << "sc_signal<sc_uint<" << bit_width << "> > " << signal_name << "(\"" << signal_name << "\");" << endl;
  if (proxy.trace_identifier != "") {
  *oss_main[w] << tab2 << "sc_trace(" << proxy.trace_identifier << ", " << signal_name << ", \"" << signal_name << "\");" << endl;
  }
  *oss_main[w] << tab2 << adapter_name << ".m_sc_out(" << signal_name << ");" << endl;
  *oss_main[w] << tab2 << proxy.name << "." << name_prefix << port_name << "(" << signal_name << ");" << endl;
}



void connect_bool_input(const string& module_type,
                        const string& module_name,
                        proxy_info&   proxy,
                        const string& name_prefix,
                        const string& port_name)
{
  XTSC_TRACE(logger, "enter connect_bool_input()");
  string signal_name(module_name + "_" + port_name);
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << proxy.module_name << " proxy " << proxy.name << " to bool input " << port_name
                       << " of " << module_type << " " << module_name << ":" << endl;
  *oss_main[w] << tab2 << "sc_signal<bool> " << signal_name << "(\"" << signal_name << "\");" << endl;
  if (proxy.trace_identifier != "") {
  *oss_main[w] << tab2 << "sc_trace(" << proxy.trace_identifier << ", " << signal_name << ", \"" << signal_name << "\");" << endl;
  }
  *oss_main[w] << tab2 << proxy.name << "." << name_prefix << port_name << "(" << signal_name << ");" << endl;
  *oss_main[w] << tab2 << module_name << "->get_bool_input(\"" << port_name << "\")(" << signal_name << ");" << endl;
}



void connect_bool_output(const string& module_type,
                         const string& module_name,
                         proxy_info&   proxy,
                         const string& name_prefix,
                         const string& port_name)
{
  XTSC_TRACE(logger, "enter connect_bool_output()");
  string signal_name(module_name + "_" + port_name);
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect bool output " << port_name << " of " << module_type << " " << module_name << " to "
                       << proxy.module_name << " proxy " << proxy.name << ":" << endl;
  *oss_main[w] << tab2 << "sc_signal<bool> " << signal_name << "(\"" << signal_name << "\");" << endl;
  if (proxy.trace_identifier != "") {
  *oss_main[w] << tab2 << "sc_trace(" << proxy.trace_identifier << ", " << signal_name << ", \"" << signal_name << "\");" << endl;
  }
  *oss_main[w] << tab2 << module_name << "->get_bool_output(\"" << port_name << "\")(" << signal_name << ");" << endl;
  *oss_main[w] << tab2 << proxy.name << "." << name_prefix << port_name << "(" << signal_name << ");" << endl;
}



void connect_module_to_wrapper(const string&            module_type,
                               xtsc_module_pin_base&    module,
                               const string&            module_name,
                               const string&            name_prefix,
                               u32                      set_id)
{
  XTSC_TRACE(logger, "enter connect_module_to_wrapper()");
  for (u32 type=1; type<=6; ++type) {
    set_string ports;
    switch (type) {
      case 1: ports = module.get_wide_input_set (set_id); break;
      case 2: ports = module.get_wide_output_set(set_id); break;
      case 3: ports = module.get_uint_input_set (set_id); break;
      case 4: ports = module.get_uint_output_set(set_id); break;
      case 5: ports = module.get_bool_input_set (set_id); break;
      case 6: ports = module.get_bool_output_set(set_id); break;
    }
    for (set_string::const_iterator ip = ports.begin(); ip != ports.end(); ++ip) {
      string module_io_name(*ip);
      string wrapper_io_name(name_prefix + module_io_name);
      u32 bits = module.get_bit_width(module_io_name);
      add_wrapper_io(wrapper_io_name, bits, ((type & 0x1) != 0), (type <= 2));
      switch (type) {
        case 1: connect_wide_input (module_type, module_name, module_io_name, wrapper_io_name, bits); break;
        case 2: connect_wide_output(module_type, module_name, module_io_name, wrapper_io_name, bits); break;
        case 3: connect_uint_input (module_type, module_name, module_io_name, wrapper_io_name, bits); break;
        case 4: connect_uint_output(module_type, module_name, module_io_name, wrapper_io_name, bits); break;
        case 5: connect_bool_input (module_type, module_name, module_io_name, wrapper_io_name);       break;
        case 6: connect_bool_output(module_type, module_name, module_io_name, wrapper_io_name);       break;
      }
    }
  }
}



void connect_wide_input(const string&   module_type,
                        const string&   module_name,
                        const string&   module_input_name,
                        const string&   wrapper_input_name,
                        u32             bit_width)
{
  XTSC_TRACE(logger, "enter connect_wide_input()");
  string adapter_name(wrapper_input_name + "_adapter");
  ostringstream type;
  type << "xtsc_sc_in_sc_bv_base_adapter";
  if (bit_width > 1) {
    type << "<" << setw(4) << bit_width << ", sc_bv<" << setw(4) << bit_width << "> >";
  }
  else {
    type << "<   1, bool        >";
  }
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect wrapper input " << wrapper_input_name << " to sc_bv_base input " << module_input_name
                       << " of " << module_type << " " << module_name << " using adapter:" << endl;
  *oss_main[w] << tab2 << type.str() << " *" << adapter_name << " = new " << endl;
  *oss_main[w] << tab2 << type.str() << "(\"" << adapter_name << "\");" << endl;
  *oss_main[w] << tab2 << adapter_name << "->m_sc_in(" << wrapper_input_name << ");" << endl;
  *oss_main[w] << tab2 << module_name << "->get_wide_input(\"" << module_input_name << "\")(" << adapter_name
                       << "->m_sc_export);" << endl;
}



void connect_wide_output(const string&  module_type,
                         const string&  module_name,
                         const string&  module_output_name,
                         const string&  wrapper_output_name,
                         u32            bit_width)
{
  XTSC_TRACE(logger, "enter connect_wide_output()");
  string adapter_name(wrapper_output_name + "_adapter");
  ostringstream type;
  type << "xtsc_sc_out_sc_bv_base_adapter";
  if (bit_width > 1) {
    type << "<" << setw(4) << bit_width << ", sc_bv<" << setw(4) << bit_width << "> >";
  }
  else {
    type << "<   1, bool        >";
  }
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect sc_bv_base output " << module_output_name << " of " << module_type << " " << module_name
                       << " to wrapper output " << wrapper_output_name << " using adapter:" << endl;
  *oss_main[w] << tab2 << type.str() << " *" << adapter_name << " = new " << endl;
  *oss_main[w] << tab2 << type.str() << "(\"" << adapter_name << "\");" << endl;
  *oss_main[w] << tab2 << module_name << "->get_wide_output(\"" << module_output_name << "\")(" << adapter_name
                       << "->m_sc_export);" << endl;
  *oss_main[w] << tab2 << adapter_name << "->m_sc_out(" << wrapper_output_name << ");" << endl;
}



void connect_uint_input(const string&   module_type,
                        const string&   module_name,
                        const string&   module_input_name,
                        const string&   wrapper_input_name,
                        u32             bit_width)
{
  XTSC_TRACE(logger, "enter connect_uint_input()");
  string adapter_name(wrapper_input_name + "_adapter");
  ostringstream type;
  type << "xtsc_sc_in_sc_uint_base_adapter<" << bit_width << ", sc_uint<" << bit_width << "> >";
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect wrapper input " << wrapper_input_name << " to sc_uint_base input " << module_input_name
                       << " of " << module_type << " " << module_name << " using adapter:" << endl;
  *oss_main[w] << tab2 << type.str() << " *" << adapter_name << " = new " << endl;
  *oss_main[w] << tab2 << type.str() << "(\"" << adapter_name << "\");" << endl;
  *oss_main[w] << tab2 << adapter_name << "->m_sc_in(" << wrapper_input_name << ");" << endl;
  *oss_main[w] << tab2 << module_name << "->get_uint_input(\"" << module_input_name << "\")(" << adapter_name
                       << "->m_sc_export);" << endl;
}



void connect_uint_output(const string&  module_type,
                         const string&  module_name,
                         const string&  module_output_name,
                         const string&  wrapper_output_name,
                         u32            bit_width)
{
  XTSC_TRACE(logger, "enter connect_uint_output()");
  string adapter_name(wrapper_output_name + "_adapter");
  ostringstream type;
  type << "xtsc_sc_out_sc_uint_base_adapter<" << bit_width << ", sc_uint<" << bit_width << "> >";
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect sc_uint_base output " << module_output_name << " of " << module_type << " " << module_name
                       << " to wrapper output " << wrapper_output_name << " using adapter:" << endl;
  *oss_main[w] << tab2 << type.str() << " *" << adapter_name << " = new " << endl;
  *oss_main[w] << tab2 << type.str() << "(\"" << adapter_name << "\");" << endl;
  *oss_main[w] << tab2 << module_name << "->get_uint_output(\"" << module_output_name << "\")(" << adapter_name
                       << "->m_sc_export);" << endl;
  *oss_main[w] << tab2 << adapter_name << "->m_sc_out(" << wrapper_output_name << ");" << endl;
}



void connect_bool_input(const string&   module_type,
                        const string&   module_name,
                        const string&   module_input_name,
                        const string&   wrapper_input_name)
{
  XTSC_TRACE(logger, "enter connect_bool_input()");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect wrapper input " << wrapper_input_name << " to bool input " << module_input_name
                       << " of " << module_type << " " << module_name << ":" << endl;
  *oss_main[w] << tab2 << module_name << "->get_bool_input(\"" << module_input_name << "\")(" << wrapper_input_name << ");" << endl;
}



void connect_bool_output(const string&  module_type,
                         const string&  module_name,
                         const string&  module_output_name,
                         const string&  wrapper_output_name)
{
  XTSC_TRACE(logger, "enter connect_bool_output()");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect bool output " << module_output_name << " of " << module_type << " " << module_name
                       << " to wrapper output " << wrapper_output_name << ":" << endl;
  *oss_main[w] << tab2 << module_name << "->get_bool_output(\"" << module_output_name << "\")(" << wrapper_output_name << ");"
                       << endl;
}



void add_adapter(ostringstream& oss, const string& name, u32 bits, bool in, u32 nc) {
  XTSC_TRACE(logger, "enter add_adapter()");
  ostringstream type;
  type << (in ? "xtsc_sc_in_sc_bv_base_adapter " : "xtsc_sc_out_sc_bv_base_adapter");
  if (bits > 1) {
    type << "<" << setw(4) << bits << ", sc_bv<" << setw(4) << bits << "> >";
  }
  else {
    type << "<   1, bool        >";
  }
  const char *spc = space(nc - min(nc, name.length()));
  if (verilog_on_top) {
    oss << tab2 << type.str() << " *" << name << spc << " = new " << endl;
    oss << tab2 << type.str() << "(\"" << name << "\"" << spc << ");" << endl;
    oss << endl;
  }
  else {
    oss << tab2 << type.str() << " " << name << spc << "(\"" << name << "\"" << spc << ");" << endl;
  }
}



void add_signal(ostringstream& oss, const string& name, u32 bits, u32 nc) {
  XTSC_TRACE(logger, "enter add_signal()");
  ostringstream type;
  type << "sc_signal";
  if (bits > 1) {
    type << "<sc_bv<" << setw(4) << bits << "> >";
  }
  else {
    type << "<bool        >";
  }
  const char *spc = space(nc - min(nc, name.length()));
  if (verilog_on_top) {
    oss << tab2 << type.str() << " *" << name << spc << "= new " << type.str() << "(\"" << name << "\"" << spc << ");" << endl;
  }
  else {
    oss << tab2 << type.str() << " " << name << spc << "(\"" << name << "\"" << spc << ");" << endl;
  }
}



void add_bit_field(ostream& os, u32 bits) {
  XTSC_TRACE(logger, "enter add_bit_field()");
  if (bits < 2) {
    os << "        ";
  }
  else {
    os << "[" << setfill(' ') << setw(4) << (bits-1) << ":0]";
  }
  os << "       ";
}



void add_template_args(ostream& os, u32 bits, bool bv, bool justify) {
  os << "<";
  if (bits == 1) {
    os << "bool" << (justify ? "         " : "");
  }
  else {
    os << (bv ? "sc_bv" : "sc_uint");
    if (justify && bv) os << "  ";
    os << "<" << setw(justify ? 4 : 1) << bits << ">";
  }
  os << " >";
}



void add_proxy_io(proxy_info& proxy, const string& name, u32 bits, bool input, bool bv, bool clock) {
  XTSC_TRACE(logger, "enter add_proxy_io()");
  if (bits > 1) {
    if (bv) {
      proxy.sc_bv_list.push_back(make_pair(name, bits));
    }
    else {
      proxy.sc_uint_list.push_back(make_pair(name, bits));
    }
  }
  proxy.ports << tab1 << name << "," << endl;
  if (input) {
    proxy.inputs << tab1 << "input  ";
    add_bit_field(proxy.inputs, bits);
    proxy.inputs << name << ";" << endl;
    if (!clock) {
      proxy.displays.push_back(name);
    }
  }
  else {
    proxy.outputs << tab1 << "output ";
    add_bit_field(proxy.outputs, bits);
    proxy.outputs << name << ";" << endl;
    proxy.regs << tab1 << "reg    ";
    add_bit_field(proxy.regs, bits);
    proxy.regs << name << space(30-name.length()) << "= " << space(((bits<10) ? 3 : (bits<100) ? 2 : (bits<1000) ? 1 : 0))
               << bits << "'h0;" << endl;
  }
}



void add_wrapper_io(const string& name, u32 bits, bool input, bool bv) {
  XTSC_TRACE(logger, "enter add_wrapper_io(\"" << name << "\", " << bits << ", " << input << ", " << bv << ")");
  confirm_a_wrapper_is_defined();
  wrapper_info& wrapper = *p_current_wrapper;
  wrapper.ctor_init_list.push_back(name);
  wrapper.ports << tab1 << "sc_" << (input ? "in " : "out");
  add_template_args(wrapper.ports, bits, bv, true);
  wrapper.ports << "  " << name << ";" << endl;
  if (input) {
    wrapper.connected_input_list.push_back(make_pair(name, bits));
  }
  else {
    wrapper.connected_output_list.push_back(make_pair(name, bits));
  }
}



void add_identifier(const string& name, void *p_void) {
  XTSC_TRACE(logger, "enter add_identifier()");
  if (identifier_map[w]->find(name) != identifier_map[w]->end()) {
    ostringstream oss;
    oss << "Duplicate <Identifier> '" << name << "' found in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  (*identifier_map[w])[name] = p_void;
}



void *get_identifier(const string& name) {
  XTSC_TRACE(logger, "enter get_identifier()");
  map<string, void*>::const_iterator imap = identifier_map[w]->find(name);
  if (imap == identifier_map[w]->end()) {
    ostringstream oss;
    oss << "<Identifier> '" << name << "' not found in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  return imap->second;
}



void confirm_no_core_parameter_lookups() {
  XTSC_TRACE(logger, "enter confirm_no_core_parameter_lookups()");
  if (p_memory_parms            ||
      p_memory_pin_parms        ||
      p_memory_trace_parms      ||
      p_tlm2pin_parms           ||
      p_pin2tlm_parms           ||
      p_lookup_parms            ||
      p_arbiter_parms           ||
      p_router_parms)
  {
    ostringstream oss;
    oss << "Core parameters cannot be changed between device parameter lookup and device creation." << endl;
    oss << "Although device parameters have been obtained by core parameter lookup for at least" << endl;
    oss << "  one device (" <<
                                (p_memory_parms         ? "xtsc_memory/--memory_port"       : "") <<
                                (p_memory_pin_parms     ? " xtsc_memory_pin"                : "") <<
                                (p_memory_trace_parms   ? " xtsc_memory_trace"              : "") <<
                                (p_tlm2pin_parms        ? " xtsc_tlm2pin_memory_transactor" : "") <<
                                (p_pin2tlm_parms        ? " xtsc_pin2tlm_memory_transactor" : "") <<
                                (p_lookup_parms         ? " xtsc_lookup"                    : "") <<
                                (p_arbiter_parms        ? " xtsc_arbiter"                   : "") <<
                                (p_router_parms         ? " xtsc_router"                    : "") <<
                        "), the corresponding device(s) has not yet been created" << endl;
    oss << "  at the point in processing when the following command could possibly result in " << endl;
    oss << "  changes to core parameters: ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_assignment() {
  XTSC_TRACE(logger, "enter confirm_assignment()");
  if (!command_is_assignment) {
    ostringstream oss;
    oss << "Command should be an assignment but no equal sign found in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_non_empty_assignment() {
  XTSC_TRACE(logger, "enter confirm_non_empty_assignment()");
  confirm_assignment();
  if (rem == "") {
    ostringstream oss;
    oss << "Command should be a non-empty assignment but nothing found after equal sign found in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_identifier(const string& name) {
  if (!is_identifier(name)) {
    ostringstream oss;
    oss << "'" << name << "' is not an identifier in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_more_csv() {
  if (more_csv) {
    ostringstream oss;
    oss << "Too many arguments in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



// Step 20:  Define confirm_no_XXX_connected() methods as declared in Step 8.
void confirm_no_consumer_connected(const loader_info& li) {
  XTSC_TRACE(logger, "enter confirm_no_consumer_connected(loader_info)");
  if (li.consumer_connected) {
    ostringstream oss;
    oss << "Loader '" << li.name << "' already has a consumer connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_consumer_connected(const queue_info& qi, u32 consumer_port) {
  XTSC_TRACE(logger, "enter confirm_no_consumer_connected(queue_info, consumer_port)");
  if (consumer_port >= qi.num_consumers) {
    ostringstream oss;
    oss << "Queue '" << qi.name << "' <ConsumerPort> (" << consumer_port << ") out-of-bounds in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (qi.consumer_connected[consumer_port]) {
    ostringstream oss;
    oss << "Queue '" << qi.name << "' already has a consumer connected to consumer port #" << consumer_port
        << " so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_consumer_connected(const queue_pin_info& qi) {
  XTSC_TRACE(logger, "enter confirm_no_consumer_connected(queue_pin_info)");
  if (qi.consumer_connected) {
    ostringstream oss;
    oss << "Queue '" << qi.name << "' already has a consumer connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_export_state_connected(const core_info& ci, const string& export_state_name) {
  XTSC_TRACE(logger, "enter confirm_no_export_state_connected(core_info)");
  if (ci.export_state_connected.find(export_state_name) == ci.export_state_connected.end()) {
    ostringstream oss;
    oss << "Core '" << ci.name << "' has no export state named \"" << export_state_name << "\"; requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (ci.export_state_connected.find(export_state_name)->second) {
    ostringstream oss;
    oss << "Core '" << ci.name << "' already has export state \"" << export_state_name
        << "\" connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_first_tx_connected(const loader_info& li) {
  XTSC_TRACE(logger, "enter confirm_no_first_tx_connected(loader_info)");
  if (li.first_tx_connected) {
    ostringstream oss;
    oss << "Loader '" << li.name
        << "' already has a the first TX in the chain connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}


  
void confirm_no_import_wire_connected(const core_info& ci, const string& import_wire_name) {
  XTSC_TRACE(logger, "enter confirm_no_import_wire_connected(core_info)");
  if (ci.import_wire_connected.find(import_wire_name) == ci.import_wire_connected.end()) {
    ostringstream oss;
    oss << "Core '" << ci.name << "' has no import wire named \"" << import_wire_name << "\"; requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (ci.import_wire_connected.find(import_wire_name)->second) {
    ostringstream oss;
    oss << "Core '" << ci.name << "' already has import wire \"" << import_wire_name
        << "\" connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_inbound_connected(const core_info& ci) {
  XTSC_TRACE(logger, "enter confirm_no_inbound_connected(core_info)");
  if (ci.inbound_connected) {
    ostringstream oss;
    oss << "Core '" << ci.name << "' already has inbound PIF connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_input_queue_connected(const core_info& ci, const string& input_queue_name) {
  XTSC_TRACE(logger, "enter confirm_no_input_queue_connected(core_info)");
  if (ci.input_queue_connected.find(input_queue_name) == ci.input_queue_connected.end()) {
    ostringstream oss;
    oss << "Core '" << ci.name << "' has no input queue named \"" << input_queue_name << "\"; requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (ci.input_queue_connected.find(input_queue_name)->second) {
    ostringstream oss;
    oss << "Core '" << ci.name << "' already has input queue \"" << input_queue_name
        << "\" connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_last_tx_connected(const loader_info& li) {
  XTSC_TRACE(logger, "enter confirm_no_last_tx_connected(loader_info)");
  if (li.last_tx_connected) {
    ostringstream oss;
    oss << "Loader '" << li.name
        << "' already has a the last TX in the chain connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}


  
void confirm_no_lookup_connected(const core_info& ci, const string& lookup_name) {
  XTSC_TRACE(logger, "enter confirm_no_lookup_connected(core_info)");
  if (ci.lookup_connected.find(lookup_name) == ci.lookup_connected.end()) {
    ostringstream oss;
    oss << "Core '" << ci.name << "' has no lookup named \"" << lookup_name << "\"; requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (ci.lookup_connected.find(lookup_name)->second) {
    ostringstream oss;
    oss << "Core '" << ci.name << "' already has lookup \"" << lookup_name
        << "\" connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_lookup_connected(const driver_info& di) {
  XTSC_TRACE(logger, "enter confirm_no_lookup_connected(driver_info)");
  if (di.lookup_connected) {
    ostringstream oss;
    oss << "Driver '" << di.name << "' already has a lookup connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_master_connected(const cohctrl_info& ci, u32 cohctrl_port) {
  XTSC_TRACE(logger, "enter confirm_no_master_connected(cohctrl_info)");
  if (cohctrl_port >= ci.num_clients) {
    ostringstream oss;
    oss << "Cohctrl '" << ci.name << "' port " << cohctrl_port << " is out of range [0," << (ci.num_clients-1)
        << "] in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (ci.master_connected[cohctrl_port]) {
    ostringstream oss;
    oss << "Cohctrl '" << ci.name << "' already has a master connected to port #" << cohctrl_port
        << " so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_master_connected(const dma_info& di, u32 dma_port) {
  XTSC_TRACE(logger, "enter confirm_no_master_connected(dma_info)");
  if (dma_port >= di.num_ports) {
    ostringstream oss;
    oss << "Dma '" << di.name << "' port " << dma_port << " is out of range [0," << (di.num_ports-1) << "] in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (di.master_connected[dma_port]) {
    ostringstream oss;
    oss << "Dma '" << di.name << "' already has a master connected to port #" << dma_port
        << " so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_master_connected(const lookup_pin_info& li) {
  XTSC_TRACE(logger, "enter confirm_no_master_connected(lookup_pin_info)");
  if (li.master_connected) {
    ostringstream oss;
    oss << "Lookup '" << li.name << "' already has a master connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_master_connected(const memory_info& mi, u32 memory_port) {
  XTSC_TRACE(logger, "enter confirm_no_master_connected(memory_info)");
  if (memory_port >= mi.num_ports) {
    ostringstream oss;
    oss << "Memory '" << mi.name << "' port " << memory_port << " is out of range [0," << (mi.num_ports-1) << "] in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (mi.master_connected[memory_port]) {
    ostringstream oss;
    oss << "Memory '" << mi.name << "' already has a master connected to port #" << memory_port
        << " so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_master_connected(const memory_pin_info& mi, u32 memory_port) {
  XTSC_TRACE(logger, "enter confirm_no_master_connected(memory_pin_info)");
  if (memory_port >= mi.num_ports) {
    ostringstream oss;
    oss << "Memory '" << mi.name << "' port " << memory_port << " is out of range [0," << (mi.num_ports-1) << "] in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (mi.master_connected[memory_port]) {
    ostringstream oss;
    oss << "Memory '" << mi.name << "' already has a master connected to port #" << memory_port
        << " so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_master_connected(const memory_trace_info& mi, u32 memory_port) {
  XTSC_TRACE(logger, "enter confirm_no_master_connected(memory_trace_info)");
  if (memory_port >= mi.num_ports) {
    ostringstream oss;
    oss << "Memory trace '" << mi.name << "' port " << memory_port << " is out of range [0," << (mi.num_ports-1) << "] in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (mi.master_connected[memory_port]) {
    ostringstream oss;
    oss << "Memory trace '" << mi.name << "' already has a master connected to port #" << memory_port
        << " so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_master_connected(const mmio_info& mi) {
  XTSC_TRACE(logger, "enter confirm_no_master_connected(mmio_info)");
  if (mi.master_connected) {
    ostringstream oss;
    oss << "mmio '" << mi.name << "' already has a master connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_master_connected(const pin2tlm_info& pi, u32 memory_port) {
  XTSC_TRACE(logger, "enter confirm_no_master_connected(pin2tlm_info)");
  if (memory_port >= pi.num_ports) {
    ostringstream oss;
    oss << "pin2tlm '" << pi.name << "' port " << memory_port << " is out of range [0," << (pi.num_ports-1) << "] in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (pi.master_connected[memory_port]) {
    ostringstream oss;
    oss << "pin2tlm '" << pi.name << "' already has a master connected to port #" << memory_port 
        << " so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_master_connected(const router_info& ri) {
  XTSC_TRACE(logger, "enter confirm_no_master_connected(router_info)");
  if (ri.master_connected) {
    ostringstream oss;
    oss << "Router '" << ri.name << "' already has a master connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_master_connected(const slave_info& si) {
  XTSC_TRACE(logger, "enter confirm_no_master_connected(slave_info)");
  if (si.master_connected) {
    ostringstream oss;
    oss << "Slave '" << si.name << "' already has a master connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_master_connected(const tlm2pin_info& ti, u32 memory_port) {
  XTSC_TRACE(logger, "enter confirm_no_master_connected(tlm2pin_info)");
  if (memory_port >= ti.num_ports) {
    ostringstream oss;
    oss << "tlm2pin '" << ti.name << "' port " << memory_port << " is out of range [0," << (ti.num_ports-1) << "] in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (ti.master_connected[memory_port]) {
    ostringstream oss;
    oss << "tlm2pin '" << ti.name << "' already has a master connected to port #" << memory_port 
        << " so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_memory_connected(const core_info& ci, xtsc_core::memory_port mem_port) {
  XTSC_TRACE(logger, "enter confirm_no_memory_connected()");
  if (ci.memory_connected[mem_port]) {
    ostringstream oss;
    oss << "Core '" << ci.name << "' already has a device connected to the " << xtsc_core::get_memory_port_name(mem_port)
        << " port so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_output_queue_connected(const core_info& ci, const string& output_queue_name) {
  XTSC_TRACE(logger, "enter confirm_no_output_queue_connected(core_info)");
  if (ci.output_queue_connected.find(output_queue_name) == ci.output_queue_connected.end()) {
    ostringstream oss;
    oss << "Core '" << ci.name << "' has no output queue named \"" << output_queue_name << "\"; requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (ci.output_queue_connected.find(output_queue_name)->second) {
    ostringstream oss;
    oss << "Core '" << ci.name << "' already has output queue \"" << output_queue_name
        << "\" connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_queue_connected(const consumer_info& ci) {
  XTSC_TRACE(logger, "enter confirm_no_queue_connected(consumer_info)");
  if (ci.queue_connected) {
    ostringstream oss;
    oss << "Consumer '" << ci.name << "' already has a queue connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_queue_connected(const producer_info& pi) {
  XTSC_TRACE(logger, "enter confirm_no_queue_connected(producer_info)");
  if (pi.queue_connected) {
    ostringstream oss;
    oss << "Producer '" << pi.name << "' already has a queue connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_producer_connected(const queue_info& qi, u32 producer_port) {
  XTSC_TRACE(logger, "enter confirm_no_producer_connected(queue_info, producer_port)");
  if (producer_port >= qi.num_producers) {
    ostringstream oss;
    oss << "Queue '" << qi.name << "' <ProducerPort> (" << producer_port << ") out-of-bounds in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (qi.producer_connected[producer_port]) {
    ostringstream oss;
    oss << "Queue '" << qi.name << "' already has a producer connected to producer port #" << producer_port
        << " so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_producer_connected(const loader_info& li) {
  XTSC_TRACE(logger, "enter confirm_no_producer_connected(loader_info)");
  if (li.producer_connected) {
    ostringstream oss;
    oss << "Loader '" << li.name << "' already has a producer connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_producer_connected(const queue_pin_info& qi) {
  XTSC_TRACE(logger, "enter confirm_no_producer_connected(queue_pin_info)");
  if (qi.producer_connected) {
    ostringstream oss;
    oss << "Queue '" << qi.name << "' already has a producer connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_slave_connected(const arbiter_info& ai) {
  XTSC_TRACE(logger, "enter confirm_no_slave_connected(arbiter_info)");
  if (ai.slave_connected) {
    ostringstream oss;
    oss << "Arbiter '" << ai.name << "' already has a slave connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_slave_connected(const cohctrl_info& ci) {
  XTSC_TRACE(logger, "enter confirm_no_slave_connected(cohctrl_info)");
  if (ci.slave_connected) {
    ostringstream oss;
    oss << "Cohctrl '" << ci.name
        << "' already has a memory interface slave connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_slave_connected(const dma_info& di) {
  XTSC_TRACE(logger, "enter confirm_no_slave_connected(dma_info)");
  if (di.slave_connected) {
    ostringstream oss;
    oss << "Dma '" << di.name
        << "' already has a memory interface slave connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_slave_connected(const master_info& mi) {
  XTSC_TRACE(logger, "enter confirm_no_slave_connected(master_info)");
  if (mi.slave_connected) {
    ostringstream oss;
    oss << "Master '" << mi.name << "' already has a slave connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_slave_connected(const memory_trace_info& mi, u32 memory_port) {
  XTSC_TRACE(logger, "enter confirm_no_slave_connected(memory_trace_info)");
  if (memory_port >= mi.num_ports) {
    ostringstream oss;
    oss << "memory_trace '" << mi.name << "' port " << memory_port << " is out of range [0," << (mi.num_ports-1) << "] in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (mi.slave_connected[memory_port]) {
    ostringstream oss;
    oss << "memory_trace '" << mi.name << "' already has a slave connected to port #" << memory_port
        << " so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_slave_connected(const pin2tlm_info& pi, u32 memory_port) {
  XTSC_TRACE(logger, "enter confirm_no_slave_connected(pin2tlm_info)");
  if (memory_port >= pi.num_ports) {
    ostringstream oss;
    oss << "pin2tlm '" << pi.name << "' port " << memory_port << " is out of range [0," << (pi.num_ports-1) << "] in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (pi.slave_connected[memory_port]) {
    ostringstream oss;
    oss << "pin2tlm '" << pi.name << "' already has a slave connected to port #" << memory_port
        << " so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_slave_connected(const tlm2pin_info& ti, u32 memory_port) {
  XTSC_TRACE(logger, "enter confirm_no_slave_connected(tlm2pin_info)");
  if (memory_port >= ti.num_ports) {
    ostringstream oss;
    oss << "tlm2pin '" << ti.name << "' port " << memory_port << " is out of range [0," << (ti.num_ports-1) << "] in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (ti.slave_connected[memory_port]) {
    ostringstream oss;
    oss << "tlm2pin '" << ti.name << "' already has a slave connected to port #" << memory_port
        << " so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_snoop_connected(const core_info& ci) {
  XTSC_TRACE(logger, "enter confirm_no_snoop_connected(core_info)");
  if (ci.snoop_connected) {
    ostringstream oss;
    oss << "Core '" << ci.name << "' already has snoop connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_snoop_connected(const cohctrl_info& ci, u32 cohctrl_port) {
  XTSC_TRACE(logger, "enter confirm_no_snoop_connected(cohctrl_info)");
  if (cohctrl_port >= ci.num_clients) {
    ostringstream oss;
    oss << "Cohctrl '" << ci.name << "' port " << cohctrl_port << " is out of range [0," << (ci.num_clients-1)
        << "] in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (ci.snoop_connected[cohctrl_port]) {
    ostringstream oss;
    oss << "Cohctrl '" << ci.name << "' already has snoop port #" << cohctrl_port
        << " connected so can't connect another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_ccon_connected(const cohctrl_info& ci, u32 cohctrl_port) {
  XTSC_TRACE(logger, "enter confirm_no_ccon_connected(cohctrl_info)");
  if (cohctrl_port >= ci.num_clients) {
    ostringstream oss;
    oss << "Cohctrl '" << ci.name << "' port " << cohctrl_port << " is out of range [0," << (ci.num_clients-1)
        << "] in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (ci.ccon_connected[cohctrl_port]) {
    ostringstream oss;
    oss << "Cohctrl '" << ci.name << "' already has ccon port #" << cohctrl_port
        << " connected so can't connect another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_xfer_in_connected(const core_info& ci) {
  XTSC_TRACE(logger, "enter confirm_no_xfer_in_connected(core_info)");
  if (ci.tx_xfer_in_connected) {
    ostringstream oss;
    oss << "Core '" << ci.name << "' already has tx_xfer_in connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_xfer_out_connected(const core_info& ci) {
  XTSC_TRACE(logger, "enter confirm_no_xfer_out_connected(core_info)");
  if (ci.tx_xfer_out_connected) {
    ostringstream oss;
    oss << "Core '" << ci.name << "' already has tx_xfer_out connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_system_input_connected(const core_info& ci, const string& system_input_name) {
  XTSC_TRACE(logger, "enter confirm_no_system_input_connected(core_info)");
  if (ci.system_input_connected.find(system_input_name) == ci.system_input_connected.end()) {
    ostringstream oss;
    oss << "Core '" << ci.name << "' has no system input named \"" << system_input_name << "\"; requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (ci.system_input_connected.find(system_input_name)->second) {
    ostringstream oss;
    oss << "Core '" << ci.name << "' already has system input \"" << system_input_name
        << "\" connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_no_system_output_connected(const core_info& ci, const string& system_output_name) {
  XTSC_TRACE(logger, "enter confirm_no_system_output_connected(core_info)");
  if (ci.system_output_connected.find(system_output_name) == ci.system_output_connected.end()) {
    ostringstream oss;
    oss << "Core '" << ci.name << "' has no system output named \"" << system_output_name << "\"; requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (ci.system_output_connected.find(system_output_name)->second) {
    ostringstream oss;
    oss << "Core '" << ci.name << "' already has system output \"" << system_output_name
        << "\" connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_control_exists_and_is_not_connected(const master_info& mi) {
  XTSC_TRACE(logger, "enter confirm_control_exists_and_is_not_connected()");
  if (!mi.has_control) {
    ostringstream oss;
    oss << "master '" << mi.name << "' has no control input so can't connect to it as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (mi.control_connected) {
    ostringstream oss;
    oss << "Control input of master '" << mi.name << "' is already connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_control_exists_and_is_not_connected(const producer_info& pi) {
  XTSC_TRACE(logger, "enter confirm_control_exists_and_is_not_connected()");
  if (!pi.has_control) {
    ostringstream oss;
    oss << "producer '" << pi.name << "' has no control input so can't connect to it as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (pi.control_connected) {
    ostringstream oss;
    oss << "Control input of producer '" << pi.name << "' is already connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_control_exists_and_is_not_connected(const source_info& si) {
  XTSC_TRACE(logger, "enter confirm_control_exists_and_is_not_connected()");
  if (!si.has_control) {
    ostringstream oss;
    oss << "source '" << si.name << "' has no control input so can't connect to it as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (si.control_connected) {
    ostringstream oss;
    oss << "Control input of source '" << si.name << "' is already connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_input_exists_and_is_not_connected(const distributor_info& di, const string& input_name) {
  XTSC_TRACE(logger, "enter confirm_input_exists_and_is_not_connected()");
  map<string,bool>::const_iterator ii = di.inputs_connected.find(input_name);
  if (ii == di.inputs_connected.end()) {
    ostringstream oss;
    oss << "distributor '" << di.name << "' has no input named \"" << input_name
        << "\" so can't connect to it as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (ii->second) {
    ostringstream oss;
    oss << "Input \"" << input_name << "\" of distributor '" << di.name
        << "' is already connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_lookup_exists_and_is_not_connected(const distributor_info& di, const string& lookup_name) {
  XTSC_TRACE(logger, "enter confirm_lookup_exists_and_is_not_connected()");
  map<string,bool>::const_iterator ii = di.lookups_connected.find(lookup_name);
  if (ii == di.lookups_connected.end()) {
    ostringstream oss;
    oss << "distributor '" << di.name << "' has no lookup named \"" << lookup_name
        << "\" so can't connect to it as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (ii->second) {
    ostringstream oss;
    oss << "Input \"" << lookup_name << "\" of distributor '" << di.name
        << "' is already connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_output_exists_and_is_not_connected(const distributor_info& di, const string& output_name) {
  XTSC_TRACE(logger, "enter confirm_output_exists_and_is_not_connected()");
  map<string,bool>::const_iterator io = di.outputs_connected.find(output_name);
  if (io == di.outputs_connected.end()) {
    ostringstream oss;
    oss << "distributor '" << di.name << "' has no output named \"" << output_name << "\" so can't connect it as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (io->second) {
    ostringstream oss;
    oss << "Output \"" << output_name << "\" of distributor '" << di.name
        << "' is already connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_input_exists_and_is_not_connected(const logic_info& li, const string& input_name) {
  XTSC_TRACE(logger, "enter confirm_input_exists_and_is_not_connected()");
  map<string,bool>::const_iterator ii = li.inputs_connected.find(input_name);
  if (ii == li.inputs_connected.end()) {
    ostringstream oss;
    oss << "logic '" << li.name << "' has no input named \"" << input_name << "\" so can't connect to it as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (ii->second) {
    ostringstream oss;
    oss << "Input \"" << input_name << "\" of logic '" << li.name
        << "' is already connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_output_exists_and_is_not_connected(const loader_info& li, const string& output_name) {
  XTSC_TRACE(logger, "enter confirm_output_exists_and_is_not_connected()");
  map<string,bool>::const_iterator io = li.outputs_connected.find(output_name);
  if (io == li.outputs_connected.end()) {
    ostringstream oss;
    oss << "loader '" << li.name << "' has no output named \"" << output_name << "\" so can't connect it as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (io->second) {
    ostringstream oss;
    oss << "Output \"" << output_name << "\" of loader '" << li.name
        << "' is already connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_output_exists_and_is_not_connected(const logic_info& li, const string& output_name) {
  XTSC_TRACE(logger, "enter confirm_output_exists_and_is_not_connected()");
  map<string,bool>::const_iterator io = li.outputs_connected.find(output_name);
  if (io == li.outputs_connected.end()) {
    ostringstream oss;
    oss << "logic '" << li.name << "' has no output named \"" << output_name << "\" so can't connect it as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (io->second) {
    ostringstream oss;
    oss << "Output \"" << output_name << "\" of logic '" << li.name
        << "' is already connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_input_exists_and_is_not_connected(const mmio_info& mi, const string& input_name) {
  XTSC_TRACE(logger, "enter confirm_input_exists_and_is_not_connected()");
  map<string,bool>::const_iterator ii = mi.inputs_connected.find(input_name);
  if (ii == mi.inputs_connected.end()) {
    ostringstream oss;
    oss << "mmio '" << mi.name << "' has no input named \"" << input_name << "\" so can't connect to it as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (ii->second) {
    ostringstream oss;
    oss << "Input \"" << input_name << "\" of mmio '" << mi.name
        << "' is already connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_output_exists_and_is_not_connected(const mmio_info& mi, const string& output_name) {
  XTSC_TRACE(logger, "enter confirm_output_exists_and_is_not_connected()");
  map<string,bool>::const_iterator io = mi.outputs_connected.find(output_name);
  if (io == mi.outputs_connected.end()) {
    ostringstream oss;
    oss << "mmio '" << mi.name << "' has no output named \"" << output_name << "\" so can't connect it as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (io->second) {
    ostringstream oss;
    oss << "Output \"" << output_name << "\" of mmio '" << mi.name
        << "' is already connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_output_exists_and_is_not_connected(const source_info& si, const string& output_name) {
  XTSC_TRACE(logger, "enter confirm_output_exists_and_is_not_connected()");
  map<string,bool>::const_iterator io = si.outputs_connected.find(output_name);
  if (io == si.outputs_connected.end()) {
    ostringstream oss;
    oss << "source '" << si.name << "' has no output named \"" << output_name << "\" so can't connect it as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (io->second) {
    ostringstream oss;
    oss << "Output \"" << output_name << "\" of source '" << si.name
        << "' is already connected so can't add another one as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_coherent_core(const core_info& ci) {
  XTSC_TRACE(logger, "enter confirm_coherent_core()");
  if (!ci.parms.get_bool("DataCacheIsCoherent")) {
    ostringstream oss;
    oss << "Core '" << ci.name << "' is not a coherent core in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  if (!ci.p_core->has_export_state("CCON")) {
    ostringstream oss;
    oss << "Core '" << ci.name << "' has no TLM CCON export state in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_valid_port(const arbiter_info& ai, u32 port) {
  XTSC_TRACE(logger, "enter confirm_valid_port()");
  u32 max_port = ai.parms.get_u32("num_masters") - 1;
  if (port > max_port) {
    ostringstream oss;
    oss << "Arbiter '" << ai.name << "' port " << port << " is out of range [0," << max_port << "] in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_valid_port(const cohctrl_info& ci, u32 port) {
  XTSC_TRACE(logger, "enter confirm_valid_port()");
  u32 max_port = ci.parms.get_u32("num_clients") - 1;
  if (port > max_port) {
    ostringstream oss;
    oss << "Cohctrl '" << ci.name << "' port " << port << " is out of range [0," << max_port << "] in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_valid_port(const router_info& ri, u32 port) {
  XTSC_TRACE(logger, "enter confirm_valid_port()");
  u32 max_port = ri.parms.get_u32("num_slaves") - 1;
  if (port > max_port) {
    ostringstream oss;
    oss << "Router '" << ri.name << "' port " << port << " is out of range [0," << max_port << "] in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_valid_inbound_name(const string& port_name) {
  XTSC_TRACE(logger, "enter confirm_valid_inbound_name()");
  if ((port_name != "inbound_pif") && (port_name != "snoop")) {
    ostringstream oss;
    oss << "Port name \"" << port_name << "\" must be either \"inbound_pif\" or \"snoop\" in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_systemc_on_top() {
  XTSC_TRACE(logger, "enter confirm_systemc_on_top()");
  if (!systemc_on_top) {
    ostringstream oss;
    oss << "A Systemc on top of Verilog cosimulation hasn't been declared (using the --cosim command) " 
        << "as required to use command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_verilog_on_top() {
  XTSC_TRACE(logger, "enter confirm_verilog_on_top()");
  if (!verilog_on_top) {
    ostringstream oss;
    oss << "A Verilog on top of SystemC cosimulation hasn't been declared (using the --cosim command) " 
        << "as required to use command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_a_wrapper_is_defined() {
  XTSC_TRACE(logger, "enter confirm_a_wrapper_is_defined()");
  confirm_verilog_on_top();
  if (p_current_wrapper == NULL) {
    ostringstream oss;
    oss << "No SystemC wrapper has been created but one is required in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_building_system() {
  XTSC_TRACE(logger, "enter confirm_building_system()");
  if (wrapper_state != BUILDING_SYSTEM) {
    ostringstream oss;
    oss << "Missing --create_wrapper command prior to command ";
    command_info(oss);
    oss << " (XTSC objects must be configured, created, and connected \"inside\" a wrapper"
        << " when generating a Verilog on top of SystemC simulation)";
    throw xtsc_exception(oss.str());
  }
}



void confirm_pin_level(const consumer_info& ci) {
  XTSC_TRACE(logger, "enter confirm_pin_level(consumer_info)");
  if (!ci.parms.get_bool("pin_level")) {
    ostringstream oss;
    oss << "Consumer '" << ci.name << "' has \"pin_level\"=false so cannot connect with Verilog as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_pin_level(const driver_info& di) {
  XTSC_TRACE(logger, "enter confirm_pin_level(driver_info)");
  if (!di.parms.get_bool("pin_level")) {
    ostringstream oss;
    oss << "Driver '" << di.name << "' has \"pin_level\"=false so cannot connect with Verilog as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_pin_level(const loader_info& li) {
  XTSC_TRACE(logger, "enter confirm_pin_level(loader_info)");
  if (!li.parms.get_bool("pin_level")) {
    ostringstream oss;
    oss << "Loader '" << li.name << "' has \"pin_level\"=false so cannot connect with Verilog as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_pin_level(const producer_info& pi) {
  XTSC_TRACE(logger, "enter confirm_pin_level(producer_info)");
  if (!pi.parms.get_bool("pin_level")) {
    ostringstream oss;
    oss << "Producer '" << pi.name << "' has \"pin_level\"=false so cannot connect with Verilog as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void confirm_pin_level(const source_info& si) {
  XTSC_TRACE(logger, "enter confirm_pin_level(source_info)");
  if (!si.parms.get_bool("pin_level")) {
    ostringstream oss;
    oss << "Source '" << si.name << "' has \"pin_level\"=false so cannot connect with Verilog as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



bool get_pin_level_and_confirm_match(const producer_info& pi, const loader_info& li) {
  bool pin_level = pi.parms.get_bool("pin_level");
  if (li.parms.get_bool("pin_level") != pin_level) {
    ostringstream oss;
    oss << "Producer '" << pi.name << "' has \"pin_level\"=" << boolalpha << pin_level << " but loader '" << li.name
        << "' has \"pin_level\"=" << (!pin_level) << " so cannot connect them as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  u32 bit_width = pi.parms.get_u32("bit_width");
  if (bit_width != 32) {
    ostringstream oss;
    oss << "Producer '" << pi.name << "' has \"bit_width\"=" << bit_width 
        << " so cannot connect it to 32-bit command queue interface of loader '" << li.name << "' as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  return pin_level;
}



bool get_pin_level_and_confirm_match(const loader_info& li, const consumer_info& ci) {
  bool pin_level = li.parms.get_bool("pin_level");
  if (ci.parms.get_bool("pin_level") != pin_level) {
    ostringstream oss;
    oss << "Loader '" << li.name << "' has \"pin_level\"=" << boolalpha << pin_level << " but consumer '" << ci.name
        << "' has \"pin_level\"=" << (!pin_level) << " so cannot connect them as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  u32 bit_width = ci.parms.get_u32("bit_width");
  if (bit_width != 32) {
    ostringstream oss;
    oss << "Consumer '" << ci.name << "' has \"bit_width\"=" << bit_width 
        << " so cannot connect it to 32-bit read queue interface of loader '" << li.name << "' as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  return pin_level;
}



void do_final_program_name_and_args(int argc, int argi) {
  XTSC_TRACE(logger, "enter do_final_program_name_and_args()");

  // Infer a core instantiation?
  infer_create_core("");
  init_core_parms();

  // If the last core instantiated does not have a program, then we assume
  // this program is for it.  Otherwise, in the final_processing() method 
  // we'll infer a core and give it this program.
  core_program = commands[argi++];
  bool set_explicit_core_parm_set = true;
  XTSC_DEBUG(logger, "final program name: >" << core_program << "<");
  core_program_argv = new const char *[argc-argi+1];
  core_program_argv[argc-argi] = NULL;
  for (int i=0; argi<argc; ++argi, ++i) {
    core_program_argv[i] = commands[argi].c_str();
    XTSC_DEBUG(logger, "               arg: >" << commands[argi] << "<");
  }
  if (last_core_created != "") {
    map<string,core_info*>::iterator ic = core_map[w]->find(last_core_created);
    if (ic == core_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find core '" << last_core_created << "' to load final program to.";
      throw xtsc_exception(oss.str());
    }
    if (!ic->second->has_program_loaded) {
      ic->second->load_program();
      set_explicit_core_parm_set = false;
    }
  }
  if (set_explicit_core_parm_set) {
    explicit_core_parm_set = true;
  }

  XTSC_TRACE(logger, "exit do_final_program_name_and_args(), explicit_core_parm_set=" << explicit_core_parm_set);
}



bool parse_boolean_assignment() {
  XTSC_TRACE(logger, "enter parse_boolean_assignment()");
  if ((rem_lc == "t") || (rem_lc == "true")) return true;
  if ((rem_lc == "f") || (rem_lc == "false")) return false;
  ostringstream oss;
  oss << "Command should be a boolean assignment but 'true'/'false' not found in command ";
  command_info(oss);
  throw xtsc_exception(oss.str());
}



void parse_cosim() {
  XTSC_TRACE(logger, "enter parse_cosim()");

  string top     = top_env;
  vendor         = vendor_env;
  vendor_version = vendor_version_env;
  gcc_version    = gcc_version_env;

  if (command_is_assignment) {
    if (more_csv) {
      parse_csv();
      if (csv != "") {
        top = csv;
      }
      if (more_csv) {
        parse_csv();
        if (csv != "") {
          vendor = csv;
        }
        if (more_csv) {
          parse_csv();
          if (csv != "") {
            vendor_version = csv;
          }
          if (more_csv) {
            parse_csv();
            if (csv != "") {
              gcc_version = csv;
            }
            confirm_no_more_csv();
          }
        }
      }
    }
  }

  ostringstream cosim_env;
  cosim_env << "Environment variables:" << endl
            << "  XTSC_RUN_COSIM_TOP_LANGUAGE   = " << top_env            << endl
            << "  XTSC_RUN_COSIM_VENDOR         = " << vendor_env         << endl
            << "  XTSC_RUN_COSIM_VENDOR_VERSION = " << vendor_version_env << endl
            << "  XTSC_RUN_COSIM_GCC_VERSION    = " << gcc_version_env;

  if ((top != "systemc") && (top != "verilog")) {
    ostringstream oss;
    oss << "<TopLanguage> must be one of systemc|verilog in command: ";
    command_info(oss);
    oss << endl << cosim_env.str();
    throw xtsc_exception(oss.str());
  }

  if ((vendor != "cadence") && (vendor != "mentor") && (vendor != "synopsys")) {
    ostringstream oss;
    oss << "<Vendor> must be one of cadence|mentor|synopsys in command: ";
    command_info(oss);
    oss << endl << cosim_env.str();
    throw xtsc_exception(oss.str());
  }

  if (vendor_version == "") {
    ostringstream oss;
    oss << "<VendorVersion> must be specified in command: ";
    command_info(oss);
    oss << endl << cosim_env.str();
    throw xtsc_exception(oss.str());
  }

  u32 periods = 0;
  bool adjacent = false;
  bool previous = false;
  for (u32 i=0; i < gcc_version.size(); ++i) {
    if (gcc_version[i] == '.') {
      periods += 1;
      if (previous) {
        adjacent = true;
      }
      previous = true;
    }
    else {
      previous = false;
    }
  }
  if ((periods != 2) || adjacent || (gcc_version[0] == '.') || (gcc_version[gcc_version.size()-1] == '.')) {
    ostringstream oss;
    oss << "<GccVersion> must be in format X.Y.Z (X=major version, Y=minor version, Z=patch level) in --cosim command: ";
    command_info(oss);
    oss << endl << cosim_env.str();
    throw xtsc_exception(oss.str());
  }

  gcc_minor_version = gcc_version.substr(0,gcc_version.find_last_of('.'));

  if (top == "systemc") { systemc_on_top  = true; }
  else                  { verilog_on_top  = true; }
  if (gcc_version == "3.2.3") {
    isslibdir = "iss-RHEL3";
  }
  else if (xtsc_64bit) {
    isslibdir = "iss-x86_64";
  }
  else {
    isslibdir = "iss-GCC-" + gcc_minor_version;
  }
  if (!sc_main_command) {
    sc_main_name  = "sc_main.cpp";  // This effectively changes what the default sc_main name is
  }
  multi_core_debug_sync = true;     // This changes what the default synchronized option is
}



void parse_show_modules() {
  XTSC_TRACE(logger, "enter parse_show_modules()");
  bool verbose = command_is_assignment;
  show_modules(verbose, false);
}



void parse_cycle_limit() {
  XTSC_TRACE(logger, "enter parse_cycle_limit()");
  confirm_assignment();
  cycle_limit = strtou32(rem);
}



void parse_squelch_ctor() {
  XTSC_TRACE(logger, "enter parse_squelch_ctor()");
  log4xtensa::LogLevel ll = log4xtensa::OFF_LOG_LEVEL;
  if (command_is_assignment) {
         if (rem_lc == "off"    ) ll = log4xtensa::OFF_LOG_LEVEL;
    else if (rem_lc == "fatal"  ) ll = log4xtensa::FATAL_LOG_LEVEL;
    else if (rem_lc == "error"  ) ll = log4xtensa::ERROR_LOG_LEVEL;
    else if (rem_lc == "warn"   ) ll = log4xtensa::WARN_LOG_LEVEL;
    else if (rem_lc == "note"   ) ll = log4xtensa::NOTE_LOG_LEVEL;
    else if (rem_lc == "info"   ) ll = log4xtensa::INFO_LOG_LEVEL;
    else if (rem_lc == "verbose") ll = log4xtensa::VERBOSE_LOG_LEVEL;
    else if (rem_lc == "debug"  ) ll = log4xtensa::DEBUG_LOG_LEVEL;
    else if (rem_lc == "trace"  ) ll = log4xtensa::TRACE_LOG_LEVEL;
    else if (rem_lc == "all"    ) ll = log4xtensa::ALL_LOG_LEVEL;
    else {
      ostringstream oss;
      oss << "Invalid assignment (expected off|fatal|error|warn|note|info|verbose|debug|trace|all ) in command ";
      command_info(oss);
      throw xtsc_exception(oss.str());
    }
  }
  xtsc_set_constructor_log_level(ll);
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "xtsc_set_constructor_log_level(" << ll << ");" << endl;
}



void parse_no_sim() {
  XTSC_TRACE(logger, "enter parse_no_sim()");
  if (command_is_assignment) {
    no_simulation = parse_boolean_assignment();
    if (cosim && !no_simulation) {
      ostringstream oss;
      oss << "Simulation cannot be selected when generating files for SystemC-Verilog cosimulation.  Bad command: ";
      command_info(oss);
      throw xtsc_exception(oss.str());
    }
  }
  else {
    no_simulation = true;
  }
}



void parse_no_default_mem() {
  XTSC_TRACE(logger, "enter parse_no_default_mem()");
  if (command_is_assignment) {
    no_default_mem = parse_boolean_assignment();
  }
  else {
    no_default_mem = true;
  }
}



void parse_no_default_local_mem() {
  XTSC_TRACE(logger, "enter parse_no_default_local_mem()");
  if (command_is_assignment) {
    no_default_local_mem = parse_boolean_assignment();
  }
  else {
    no_default_local_mem = true;
  }
}



void parse_string_array_separator() {
  XTSC_TRACE(logger, "enter parse_string_array_separator()");
  confirm_assignment();
  if ((rem.size() != 1) || !isprint(rem[0])) {
    stringstream oss;
    oss << "Expected a single argument of a single printable character in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  string_array_separator = rem;
}



void parse_summary() {
  XTSC_TRACE(logger, "enter parse_summary()");
  bool now = false;
  bool verbose = false;
  if (command_is_assignment) {
    string first  = "";
    string second = "";
    if (more_csv) {
      parse_csv();
      first = csv;
      if (more_csv) {
        parse_csv();
        second = csv;
        confirm_no_more_csv();
      }
    }
    else {
      first = rem_lc;
    }

    if ((first == "v") || (first == "verbose")) {
      verbose = true;
      first = "";
    }
    if ((second == "v") || (second == "verbose")) {
      verbose = true;
      second = "";
    }
    if ((first == "n") || (first == "now")) {
      now = true;
      first = "";
    }
    if ((second == "n") || (second == "now")) {
      now = true;
      second = "";
    }
    if (first != "") {
      ostringstream oss;
      oss << "First argument unrecognized (expected 'verbose' or 'now') in command ";
      command_info(oss);
      throw xtsc_exception(oss.str());
    }
    if (second != "") {
      ostringstream oss;
      oss << "Second argument unrecognized (expected 'verbose' or 'now') in command ";
      command_info(oss);
      throw xtsc_exception(oss.str());
    }
  }
  if (now) {
    log_summary(verbose);
  }
  else {
    summary = true;
    summary_verbose = verbose;
  }
}



void parse_memory_port() {
  XTSC_TRACE(logger, "enter parse_memory_port()");
  if (p_memory_parms) {
    create_memory("");
  }
  confirm_assignment();
  use_memport = xtsc_core::get_memory_port(rem);
  use_memport_had_ls = (rem_lc.find("ls") != string::npos);
}



void parse_memory_pin_port() {
  XTSC_TRACE(logger, "enter parse_memory_pin_port()");
  if (p_memory_pin_parms || p_tlm2pin_parms || p_pin2tlm_parms) {
    ostringstream oss;
    string object = p_memory_pin_parms ? "memory_pin" : p_tlm2pin_parms ? "tlm2pin" : "pin2tlm";
    oss << "There are " << object << " parameters already defined so you must instantiate a " << object
        << " object prior to envoking the --memory_pin_port command";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  confirm_assignment();
  use_memport_pin = xtsc_core::get_memory_port(rem);
  use_memport_pin_had_ls = (rem_lc.find("ls") != string::npos);
}



void parse_core_args() {
  XTSC_TRACE(logger, "enter parse_core_args()");
  confirm_assignment();
  init_core_parms();
  explicit_core_parm_set = true;
  vector<char*> args;
  while (more_csv) {
    parse_csv();
    args.push_back(xtsc_copy_c_str(csv.c_str()));
  }
  core_program_argv = new const char *[args.size()+1];
  core_program_argv[args.size()] = NULL;
  vector<char*>::iterator ia = args.begin();
  for (u32 i=0; i < args.size(); ++i, ++ia) {
    core_program_argv[i] = *ia;
  }
}



void parse_core_summary() {
  XTSC_TRACE(logger, "enter parse_core_summary()");
  bool summary = true;
  if (command_is_assignment) {
    if (more_csv && ((rem_lc == "f") || (rem_lc == "false"))) {
      summary = false;
    }
    else if (!more_csv || ((rem_lc != "t") && (rem_lc != "true"))) {
      ostringstream oss;
      oss << "Syntax error (expected --core_summary, or --core_summary=true, or --core_summary=false) in command ";
      command_info(oss);
      throw xtsc_exception(oss.str());
    }
  }
  core_summary = summary;
}



// multi_core_debug[=nowait,sync,<StartingPort>]
void parse_multi_core_debug() {
  XTSC_TRACE(logger, "enter parse_multi_core_debug()");
  parse_core_debug_helper();
  multi_core_debug_sync         = debug_sync;
  multi_core_debug_wait         = debug_wait;
  multi_core_debug_start_port   = debug_start_port;
  multi_core_debug              = true;
}



// core_debug[=nowait,sync,<StartingPort>]
void parse_core_debug() {
  XTSC_TRACE(logger, "enter parse_core_debug()");
  init_core_parms();
  explicit_core_parm_set = true;
  parse_core_debug_helper();
  core_debug_sync               = debug_sync;
  core_debug_wait               = debug_wait;
  core_debug_start_port         = debug_start_port;
  core_debug                    = true;
}



//       core_debug[=nowait,sync,<StartingPort>]
// multi_core_debug[=nowait,sync,<StartingPort>]
void parse_core_debug_helper() {
  XTSC_TRACE(logger, "enter parse_core_debug_helper()");
  debug_wait       = true;
  debug_sync       = cosim;
  debug_start_port = 0;
  if (command_is_assignment) {
    string first  = "";
    string second = "";
    string third = "";
    if (more_csv) {
      parse_csv();
      first = csv;
      if (more_csv) {
        parse_csv();
        second = csv;
        if (more_csv) {
          parse_csv();
          third = csv;
          confirm_no_more_csv();
        }
      }
    }
    else {
      first = rem_lc;
    }

    if ((first == "s") || (first == "sync") || (first == "synchronize") || (first == "synchronized")) {
      debug_sync = true;
      first = "";
    }
    if ((second == "s") || (second == "sync") || (second == "synchronize") || (second == "synchronized")) {
      debug_sync = true;
      second = "";
    }
    if ((third == "s") || (third == "sync") || (third == "synchronize") || (third == "synchronized")) {
      debug_sync = true;
      third = "";
    }

    if ((first == "nos") || (first == "nosync") || (first == "nosynchronize") || (first == "nosynchronized")) {
      debug_sync = false;
      first = "";
    }
    if ((first == "nos") || (second == "nosync") || (second == "nosynchronize") || (second == "nosynchronized")) {
      debug_sync = false;
      second = "";
    }
    if ((first == "nos") || (third == "nosync") || (third == "nosynchronize") || (third == "nosynchronized")) {
      debug_sync = false;
      third = "";
    }

    if ((first == "w") || (first == "wait") || (first == "n") || (first == "nowait")) {
      debug_wait = (first[0] == 'w');
      first = "";
    }
    if ((second == "w") || (second == "wait") || (first == "n") || (first == "nowait")) {
      debug_wait = (first[0] == 'w');
      second = "";
    }
    if ((third == "w") || (third == "wait") || (first == "n") || (first == "nowait")) {
      debug_wait = (first[0] == 'w');
      third = "";
    }
    if (first != "") {
      debug_start_port = strtou32(first);
      first = "";
    }
    else if (second != "") {
      debug_start_port = strtou32(second);
      second = "";
    }
    else if (third != "") {
      debug_start_port = strtou32(third);
      third = "";
    }
    if (second != "") {
      ostringstream oss;
      oss << "Second argument unrecognized (expected '<StartPort>', 'block', or 'wait') in command ";
      command_info(oss);
      throw xtsc_exception(oss.str());
    }
    if (third != "") {
      ostringstream oss;
      oss << "Third argument unrecognized (expected '<StartPort>', 'block', or 'wait') in command ";
      command_info(oss);
      throw xtsc_exception(oss.str());
    }
  }
}



// multi_core_profile[=TRUE|false]
void parse_multi_core_profile() {
  XTSC_TRACE(logger, "enter parse_multi_core_profile()");
  multi_core_profile = true;
  if (command_is_assignment) {
    string arg;
    if (more_csv) {
      parse_csv();
      arg = csv;
      transform(arg.begin(), arg.end(), arg.begin(), ::tolower);
      confirm_no_more_csv();
    }
    else {
      arg = rem_lc;
    }
    if ((arg == "true") || (arg == "t") || (arg == "on") || (arg == "")) {
      multi_core_profile = true;
    }
    else if ((arg == "false") || (arg == "f") || (arg == "off")) {
      multi_core_profile = false;
    }
    else {
      ostringstream oss;
      oss << "Unrecognized argument (expected 'true' or 'false') in command ";
      command_info(oss);
      throw xtsc_exception(oss.str());
    }
  }
}



void parse_core_client() {
  XTSC_TRACE(logger, "enter parse_core_client()");
  init_core_parms();
  explicit_core_parm_set = true;
  confirm_non_empty_assignment();
  if ((rem_lc.length() >= 7) && (rem_lc.substr(0, 7) == "loadbin")) {
    ostringstream oss;
    oss << "Use the \"SimClients\" or \"SimClientFile\" parameter in lieu of the --core_client command for the loadbin client: ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  // There may be more than one to keep track of, so use a vector<string>
  core_client.push_back(rem);
}



void parse_core_program() {
  XTSC_TRACE(logger, "enter parse_core_program()");
  init_core_parms();
  explicit_core_parm_set = true;
  confirm_assignment();
  core_program = rem;
  if (core_program == "") {
    explicit_no_program = true;
  }
  XTSC_DEBUG(logger, "core_program: >" << core_program << "<");
}



void parse_csv() {
  XTSC_TRACE(logger, "enter parse_csv()");
  if (!more_csv) {
    ostringstream oss;
    oss << "Required comma separated value (csv) missing in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  string::size_type pos = rem.find_first_of(",");
  if (pos == string::npos) {
    csv = rem;
    more_csv = false;
  }
  else {
    csv = rem.substr(0, pos);
    rem   .erase(0, pos+1);
    rem_lc.erase(0, pos+1);
    more_csv = true;
  }
  XTSC_DEBUG(logger, "parse_csv(): csv: >" << csv << "<  more_csv=" << (more_csv ? "true" : "false"));
}



void parse_non_empty_csv() {
  XTSC_TRACE(logger, "enter parse_non_empty_csv()");
  parse_csv();
  if (csv == "") {
    ostringstream oss;
    oss << "Comma separated value (csv) is empty in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void parse_identifier_csv() {
  XTSC_TRACE(logger, "enter parse_identifier_csv()");
  parse_non_empty_csv();
  confirm_identifier(csv);
}



// Step 21:  Define parse_create_widget() method if declared in Step 9.

// --create_lookup[=<LookupName>[,<TiePortName>]]
void parse_create_lookup() {
  XTSC_TRACE(logger, "enter parse_create_lookup()");
  string lookup_name = "";
  string tie_name   = "";
  if (command_is_assignment) {
    parse_identifier_csv();
    lookup_name = csv;
    if (more_csv) {
      parse_identifier_csv();
      confirm_no_more_csv();
      tie_name = csv;
    }
  }
  create_lookup(lookup_name, tie_name);
}



// --create_lookup_pin[=<LookupName>[,<TiePortName>]]
void parse_create_lookup_pin() {
  XTSC_TRACE(logger, "enter parse_create_lookup_pin()");
  string lookup_pin_name = "";
  string tie_name   = "";
  if (command_is_assignment) {
    parse_identifier_csv();
    lookup_pin_name = csv;
    if (more_csv) {
      parse_identifier_csv();
      confirm_no_more_csv();
      tie_name = csv;
    }
  }
  create_lookup_pin(lookup_pin_name, tie_name);
}



// --create_queue[=<QueueName>[,<TiePortName>]]
void parse_create_queue() {
  XTSC_TRACE(logger, "enter parse_create_queue()");
  string queue_name = "";
  string tie_name   = "";
  if (command_is_assignment) {
    parse_identifier_csv();
    queue_name = csv;
    if (more_csv) {
      parse_identifier_csv();
      confirm_no_more_csv();
      tie_name = csv;
    }
  }
  create_queue(queue_name, tie_name);
}



// --create_queue_pin[=<QueueName>[,<TiePortName>]]
void parse_create_queue_pin() {
  XTSC_TRACE(logger, "enter parse_create_queue_pin()");
  string queue_pin_name = "";
  string tie_name   = "";
  if (command_is_assignment) {
    parse_identifier_csv();
    queue_pin_name = csv;
    if (more_csv) {
      parse_identifier_csv();
      confirm_no_more_csv();
      tie_name = csv;
    }
  }
  create_queue_pin(queue_pin_name, tie_name);
}



// --create_signal=<SignalName>
void parse_create_signal() {
  XTSC_TRACE(logger, "enter parse_create_signal()");
  confirm_assignment();

  parse_identifier_csv();
  string signal_name = csv;

  confirm_no_more_csv();

  create_signal(signal_name);
}



// --create_wire[=<WireName>[,<TiePortName>]]
void parse_create_wire() {
  XTSC_TRACE(logger, "enter parse_create_wire()");
  string wire_name = "";
  string tie_name  = "";
  if (command_is_assignment) {
    parse_identifier_csv();
    wire_name = csv;
    if (more_csv) {
      parse_identifier_csv();
      confirm_no_more_csv();
      tie_name = csv;
    }
  }
  create_wire(wire_name, tie_name);
}



// Infer and connect default memories for unconnected core memory ports
void do_default_mem(core_info& ci) {
  XTSC_TRACE(logger, "enter do_default_mem(\"" << ci.name << "\")");
  if (p_memory_parms) {
    ostringstream oss;
    oss << "PROGRAM BUG: no outstanding memory_parm allowed when do_default_mem is called";
    throw xtsc_exception(oss.str());
  }
  XTSC_DEBUG(logger, "Checking for default memories for core '" << ci.name << "'.");
  // Save the user specified memory_port
  xtsc_core::memory_port save_use_memport = use_memport;
  // Iterate core memory ports
  for (use_memport = xtsc_core::MEM_FIRST; use_memport <= xtsc_core::MEM_LAST; ++use_memport) {
    if (ci.no_default_local_mem && (use_memport != xtsc_core::MEM_PIF)) continue;
    if (!ci.p_core->has_memory_port(use_memport)) continue;
    // Include the ls0/ls1 suffix if core is dual-ported, this is a dual-type port, and other port is connected
    bool ignore_ls_unit = true;
    if (ci.p_core->is_dual_ported(ci.p_core->is_xlmi(use_memport))) {
      if ((xtsc_core::is_ls_dual_port(use_memport, 0) && ci.memory_connected[use_memport+1]) ||
          (xtsc_core::is_ls_dual_port(use_memport, 1) && ci.memory_connected[use_memport-1]))
      {
        ignore_ls_unit = false;
      }
    }
    string memory_port_name = xtsc_core::get_memory_port_name(use_memport, ignore_ls_unit);
    string memory_name = ci.name + "_" + memory_port_name;
    if (!ci.memory_connected[use_memport]) {
      XTSC_DEBUG(logger, "Creating default memory '" << memory_name << "' for core '" << ci.name << "'.");
      if (!p_memory_parms) {
        name_memory_parms = "memory_parms__@";
        p_memory_parms = new xtsc_memory_parms(*ci.p_core, memory_port_name.c_str());
        ostringstream args;
        args << "(*" << ci.name << ", \"" << memory_port_name << "\")";
        memory_parms_args = args.str();
      }
      create_memory(memory_name, &ci.parms);
      connect_core_memory(ci.name, 0, memory_name);
    }
  }
  // Restore the user specified memory_port
  use_memport = save_use_memport;
}



// Step 22:  Define parse_connect_XXX_widget() and parse_connect_widget_XXX() methods to match
//           those declared in Step 10.


// connect_arbiter_arbiter=<MasterName>,<SlavePort>,<SlaveName>
void parse_connect_arbiter_arbiter() {
  XTSC_TRACE(logger, "enter parse_connect_arbiter_arbiter()");
  confirm_assignment();

  parse_identifier_csv();
  string master_name = csv;

  parse_non_empty_csv();
  u32 port = strtou32(csv);

  parse_identifier_csv();
  string slave_name = csv;

  confirm_no_more_csv();

  connect_arbiter_arbiter(master_name, port, slave_name);
}



// connect_arbiter_cohctrl=<ArbiterName>[,<CohctrlPort>],<CohctrlName>
void parse_connect_arbiter_cohctrl() {
  XTSC_TRACE(logger, "enter parse_connect_arbiter_cohctrl()");
  confirm_assignment();

  parse_identifier_csv();
  string arbiter_name = csv;

  parse_non_empty_csv();

  u32 cohctrl_port = 0xFFFFFFFF;

  if (more_csv) {
    cohctrl_port = strtou32(csv);
    parse_non_empty_csv();
    confirm_no_more_csv();
  }

  confirm_identifier(csv);
  string cohctrl_name = csv;

  if (cohctrl_port == 0xFFFFFFFF) {
    cohctrl_info& ci = find_or_infer_cohctrl(cohctrl_name);
    cohctrl_port = ci.get_first_free_master_port();
  }

  connect_arbiter_cohctrl(arbiter_name, cohctrl_port, cohctrl_name);
}



// connect_arbiter_core=<ArbiterName>[,<PortName>],<CoreName>
void parse_connect_arbiter_core() {
  XTSC_TRACE(logger, "enter parse_connect_arbiter_core()");
  confirm_assignment();

  parse_identifier_csv();
  string arbiter_name = csv;

  parse_identifier_csv();
  string port_name = "inbound_pif";

  if (more_csv) {
    port_name = csv;
    parse_identifier_csv();
    confirm_no_more_csv();
  }

  string core_name = csv;

  connect_arbiter_core(arbiter_name, port_name, core_name);
}



// connect_arbiter_dma=<ArbiterName>[,<DmaPort>],<DmaName>
void parse_connect_arbiter_dma() {
  XTSC_TRACE(logger, "enter parse_connect_arbiter_dma()");
  confirm_assignment();

  parse_identifier_csv();
  string arbiter_name = csv;

  parse_non_empty_csv();

  u32 dma_port = 0;

  if (more_csv) {
    dma_port = strtou32(csv);
    parse_non_empty_csv();
    confirm_no_more_csv();
  }

  confirm_identifier(csv);
  string dma_name = csv;

  connect_arbiter_dma(arbiter_name, dma_port, dma_name);
}



// connect_arbiter_memory=<ArbiterName>[,<MemoryPort>],<MemoryName>
void parse_connect_arbiter_memory() {
  XTSC_TRACE(logger, "enter parse_connect_arbiter_memory()");
  confirm_assignment();

  parse_identifier_csv();
  string arbiter_name = csv;

  parse_non_empty_csv();

  u32 memory_port = 0;

  if (more_csv) {
    memory_port = strtou32(csv);
    parse_non_empty_csv();
    confirm_no_more_csv();
  }

  confirm_identifier(csv);
  string memory_name = csv;

  connect_arbiter_memory(arbiter_name, memory_port, memory_name);
}



// connect_arbiter_memory_trace=<ArbiterName>[,<TracePort>],<TraceName>
void parse_connect_arbiter_memory_trace() {
  XTSC_TRACE(logger, "enter parse_connect_arbiter_memory_trace()");
  confirm_assignment();

  parse_identifier_csv();
  string arbiter_name = csv;

  parse_non_empty_csv();

  u32 trace_port = 0;

  if (more_csv) {
    trace_port = strtou32(csv);
    parse_non_empty_csv();
    confirm_no_more_csv();
  }

  confirm_identifier(csv);
  string trace_name = csv;

  connect_arbiter_memory_trace(arbiter_name, trace_port, trace_name);
}



// connect_arbiter_mmio=<ArbiterName>,<MmioName>
void parse_connect_arbiter_mmio() {
  XTSC_TRACE(logger, "enter parse_connect_arbiter_mmio()");
  confirm_assignment();

  parse_identifier_csv();
  string arbiter_name = csv;

  parse_identifier_csv();
  string mmio_name = csv;

  confirm_no_more_csv();

  connect_arbiter_mmio(arbiter_name, mmio_name);
}



// connect_arbiter_router=<ArbiterName>,<RouterName>
void parse_connect_arbiter_router() {
  XTSC_TRACE(logger, "enter parse_connect_arbiter_router()");
  confirm_assignment();

  parse_identifier_csv();
  string arbiter_name = csv;

  parse_identifier_csv();
  string router_name = csv;

  confirm_no_more_csv();

  connect_arbiter_router(arbiter_name, router_name);
}



// connect_arbiter_slave=<ArbiterName>,<SlaveName>
void parse_connect_arbiter_slave() {
  XTSC_TRACE(logger, "enter parse_connect_arbiter_slave()");
  confirm_assignment();

  parse_identifier_csv();
  string arbiter_name = csv;

  parse_identifier_csv();
  string slave_name = csv;

  confirm_no_more_csv();

  connect_arbiter_slave(arbiter_name, slave_name);
}



// connect_arbiter_tlm2pin=<ArbiterName>[,<Tlm2pinPort>],<Tlm2pinName>
void parse_connect_arbiter_tlm2pin() {
  XTSC_TRACE(logger, "enter parse_connect_arbiter_tlm2pin()");
  confirm_assignment();

  parse_identifier_csv();
  string arbiter_name = csv;

  string tlm2pin_name;
  u32 tlm2pin_port = 0;

  parse_non_empty_csv();
  string second = csv;

  if (more_csv) {
    parse_identifier_csv();
    tlm2pin_name = csv;
    confirm_no_more_csv();
    tlm2pin_port = strtou32(second);
  }
  else {
    tlm2pin_name = second;
    confirm_identifier(tlm2pin_name);
  }

  connect_arbiter_tlm2pin(arbiter_name, tlm2pin_port, tlm2pin_name);
}



// connect_clock_proxy=<ClockName>[,<InputName>],<ProxyName>
void parse_connect_clock_proxy() {
  XTSC_TRACE(logger, "enter parse_connect_clock_proxy()");
  confirm_assignment();

  parse_identifier_csv();
  string clock_name = csv;

  string input_name;
  string proxy_name;

  parse_identifier_csv();
  string second = csv;

  if (more_csv) {
    input_name = second;
    parse_identifier_csv();
    proxy_name = csv;
    confirm_no_more_csv();
  }
  else {
    input_name = clock_name;
    proxy_name = second;
  }

  connect_clock_proxy(clock_name, input_name, proxy_name);
}



// connect_clock_wrapper=<ClockName>,<WrapperOutputName>
void parse_connect_clock_wrapper() {
  XTSC_TRACE(logger, "enter parse_connect_clock_wrapper()");
  confirm_assignment();

  parse_identifier_csv();
  string clock_name = csv;

  parse_identifier_csv();
  string wrapper_output_name = csv;

  confirm_no_more_csv();

  connect_clock_wrapper(clock_name, wrapper_output_name);
}



// connect_cohctrl_arbiter=<CohctrlName>[,<SnoopPort],<ArbiterPort>,<ArbiterName>
void parse_connect_cohctrl_arbiter() {
  XTSC_TRACE(logger, "enter parse_connect_cohctrl_arbiter()");
  confirm_assignment();

  parse_identifier_csv();
  string cohctrl_name = csv;

  u32 snoop_port = 0xFFFFFFFF;
  u32 arbiter_port = 0;
  string arbiter_name;

  parse_non_empty_csv();
  string second = csv;

  parse_non_empty_csv();
  string third = csv;

  if (more_csv) {
    snoop_port = strtou32(second);
    arbiter_port = strtou32(third);
    parse_identifier_csv();
    arbiter_name = csv;
    confirm_no_more_csv();
  }
  else {
    arbiter_port = strtou32(second);
    arbiter_name = third;
    confirm_identifier(arbiter_name);
  }

  connect_cohctrl_arbiter(cohctrl_name, snoop_port, arbiter_port, arbiter_name);
}



// connect_cohctrl_memory=<CohctrlName>[,<MemoryPort>],<MemoryName>
void parse_connect_cohctrl_memory() {
  XTSC_TRACE(logger, "enter parse_connect_cohctrl_memory()");
  confirm_assignment();

  parse_identifier_csv();
  string cohctrl_name = csv;

  parse_non_empty_csv();

  u32 memory_port = 0;

  if (more_csv) {
    memory_port = strtou32(csv);
    parse_non_empty_csv();
    confirm_no_more_csv();
  }

  confirm_identifier(csv);
  string memory_name = csv;

  connect_cohctrl_memory(cohctrl_name, memory_port, memory_name);
}



// connect_cohctrl_memory_trace=<CohctrlName>[,<SnoopPort>],<TracePort>,<TraceName>
void parse_connect_cohctrl_memory_trace() {
  XTSC_TRACE(logger, "enter parse_connect_cohctrl_memory_trace()");
  confirm_assignment();

  parse_identifier_csv();
  string cohctrl_name = csv;

  u32 snoop_port = 0xFFFFFFFF;
  u32 trace_port = 0;
  string trace_name;

  parse_non_empty_csv();
  string second = csv;

  parse_non_empty_csv();
  string third = csv;

  if (more_csv) {
    snoop_port = strtou32(second);
    trace_port = strtou32(third);
    parse_identifier_csv();
    trace_name = csv;
    confirm_no_more_csv();
  }
  else {
    trace_port = strtou32(second);
    confirm_identifier(third);
    trace_name = third;
  }

  connect_cohctrl_memory_trace(cohctrl_name, snoop_port, trace_port, trace_name);
}



// connect_cohctrl_router=<CohctrlName>[,<SnoopPort>],<RouterName>
void parse_connect_cohctrl_router() {
  XTSC_TRACE(logger, "enter parse_connect_cohctrl_router()");
  confirm_assignment();

  parse_identifier_csv();
  string cohctrl_name = csv;

  parse_non_empty_csv();

  u32 snoop_port = 0xFFFFFFFF;

  if (more_csv) {
    snoop_port = strtou32(csv);
    parse_non_empty_csv();
    confirm_no_more_csv();
  }

  confirm_identifier(csv);
  string router_name = csv;

  connect_cohctrl_router(cohctrl_name, snoop_port, router_name);
}



// connect_cohctrl_slave=<CohctrlName>[,<SnoopPort>],<SlaveName>
void parse_connect_cohctrl_slave() {
  XTSC_TRACE(logger, "enter parse_connect_cohctrl_slave()");
  confirm_assignment();

  parse_identifier_csv();
  string cohctrl_name = csv;

  parse_non_empty_csv();

  u32 snoop_port = 0xFFFFFFFF;

  if (more_csv) {
    snoop_port = strtou32(csv);
    parse_non_empty_csv();
    confirm_no_more_csv();
  }

  confirm_identifier(csv);
  string slave_name = csv;

  connect_cohctrl_slave(cohctrl_name, snoop_port, slave_name);
}



// connect_cohctrl_tlm2pin=<CohctrlName>[,<PortNumber>],<Tlm2pinName>
void parse_connect_cohctrl_tlm2pin() {
  XTSC_TRACE(logger, "enter parse_connect_cohctrl_tlm2pin()");
  confirm_assignment();

  parse_identifier_csv();
  string cohctrl_name = csv;

  parse_non_empty_csv();

  u32 port = 0;

  if (more_csv) {
    port = strtou32(csv);
    parse_non_empty_csv();
    confirm_no_more_csv();
  }

  confirm_identifier(csv);
  string tlm2pin_name = csv;

  connect_cohctrl_tlm2pin(cohctrl_name, port, tlm2pin_name);
}



// connect_core_arbiter=<CoreName>[,<PortName>],<ArbiterPort>,<ArbiterName>
void parse_connect_core_arbiter() {
  XTSC_TRACE(logger, "enter parse_connect_core_arbiter()");
  confirm_assignment();

  parse_identifier_csv();
  string core_name = csv;

  parse_non_empty_csv();
  string second = csv;

  parse_non_empty_csv();
  string third = csv;

  u32                    arb_port;
  string                 arbiter_name;
  xtsc_core::memory_port mem_port     = use_memport;

  if (more_csv) {
    parse_identifier_csv();
    confirm_no_more_csv();
    mem_port      = xtsc_core::get_memory_port(second);
    arb_port      = strtou32(third);
    arbiter_name  = csv;
  }
  else {
    arb_port      = strtou32(second);
    arbiter_name  = third;
  }

  connect_core_arbiter(core_name, mem_port, arb_port, arbiter_name);
}



// connect_core_cohctrl=<CoreName>[,<CohctrlPort>],<CohctrlName>
void parse_connect_core_cohctrl() {
  XTSC_TRACE(logger, "enter parse_connect_core_cohctrl()");
  confirm_assignment();

  parse_identifier_csv();
  string core_name = csv;

  parse_non_empty_csv();

  u32 cohctrl_port = 0xFFFFFFFF;

  if (more_csv) {
    cohctrl_port = strtou32(csv);
    parse_non_empty_csv();
    confirm_no_more_csv();
  }

  confirm_identifier(csv);
  string cohctrl_name = csv;

  if (cohctrl_port == 0xFFFFFFFF) {
    cohctrl_info& ci = find_or_infer_cohctrl(cohctrl_name);
    cohctrl_port = ci.get_first_free_master_port();
  }

  connect_core_cohctrl(core_name, cohctrl_port, cohctrl_name);
}



// connect_core_core=<UpstreamTX>,<DownstreamTX>
// connect_core_core=<CoreSource>,<OutputName>,<InputName>,<CoreSink>
void parse_connect_core_core() {
  XTSC_TRACE(logger, "enter parse_connect_core_core()");
  confirm_assignment();

  parse_identifier_csv();
  string source_name = csv;

  string output_name;
  string input_name;
  string sink_name;

  parse_identifier_csv();
  string second = csv;

  if (more_csv) {
    output_name = second;

    parse_identifier_csv();
    input_name = csv;

    parse_identifier_csv();
    sink_name = csv;

    confirm_no_more_csv();
  }
  else {
    output_name = "tx_xfer_out";
    input_name  = "tx_xfer_in";
    sink_name   = second;
  }

  connect_core_core(source_name, output_name, input_name, sink_name);
}



// connect_core_distributor=<CoreName>,<PortNumber>,<DistributorName>
// connect_core_distributor=<CoreName>,<OutputName>,<InputName>,<DistributorName>
void parse_connect_core_distributor() {
  XTSC_TRACE(logger, "enter parse_connect_core_distributor()");
  confirm_assignment();

  parse_identifier_csv();
  string core_name = csv;

  parse_non_empty_csv();
  string second = csv;

  parse_identifier_csv();
  string third = csv;

  if (more_csv) {
    confirm_identifier(second);
    string output_name(second);
    string input_name(third);
    parse_identifier_csv();
    string distributor_name = csv;
    connect_core_distributor(core_name, output_name, input_name, distributor_name);
  }
  else {
    u32 port = strtou32(second);
    string distributor_name = third;
    connect_core_distributor(core_name, port, distributor_name);
  }
}



// connect_core_loader=<CoreName>[,<CoreInterface>],<LoaderName>
void parse_connect_core_loader() {
  XTSC_TRACE(logger, "enter parse_connect_core_loader()");
  confirm_assignment();

  parse_identifier_csv();
  string core_name = csv;

  string iface;
  string loader_name;

  parse_identifier_csv();
  string second = csv;

  if (more_csv) {
    parse_identifier_csv();
    confirm_no_more_csv();
    iface       = second;
    loader_name = csv;
  }
  else {
    iface       = "tx_xfer_out";
    loader_name = second;
  }

  connect_core_loader(core_name, iface, loader_name);
}



// connect_core_logic=<CoreName>,<OutputName>[,<InputName>],<LogicName>
void parse_connect_core_logic() {
  XTSC_TRACE(logger, "enter parse_connect_core_logic()");
  confirm_assignment();

  parse_identifier_csv();
  string core_name(csv);

  parse_identifier_csv();
  string output_name(csv);

  string input_name;
  string logic_name;

  parse_identifier_csv();
  string third(csv);

  if (more_csv) {
    parse_identifier_csv();
    confirm_no_more_csv();
    input_name  = third;
    logic_name  = csv;
  }
  else {
    input_name  = output_name;
    logic_name  = third;
  }

  connect_core_logic(core_name, output_name, input_name, logic_name);
}



// connect_core_lookup=<CoreName>,<TiePortName>[,<LookupName>]
void parse_connect_core_lookup() {
  XTSC_TRACE(logger, "enter parse_connect_core_lookup()");
  confirm_assignment();

  parse_identifier_csv();
  string core_name = csv;

  parse_identifier_csv();
  string tie_name = csv;

  string lookup_name = tie_name;
  if (more_csv) {
    parse_identifier_csv();
    confirm_no_more_csv();
    lookup_name = csv;
  }
  connect_core_lookup(core_name, tie_name, lookup_name);
}



// connect_core_lookup_pin=<CoreName>,<TiePortName>[,<LookupName>]
void parse_connect_core_lookup_pin() {
  XTSC_TRACE(logger, "enter parse_connect_core_lookup_pin()");
  confirm_assignment();

  parse_identifier_csv();
  string core_name = csv;

  parse_identifier_csv();
  string tie_name = csv;

  string lookup_pin_name = tie_name;
  if (more_csv) {
    parse_identifier_csv();
    confirm_no_more_csv();
    lookup_pin_name = csv;
  }
  connect_core_lookup_pin(core_name, tie_name, lookup_pin_name);
}



// connect_core_memory=<CoreName>[,<MemoryPort>],<MemoryName>
void parse_connect_core_memory() {
  XTSC_TRACE(logger, "enter parse_connect_core_memory()");
  confirm_assignment();

  parse_identifier_csv();
  string core_name = csv;

  parse_non_empty_csv();

  u32 memory_port = 0;

  if (more_csv) {
    memory_port = strtou32(csv);
    parse_non_empty_csv();
    confirm_no_more_csv();
  }

  confirm_identifier(csv);
  string memory_name = csv;

  connect_core_memory(core_name, memory_port, memory_name);
}



// connect_core_memory_trace=<CoreName>,<PortName>[,<TracePort>],<TraceName>
void parse_connect_core_memory_trace() {
  XTSC_TRACE(logger, "enter parse_connect_core_memory_trace()");
  confirm_assignment();

  parse_identifier_csv();
  string core_name = csv;

  parse_identifier_csv();
  string port_name = csv;

  u32 trace_port = 0;

  parse_non_empty_csv();

  if (more_csv) {
    trace_port = strtou32(csv);
    parse_identifier_csv();
    confirm_no_more_csv();
  }

  string trace_name = csv;

  xtsc_core::memory_port mem_port = xtsc_core::get_memory_port(port_name.c_str());
  connect_core_memory_trace(core_name, mem_port, trace_port, trace_name);
}



// connect_core_mmio=<CoreName>[,<MemoryPort>],<MmioName>
// connect_core_mmio=<CoreName>,<OutputName>[,<InputName>],<MmioName>
void parse_connect_core_mmio() {
  XTSC_TRACE(logger, "enter parse_connect_core_mmio()");
  confirm_assignment();

  parse_identifier_csv();
  string core_name(csv);

  parse_identifier_csv();
  string second(csv);

  string                 output_name;
  string                 input_name;
  string                 mmio_name;
  xtsc_core::memory_port mem_port               = use_memport;
  bool                   is_memory_connect      = false;

  if (more_csv) {

    parse_identifier_csv();
    string third(csv);

    if (more_csv) {
      parse_identifier_csv();
      confirm_no_more_csv();
      output_name       = second;
      input_name        = third;
      mmio_name         = csv;
      is_memory_connect = false;
    }
    else {
      try {
        mem_port                = xtsc_core::get_memory_port(second);
        mmio_name               = third;
        is_memory_connect       = true;
      }
      catch (...) {
        output_name             = second;
        input_name              = second;
        mmio_name               = third;
        is_memory_connect       = false;
      }
    }

  }
  else {
    mmio_name           = second;
    is_memory_connect   = true;
  }

  if (is_memory_connect) {
    connect_core_mmio(core_name, mem_port, mmio_name);
  }
  else {
    connect_core_mmio(core_name, output_name, input_name, mmio_name);
  }
}



// connect_core_proxy=<CoreName>,<Interface>[,<NamePrefix>],<ProxyName>
void parse_connect_core_proxy() {
  XTSC_TRACE(logger, "enter parse_connect_core_proxy()");
  confirm_assignment();

  parse_identifier_csv();
  string core_name = csv;

  parse_identifier_csv();
  string iface = csv;

  string proxy_name;
  string name_prefix;

  parse_csv();

  if (more_csv) {
    name_prefix = csv;
    parse_identifier_csv();
    if (name_prefix != "") confirm_identifier(name_prefix);
  }

  proxy_name = csv;
  confirm_no_more_csv();

  connect_core_proxy(core_name, iface, name_prefix, proxy_name);
}



// connect_core_queue=<CoreName>,<TiePortName>[,<ProducerPort>][,<QueueName>]
void parse_connect_core_queue() {
  XTSC_TRACE(logger, "enter parse_connect_core_queue()");
  confirm_assignment();

  parse_identifier_csv();
  string core_name = csv;

  parse_identifier_csv();
  string tie_name = csv;

  u32 producer_port = 0;
  string queue_name = tie_name;
  if (more_csv) {
    parse_non_empty_csv();
    if (is_identifier(csv)) {
      queue_name = csv;
    }
    else {
      producer_port = strtou32(csv);
      if (more_csv) {
        parse_identifier_csv();
        queue_name = csv;
      }
    }
    confirm_no_more_csv();
  }
  connect_core_queue(core_name, tie_name, producer_port, queue_name);
}



// connect_core_queue_pin=<CoreName>,<TiePortName>[,<QueueName>]
void parse_connect_core_queue_pin() {
  XTSC_TRACE(logger, "enter parse_connect_core_queue_pin()");
  confirm_assignment();

  parse_identifier_csv();
  string core_name = csv;

  parse_identifier_csv();
  string tie_name = csv;

  string queue_pin_name = tie_name;
  if (more_csv) {
    parse_identifier_csv();
    confirm_no_more_csv();
    queue_pin_name = csv;
  }
  connect_core_queue_pin(core_name, tie_name, queue_pin_name);
}



// connect_core_router=<CoreName>[,<PortName>],<RouterName>
void parse_connect_core_router() {
  XTSC_TRACE(logger, "enter parse_connect_core_router()");
  confirm_assignment();

  parse_identifier_csv();
  string core_name = csv;

  parse_identifier_csv();
  string second = csv;

  string                 router_name;
  xtsc_core::memory_port mem_port     = use_memport;

  if (more_csv) {
    parse_identifier_csv();
    confirm_no_more_csv();
    mem_port            = xtsc_core::get_memory_port(second);
    router_name         = csv;
  }
  else {
    router_name         = second;
  }

  connect_core_router(core_name, mem_port, router_name);
}



// connect_core_signal=<CoreName>,<OutputPinName>[,<SignalName>]
void parse_connect_core_signal() {
  XTSC_TRACE(logger, "enter parse_connect_core_signal()");
  confirm_assignment();

  parse_identifier_csv();
  string core_name = csv;

  parse_identifier_csv();
  string output_pin_name = csv;

  string signal_name = output_pin_name;
  if (more_csv) {
    parse_identifier_csv();
    confirm_no_more_csv();
    signal_name = csv;
  }
  connect_core_signal(core_name, output_pin_name, signal_name);
}



// connect_core_slave=<CoreName>[,<PortName>],<SlaveName>
void parse_connect_core_slave() {
  XTSC_TRACE(logger, "enter parse_connect_core_slave()");
  confirm_assignment();

  parse_identifier_csv();
  string core_name = csv;

  parse_identifier_csv();
  string second = csv;

  string                 slave_name;
  xtsc_core::memory_port mem_port     = use_memport;

  if (more_csv) {
    parse_identifier_csv();
    confirm_no_more_csv();
    mem_port            = xtsc_core::get_memory_port(second);
    slave_name          = csv;
  }
  else {
    slave_name          = second;
  }

  connect_core_slave(core_name, mem_port, slave_name);
}



// connect_core_tlm2pin=<CoreName>[,<PortName>][,<Tlm2pinPort>],<Tlm2pinName>
void parse_connect_core_tlm2pin() {
  XTSC_TRACE(logger, "enter parse_connect_core_tlm2pin()");
  confirm_assignment();

  parse_identifier_csv();
  string core_name = csv;

  parse_non_empty_csv();
  string second = csv;

  string        port_name;
  string        tlm2pin_name;
  u32           tlm2pin_port = 0;

  if (more_csv) {
    parse_non_empty_csv();
    string third = csv;
    if (more_csv) {
      // 4 words (3 commas)
      parse_identifier_csv();
      confirm_no_more_csv();
      port_name           = second;
      confirm_identifier(port_name);
      tlm2pin_port = strtou32(third);
      tlm2pin_name     = csv;
    }
    else {
      // 3 words (2 commas)
      tlm2pin_name     = third;
      confirm_identifier(tlm2pin_name);
      if (isdigit(second[0])) {
        // second is <Tlm2pinPort>
        tlm2pin_port = strtou32(second);
        tlm2pin_info& ti = find_or_infer_tlm2pin(tlm2pin_name);
        port_name = ti.parms.get_c_str("memory_interface");
      }
      else {
        // second is <PortName>
        port_name           = second;
      }
    }
  }
  else {
    // 2 words (1 comma)
    tlm2pin_name     = second;
    confirm_identifier(tlm2pin_name);
    tlm2pin_info& ti = find_or_infer_tlm2pin(tlm2pin_name);
    port_name           = ti.parms.get_c_str("memory_interface");
  }

  xtsc_core::memory_port mem_port = xtsc_core::get_memory_port(port_name.c_str());
  connect_core_tlm2pin(core_name, mem_port, tlm2pin_port, tlm2pin_name);
}



// connect_core_wire=<CoreName>,<OutputName>[,<WireName>]
void parse_connect_core_wire() {
  XTSC_TRACE(logger, "enter parse_connect_core_wire()");
  confirm_assignment();

  parse_identifier_csv();
  string core_name = csv;

  parse_identifier_csv();
  string output_name = csv;

  string wire_name = output_name;
  if (more_csv) {
    parse_identifier_csv();
    confirm_no_more_csv();
    wire_name = csv;
  }
  connect_core_wire(core_name, output_name, wire_name);
}



// connect_core_wrapper=<CoreName>,<Interface>[,<NamePrefix>]
void parse_connect_core_wrapper() {
  XTSC_TRACE(logger, "enter parse_connect_core_wrapper()");
  confirm_assignment();

  parse_identifier_csv();
  string core_name = csv;

  parse_identifier_csv();
  string iface = csv;

  string name_prefix;
  
  if (more_csv) {
    parse_csv();
    name_prefix = csv;
    if (name_prefix != "") confirm_identifier(name_prefix);
  }

  confirm_no_more_csv();

  connect_core_wrapper(core_name, iface, name_prefix);
}



// connect_distributor_core=<DistributorName>,<PortNumber>[,<InputName>],<CoreName>
void parse_connect_distributor_core() {
  XTSC_TRACE(logger, "enter parse_connect_distributor_core()");
  confirm_assignment();

  parse_identifier_csv();
  string distributor_name = csv;

  parse_non_empty_csv();
  u32 port = strtou32(csv);

  parse_identifier_csv();
  string third = csv;
  string input_name("BInterrupt");
  string core_name;

  if (more_csv) {
    input_name = third;
    parse_identifier_csv();
    core_name = csv;
    confirm_no_more_csv();
  }
  else {
    core_name = third;
  }

  connect_distributor_core(distributor_name, port, input_name, core_name);
}



// connect_distributor_logic=<DistributorName>,<OutputName>,<InputName>,<LogicName>
void parse_connect_distributor_logic() {
  XTSC_TRACE(logger, "enter parse_connect_distributor_logic()");
  confirm_assignment();

  parse_identifier_csv();
  string distributor_name = csv;

  parse_identifier_csv();
  string output_name = csv;

  parse_identifier_csv();
  string input_name = csv;

  parse_identifier_csv();
  string logic_name = csv;

  confirm_no_more_csv();

  connect_distributor_logic(distributor_name, output_name, input_name, logic_name);
}



// connect_distributor_mmio=<DistributorName>,<OutputName>,<InputName>,<MmioName>
void parse_connect_distributor_mmio() {
  XTSC_TRACE(logger, "enter parse_connect_distributor_mmio()");
  confirm_assignment();

  parse_identifier_csv();
  string distributor_name = csv;

  parse_identifier_csv();
  string output_name = csv;

  parse_identifier_csv();
  string input_name = csv;

  parse_identifier_csv();
  string mmio_name = csv;

  confirm_no_more_csv();

  connect_distributor_mmio(distributor_name, output_name, input_name, mmio_name);
}



// connect_distributor_wire=<DistributorName>,<OutputName>,<WireName>
void parse_connect_distributor_wire() {
  XTSC_TRACE(logger, "enter parse_connect_distributor_wire()");
  confirm_assignment();

  parse_identifier_csv();
  string distributor_name = csv;

  parse_identifier_csv();
  string output_name = csv;

  parse_identifier_csv();
  string wire_name = csv;

  confirm_no_more_csv();

  connect_distributor_wire(distributor_name, output_name, wire_name);
}



// connect_dma_arbiter=<DmaName>,<ArbiterPort>,<ArbiterName>
void parse_connect_dma_arbiter() {
  XTSC_TRACE(logger, "enter parse_connect_dma_arbiter()");
  confirm_assignment();

  parse_identifier_csv();
  string dma_name = csv;

  parse_non_empty_csv();
  u32 arbiter_port = strtou32(csv);

  parse_identifier_csv();
  string arbiter_name = csv;

  confirm_no_more_csv();

  connect_dma_arbiter(dma_name, arbiter_port, arbiter_name);
}



// connect_dma_memory=<DmaName>[,<MemoryPort>],<MemoryName>
void parse_connect_dma_memory() {
  XTSC_TRACE(logger, "enter parse_connect_dma_memory()");
  confirm_assignment();

  parse_identifier_csv();
  string dma_name = csv;

  parse_non_empty_csv();

  u32 memory_port = 0;

  if (more_csv) {
    memory_port = strtou32(csv);
    parse_non_empty_csv();
    confirm_no_more_csv();
  }

  confirm_identifier(csv);
  string memory_name = csv;

  connect_dma_memory(dma_name, memory_port, memory_name);
}



// connect_dma_memory_trace=<DmaName>[,<TracePort>],<TraceName>
void parse_connect_dma_memory_trace() {
  XTSC_TRACE(logger, "enter parse_connect_dma_memory_trace()");
  confirm_assignment();

  parse_identifier_csv();
  string dma_name = csv;

  parse_non_empty_csv();

  u32 trace_port = 0;

  if (more_csv) {
    trace_port = strtou32(csv);
    parse_non_empty_csv();
    confirm_no_more_csv();
  }

  confirm_identifier(csv);
  string trace_name = csv;

  connect_dma_memory_trace(dma_name, trace_port, trace_name);
}



// connect_dma_router=<DmaName>,<RouterName>
void parse_connect_dma_router() {
  XTSC_TRACE(logger, "enter parse_connect_dma_router()");
  confirm_assignment();

  parse_identifier_csv();
  string dma_name = csv;

  parse_identifier_csv();
  string router_name = csv;

  confirm_no_more_csv();

  connect_dma_router(dma_name, router_name);
}



// connect_driver_distributor=<DriverName>,<LookupName>,<DistributorName>
void parse_connect_driver_distributor() {
  XTSC_TRACE(logger, "enter parse_connect_driver_distributor()");
  confirm_assignment();

  parse_identifier_csv();
  string driver_name = csv;

  parse_identifier_csv();
  string lookup_name = csv;

  parse_identifier_csv();
  string distributor_name = csv;

  confirm_no_more_csv();

  connect_driver_distributor(driver_name, lookup_name, distributor_name);
}



// connect_driver_lookup=<DriverName>,<LookupName>
void parse_connect_driver_lookup() {
  XTSC_TRACE(logger, "enter parse_connect_driver_lookup()");
  confirm_assignment();

  parse_identifier_csv();
  string driver_name = csv;

  parse_identifier_csv();
  string lookup_name = csv;

  confirm_no_more_csv();

  connect_driver_lookup(driver_name, lookup_name);
}



// connect_driver_lookup_pin=<DriverName>,<LookupName>
void parse_connect_driver_lookup_pin() {
  XTSC_TRACE(logger, "enter parse_connect_driver_lookup_pin()");
  confirm_assignment();

  parse_identifier_csv();
  string driver_name = csv;

  parse_identifier_csv();
  string lookup_pin_name = csv;

  confirm_no_more_csv();

  connect_driver_lookup_pin(driver_name, lookup_pin_name);
}



// connect_driver_proxy=<DriverName>[,<NamePrefix>],<ProxyName>
void parse_connect_driver_proxy() {
  XTSC_TRACE(logger, "enter parse_connect_driver_proxy()");
  confirm_assignment();

  parse_identifier_csv();
  string driver_name = csv;

  parse_identifier_csv();
  string second = csv;

  string proxy_name;
  string name_prefix("@");

  if (more_csv) {
    name_prefix = second;
    parse_identifier_csv();
    proxy_name = csv;
    confirm_no_more_csv();
  }
  else {
    proxy_name = second;
  }

  connect_driver_proxy(driver_name, name_prefix, proxy_name);
}



// connect_driver_wrapper=<DriverName>,<NamePrefix>
void parse_connect_driver_wrapper() {
  XTSC_TRACE(logger, "enter parse_connect_driver_wrapper()");
  confirm_assignment();

  parse_identifier_csv();
  string driver_name = csv;

  parse_identifier_csv();
  string name_prefix = csv;

  confirm_no_more_csv();

  connect_driver_wrapper(driver_name, name_prefix);
}



// connect_loader_consumer=<LoaderName>,<CoreName>
void parse_connect_loader_consumer() {
  XTSC_TRACE(logger, "enter parse_connect_loader_consumer()");
  confirm_assignment();

  parse_identifier_csv();
  string loader_name = csv;

  parse_identifier_csv();
  string consumer_name = csv;

  confirm_no_more_csv();

  connect_loader_consumer(loader_name, consumer_name);
}



// connect_loader_core=<LoaderName>[,<CoreInterface>],<CoreName>
void parse_connect_loader_core() {
  XTSC_TRACE(logger, "enter parse_connect_loader_core()");
  confirm_assignment();

  parse_identifier_csv();
  string loader_name = csv;

  string iface;
  string core_name;

  parse_identifier_csv();
  string second = csv;

  if (more_csv) {
    parse_identifier_csv();
    confirm_no_more_csv();
    iface     = second;
    core_name = csv;
  }
  else {
    iface     = "tx_xfer_in";
    core_name = second;
  }

  connect_loader_core(loader_name, iface, core_name);
}



// connect_loader_logic=<LoaderName>,<OutputName>[,<InputName>],<LogicName>
void parse_connect_loader_logic() {
  XTSC_TRACE(logger, "enter parse_connect_loader_logic()");
  confirm_assignment();
  string loader_name, output_name, input_name, logic_name;
  string third;

  parse_identifier_csv();
  loader_name = csv;

  parse_identifier_csv();
  output_name = csv;

  parse_identifier_csv();
  third = csv;

  if (more_csv) {
    parse_identifier_csv();
    input_name = third;
    logic_name = csv;
    confirm_no_more_csv();
  }
  else {
    logic_name = third;
    input_name = output_name;
  }

  connect_loader_logic(loader_name, output_name, input_name, logic_name);
}



// connect_loader_wire=<LoaderName>[,<OutputName>],<WireName>
void parse_connect_loader_wire() {
  XTSC_TRACE(logger, "enter parse_connect_loader_wire()");
  confirm_assignment();
  string loader_name, output_name, wire_name;
  string second;

  parse_identifier_csv();
  loader_name = csv;

  parse_identifier_csv();
  second = csv;

  if (more_csv) {
    parse_identifier_csv();
    output_name = second;
    wire_name = csv;
    confirm_no_more_csv();
  }
  else {
    wire_name = second;
    output_name = wire_name;
  }

  connect_loader_wire(loader_name, output_name, wire_name);
}



// connect_logic_cohctrl=<LogicName>,<OutputName>,<CohctrlPort>,<CohctrlName>
void parse_connect_logic_cohctrl() {
  XTSC_TRACE(logger, "enter parse_connect_logic_cohctrl()");
  confirm_assignment();

  parse_identifier_csv();
  string logic_name(csv);

  parse_identifier_csv();
  string output_name(csv);

  parse_non_empty_csv();
  u32 port = strtou32(csv);

  parse_identifier_csv();
  string cohctrl_name(csv);

  confirm_no_more_csv();

  connect_logic_cohctrl(logic_name, output_name, port, cohctrl_name);
}



// connect_logic_core=<LogicName>[,<OutputName>],<InputName>,<CoreName>
void parse_connect_logic_core() {
  XTSC_TRACE(logger, "enter parse_connect_logic_core()");
  confirm_assignment();

  parse_identifier_csv();
  string logic_name(csv);

  parse_identifier_csv();
  string second(csv);

  parse_identifier_csv();
  string third(csv);

  string output_name(second);
  string input_name(third);
  string core_name(third);

  if (more_csv) {
    parse_identifier_csv();
    confirm_no_more_csv();
    core_name = csv;
  }
  else {
    input_name = second;
  }

  connect_logic_core(logic_name, output_name, input_name, core_name);
}



// connect_logic_distributor=<LogicName>,<OutputName>,<InputName>,<DistributorName>
void parse_connect_logic_distributor() {
  XTSC_TRACE(logger, "enter parse_connect_logic_distributor()");
  confirm_assignment();

  parse_identifier_csv();
  string logic_name = csv;

  parse_identifier_csv();
  string output_name = csv;

  parse_identifier_csv();
  string input_name = csv;

  parse_identifier_csv();
  string distributor_name = csv;

  confirm_no_more_csv();

  connect_logic_distributor(logic_name, output_name, input_name, distributor_name);
}



// connect_logic_logic=<SourceName>,<OutputName>[,<InputName>],<SinkName>
void parse_connect_logic_logic() {
  XTSC_TRACE(logger, "enter parse_connect_logic_logic()");
  confirm_assignment();

  parse_identifier_csv();
  string source_name = csv;

  parse_identifier_csv();
  string output_name = csv;

  string input_name, sink_name;

  parse_identifier_csv();
  string third = csv;

  if (more_csv) {
    input_name = third;
    parse_identifier_csv();
    sink_name = csv;
    confirm_no_more_csv();
  }
  else {
    input_name = output_name;
    sink_name = third;
  }

  connect_logic_logic(source_name, output_name, input_name, sink_name);
}



// connect_logic_master=<LogicName>,<OutputName>,<MasterName>
void parse_connect_logic_master() {
  XTSC_TRACE(logger, "enter parse_connect_logic_master()");
  confirm_assignment();

  parse_identifier_csv();
  string logic_name(csv);

  parse_identifier_csv();
  string output_name(csv);

  parse_identifier_csv();
  string master_name(csv);

  confirm_no_more_csv();

  connect_logic_master(logic_name, output_name, master_name);
}



// connect_logic_mmio=<LogicName>,<OutputName>[,<InputName>],<MmioName>
void parse_connect_logic_mmio() {
  XTSC_TRACE(logger, "enter parse_connect_logic_mmio()");
  confirm_assignment();

  parse_identifier_csv();
  string logic_name = csv;

  parse_identifier_csv();
  string output_name = csv;

  string input_name, mmio_name;

  parse_identifier_csv();
  string third = csv;

  if (more_csv) {
    input_name = third;
    parse_identifier_csv();
    mmio_name = csv;
    confirm_no_more_csv();
  }
  else {
    input_name = output_name;
    mmio_name = third;
  }

  connect_logic_mmio(logic_name, output_name, input_name, mmio_name);
}



// connect_logic_producer=<LogicName>,<OutputName>,<ProducerName>
void parse_connect_logic_producer() {
  XTSC_TRACE(logger, "enter parse_connect_logic_producer()");
  confirm_assignment();

  parse_identifier_csv();
  string logic_name(csv);

  parse_identifier_csv();
  string output_name(csv);

  parse_identifier_csv();
  string producer_name(csv);

  confirm_no_more_csv();

  connect_logic_producer(logic_name, output_name, producer_name);
}



// connect_logic_proxy=<LogicName>,<OutputName>[,<InputName>],<ProxyName>
void parse_connect_logic_proxy() {
  XTSC_TRACE(logger, "enter parse_connect_logic_proxy()");
  confirm_assignment();

  parse_identifier_csv();
  string logic_name = csv;

  parse_identifier_csv();
  string output_name = csv;

  string input_name, proxy_name;

  parse_identifier_csv();
  string third = csv;

  if (more_csv) {
    input_name = third;
    parse_identifier_csv();
    proxy_name = csv;
    confirm_no_more_csv();
  }
  else {
    input_name = output_name;
    proxy_name = third;
  }

  connect_logic_proxy(logic_name, output_name, input_name, proxy_name);
}



// connect_logic_source=<LogicName>,<OutputName>,<SourceName>
void parse_connect_logic_source() {
  XTSC_TRACE(logger, "enter parse_connect_logic_source()");
  confirm_assignment();

  parse_identifier_csv();
  string logic_name(csv);

  parse_identifier_csv();
  string output_name(csv);

  parse_identifier_csv();
  string source_name(csv);

  confirm_no_more_csv();

  connect_logic_source(logic_name, output_name, source_name);
}



// connect_logic_wire=<LogicName>[,<OutputName>],<WireName>
void parse_connect_logic_wire() {
  XTSC_TRACE(logger, "enter parse_connect_logic_wire()");
  confirm_assignment();

  parse_identifier_csv();
  string logic_name(csv);

  parse_identifier_csv();
  string output_name(csv);
  string wire_name(csv);

  if (more_csv) {
    parse_identifier_csv();
    confirm_no_more_csv();
    wire_name = csv;
  }

  connect_logic_wire(logic_name, output_name, wire_name);
}




// connect_logic_wrapper=<LogicName>,<LogicOutputName>[,<WrapperOutputName>]
void parse_connect_logic_wrapper() {
  XTSC_TRACE(logger, "enter parse_connect_logic_wrapper()");
  confirm_assignment();

  parse_identifier_csv();
  string logic_name = csv;

  parse_identifier_csv();
  string logic_output_name = csv;

  string wrapper_output_name(logic_output_name);

  if (more_csv) {
    parse_identifier_csv();
    wrapper_output_name = csv;
    confirm_no_more_csv();
  }

  connect_logic_wrapper(logic_name, logic_output_name, wrapper_output_name);
}



// connect_master_arbiter=<MasterName>,<ArbiterPort>,<ArbiterName>
void parse_connect_master_arbiter() {
  XTSC_TRACE(logger, "enter parse_connect_master_arbiter()");
  confirm_assignment();

  parse_identifier_csv();
  string master_name = csv;

  parse_non_empty_csv();
  u32 port = strtou32(csv);

  parse_identifier_csv();
  string arbiter_name = csv;

  confirm_no_more_csv();

  connect_master_arbiter(master_name, port, arbiter_name);
}



// connect_master_cohctrl=<MasterName>[,<CohctrlPort>],<CohctrlName>
void parse_connect_master_cohctrl() {
  XTSC_TRACE(logger, "enter parse_connect_master_cohctrl()");
  confirm_assignment();

  parse_identifier_csv();
  string master_name = csv;

  parse_non_empty_csv();

  u32 cohctrl_port = 0xFFFFFFFF;
  if (more_csv) {
    cohctrl_port = strtou32(csv);
    parse_non_empty_csv();
    confirm_no_more_csv();
  }

  confirm_identifier(csv);
  string cohctrl_name = csv;

  if (cohctrl_port == 0xFFFFFFFF) {
    cohctrl_info& ci = find_or_infer_cohctrl(cohctrl_name);
    cohctrl_port = ci.get_first_free_master_port();
  }

  connect_master_cohctrl(master_name, cohctrl_port, cohctrl_name);
}



// connect_master_core=<MasterName>[,<PortName>],<CoreName>
void parse_connect_master_core() {
  XTSC_TRACE(logger, "enter parse_connect_master_core()");
  confirm_assignment();

  parse_identifier_csv();
  string master_name = csv;

  parse_identifier_csv();

  string port_name = "inbound_pif";

  if (more_csv) {
    port_name = csv;
    parse_identifier_csv();
    confirm_no_more_csv();
  }

  string core_name = csv;

  connect_master_core(master_name, port_name, core_name);
}



// connect_master_dma=<MasterName>[,<DmaPort>],<DmaName>
void parse_connect_master_dma() {
  XTSC_TRACE(logger, "enter parse_connect_master_dma()");
  confirm_assignment();

  parse_identifier_csv();
  string master_name = csv;

  parse_non_empty_csv();

  u32 dma_port = 0;

  if (more_csv) {
    dma_port = strtou32(csv);
    parse_non_empty_csv();
    confirm_no_more_csv();
  }

  confirm_identifier(csv);
  string dma_name = csv;

  connect_master_dma(master_name, dma_port, dma_name);
}



// connect_master_memory=<MasterName>[,<MemoryPort>],<MemoryName>
void parse_connect_master_memory() {
  XTSC_TRACE(logger, "enter parse_connect_master_memory()");
  confirm_assignment();

  parse_identifier_csv();
  string master_name = csv;

  parse_non_empty_csv();

  u32 memory_port = 0;

  if (more_csv) {
    memory_port = strtou32(csv);
    parse_non_empty_csv();
    confirm_no_more_csv();
  }

  confirm_identifier(csv);
  string memory_name = csv;

  connect_master_memory(master_name, memory_port, memory_name);
}



// connect_master_memory_trace=<MasterName>[,<TracePort>],<TraceName>
void parse_connect_master_memory_trace() {
  XTSC_TRACE(logger, "enter parse_connect_master_memory_trace()");
  confirm_assignment();

  parse_identifier_csv();
  string master_name = csv;

  parse_non_empty_csv();

  u32 trace_port = 0;

  if (more_csv) {
    trace_port = strtou32(csv);
    parse_non_empty_csv();
    confirm_no_more_csv();
  }

  confirm_identifier(csv);
  string trace_name = csv;

  connect_master_memory_trace(master_name, trace_port, trace_name);
}



// connect_master_mmio=<MasterName>,<MmioName>
void parse_connect_master_mmio() {
  XTSC_TRACE(logger, "enter parse_connect_master_mmio()");
  confirm_assignment();

  parse_identifier_csv();
  string master_name = csv;

  parse_identifier_csv();
  string mmio_name = csv;

  confirm_no_more_csv();

  connect_master_mmio(master_name, mmio_name);
}



// connect_master_router=<MasterName>,<RouterName>
void parse_connect_master_router() {
  XTSC_TRACE(logger, "enter parse_connect_master_router()");
  confirm_assignment();

  parse_identifier_csv();
  string master_name = csv;

  parse_identifier_csv();
  string router_name = csv;

  confirm_no_more_csv();

  connect_master_router(master_name, router_name);
}



// connect_master_slave=<MasterName>,<SlaveName>
void parse_connect_master_slave() {
  XTSC_TRACE(logger, "enter parse_connect_master_slave()");
  confirm_assignment();

  parse_identifier_csv();
  string master_name = csv;

  parse_identifier_csv();
  string slave_name = csv;

  confirm_no_more_csv();

  connect_master_slave(master_name, slave_name);
}



// connect_master_tlm2pin=<MasterName>[,<Tlm2pinPort>],<Tlm2pinName>
void parse_connect_master_tlm2pin() {
  XTSC_TRACE(logger, "enter parse_connect_master_tlm2pin()");
  confirm_assignment();

  parse_identifier_csv();
  string master_name = csv;

  string tlm2pin_name;
  u32 tlm2pin_port = 0;

  parse_non_empty_csv();
  string second = csv;

  if (more_csv) {
    parse_identifier_csv();
    tlm2pin_name = csv;
    confirm_no_more_csv();
    tlm2pin_port = strtou32(second);
  }
  else {
    tlm2pin_name = second;
    confirm_identifier(tlm2pin_name);
  }


  connect_master_tlm2pin(master_name, tlm2pin_port, tlm2pin_name);
}



// connect_memory_trace_arbiter=<TraceName>[,<TracePort>],<ArbiterPort>,<ArbiterName>
void parse_connect_memory_trace_arbiter() {
  XTSC_TRACE(logger, "enter parse_connect_memory_trace_arbiter()");
  confirm_assignment();

  parse_identifier_csv();
  string trace_name = csv;

  u32 trace_port = 0;
  u32 arbiter_port = 0;
  string arbiter_name;

  parse_non_empty_csv();
  string second = csv;

  parse_non_empty_csv();
  string third = csv;

  if (more_csv) {
    parse_identifier_csv();
    arbiter_name = csv;
    confirm_no_more_csv();
    trace_port   = strtou32(second);
    arbiter_port = strtou32(third);
  }
  else {
    arbiter_port = strtou32(second);
    arbiter_name = third;
    confirm_identifier(arbiter_name);
  }

  connect_memory_trace_arbiter(trace_name, trace_port, arbiter_port, arbiter_name);
}



// connect_memory_trace_cohctrl=<TraceName>[[,<TracePort>],<CohctrlPort>],<CohctrlName>
void parse_connect_memory_trace_cohctrl() {
  XTSC_TRACE(logger, "enter parse_connect_memory_trace_cohctrl()");
  confirm_assignment();

  parse_identifier_csv();
  string trace_name = csv;

  u32 trace_port   = 0;
  u32 cohctrl_port = 0;
  string cohctrl_name;

  parse_non_empty_csv();
  string second = csv;

  if (more_csv) {
    parse_non_empty_csv();
    string third = csv;
    if (more_csv) {
      parse_identifier_csv();
      cohctrl_name = csv;
      confirm_no_more_csv();
      trace_port   = strtou32(second);
      cohctrl_port = strtou32(third);
    }
    else {
      cohctrl_port = strtou32(second);
      cohctrl_name = third;
      confirm_identifier(cohctrl_name);
    }
  }
  else {
    cohctrl_name = second;
    confirm_identifier(cohctrl_name);
  }

  connect_memory_trace_cohctrl(trace_name, trace_port, cohctrl_port, cohctrl_name);
}



// connect_memory_trace_core=<TraceName>[[,<TracePort>],<PortName>],<CoreName>
void parse_connect_memory_trace_core() {
  XTSC_TRACE(logger, "enter parse_connect_memory_trace_core()");
  confirm_assignment();

  parse_identifier_csv();
  string trace_name = csv;

  u32 trace_port = 0;
  string port_name("inbound_pif");
  string core_name;

  parse_non_empty_csv();
  string second = csv;

  if (more_csv) {
    parse_non_empty_csv();
    string third = csv;
    if (more_csv) {
      parse_identifier_csv();
      core_name = csv;
      confirm_no_more_csv();
      trace_port = strtou32(second);
      port_name  = third;
    }
    else {
      port_name = second;
      core_name = third;
      confirm_identifier(core_name);
    }
    confirm_identifier(port_name);
  }
  else {
    core_name = second;
    confirm_identifier(core_name);
  }

  connect_memory_trace_core(trace_name, trace_port, port_name, core_name);
}



// connect_memory_trace_dma=<TraceName>[[,<TracePort>,]<DmaPort>],<DmaName>
void parse_connect_memory_trace_dma() {
  XTSC_TRACE(logger, "enter parse_connect_memory_trace_dma()");
  confirm_assignment();

  parse_identifier_csv();
  string trace_name = csv;

  u32 trace_port   = 0;
  u32 dma_port = 0;
  string dma_name;

  parse_non_empty_csv();
  string second = csv;

  if (more_csv) {
    parse_non_empty_csv();
    string third = csv;
    if (more_csv) {
      parse_identifier_csv();
      dma_name = csv;
      confirm_no_more_csv();
      trace_port  = strtou32(second);
      dma_port = strtou32(third);
    }
    else {
      dma_port = strtou32(second);
      dma_name = third;
      confirm_identifier(dma_name);
    }
  }
  else {
    dma_name = second;
    confirm_identifier(dma_name);
  }

  connect_memory_trace_dma(trace_name, trace_port, dma_port, dma_name);
}



// connect_memory_trace_memory=<TraceName>[[,<TracePort>,]<MemoryPort>],<MemoryName>
void parse_connect_memory_trace_memory() {
  XTSC_TRACE(logger, "enter parse_connect_memory_trace_memory()");
  confirm_assignment();

  parse_identifier_csv();
  string trace_name = csv;

  u32 trace_port   = 0;
  u32 memory_port = 0;
  string memory_name;

  parse_non_empty_csv();
  string second = csv;

  if (more_csv) {
    parse_non_empty_csv();
    string third = csv;
    if (more_csv) {
      parse_identifier_csv();
      memory_name = csv;
      confirm_no_more_csv();
      trace_port  = strtou32(second);
      memory_port = strtou32(third);
    }
    else {
      memory_port = strtou32(second);
      memory_name = third;
      confirm_identifier(memory_name);
    }
  }
  else {
    memory_name = second;
    confirm_identifier(memory_name);
  }

  connect_memory_trace_memory(trace_name, trace_port, memory_port, memory_name);
}



// connect_memory_trace_mmio=<TraceName>[,<TracePort>],<MmioName>
void parse_connect_memory_trace_mmio() {
  XTSC_TRACE(logger, "enter parse_connect_memory_trace_mmio()");
  confirm_assignment();

  parse_identifier_csv();
  string trace_name = csv;

  parse_non_empty_csv();

  u32 trace_port = 0;

  if (more_csv) {
    trace_port = strtou32(csv);
    parse_non_empty_csv();
    confirm_no_more_csv();
  }

  confirm_identifier(csv);
  string mmio_name = csv;

  connect_memory_trace_mmio(trace_name, trace_port, mmio_name);
}



// connect_memory_trace_router=<TraceName>[,<TracePort>],<RouterName>
void parse_connect_memory_trace_router() {
  XTSC_TRACE(logger, "enter parse_connect_memory_trace_router()");
  confirm_assignment();

  parse_identifier_csv();
  string trace_name = csv;

  parse_non_empty_csv();

  u32 trace_port = 0;

  if (more_csv) {
    trace_port = strtou32(csv);
    parse_non_empty_csv();
    confirm_no_more_csv();
  }

  confirm_identifier(csv);
  string router_name = csv;

  connect_memory_trace_router(trace_name, trace_port, router_name);
}



// connect_memory_trace_slave=<TraceName>[,<TracePort>],<SlaveName>
void parse_connect_memory_trace_slave() {
  XTSC_TRACE(logger, "enter parse_connect_memory_trace_slave()");
  confirm_assignment();

  parse_identifier_csv();
  string trace_name = csv;

  parse_non_empty_csv();

  u32 trace_port = 0;

  if (more_csv) {
    trace_port = strtou32(csv);
    parse_non_empty_csv();
    confirm_no_more_csv();
  }

  confirm_identifier(csv);
  string slave_name = csv;

  connect_memory_trace_slave(trace_name, trace_port, slave_name);
}



// connect_memory_trace_tlm2pin=<TraceName>[[,<TracePort>],<Tlm2pinPort>],<Tlm2pinName>
void parse_connect_memory_trace_tlm2pin() {
  XTSC_TRACE(logger, "enter parse_connect_memory_trace_tlm2pin()");
  confirm_assignment();

  parse_identifier_csv();
  string trace_name = csv;

  u32 trace_port   = 0;
  u32 tlm2pin_port = 0;
  string tlm2pin_name;

  parse_non_empty_csv();
  string second = csv;

  if (more_csv) {
    parse_non_empty_csv();
    string third = csv;
    if (more_csv) {
      parse_identifier_csv();
      tlm2pin_name = csv;
      confirm_no_more_csv();
      trace_port  = strtou32(second);
      tlm2pin_port = strtou32(third);
    }
    else {
      tlm2pin_port = strtou32(second);
      tlm2pin_name = third;
      confirm_identifier(tlm2pin_name);
    }
  }
  else {
    tlm2pin_name = second;
    confirm_identifier(tlm2pin_name);
  }

  connect_memory_trace_tlm2pin(trace_name, trace_port, tlm2pin_port, tlm2pin_name);
}



// connect_mmio_core=<MmioName>[,<OutputName>],<InputName>,<CoreName>
void parse_connect_mmio_core() {
  XTSC_TRACE(logger, "enter parse_connect_mmio_core()");
  confirm_assignment();

  parse_identifier_csv();
  string mmio_name(csv);

  parse_identifier_csv();
  string second(csv);

  parse_identifier_csv();
  string third(csv);

  string output_name(second);
  string input_name(third);
  string core_name(third);

  if (more_csv) {
    parse_identifier_csv();
    confirm_no_more_csv();
    core_name = csv;
  }
  else {
    input_name = second;
  }

  connect_mmio_core(mmio_name, output_name, input_name, core_name);
}



// connect_mmio_distributor=<MmioName>,<OutputName>,<InputName>,<DistributorName>
void parse_connect_mmio_distributor() {
  XTSC_TRACE(logger, "enter parse_connect_mmio_distributor()");
  confirm_assignment();

  parse_identifier_csv();
  string mmio_name = csv;

  parse_identifier_csv();
  string output_name = csv;

  parse_identifier_csv();
  string input_name = csv;

  parse_identifier_csv();
  string distributor_name = csv;

  confirm_no_more_csv();

  connect_mmio_distributor(mmio_name, output_name, input_name, distributor_name);
}



// connect_mmio_logic=<MmioName>,<OutputName>[,<InputName>],<LogicName>
void parse_connect_mmio_logic() {
  XTSC_TRACE(logger, "enter parse_connect_mmio_logic()");
  confirm_assignment();

  parse_identifier_csv();
  string mmio_name = csv;

  parse_identifier_csv();
  string output_name = csv;

  string input_name, logic_name;

  parse_identifier_csv();
  string third = csv;

  if (more_csv) {
    input_name = third;
    parse_identifier_csv();
    logic_name = csv;
    confirm_no_more_csv();
  }
  else {
    input_name = output_name;
    logic_name = third;
  }

  connect_mmio_logic(mmio_name, output_name, input_name, logic_name);
}



// connect_mmio_master=<MmioName>,<OutputName>,<MasterName>
void parse_connect_mmio_master() {
  XTSC_TRACE(logger, "enter parse_connect_mmio_master()");
  confirm_assignment();

  parse_identifier_csv();
  string mmio_name(csv);

  parse_identifier_csv();
  string output_name(csv);

  parse_identifier_csv();
  string master_name(csv);

  confirm_no_more_csv();

  connect_mmio_master(mmio_name, output_name, master_name);
}



// connect_mmio_mmio=<SourceName>,<OutputName>[,<InputName>],<SinkName>
void parse_connect_mmio_mmio() {
  XTSC_TRACE(logger, "enter parse_connect_mmio_mmio()");
  confirm_assignment();

  parse_identifier_csv();
  string source_name = csv;

  parse_identifier_csv();
  string output_name = csv;

  string input_name, sink_name;

  parse_identifier_csv();
  string third = csv;

  if (more_csv) {
    input_name = third;
    parse_identifier_csv();
    sink_name = csv;
    confirm_no_more_csv();
  }
  else {
    input_name = output_name;
    sink_name = third;
  }

  connect_mmio_mmio(source_name, output_name, input_name, sink_name);
}



// connect_mmio_producer=<MmioName>,<OutputName>,<ProducerName>
void parse_connect_mmio_producer() {
  XTSC_TRACE(logger, "enter parse_connect_mmio_producer()");
  confirm_assignment();

  parse_identifier_csv();
  string mmio_name(csv);

  parse_identifier_csv();
  string output_name(csv);

  parse_identifier_csv();
  string producer_name(csv);

  confirm_no_more_csv();

  connect_mmio_producer(mmio_name, output_name, producer_name);
}



// connect_mmio_proxy=<MmioName>,<OutputName>[,<InputName>],<ProxyName>
void parse_connect_mmio_proxy() {
  XTSC_TRACE(logger, "enter parse_connect_mmio_proxy()");
  confirm_assignment();

  parse_identifier_csv();
  string mmio_name = csv;

  parse_identifier_csv();
  string output_name = csv;

  string input_name, proxy_name;

  parse_identifier_csv();
  string third = csv;

  if (more_csv) {
    input_name = third;
    parse_identifier_csv();
    proxy_name = csv;
    confirm_no_more_csv();
  }
  else {
    input_name = output_name;
    proxy_name = third;
  }

  connect_mmio_proxy(mmio_name, output_name, input_name, proxy_name);
}



// connect_mmio_source=<MmioName>,<OutputName>,<SourceName>
void parse_connect_mmio_source() {
  XTSC_TRACE(logger, "enter parse_connect_mmio_source()");
  confirm_assignment();

  parse_identifier_csv();
  string mmio_name(csv);

  parse_identifier_csv();
  string output_name(csv);

  parse_identifier_csv();
  string source_name(csv);

  confirm_no_more_csv();

  connect_mmio_source(mmio_name, output_name, source_name);
}



// connect_mmio_wire=<MmioName>[,<OutputName>],<WireName>
void parse_connect_mmio_wire() {
  XTSC_TRACE(logger, "enter parse_connect_mmio_wire()");
  confirm_assignment();

  parse_identifier_csv();
  string mmio_name(csv);

  parse_identifier_csv();
  string output_name(csv);
  string wire_name(csv);

  if (more_csv) {
    parse_identifier_csv();
    confirm_no_more_csv();
    wire_name = csv;
  }

  connect_mmio_wire(mmio_name, output_name, wire_name);
}




// connect_mmio_wrapper=<MmioName>,<MmioOutputName>[,<WrapperOutputName>]
void parse_connect_mmio_wrapper() {
  XTSC_TRACE(logger, "enter parse_connect_mmio_wrapper()");
  confirm_assignment();

  parse_identifier_csv();
  string mmio_name = csv;

  parse_identifier_csv();
  string mmio_output_name = csv;

  string wrapper_output_name(mmio_output_name);

  if (more_csv) {
    parse_identifier_csv();
    wrapper_output_name = csv;
    confirm_no_more_csv();
  }

  connect_mmio_wrapper(mmio_name, mmio_output_name, wrapper_output_name);
}



// connect_pin2tlm_arbiter=<Pin2tlmName>[,<Pin2tlmPort>],<ArbiterPort>,<ArbiterName>
void parse_connect_pin2tlm_arbiter() {
  XTSC_TRACE(logger, "enter parse_connect_pin2tlm_arbiter()");
  confirm_assignment();

  parse_identifier_csv();
  string pin2tlm_name = csv;

  u32 pin2tlm_port = 0;
  u32 arbiter_port = 0;
  string arbiter_name;

  parse_non_empty_csv();
  string second = csv;

  parse_non_empty_csv();
  string third = csv;

  if (more_csv) {
    parse_identifier_csv();
    arbiter_name = csv;
    confirm_no_more_csv();
    pin2tlm_port = strtou32(second);
    arbiter_port = strtou32(third);
  }
  else {
    arbiter_port = strtou32(second);
    arbiter_name = third;
    confirm_identifier(arbiter_name);
  }

  connect_pin2tlm_arbiter(pin2tlm_name, pin2tlm_port, arbiter_port, arbiter_name);
}



// connect_pin2tlm_cohctrl=<Pin2tlmName>[,<Pin2tlmPort>],<CohctrlPort>,<CohctrlName>
void parse_connect_pin2tlm_cohctrl() {
  XTSC_TRACE(logger, "enter parse_connect_pin2tlm_cohctrl()");
  confirm_assignment();

  parse_identifier_csv();
  string pin2tlm_name = csv;

  u32 pin2tlm_port = 0;
  u32 cohctrl_port = 0;
  string cohctrl_name;

  parse_non_empty_csv();
  string second = csv;

  parse_non_empty_csv();
  string third = csv;

  if (more_csv) {
    parse_identifier_csv();
    cohctrl_name = csv;
    confirm_no_more_csv();
    pin2tlm_port = strtou32(second);
    cohctrl_port = strtou32(third);
  }
  else {
    cohctrl_port = strtou32(second);
    cohctrl_name = third;
    confirm_identifier(cohctrl_name);
  }

  connect_pin2tlm_cohctrl(pin2tlm_name, pin2tlm_port, cohctrl_port, cohctrl_name);
}



// connect_pin2tlm_core=<Pin2tlmName>[,<Pin2tlmPort>],<CoreName>
void parse_connect_pin2tlm_core() {
  XTSC_TRACE(logger, "enter parse_connect_pin2tlm_core()");
  confirm_assignment();

  parse_identifier_csv();
  string pin2tlm_name = csv;

  u32 pin2tlm_port = 0;
  string core_name;

  parse_non_empty_csv();
  string second = csv;

  if (more_csv) {
    parse_identifier_csv();
    core_name = csv;
    confirm_no_more_csv();
    pin2tlm_port = strtou32(second);
  }
  else {
    core_name = second;
    confirm_identifier(core_name);
  }

  connect_pin2tlm_core(pin2tlm_name, pin2tlm_port, core_name);
}



// connect_pin2tlm_memory=<Pin2tlmName>[[,<Pin2tlmPort>],<MemoryPort>],<MemoryName>
void parse_connect_pin2tlm_memory() {
  XTSC_TRACE(logger, "enter parse_connect_pin2tlm_memory()");
  confirm_assignment();

  parse_identifier_csv();
  string pin2tlm_name = csv;

  u32 pin2tlm_port = 0;
  u32 memory_port = 0;
  string memory_name;

  parse_non_empty_csv();
  string second = csv;

  if (more_csv) {
    parse_non_empty_csv();
    string third = csv;
    if (more_csv) {
      parse_identifier_csv();
      memory_name = csv;
      confirm_no_more_csv();
      pin2tlm_port = strtou32(second);
      memory_port = strtou32(third);
    }
    else {
      memory_port = strtou32(second);
      memory_name = third;
      confirm_identifier(memory_name);
    }
  }
  else {
    memory_name = second;
    confirm_identifier(memory_name);
  }

  connect_pin2tlm_memory(pin2tlm_name, pin2tlm_port, memory_port, memory_name);
}



// connect_pin2tlm_memory_trace=<Pin2tlmName>[[,<Pin2tlmPort>],<TracePort>],<TraceName>
void parse_connect_pin2tlm_memory_trace() {
  XTSC_TRACE(logger, "enter parse_connect_pin2tlm_memory_trace()");
  confirm_assignment();

  parse_identifier_csv();
  string pin2tlm_name = csv;

  u32 pin2tlm_port = 0;
  u32 trace_port = 0;
  string trace_name;

  parse_non_empty_csv();
  string second = csv;

  if (more_csv) {
    parse_non_empty_csv();
    string third = csv;
    if (more_csv) {
      parse_identifier_csv();
      trace_name = csv;
      confirm_no_more_csv();
      pin2tlm_port = strtou32(second);
      trace_port = strtou32(third);
    }
    else {
      trace_port = strtou32(second);
      trace_name = third;
      confirm_identifier(trace_name);
    }
  }
  else {
    trace_name = second;
    confirm_identifier(trace_name);
  }

  connect_pin2tlm_memory_trace(pin2tlm_name, pin2tlm_port, trace_port, trace_name);
}



// connect_pin2tlm_mmio=<Pin2tlmName>[,<Pin2tlmPort>],<MmioName>
void parse_connect_pin2tlm_mmio() {
  XTSC_TRACE(logger, "enter parse_connect_pin2tlm_mmio()");
  confirm_assignment();

  parse_identifier_csv();
  string pin2tlm_name = csv;

  u32 pin2tlm_port = 0;
  string mmio_name;

  parse_non_empty_csv();
  string second = csv;

  if (more_csv) {
    parse_identifier_csv();
    mmio_name = csv;
    confirm_no_more_csv();
    pin2tlm_port = strtou32(second);
  }
  else {
    mmio_name = second;
    confirm_identifier(mmio_name);
  }

  connect_pin2tlm_mmio(pin2tlm_name, pin2tlm_port, mmio_name);
}



// connect_pin2tlm_router=<Pin2tlmName>[,<Pin2tlmPort>],<RouterName>
void parse_connect_pin2tlm_router() {
  XTSC_TRACE(logger, "enter parse_connect_pin2tlm_router()");
  confirm_assignment();

  parse_identifier_csv();
  string pin2tlm_name = csv;

  u32 pin2tlm_port = 0;
  string router_name;

  parse_non_empty_csv();
  string second = csv;

  if (more_csv) {
    parse_identifier_csv();
    router_name = csv;
    confirm_no_more_csv();
    pin2tlm_port = strtou32(second);
  }
  else {
    router_name = second;
    confirm_identifier(router_name);
  }

  connect_pin2tlm_router(pin2tlm_name, pin2tlm_port, router_name);
}



// connect_pin2tlm_slave=<Pin2tlmName>[,<Pin2tlmPort>],<SlaveName>
void parse_connect_pin2tlm_slave() {
  XTSC_TRACE(logger, "enter parse_connect_pin2tlm_slave()");
  confirm_assignment();

  parse_identifier_csv();
  string pin2tlm_name = csv;

  u32 pin2tlm_port = 0;
  string slave_name;

  parse_non_empty_csv();
  string second = csv;

  if (more_csv) {
    parse_identifier_csv();
    slave_name = csv;
    confirm_no_more_csv();
    pin2tlm_port = strtou32(second);
  }
  else {
    slave_name = second;
    confirm_identifier(slave_name);
  }

  connect_pin2tlm_slave(pin2tlm_name, pin2tlm_port, slave_name);
}



// connect_producer_loader=<ProducerName>,<LoaderName>
void parse_connect_producer_loader() {
  XTSC_TRACE(logger, "enter parse_connect_producer_loader()");
  confirm_assignment();

  parse_identifier_csv();
  string producer_name = csv;

  parse_identifier_csv();
  string loader_name = csv;

  confirm_no_more_csv();

  connect_producer_loader(producer_name, loader_name);
}



// connect_producer_proxy=<ProducerName>[,<NamePrefix>],<ProxyName>
void parse_connect_producer_proxy() {
  XTSC_TRACE(logger, "enter parse_connect_producer_proxy()");
  confirm_assignment();

  parse_identifier_csv();
  string producer_name = csv;

  parse_identifier_csv();
  string second = csv;

  string proxy_name;
  string name_prefix("@");

  if (more_csv) {
    name_prefix = second;
    parse_identifier_csv();
    proxy_name = csv;
    confirm_no_more_csv();
  }
  else {
    proxy_name = second;
  }

  connect_producer_proxy(producer_name, name_prefix, proxy_name);
}



// connect_producer_queue=<ProducerName>[,<ProducerPort>],<QueueName>
void parse_connect_producer_queue() {
  XTSC_TRACE(logger, "enter parse_connect_producer_queue()");
  confirm_assignment();

  parse_identifier_csv();
  string producer_name = csv;

  u32 producer_port = 0;
  string queue_name;
  parse_non_empty_csv();

  if (is_identifier(csv)) {
    queue_name = csv;
  }
  else {
    producer_port = strtou32(csv);
    parse_identifier_csv();
    queue_name = csv;
  }
  confirm_no_more_csv();

  connect_producer_queue(producer_name, producer_port, queue_name);
}



// connect_producer_queue_pin=<ProducerName>,<QueueName>
void parse_connect_producer_queue_pin() {
  XTSC_TRACE(logger, "enter parse_connect_producer_queue_pin()");
  confirm_assignment();

  parse_identifier_csv();
  string producer_name = csv;

  parse_identifier_csv();
  string queue_pin_name = csv;

  confirm_no_more_csv();

  connect_producer_queue_pin(producer_name, queue_pin_name);
}



// connect_producer_wrapper=<ProducerName>,<NamePrefix>
void parse_connect_producer_wrapper() {
  XTSC_TRACE(logger, "enter parse_connect_producer_wrapper()");
  confirm_assignment();

  parse_identifier_csv();
  string producer_name = csv;

  parse_identifier_csv();
  string name_prefix = csv;

  confirm_no_more_csv();

  connect_producer_wrapper(producer_name, name_prefix);
}



// connect_proxy_cohctrl=<ProxyName>[,<OutputName>],<CohctrlPort>,<CohctrlName>
void parse_connect_proxy_cohctrl() {
  XTSC_TRACE(logger, "enter parse_connect_proxy_cohctrl()");
  confirm_assignment();

  parse_identifier_csv();
  string proxy_name = csv;

  parse_csv();
  string second = csv;

  parse_csv();
  string third = csv;

  string output_name("TIE_CCON");
  u32    cohctrl_port = 0;
  string cohctrl_name;

  if (more_csv) {
    confirm_identifier(second);
    output_name = second;
    cohctrl_port = strtou32(third);
    parse_identifier_csv();
    cohctrl_name = csv;
    confirm_no_more_csv();
  }
  else {
    cohctrl_port = strtou32(second);
    confirm_identifier(third);
    cohctrl_name = third;
  }

  connect_proxy_cohctrl(proxy_name, output_name, cohctrl_port, cohctrl_name);
}



// connect_proxy_consumer=<ProxyName>[,<NamePrefix>],<ConsumerName>
void parse_connect_proxy_consumer() {
  XTSC_TRACE(logger, "enter parse_connect_proxy_consumer()");
  confirm_assignment();

  parse_identifier_csv();
  string proxy_name = csv;

  parse_identifier_csv();
  string second = csv;

  string consumer_name;
  string name_prefix("@");

  if (more_csv) {
    name_prefix = second;
    parse_identifier_csv();
    consumer_name = csv;
    confirm_no_more_csv();
  }
  else {
    consumer_name = second;
  }

  connect_proxy_consumer(proxy_name, name_prefix, consumer_name);
}



// connect_proxy_core=<ProxyName>[,<NamePrefix>],<Interface>,<CoreName>
void parse_connect_proxy_core() {
  XTSC_TRACE(logger, "enter parse_connect_proxy_core()");
  confirm_assignment();

  parse_identifier_csv();
  string proxy_name = csv;

  string name_prefix, iface, core_name;

  parse_csv();
  string second = csv;

  if (second != "") confirm_identifier(second);

  parse_identifier_csv();
  string third = csv;

  if (more_csv) {
    name_prefix = second;
    iface = third;
    parse_identifier_csv();
    core_name = csv;
    confirm_no_more_csv();
  }
  else {
    iface = second;
    confirm_identifier(iface);
    core_name = third;
  }

  connect_proxy_core(proxy_name, name_prefix, iface, core_name);
}



// connect_proxy_lookup_pin=<ProxyName>[,<NamePrefix>],<LookupName>
void parse_connect_proxy_lookup_pin() {
  XTSC_TRACE(logger, "enter parse_connect_proxy_lookup_pin()");
  confirm_assignment();

  parse_identifier_csv();
  string proxy_name = csv;

  parse_identifier_csv();
  string second = csv;

  string lookup_pin_name;
  string name_prefix("@");

  if (more_csv) {
    name_prefix = second;
    parse_identifier_csv();
    lookup_pin_name = csv;
    confirm_no_more_csv();
  }
  else {
    lookup_pin_name = second;
  }

  connect_proxy_lookup_pin(proxy_name, name_prefix, lookup_pin_name);
}



// connect_proxy_memory_pin=<ProxyName>[,<NamePrefix>][,<MemoryPort>],<MemoryName>
void parse_connect_proxy_memory_pin() {
  XTSC_TRACE(logger, "enter parse_connect_proxy_memory_pin()");
  confirm_assignment();

  parse_identifier_csv();
  string proxy_name = csv;

  parse_csv();
  string second = csv;

  string name_prefix;
  u32    memory_port = 0;
  string memory_name;

  if (more_csv) {
    parse_csv();
    string third = csv;
    if (more_csv) {
      name_prefix = second;
      memory_port = strtou32(third);
      parse_csv();
      memory_name = csv;
      confirm_no_more_csv();
    }
    else {
      if ((second == "") || (second[0] < '0') || (second[0] > '9')) {
        name_prefix = second;
      }
      else {
        memory_port = strtou32(second);
      }
      memory_name = third;
    }
  }
  else {
    memory_name = second;
  }

  if (name_prefix != "") confirm_identifier(name_prefix);
  confirm_identifier(memory_name);

  connect_proxy_memory_pin(proxy_name, name_prefix, memory_port, memory_name);
}



// connect_proxy_loader=<ProxyName>[,<NamePrefix>],<LoaderName>
void parse_connect_proxy_loader() {
  XTSC_TRACE(logger, "enter parse_connect_proxy_loader()");
  confirm_assignment();

  parse_identifier_csv();
  string proxy_name = csv;

  parse_identifier_csv();
  string second = csv;

  string loader_name;
  string name_prefix;

  if (more_csv) {
    name_prefix = second;
    parse_identifier_csv();
    loader_name = csv;
    confirm_no_more_csv();
  }
  else {
    loader_name = second;
  }

  connect_proxy_loader(proxy_name, name_prefix, loader_name);
}



// connect_proxy_logic=<ProxyName>[,<OutputName>],<InputName>,<LogicName>
void parse_connect_proxy_logic() {
  XTSC_TRACE(logger, "enter parse_connect_proxy_logic()");
  confirm_assignment();

  parse_identifier_csv();
  string proxy_name = csv;

  parse_identifier_csv();
  string output_name = csv;

  string input_name, logic_name;

  parse_identifier_csv();
  string third = csv;

  if (more_csv) {
    input_name = third;
    parse_identifier_csv();
    logic_name = csv;
    confirm_no_more_csv();
  }
  else {
    input_name = output_name;
    logic_name = third;
  }

  connect_proxy_logic(proxy_name, output_name, input_name, logic_name);
}



// connect_proxy_mmio=<ProxyName>[,<OutputName>],<InputName>,<MmioName>
void parse_connect_proxy_mmio() {
  XTSC_TRACE(logger, "enter parse_connect_proxy_mmio()");
  confirm_assignment();

  parse_identifier_csv();
  string proxy_name = csv;

  parse_identifier_csv();
  string output_name = csv;

  string input_name, mmio_name;

  parse_identifier_csv();
  string third = csv;

  if (more_csv) {
    input_name = third;
    parse_identifier_csv();
    mmio_name = csv;
    confirm_no_more_csv();
  }
  else {
    input_name = output_name;
    mmio_name = third;
  }

  connect_proxy_mmio(proxy_name, output_name, input_name, mmio_name);
}



// connect_proxy_pin2tlm=<ProxyName>[,<NamePrefix>][,<MemoryPort>],<Pin2tlmName>
void parse_connect_proxy_pin2tlm() {
  XTSC_TRACE(logger, "enter parse_connect_proxy_pin2tlm()");
  confirm_assignment();

  parse_identifier_csv();
  string proxy_name = csv;

  parse_csv();
  string second = csv;

  string name_prefix;
  u32    memory_port = 0;
  string pin2tlm_name;

  if (more_csv) {
    parse_csv();
    string third = csv;
    if (more_csv) {
      name_prefix = second;
      memory_port = strtou32(third);
      parse_csv();
      pin2tlm_name = csv;
      confirm_no_more_csv();
    }
    else {
      if ((second == "") || (second[0] < '0') || (second[0] > '9')) {
        name_prefix = second;
      }
      else {
        memory_port = strtou32(second);
      }
      pin2tlm_name = third;
    }
  }
  else {
    pin2tlm_name = second;
  }

  if (name_prefix != "") confirm_identifier(name_prefix);
  confirm_identifier(pin2tlm_name);

  connect_proxy_pin2tlm(proxy_name, name_prefix, memory_port, pin2tlm_name);
}



// connect_proxy_queue_pin=<ProxyName>[,<NamePrefix>],<QueueName>
void parse_connect_proxy_queue_pin() {
  XTSC_TRACE(logger, "enter parse_connect_proxy_queue_pin()");
  confirm_assignment();

  parse_identifier_csv();
  string proxy_name = csv;

  parse_identifier_csv();
  string second = csv;

  string queue_pin_name;
  string name_prefix("@");

  if (more_csv) {
    name_prefix = second;
    parse_identifier_csv();
    queue_pin_name = csv;
    confirm_no_more_csv();
  }
  else {
    queue_pin_name = second;
  }

  connect_proxy_queue_pin(proxy_name, name_prefix, queue_pin_name);
}



// connect_proxy_wire=<ProxyName>[,<OutputName>],<WireName>
void parse_connect_proxy_wire() {
  XTSC_TRACE(logger, "enter parse_connect_proxy_wire()");
  confirm_assignment();

  parse_identifier_csv();
  string proxy_name = csv;

  parse_identifier_csv();
  string output_name = csv;

  string wire_name;

  if (more_csv) {
    parse_identifier_csv();
    wire_name = csv;
    confirm_no_more_csv();
  }
  else {
    wire_name = output_name;
  }

  connect_proxy_wire(proxy_name, output_name, wire_name);
}



// connect_queue_consumer=<QueueName>[,<ConsumerPort>],<ConsumerName>
void parse_connect_queue_consumer() {
  XTSC_TRACE(logger, "enter parse_connect_queue_consumer()");
  confirm_assignment();

  parse_identifier_csv();
  string queue_name = csv;

  u32 consumer_port = 0;
  string consumer_name;
  parse_non_empty_csv();

  if (is_identifier(csv)) {
    consumer_name = csv;
  }
  else {
    consumer_port = strtou32(csv);
    parse_identifier_csv();
    consumer_name = csv;
  }
  confirm_no_more_csv();

  connect_queue_consumer(queue_name, consumer_port, consumer_name);
}



// connect_queue_core=[<QueueName>,][<ConsumerPort>,]<TiePortName>,<CoreName>
void parse_connect_queue_core() {
  XTSC_TRACE(logger, "enter parse_connect_queue_core()");
  confirm_assignment();
  string queue_name, tie_name, core_name;
  u32 consumer_port = 0;

  parse_non_empty_csv();
  string first = csv;

  parse_non_empty_csv();
  string second = csv;

  if (more_csv) {
    parse_non_empty_csv();
    string third = csv;
    if (more_csv) {
      queue_name = first;
      confirm_identifier(queue_name);
      consumer_port = strtou32(second);
      tie_name = third;
      confirm_identifier(tie_name);
      parse_identifier_csv();
      core_name = csv;
      confirm_no_more_csv();
    }
    else {
      tie_name = second;
      confirm_identifier(tie_name);
      core_name = third;
      confirm_identifier(core_name);
      if (is_identifier(first)) {
        queue_name = first;
      }
      else {
        queue_name = tie_name;
        consumer_port = strtou32(first);
      }
    }
  }
  else {
    queue_name = first;
    tie_name   = first;
    core_name  = second;
  }

  connect_queue_core(queue_name, consumer_port, tie_name, core_name);
}



// connect_queue_pin_consumer=<QueueName>,<ConsumerName>
void parse_connect_queue_pin_consumer() {
  XTSC_TRACE(logger, "enter parse_connect_queue_pin_consumer()");
  confirm_assignment();

  parse_identifier_csv();
  string queue_pin_name = csv;

  parse_identifier_csv();
  string consumer_name = csv;

  confirm_no_more_csv();

  connect_queue_pin_consumer(queue_pin_name, consumer_name);
}



// connect_queue_pin_core=[<QueueName>,]<TiePortName>,<CoreName>
void parse_connect_queue_pin_core() {
  XTSC_TRACE(logger, "enter parse_connect_queue_pin_core()");
  confirm_assignment();
  string queue_pin_name, tie_name, core_name;

  parse_identifier_csv();
  string first = csv;

  parse_identifier_csv();
  string second = csv;

  if (more_csv) {
    parse_identifier_csv();
    confirm_no_more_csv();
    queue_pin_name = first;
    tie_name       = second;
    core_name      = csv;
  }
  else {
    queue_pin_name = first;
    tie_name       = first;
    core_name      = second;
  }
  connect_queue_pin_core(queue_pin_name, tie_name, core_name);
}



// connect_queue_pin_proxy=<ProducerName>[,<NamePrefix>],<ProxyName>
void parse_connect_queue_pin_proxy() {
  XTSC_TRACE(logger, "enter parse_connect_queue_pin_proxy()");
  confirm_assignment();

  parse_identifier_csv();
  string queue_pin_name = csv;

  parse_identifier_csv();
  string second = csv;

  string proxy_name;
  string name_prefix("@");

  if (more_csv) {
    name_prefix = second;
    parse_identifier_csv();
    proxy_name = csv;
    confirm_no_more_csv();
  }
  else {
    proxy_name = second;
  }

  connect_queue_pin_proxy(queue_pin_name, name_prefix, proxy_name);
}



// connect_queue_pin_wrapper=<QueueName>,<NamePrefix>
void parse_connect_queue_pin_wrapper() {
  XTSC_TRACE(logger, "enter parse_connect_queue_pin_wrapper()");
  confirm_assignment();

  parse_identifier_csv();
  string queue_pin_name = csv;

  parse_identifier_csv();
  string name_prefix = csv;

  confirm_no_more_csv();

  connect_queue_pin_wrapper(queue_pin_name, name_prefix);
}



// connect_router_arbiter=<RouterName>,<RouterPort>,<ArbiterPort>,<ArbiterName>
void parse_connect_router_arbiter() {
  XTSC_TRACE(logger, "enter parse_connect_router_arbiter()");
  confirm_assignment();

  parse_identifier_csv();
  string router_name = csv;

  parse_non_empty_csv();
  u32 router_port = strtou32(csv);

  parse_non_empty_csv();
  u32 arbiter_port = strtou32(csv);

  parse_identifier_csv();
  string arbiter_name = csv;

  confirm_no_more_csv();

  connect_router_arbiter(router_name, router_port, arbiter_port, arbiter_name);
}



// cohctrl_router_cohctrl=<RouterName>,<RouterPort>[,<CohctrlPort>],<CohctrlName>
void parse_connect_router_cohctrl() {
  XTSC_TRACE(logger, "enter parse_connect_router_cohctrl()");
  confirm_assignment();

  parse_identifier_csv();
  string router_name = csv;

  parse_non_empty_csv();
  u32 router_port = strtou32(csv);

  parse_non_empty_csv();

  u32 cohctrl_port = 0xFFFFFFFF;

  if (more_csv) {
    cohctrl_port = strtou32(csv);
    parse_non_empty_csv();
    confirm_no_more_csv();
  }

  confirm_identifier(csv);
  string cohctrl_name = csv;

  if (cohctrl_port == 0xFFFFFFFF) {
    cohctrl_info& ci = find_or_infer_cohctrl(cohctrl_name);
    cohctrl_port = ci.get_first_free_master_port();
  }

  connect_router_cohctrl(router_name, router_port, cohctrl_port, cohctrl_name);
}



// connect_router_core=<RouterName>,<RouterPort>[,<PortName>],<CoreName>
void parse_connect_router_core() {
  XTSC_TRACE(logger, "enter parse_connect_router_core()");
  confirm_assignment();

  parse_identifier_csv();
  string router_name = csv;

  parse_non_empty_csv();
  u32 port = strtou32(csv);

  parse_identifier_csv();

  string port_name = "inbound_pif";

  if (more_csv) {
    port_name = csv;
    parse_identifier_csv();
    confirm_no_more_csv();
  }

  string core_name = csv;

  connect_router_core(router_name, port, port_name, core_name);
}



// connect_router_dma=<RouterName>,<RouterPort>[,<DmaPort>],<DmaName>
void parse_connect_router_dma() {
  XTSC_TRACE(logger, "enter parse_connect_router_dma()");
  confirm_assignment();

  parse_identifier_csv();
  string router_name = csv;

  parse_non_empty_csv();
  u32 router_port = strtou32(csv);

  parse_non_empty_csv();

  u32 dma_port = 0;

  if (more_csv) {
    dma_port = strtou32(csv);
    parse_non_empty_csv();
    confirm_no_more_csv();
  }

  confirm_identifier(csv);
  string dma_name = csv;

  connect_router_dma(router_name, router_port, dma_port, dma_name);
}



// connect_router_memory=<RouterName>,<RouterPort>[,<MemoryPort>],<MemoryName>
void parse_connect_router_memory() {
  XTSC_TRACE(logger, "enter parse_connect_router_memory()");
  confirm_assignment();

  parse_identifier_csv();
  string router_name = csv;

  parse_non_empty_csv();
  u32 router_port = strtou32(csv);

  parse_non_empty_csv();

  u32 memory_port = 0;

  if (more_csv) {
    memory_port = strtou32(csv);
    parse_non_empty_csv();
    confirm_no_more_csv();
  }

  confirm_identifier(csv);
  string memory_name = csv;

  connect_router_memory(router_name, router_port, memory_port, memory_name);
}



// connect_router_memory_trace=<RouterName>,<RouterPort>[,<TracePort>],<TraceName>
void parse_connect_router_memory_trace() {
  XTSC_TRACE(logger, "enter parse_connect_router_memory_trace()");
  confirm_assignment();

  parse_identifier_csv();
  string router_name = csv;

  parse_non_empty_csv();
  u32 router_port = strtou32(csv);

  parse_non_empty_csv();

  u32 trace_port = 0;

  if (more_csv) {
    trace_port = strtou32(csv);
    parse_non_empty_csv();
    confirm_no_more_csv();
  }

  confirm_identifier(csv);
  string trace_name = csv;

  connect_router_memory_trace(router_name, router_port, trace_port, trace_name);
}



// connect_router_mmio=<RouterName>,<RouterPort>,<MmioName>
void parse_connect_router_mmio() {
  XTSC_TRACE(logger, "enter parse_connect_router_mmio()");
  confirm_assignment();

  parse_identifier_csv();
  string router_name = csv;

  parse_non_empty_csv();
  u32 port = strtou32(csv);

  parse_identifier_csv();
  string mmio_name = csv;

  confirm_no_more_csv();

  connect_router_mmio(router_name, port, mmio_name);
}



// connect_router_router=<MasterName>,<MasterPort>,<SlaveName>
void parse_connect_router_router() {
  XTSC_TRACE(logger, "enter parse_connect_router_router()");
  confirm_assignment();

  parse_identifier_csv();
  string master_name = csv;

  parse_non_empty_csv();
  u32 port = strtou32(csv);

  parse_identifier_csv();
  string slave_name = csv;

  confirm_no_more_csv();

  connect_router_router(master_name, port, slave_name);
}



// connect_router_slave=<RouterName>,<RouterPort>,<SlaveName>
void parse_connect_router_slave() {
  XTSC_TRACE(logger, "enter parse_connect_router_slave()");
  confirm_assignment();

  parse_identifier_csv();
  string router_name = csv;

  parse_non_empty_csv();
  u32 port = strtou32(csv);

  parse_identifier_csv();
  string slave_name = csv;

  confirm_no_more_csv();

  connect_router_slave(router_name, port, slave_name);
}



// connect_router_tlm2pin=<RouterName>,<RouterPort>[,<Tlm2pinPort>],<Tlm2pinName>
void parse_connect_router_tlm2pin() {
  XTSC_TRACE(logger, "enter parse_connect_router_tlm2pin()");
  confirm_assignment();

  parse_identifier_csv();
  string router_name = csv;

  parse_non_empty_csv();
  u32 router_port = strtou32(csv);

  string tlm2pin_name;
  u32 tlm2pin_port = 0;

  parse_non_empty_csv();
  string third = csv;

  if (more_csv) {
    parse_identifier_csv();
    tlm2pin_name = csv;
    confirm_no_more_csv();
    tlm2pin_port = strtou32(third);
  }
  else {
    tlm2pin_name = third;
    confirm_identifier(tlm2pin_name);
  }

  connect_router_tlm2pin(router_name, router_port, tlm2pin_port, tlm2pin_name);
}



// connect_signal_core=[<SignalName>,]<InputPinName>,<CoreName>
void parse_connect_signal_core() {
  XTSC_TRACE(logger, "enter parse_connect_signal_core()");
  confirm_assignment();
  string signal_name, input_pin_name, core_name;

  parse_identifier_csv();
  string first = csv;

  parse_identifier_csv();
  string second = csv;

  if (more_csv) {
    parse_identifier_csv();
    confirm_no_more_csv();
    signal_name    = first;
    input_pin_name = second;
    core_name      = csv;
  }
  else {
    signal_name    = first;
    input_pin_name = first;
    core_name      = second;
  }
  connect_signal_core(signal_name, input_pin_name, core_name);
}



// connect_source_cohctrl=<SourceName>[,<OutputName>],<CohctrlPort>,<CohctrlName>
void parse_connect_source_cohctrl() {
  XTSC_TRACE(logger, "enter parse_connect_source_cohctrl()");
  confirm_assignment();

  parse_identifier_csv();
  string source_name(csv);

  string second, third;
  string output_name, cohctrl_name;
  u32 port = 0;

  parse_non_empty_csv();
  second = csv;

  parse_non_empty_csv();
  third = csv;

  if (more_csv) {
    output_name = second;
    confirm_identifier(output_name);
    port = strtou32(third);
    parse_identifier_csv();
    cohctrl_name = csv;
    confirm_no_more_csv();
  }
  else {
    port = strtou32(second);
    cohctrl_name = third;
    confirm_identifier(cohctrl_name);
  }

  connect_source_cohctrl(source_name, output_name, port, cohctrl_name);
}



// connect_source_core=[<SourceName>,[<OutputName>,]]<InputName>,<CoreName>
void parse_connect_source_core() {
  XTSC_TRACE(logger, "enter parse_connect_source_core()");
  confirm_assignment();
  string source_name, output_name, input_name, core_name;
  string first, second, third;

  parse_identifier_csv();
  first = csv;

  parse_identifier_csv();
  second = csv;

  if (more_csv) {
    parse_identifier_csv();
    third = csv;
    if (more_csv) {
      parse_identifier_csv();
      source_name = first;
      output_name = second;
      input_name  = third;
      core_name   = csv;
      confirm_no_more_csv();
    }
    else {
      source_name = first;
      input_name  = second;
      core_name   = third;
    }
  }
  else {
    source_name = first;
    input_name  = first;
    core_name   = second;
  }
  connect_source_core(source_name, output_name, input_name, core_name);
}



// connect_source_distributor=<SourceName>[,<OutputName>],<InputName>,<DistributorName>
void parse_connect_source_distributor() {
  XTSC_TRACE(logger, "enter parse_connect_source_distributor()");
  confirm_assignment();

  parse_identifier_csv();
  string source_name = csv;

  parse_identifier_csv();
  string second = csv;

  parse_identifier_csv();
  string third = csv;

  string output_name, input_name, distributor_name;

  if (more_csv) {
    output_name = second;
    input_name = third;
    parse_identifier_csv();
    distributor_name = csv;
    confirm_no_more_csv();
  }
  else {
    output_name = "";
    input_name = second;
    distributor_name = third;
  }

  connect_source_distributor(source_name, output_name, input_name, distributor_name);
}



// connect_source_logic=[<SourceName>,[<OutputName>,]]<InputName>,<LogicName>
void parse_connect_source_logic() {
  XTSC_TRACE(logger, "enter parse_connect_source_logic()");
  confirm_assignment();
  string source_name, output_name, input_name, logic_name;
  string first, second, third;

  parse_identifier_csv();
  first = csv;

  parse_identifier_csv();
  second = csv;

  if (more_csv) {
    parse_identifier_csv();
    third = csv;
    if (more_csv) {
      parse_identifier_csv();
      source_name = first;
      output_name = second;
      input_name  = third;
      logic_name  = csv;
      confirm_no_more_csv();
    }
    else {
      source_name = first;
      input_name  = second;
      logic_name  = third;
    }
  }
  else {
    source_name = first;
    input_name  = first;
    logic_name  = second;
  }
  connect_source_logic(source_name, output_name, input_name, logic_name);
}



// connect_source_mmio=[<SourceName>,[<OutputName>,]]<InputName>,<MmioName>
void parse_connect_source_mmio() {
  XTSC_TRACE(logger, "enter parse_connect_source_mmio()");
  confirm_assignment();
  string source_name, output_name, input_name, mmio_name;
  string first, second, third;

  parse_identifier_csv();
  first = csv;

  parse_identifier_csv();
  second = csv;

  if (more_csv) {
    parse_identifier_csv();
    third = csv;
    if (more_csv) {
      parse_identifier_csv();
      source_name = first;
      output_name = second;
      input_name  = third;
      mmio_name   = csv;
      confirm_no_more_csv();
    }
    else {
      source_name = first;
      input_name  = second;
      mmio_name   = csv;
    }
  }
  else {
    source_name = first;
    input_name  = first;
    mmio_name   = second;
  }
  connect_source_mmio(source_name, output_name, input_name, mmio_name);
}



// connect_source_proxy=<SourceName>[[,<OutputName>],<PortName>],<ProxyName>
void parse_connect_source_proxy() {
  XTSC_TRACE(logger, "enter parse_connect_source_proxy()");
  confirm_assignment();
  string source_name, output_name, port_name, proxy_name;
  string second, third;

  parse_identifier_csv();
  source_name = csv;

  parse_identifier_csv();
  second = csv;

  if (more_csv) {
    parse_identifier_csv();
    third = csv;
    if (more_csv) {
      parse_identifier_csv();
      output_name = second;
      port_name = third;
      proxy_name = csv;
      confirm_no_more_csv();
    }
    else {
      port_name = second;
      proxy_name = third;
    }
  }
  else {
    proxy_name = second;
  }

  connect_source_proxy(source_name, output_name, port_name, proxy_name);
}



// connect_source_signal=<SourceName>[,<OutputName>],<SignalName>
void parse_connect_source_signal() {
  XTSC_TRACE(logger, "enter parse_connect_source_signal()");
  confirm_assignment();
  string source_name, output_name, signal_name;
  string second;

  parse_identifier_csv();
  source_name = csv;

  parse_identifier_csv();
  second = csv;

  if (more_csv) {
    parse_identifier_csv();
    output_name = second;
    signal_name = csv;
    confirm_no_more_csv();
  }
  else {
    signal_name = second;
  }

  connect_source_signal(source_name, output_name, signal_name);
}



// connect_source_wire=<SourceName>[,<OutputName>],<WireName>
void parse_connect_source_wire() {
  XTSC_TRACE(logger, "enter parse_connect_source_wire()");
  confirm_assignment();
  string source_name, output_name, wire_name;
  string second;

  parse_identifier_csv();
  source_name = csv;

  parse_identifier_csv();
  second = csv;

  if (more_csv) {
    parse_identifier_csv();
    output_name = second;
    wire_name = csv;
    confirm_no_more_csv();
  }
  else {
    wire_name = second;
  }

  connect_source_wire(source_name, output_name, wire_name);
}



// connect_source_wrapper=<SourceName>[[,<OutputName>],<WrapperOutputName>]
void parse_connect_source_wrapper() {
  XTSC_TRACE(logger, "enter parse_connect_source_wrapper()");
  confirm_assignment();
  string source_name, output_name, wrapper_output_name;

  parse_identifier_csv();
  source_name = csv;

  if (more_csv) {
    parse_identifier_csv();
    string second = csv;

    if (more_csv) {
      parse_identifier_csv();
      wrapper_output_name = csv;
      output_name = second;
      confirm_no_more_csv();
    }
    else {
      wrapper_output_name = second;
    }
  }

  connect_source_wrapper(source_name, output_name, wrapper_output_name);
}



// connect_tlm2pin_memory_pin=<Tlm2pinName>[[,<Tlm2pinPort>],<MemoryPort>],<MemoryName>
void parse_connect_tlm2pin_memory_pin() {
  XTSC_TRACE(logger, "enter parse_connect_tlm2pin_memory_pin()");
  confirm_assignment();

  parse_identifier_csv();
  string tlm2pin_name = csv;

  string memory_pin_name;
  u32 tlm2pin_port = 0;
  u32 memory_port = 0;

  parse_non_empty_csv();
  string second = csv;

  if (more_csv) {
    parse_non_empty_csv();
    string third = csv;
    if (more_csv) {
      // 4 words (3 commas)
      parse_identifier_csv();
      memory_pin_name = csv;
      confirm_no_more_csv();
      tlm2pin_port = strtou32(second);
      memory_port  = strtou32(third);
    }
    else {
      // 3 words (2 commas)
      memory_pin_name = third;
      confirm_identifier(memory_pin_name);
      memory_port = strtou32(second);
    }
  }
  else {
    // 2 words (1 comma)
    memory_pin_name = second;
    confirm_identifier(memory_pin_name);
  }

  connect_tlm2pin_memory_pin(tlm2pin_name, tlm2pin_port, memory_port, memory_pin_name);
}



// connect_tlm2pin_pin2tlm=<Tlm2pinName>[,<Tlm2pinPort>,<Pin2tlmPort>],<Pin2tlmName>
void parse_connect_tlm2pin_pin2tlm() {
  XTSC_TRACE(logger, "enter parse_connect_tlm2pin_pin2tlm()");
  confirm_assignment();

  parse_identifier_csv();
  string tlm2pin_name = csv;

  string pin2tlm_name;
  u32 tlm2pin_port = 0;
  u32 pin2tlm_port = 0;

  parse_non_empty_csv();
  string second = csv;

  if (more_csv) {
    // 4 words (3 commas)
    parse_non_empty_csv();
    string third = csv;
    parse_identifier_csv();
    pin2tlm_name = csv;
    confirm_no_more_csv();
    tlm2pin_port = strtou32(second);
    pin2tlm_port = strtou32(third);
  }
  else {
    // 2 words (1 comma)
    pin2tlm_name = second;
    confirm_identifier(pin2tlm_name);
  }

  connect_tlm2pin_pin2tlm(tlm2pin_name, tlm2pin_port, pin2tlm_port, pin2tlm_name);
}



// connect_tlm2pin_proxy=<Tlm2pinName>[,<MemoryPort>][,<NamePrefix>],<ProxyName>
void parse_connect_tlm2pin_proxy() {
  XTSC_TRACE(logger, "enter parse_connect_tlm2pin_proxy()");
  confirm_assignment();

  parse_identifier_csv();
  string tlm2pin_name = csv;

  parse_csv();
  string second = csv;

  u32    memory_port = 0;
  string name_prefix;
  string proxy_name;

  if (more_csv) {
    parse_csv();
    string third = csv;
    if (more_csv) {
      memory_port = strtou32(second);
      name_prefix = third;
      parse_csv();
      proxy_name = csv;
      confirm_no_more_csv();
    }
    else {
      if ((second == "") || (second[0] < '0') || (second[0] > '9')) {
        name_prefix = second;
      }
      else {
        memory_port = strtou32(second);
      }
      proxy_name = third;
    }
  }
  else {
    proxy_name = second;
  }

  if (name_prefix != "") confirm_identifier(name_prefix);
  confirm_identifier(proxy_name);

  connect_tlm2pin_proxy(tlm2pin_name, memory_port, name_prefix, proxy_name);
}



// connect_tlm2pin_wrapper=<Tlm2pinName>[,<MemoryPort>][,<NamePrefix>]
void parse_connect_tlm2pin_wrapper() {
  XTSC_TRACE(logger, "enter parse_connect_tlm2pin_wrapper()");
  confirm_assignment();

  parse_identifier_csv();
  string tlm2pin_name = csv;

  u32 memory_port = 0;
  string name_prefix;

  if (more_csv) {
    parse_csv();
    if ((csv == "") || (csv[0] < '0') || (csv[0] > '9')) {
      name_prefix = csv;
    }
    else {
      memory_port = strtou32(csv);
      if (more_csv) {
        parse_csv();
        name_prefix = csv;
      }
    }
    confirm_no_more_csv();
  }

  if (name_prefix != "") confirm_identifier(name_prefix);

  connect_tlm2pin_wrapper(tlm2pin_name, memory_port, name_prefix);
}



// connect_wire_core=[<WireName>,]<TiePortName>,<CoreName>
void parse_connect_wire_core() {
  XTSC_TRACE(logger, "enter parse_connect_wire_core()");
  confirm_assignment();
  string wire_name, tie_name, core_name;

  parse_identifier_csv();
  string first = csv;

  parse_identifier_csv();
  string second = csv;

  if (more_csv) {
    parse_identifier_csv();
    confirm_no_more_csv();
    wire_name = first;
    tie_name  = second;
    core_name = csv;
  }
  else {
    wire_name = first;
    tie_name  = first;
    core_name = second;
  }
  connect_wire_core(wire_name, tie_name, core_name);
}



// connect_wrapper_cohctrl=[<InputName>,]<CohctrlPort>,<CohctrlName>
void parse_connect_wrapper_cohctrl() {
  XTSC_TRACE(logger, "enter parse_connect_wrapper_cohctrl()");
  confirm_assignment();
  string input_name("TIE_CCON");
  u32    cohctrl_port = 0;
  string cohctrl_name;

  parse_csv();
  string first = csv;

  parse_csv();
  string second = csv;

  if (more_csv) {
    confirm_identifier(first);
    input_name = first;
    cohctrl_port = strtou32(second);
    parse_identifier_csv();
    cohctrl_name = csv;
    confirm_no_more_csv();
  }
  else {
    cohctrl_port = strtou32(first);
    confirm_identifier(second);
    cohctrl_name = second;
  }

  connect_wrapper_cohctrl(input_name, cohctrl_port, cohctrl_name);
}



// connect_wrapper_consumer=<NamePrefix>,<ConsumerName>
void parse_connect_wrapper_consumer() {
  XTSC_TRACE(logger, "enter parse_connect_wrapper_consumer()");
  confirm_assignment();

  parse_identifier_csv();
  string name_prefix(csv);

  parse_identifier_csv();
  string consumer_name(csv);

  confirm_no_more_csv();

  connect_wrapper_consumer(name_prefix, consumer_name);
}



// connect_wrapper_core=[<NamePrefix>,]<Interface>,<CoreName>
void parse_connect_wrapper_core() {
  XTSC_TRACE(logger, "enter parse_connect_wrapper_core()");
  confirm_assignment();
  string name_prefix, iface, core_name;

  parse_csv();
  string first = csv;

  parse_identifier_csv();
  string second = csv;

  if (more_csv) {
    parse_identifier_csv();
    confirm_no_more_csv();
    name_prefix = first;
    iface       = second;
    core_name   = csv;
  }
  else {
    iface       = first;
    core_name   = second;
  }

  if (name_prefix != "") confirm_identifier(name_prefix);

  connect_wrapper_core(name_prefix, iface, core_name);
}



// connect_wrapper_lookup_pin=<NamePrefix>,<LookupName>
void parse_connect_wrapper_lookup_pin() {
  XTSC_TRACE(logger, "enter parse_connect_wrapper_lookup_pin()");
  confirm_assignment();

  parse_identifier_csv();
  string name_prefix(csv);

  parse_identifier_csv();
  string lookup_pin_name(csv);

  confirm_no_more_csv();

  connect_wrapper_lookup_pin(name_prefix, lookup_pin_name);
}



// connect_wrapper_memory_pin=[<NamePrefix>,][<MemoryPort>,]<MemoryName>
void parse_connect_wrapper_memory_pin() {
  XTSC_TRACE(logger, "enter parse_connect_wrapper_memory_pin()");
  confirm_assignment();

  string first, second;
  string name_prefix, memory_name;
  u32 memory_port = 0;

  parse_csv();
  first = csv;

  if (more_csv) {
    parse_csv();
    second = csv;
    if (more_csv) {
      parse_csv();
      memory_name = csv;
      name_prefix = first;
      memory_port = strtou32(second);
      confirm_no_more_csv();
    }
    else {
      memory_name = second;
      if ((first == "") || (first[0] < '0') || (first[0] > '9')) {
        name_prefix = first;
      }
      else {
        memory_port = strtou32(first);
      }
    }
  }
  else {
    memory_name = first;
  }

  if (name_prefix != "") confirm_identifier(name_prefix);
  confirm_identifier(memory_name);

  connect_wrapper_memory_pin(name_prefix, memory_port, memory_name);
}



// connect_wrapper_loader=[<NamePrefix>,]<LoaderName>
void parse_connect_wrapper_loader() {
  XTSC_TRACE(logger, "enter parse_connect_wrapper_loader()");
  confirm_assignment();

  string name_prefix, loader_name;
  parse_identifier_csv();

  if (more_csv) {
    name_prefix = csv;
    parse_identifier_csv();
  }

  loader_name = csv;

  confirm_no_more_csv();

  connect_wrapper_loader(name_prefix, loader_name);
}



// connect_wrapper_logic=[<WrapperInputName>,]<LogicInputName>,<LogicName>
void parse_connect_wrapper_logic() {
  XTSC_TRACE(logger, "enter parse_connect_wrapper_logic()");
  confirm_assignment();

  parse_identifier_csv();
  string wrapper_input_name = csv;

  string logic_input_name, logic_name;

  parse_identifier_csv();
  string second = csv;

  if (more_csv) {
    logic_input_name = second;
    parse_identifier_csv();
    logic_name = csv;
    confirm_no_more_csv();
  }
  else {
    logic_input_name = wrapper_input_name;
    logic_name = second;
  }

  connect_wrapper_logic(wrapper_input_name, logic_input_name, logic_name);
}



// connect_wrapper_mmio=[<WrapperInputName>,]<MmioInputName>,<MmioName>
void parse_connect_wrapper_mmio() {
  XTSC_TRACE(logger, "enter parse_connect_wrapper_mmio()");
  confirm_assignment();

  parse_identifier_csv();
  string wrapper_input_name = csv;

  string mmio_input_name, mmio_name;

  parse_identifier_csv();
  string second = csv;

  if (more_csv) {
    mmio_input_name = second;
    parse_identifier_csv();
    mmio_name = csv;
    confirm_no_more_csv();
  }
  else {
    mmio_input_name = wrapper_input_name;
    mmio_name = second;
  }

  connect_wrapper_mmio(wrapper_input_name, mmio_input_name, mmio_name);
}



// connect_wrapper_pin2tlm=[<NamePrefix>,][<MemoryPort>,]<Pin2tlmName>
void parse_connect_wrapper_pin2tlm() {
  XTSC_TRACE(logger, "enter parse_connect_wrapper_pin2tlm()");
  confirm_assignment();

  string first, second;
  string name_prefix, pin2tlm_name;
  u32 memory_port = 0;

  parse_csv();
  first = csv;

  if (more_csv) {
    parse_csv();
    second = csv;
    if (more_csv) {
      parse_csv();
      pin2tlm_name = csv;
      name_prefix = first;
      memory_port = strtou32(second);
      confirm_no_more_csv();
    }
    else {
      pin2tlm_name = second;
      if ((first == "") || (first[0] < '0') || (first[0] > '9')) {
        name_prefix = first;
      }
      else {
        memory_port = strtou32(first);
      }
    }
  }
  else {
    pin2tlm_name = first;
  }

  if (name_prefix != "") confirm_identifier(name_prefix);
  confirm_identifier(pin2tlm_name);

  connect_wrapper_pin2tlm(name_prefix, memory_port, pin2tlm_name);
}



// connect_wrapper_queue_pin=<NamePrefix>,<QueueName>
void parse_connect_wrapper_queue_pin() {
  XTSC_TRACE(logger, "enter parse_connect_wrapper_queue_pin()");
  confirm_assignment();

  parse_identifier_csv();
  string name_prefix(csv);

  parse_identifier_csv();
  string queue_pin_name(csv);

  confirm_no_more_csv();

  connect_wrapper_queue_pin(name_prefix, queue_pin_name);
}



// connect_wrapper_wire=<WrapperInputName>,<WireName>
void parse_connect_wrapper_wire() {
  XTSC_TRACE(logger, "enter parse_connect_wrapper_wire()");
  confirm_assignment();

  parse_identifier_csv();
  string wrapper_input_name = csv;

  parse_identifier_csv();
  string wire_name = csv;

  confirm_no_more_csv();

  if (wrapper_input_name == wire_name) {
    ostringstream oss;
    oss << "<WrapperInputName> and <WireName> cannot be the same in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }

  connect_wrapper_wire(wrapper_input_name, wire_name);
}



// Step 23:  Define connect_XXX_widget() and connect_widget_XXX() methods to match
//           those declared in Step 11.

void connect_clock_proxy(const string& clock_name, const string& input_name, const string& proxy_name) {
  XTSC_TRACE(logger, "enter connect_clock_proxy()");
  clock_info& ci = find_or_infer_clock(clock_name);
  proxy_info& pi = find_or_infer_proxy(proxy_name);
  XTSC_DEBUG(logger, "connecting clock '" << clock_name << "' to input '" << input_name << "' of proxy " << proxy_name << ".");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect clock '" << clock_name << "' to input '" << input_name << "' of " << pi.module_name
                       << " proxy '" << proxy_name << "':" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << input_name << "(*" << clock_name << ");" << endl;
  pi.connected_clock_list.push_back(&ci);
  add_proxy_io(pi, input_name, 1, true, false, true);
}



void connect_clock_wrapper(const string& clock_name, const string& wrapper_output_name) {
  XTSC_TRACE(logger, "enter connect_clock_wrapper()");
  find_or_infer_clock(clock_name);
  confirm_a_wrapper_is_defined();
  wrapper_info& wi = *p_current_wrapper;
  XTSC_DEBUG(logger, "connecting clock '" << clock_name << "' to wrapper.");
  wi.connected_clock_list.push_back(make_pair(clock_name,wrapper_output_name));
  add_wrapper_io(wrapper_output_name, 1, false, false);
}



void connect_arbiter_arbiter(const string& master_name, u32 port, const string& slave_name) {
  XTSC_TRACE(logger, "enter connect_arbiter_arbiter()");
  arbiter_info& master = find_or_infer_arbiter(master_name);
  arbiter_info& slave  = find_or_infer_arbiter(slave_name);
  confirm_no_slave_connected(master);
  confirm_valid_port(slave, port);
  XTSC_DEBUG(logger, "connecting master arbiter '" << master_name << "' to slave arbiter '" << 
                     slave_name << "' port " << port << ".");
  slave.p_arbiter->connect(*master.p_arbiter, port);
  master.slave_connected = true;
  slave.num_master_connected += 1;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << master_name << " to " << slave_name << endl;
  *oss_main[w] << tab2 << slave_name << "->connect(*" << master_name << ", " << port << ");" << endl;
}



void connect_arbiter_cohctrl(const string& arbiter_name, u32 cohctrl_port, const string& cohctrl_name) {
  XTSC_TRACE(logger, "enter connect_arbiter_cohctrl()");
  arbiter_info& ai = find_or_infer_arbiter(arbiter_name);
  cohctrl_info& ci = find_or_infer_cohctrl(cohctrl_name);
  confirm_no_master_connected(ci, cohctrl_port);
  confirm_no_slave_connected(ai);
  XTSC_DEBUG(logger, "connecting arbiter '" << arbiter_name << "' to client port " << cohctrl_port <<
                     " of cohctrl '" << cohctrl_name << "'.");
  ai.p_arbiter->connect(*ci.p_cohctrl, xtsc_cohctrl::PT_CLIENT, cohctrl_port, 0);
  ci.master_connected[cohctrl_port] = true;
  ai.slave_connected  = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << arbiter_name << " to port " << cohctrl_port << " of "<< cohctrl_name << endl;
  *oss_main[w] << tab2 << arbiter_name << "->connect(*" << cohctrl_name << ", xtsc_cohctrl::PT_CLIENT, " << cohctrl_port
                       << ", 0);" << endl;
}



void connect_arbiter_core(const string& arbiter_name, const string& port_name, const string& core_name) {
  XTSC_TRACE(logger, "enter connect_arbiter_core()");
  arbiter_info& ai = find_or_infer_arbiter(arbiter_name);
  core_info&    ci = find_or_infer_core(core_name, "");
  confirm_no_slave_connected(ai);
  confirm_valid_inbound_name(port_name);
  if (port_name == "snoop") {
    confirm_no_snoop_connected(ci);
    ci.snoop_connected = true;
  }
  else {
    confirm_no_inbound_connected(ci);
    ci.inbound_connected = true;
  }
  XTSC_DEBUG(logger, "connecting slave port of arbiter '" << arbiter_name << "' to " << port_name << " of core '" << core_name <<
                     "'.");
  ai.p_arbiter->connect(*ci.p_core, port_name.c_str());
  ai.slave_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << arbiter_name << " to " << core_name << endl;
  *oss_main[w] << tab2 << arbiter_name << "->connect(*" << core_name << ", \"" << port_name << "\");" << endl;
}



void connect_arbiter_dma(const string& arbiter_name, u32 dma_port, const string& dma_name) {
  XTSC_TRACE(logger, "enter connect_arbiter_dma()");
  arbiter_info& ai = find_or_infer_arbiter(arbiter_name);
  dma_info& di = find_or_infer_dma(dma_name);
  confirm_no_master_connected(di, dma_port);
  confirm_no_slave_connected(ai);
  XTSC_DEBUG(logger, "connecting arbiter '" << arbiter_name << "' to port " << dma_port << " of dma '" << dma_name << "'.");
  di.p_dma->connect(*ai.p_arbiter, dma_port);
  di.master_connected[dma_port] = true;
  ai.slave_connected  = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << arbiter_name << " to port " << dma_port << " of "<< dma_name << endl;
  *oss_main[w] << tab2 << dma_name << "->connect(*" << arbiter_name << ", " << dma_port << ");" << endl;
}



void connect_arbiter_memory(const string& arbiter_name, u32 memory_port, const string& memory_name) {
  XTSC_TRACE(logger, "enter connect_arbiter_memory()");
  arbiter_info& ai = find_or_infer_arbiter(arbiter_name);
  xtsc_core_parms *p_cp = get_newest_core_parms();
  memory_info& mi = find_or_infer_memory(memory_name, p_cp);
  confirm_no_master_connected(mi, memory_port);
  confirm_no_slave_connected(ai);
  XTSC_DEBUG(logger, "connecting arbiter '" << arbiter_name << "' to port " << memory_port << " of memory '" << memory_name << "'.");
  mi.p_memory->connect(*ai.p_arbiter, memory_port);
  mi.master_connected[memory_port] = true;
  ai.slave_connected  = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << arbiter_name << " to port " << memory_port << " of "<< memory_name << endl;
  *oss_main[w] << tab2 << memory_name << "->connect(*" << arbiter_name << ", " << memory_port << ");" << endl;
}



void connect_arbiter_memory_trace(const string& arbiter_name, u32 trace_port, const string& trace_name) {
  XTSC_TRACE(logger, "enter connect_arbiter_memory_trace()");
  arbiter_info&      ai = find_or_infer_arbiter(arbiter_name);
  memory_trace_info& mi = find_or_infer_memory_trace(trace_name);
  confirm_no_slave_connected(ai);
  confirm_no_master_connected(mi, trace_port);
  XTSC_DEBUG(logger, "connecting slave port of arbiter '" << arbiter_name << "' to master port #" << trace_port <<
                     " of memory_trace '" << trace_name << "'.");
  mi.p_memory_trace->connect(*ai.p_arbiter, trace_port);
  ai.slave_connected = true;
  mi.master_connected[trace_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << arbiter_name << " to " << trace_name << endl;
  *oss_main[w] << tab2 << trace_name << "->connect(*" << arbiter_name << ", " << trace_port << ");" << endl;
}



void connect_arbiter_mmio(const string& arbiter_name, const string& mmio_name) {
  XTSC_TRACE(logger, "enter connect_arbiter_mmio()");
  arbiter_info& ai = find_or_infer_arbiter(arbiter_name);
  mmio_info&    mi = find_or_infer_mmio(mmio_name);
  confirm_no_slave_connected(ai);
  confirm_no_master_connected(mi);
  XTSC_DEBUG(logger, "connecting slave port of arbiter '" << arbiter_name << "' to memory interface of mmio '" << mmio_name << "'.");
  mi.p_mmio->connect(*ai.p_arbiter);
  ai.slave_connected = true;
  mi.master_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << arbiter_name << " to " << mmio_name << endl;
  *oss_main[w] << tab2 << mmio_name << "->connect(*" << arbiter_name << ");" << endl;
}



void connect_arbiter_router(const string& arbiter_name, const string& router_name) {
  XTSC_TRACE(logger, "enter connect_arbiter_router()");
  arbiter_info& ai = find_or_infer_arbiter(arbiter_name);
  router_info&  ri = find_or_infer_router(router_name);
  confirm_no_slave_connected(ai);
  confirm_no_master_connected(ri);
  XTSC_DEBUG(logger, "connecting slave port of arbiter '" << arbiter_name << "' to master port of router '" << router_name << "'.");
  ri.p_router->connect(*ai.p_arbiter);
  ai.slave_connected = true;
  ri.master_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << arbiter_name << " to " << router_name << endl;
  *oss_main[w] << tab2 << router_name << "->connect(*" << arbiter_name << ");" << endl;
}



void connect_arbiter_slave(const string& arbiter_name, const string& slave_name) {
  XTSC_TRACE(logger, "enter connect_arbiter_slave()");
  arbiter_info& ai = find_or_infer_arbiter(arbiter_name);
  slave_info&   si = find_or_infer_slave(slave_name);
  confirm_no_slave_connected(ai);
  confirm_no_master_connected(si);
  XTSC_DEBUG(logger, "connecting slave port of arbiter '" << arbiter_name << "' to master port of slave '" << slave_name << "'.");
  si.p_slave->connect(*ai.p_arbiter);
  ai.slave_connected = true;
  si.master_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << arbiter_name << " to " << slave_name << endl;
  *oss_main[w] << tab2 << slave_name << "->connect(*" << arbiter_name << ");" << endl;
}



void connect_arbiter_tlm2pin(const string& arbiter_name, u32 tlm2pin_port, const string& tlm2pin_name) {
  XTSC_TRACE(logger, "enter connect_arbiter_tlm2pin()");
  arbiter_info&  ai = find_or_infer_arbiter(arbiter_name);
  tlm2pin_info&  ti = find_or_infer_tlm2pin(tlm2pin_name);
  confirm_no_slave_connected(ai);
  confirm_no_master_connected(ti, tlm2pin_port);
  XTSC_DEBUG(logger, "connecting slave port of arbiter '" << arbiter_name << "' to master port #" << tlm2pin_port <<
                     " of tlm2pin '" << tlm2pin_name << "'.");
  ti.p_tlm2pin->connect(*ai.p_arbiter, tlm2pin_port);
  ai.slave_connected = true;
  ti.master_connected[tlm2pin_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << arbiter_name << " to " << tlm2pin_name << endl;
  *oss_main[w] << tab2 << tlm2pin_name << "->connect(*" << arbiter_name << ", " << tlm2pin_port << ");" << endl;
}



void connect_cohctrl_arbiter(const string& cohctrl_name, u32 snoop_port, u32 arbiter_port, const string& arbiter_name) {
  XTSC_TRACE(logger, "enter connect_cohctrl_arbiter()");
  cohctrl_info& ci = find_or_infer_cohctrl(cohctrl_name);
  arbiter_info& ai = find_or_infer_arbiter(arbiter_name);
  confirm_valid_port(ai, arbiter_port);
  string iface("memory interface");
  string port("xtsc_cohctrl::PT_MEMORY");
  xtsc_cohctrl::port_type port_type = xtsc_cohctrl::PT_MEMORY;
  if (snoop_port == 0xFFFFFFFF) {
    confirm_no_slave_connected(ci);
    ci.slave_connected = true;
  }
  else {
    confirm_no_snoop_connected(ci, snoop_port);
    ci.snoop_connected[snoop_port] = true;
    ostringstream oss;
    oss << "snoop port #" << snoop_port;
    iface = oss.str();
    port = "xtsc_cohctrl::PT_SNOOP";
    port_type = xtsc_cohctrl::PT_SNOOP;
  }
  XTSC_DEBUG(logger, "connecting " << iface << " of cohctrl '" << cohctrl_name << "' to port " << arbiter_port <<
                     " of arbiter '" << arbiter_name << "'.");
  ai.p_arbiter->connect(*ci.p_cohctrl, port_type, snoop_port, arbiter_port);
  ai.num_master_connected += 1;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << cohctrl_name << " " << iface << " to port " << arbiter_port << " of " << arbiter_name
                       << endl;
  *oss_main[w] << tab2 << arbiter_name << "->connect(*" << cohctrl_name << ", " << port << ", 0x" << hex << snoop_port << ", " << dec
                       << arbiter_port << ");" << endl;
}



void connect_cohctrl_memory(const string& cohctrl_name, u32 memory_port, const string& memory_name) {
  XTSC_TRACE(logger, "enter connect_cohctrl_memory()");
  cohctrl_info& ci = find_or_infer_cohctrl(cohctrl_name);
  xtsc_core_parms *p_cp = get_newest_core_parms();
  memory_info&  mi = find_or_infer_memory(memory_name, p_cp);
  confirm_no_slave_connected(ci);
  confirm_no_master_connected(mi, memory_port);
  XTSC_DEBUG(logger, "connecting cohctrl '" << cohctrl_name << "' to port " << memory_port <<
                     " of memory '" << memory_name << "'.");
  mi.p_memory->connect(*ci.p_cohctrl, memory_port);
  ci.slave_connected = true;
  mi.master_connected[memory_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << cohctrl_name << " to port " << memory_port << " of " << memory_name << endl;
  *oss_main[w] << tab2 << memory_name << "->connect(*" << cohctrl_name << ", " << memory_port << ");" << endl;
}



void connect_cohctrl_memory_trace(const string& cohctrl_name, u32 snoop_port, u32 trace_port, const string& trace_name) {
  XTSC_TRACE(logger, "enter connect_cohctrl_memory_trace()");
  cohctrl_info&      ci = find_or_infer_cohctrl(cohctrl_name);
  memory_trace_info& mi = find_or_infer_memory_trace(trace_name);
  confirm_no_master_connected(mi, trace_port);
  string iface("memory interface");
  string port("xtsc_cohctrl::PT_MEMORY");
  xtsc_cohctrl::port_type port_type = xtsc_cohctrl::PT_MEMORY;
  if (snoop_port == 0xFFFFFFFF) {
    confirm_no_slave_connected(ci);
    ci.slave_connected = true;
  }
  else {
    confirm_no_snoop_connected(ci, snoop_port);
    ci.snoop_connected[snoop_port] = true;
    ostringstream oss;
    oss << "snoop port #" << snoop_port;
    iface = oss.str();
    port = "xtsc_cohctrl::PT_SNOOP";
    port_type = xtsc_cohctrl::PT_SNOOP;
  }
  XTSC_DEBUG(logger, "connecting " << iface << " of cohctrl '" << cohctrl_name << "' to port " << trace_port <<
                     " of memory_trace '" << trace_name << "'.");
  mi.p_memory_trace->connect(*ci.p_cohctrl, port_type, snoop_port, trace_port);
  mi.master_connected[trace_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << cohctrl_name << " " << iface << " to port " << trace_port << " of " << trace_name
                       << endl;
  *oss_main[w] << tab2 << trace_name << "->connect(*" << cohctrl_name << ", " << port << ", 0x" << hex << snoop_port << ", " << dec
                       << trace_port << ");" << endl;
}



void connect_cohctrl_router(const string& cohctrl_name, u32 snoop_port, const string& router_name) {
  XTSC_TRACE(logger, "enter connect_cohctrl_router()");
  cohctrl_info& ci = find_or_infer_cohctrl(cohctrl_name);
  router_info&  ri = find_or_infer_router(router_name);
  string iface("memory interface");
  string port("xtsc_cohctrl::PT_MEMORY");
  xtsc_cohctrl::port_type port_type = xtsc_cohctrl::PT_MEMORY;
  if (snoop_port == 0xFFFFFFFF) {
    confirm_no_slave_connected(ci);
    ci.slave_connected = true;
  }
  else {
    confirm_no_snoop_connected(ci, snoop_port);
    ci.snoop_connected[snoop_port] = true;
    ostringstream oss;
    oss << "snoop port #" << snoop_port;
    iface = oss.str();
    port = "xtsc_cohctrl::PT_SNOOP";
    port_type = xtsc_cohctrl::PT_SNOOP;
  }
  confirm_no_master_connected(ri);
  XTSC_DEBUG(logger, "connecting " << iface << " of cohctrl '" << cohctrl_name <<
                     "' to master port of router '" << router_name << "'.");
  ri.p_router->connect(*ci.p_cohctrl, port_type, snoop_port, 0);
  ri.master_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << cohctrl_name << " " << iface << " to " << router_name << endl;
  *oss_main[w] << tab2 << router_name << "->connect(*" << cohctrl_name << ", " << port << ", 0x" << hex << snoop_port << ", 0);"
                       << dec << endl;
}



void connect_cohctrl_slave(const string& cohctrl_name, u32 snoop_port, const string& slave_name) {
  XTSC_TRACE(logger, "enter connect_cohctrl_slave()");
  cohctrl_info& ci = find_or_infer_cohctrl(cohctrl_name);
  slave_info&   si = find_or_infer_slave(slave_name);
  string iface("memory interface");
  if (snoop_port == 0xFFFFFFFF) {
    confirm_no_slave_connected(ci);
    ci.slave_connected = true;
  }
  else {
    confirm_no_snoop_connected(ci, snoop_port);
    ci.snoop_connected[snoop_port] = true;
    ostringstream oss;
    oss << "snoop port #" << snoop_port;
    iface = oss.str();
  }
  confirm_no_master_connected(si);
  XTSC_DEBUG(logger, "connecting " << iface << " of cohctrl '" << cohctrl_name <<
                     "' to master port of slave '" << slave_name << "'.");
  si.p_slave->connect(*ci.p_cohctrl, snoop_port);
  si.master_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << cohctrl_name << " " << iface << " to " << slave_name << endl;
  *oss_main[w] << tab2 << slave_name << "->connect(*" << cohctrl_name << ", 0x" << hex << snoop_port << ");" << dec << endl;
}



void connect_cohctrl_tlm2pin(const string& cohctrl_name, u32 port, const string& tlm2pin_name) {
  XTSC_TRACE(logger, "enter connect_cohctrl_tlm2pin()");
  cohctrl_info& ci = find_or_infer_cohctrl(cohctrl_name);
  tlm2pin_info& ti = find_or_infer_tlm2pin(tlm2pin_name);
  bool is_snoop = ti.parms.get_bool("snoop");
  if (is_snoop) {
    confirm_no_snoop_connected(ci, port);
    ci.snoop_connected[port] = true;
    confirm_no_master_connected(ti, 0);
    XTSC_DEBUG(logger, "connecting port " << port << " of cohctrl '" << cohctrl_name << "' to tlm2pin '" << tlm2pin_name << "'.");
    ti.p_tlm2pin->connect(*ci.p_cohctrl, port);
    ci.snoop_connected[port] = true;
    ti.master_connected[0] = true;
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Connect port " << port << " of cohctrl " << cohctrl_name << " to " << tlm2pin_name << endl;
    *oss_main[w] << tab2 << tlm2pin_name << "->connect(*" << cohctrl_name << ", " << port << ");" << endl;
  }
  else {
    confirm_no_slave_connected(ci);
    confirm_no_master_connected(ti, port);
    XTSC_DEBUG(logger, "connecting cohctrl '" << cohctrl_name << "' to port " << port << " of tlm2pin '" << tlm2pin_name << "'.");
    ti.p_tlm2pin->connect(*ci.p_cohctrl, port);
    ci.slave_connected = true;
    ti.master_connected[port] = true;
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Connect " << cohctrl_name << " to port " << port << " of " << tlm2pin_name << endl;
    *oss_main[w] << tab2 << tlm2pin_name << "->connect(*" << cohctrl_name << ", " << port << ");" << endl;
  }
}



void connect_core_arbiter(const string& core_name, xtsc_core::memory_port mem_port, u32 port, const string& arbiter_name) {
  XTSC_TRACE(logger, "enter connect_core_arbiter()");
  core_info&    ci = find_or_infer_core(core_name, "");
  arbiter_info& ai = find_or_infer_arbiter(arbiter_name);
  confirm_no_memory_connected(ci, mem_port);
  confirm_valid_port(ai, port);
  const char *memory_port_name = xtsc_core::get_memory_port_name(mem_port);
  XTSC_DEBUG(logger, "connecting master core '" << core_name << "' to slave arbiter '" << 
                     arbiter_name << "' port " << port << ".");
  ai.p_arbiter->connect(*ci.p_core, memory_port_name, port);
  ci.memory_connected[mem_port] = true;
  ai.num_master_connected += 1;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << core_name << " to " << arbiter_name << endl;
  *oss_main[w] << tab2 << arbiter_name << "->connect(*" << core_name << ", \"" << memory_port_name << "\", " << port << ");" << endl;
}



void connect_core_cohctrl(const string& core_name, u32 cohctrl_port, const string& cohctrl_name) {
  XTSC_TRACE(logger, "enter connect_core_cohctrl()");
  core_info&    corei = find_or_infer_core(core_name, "");
  cohctrl_info& ctrli = find_or_infer_cohctrl(cohctrl_name);
  XTSC_DEBUG(logger, "connecting core '" << core_name << "' to port " << cohctrl_port << " of cohctrl '" << cohctrl_name << "'.");
  confirm_coherent_core(corei);
  bool outbound = (!ctrli.master_connected[cohctrl_port] && !corei.memory_connected[xtsc_core::MEM_PIF]);
  bool snoop    = (!ctrli.snoop_connected [cohctrl_port] && !corei.snoop_connected);
  bool ccon     = (!ctrli.ccon_connected  [cohctrl_port] && !corei.export_state_connected["CCON"]);
  if (!outbound && !snoop && !ccon) {
    ostringstream oss;
    oss << "Can connect neither the master port nor the snoop port nor the ccon port of cohctrl '" << ctrli.name << "' port #"
        << cohctrl_port << " to core '" << corei.name << "' as requested by command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  ctrli.p_cohctrl->connect(*corei.p_core, cohctrl_port, outbound, snoop, ccon);
  if (outbound) {
    ctrli.master_connected[cohctrl_port] = true;
    corei.memory_connected[xtsc_core::MEM_PIF]  = true;
  }
  if (snoop) {
    ctrli.snoop_connected[cohctrl_port] = true;
    corei.snoop_connected  = true;
  }
  if (ccon) {
    ctrli.ccon_connected[cohctrl_port] = true;
    corei.export_state_connected["CCON"] = true;
  }
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << core_name << " to port " << cohctrl_port << " of "<< cohctrl_name << endl;
  *oss_main[w] << tab2 << cohctrl_name << "->connect(*" << core_name << ", " << cohctrl_port << ", " << boolalpha
                       << outbound << ", " << snoop << ", " << ccon << ");" << endl;
}



void connect_core_core(const string& source_name, const string& output_name, const string& input_name, const string& sink_name) {
  XTSC_TRACE(logger, "enter connect_core_core()");
  core_info&    ci1 = find_or_infer_core(source_name, "");  // ci1=source
  core_info&    ci2 = find_or_infer_core(sink_name, "");    // ci2=sink
  if ((output_name == "tx_xfer_out") || (output_name == "tx_xfer_in") || (input_name == "tx_xfer_out") || (input_name == "tx_xfer_in")) {
    confirm_no_xfer_out_connected(ci1);
    ci1.tx_xfer_out_connected = true;
    confirm_no_xfer_in_connected(ci2);
    ci2.tx_xfer_in_connected = true;
  }
  else {
    if (ci1.p_core->has_export_state(output_name.c_str())) {
      confirm_no_export_state_connected(ci1, output_name);
      ci1.export_state_connected[output_name] = true;
    }
    else {
      confirm_no_system_output_connected(ci1, output_name);
      ci1.system_output_connected[output_name] = true;
    }
    confirm_no_system_input_connected(ci2, input_name);
    ci2.system_input_connected[input_name] = true;
  }
  XTSC_DEBUG(logger, "connecting output '" << output_name << "' of source core '" << source_name <<
                     "' to input '" << input_name << "' of sink core '" << sink_name << "'.");
  ci2.p_core->connect(*ci1.p_core, output_name.c_str(), input_name.c_str());
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << source_name << " to " << sink_name << endl;
  *oss_main[w] << tab2 << sink_name << "->connect(*" << source_name << ", \"" << output_name << "\", \"" << input_name
                       << "\");" << endl;
}



void connect_core_distributor(const string& core_name, u32 port, const string& distributor_name) {
  XTSC_TRACE(logger, "enter connect_core_distributor()");
  core_info&         ci = find_or_infer_core(core_name, "");
  distributor_info&  di = find_or_infer_distributor(distributor_name);

  u32 num_ports = di.p_distributor->get_num_ports();
  if (num_ports <= port) {
    ostringstream oss;
    oss << "xtsc_interrupt_distributor '" << distributor_name << "' has no port #"
        << port << " (valid port numbers are 0-" << (num_ports-1) << "): ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }

  string WMPINT_ADDR    ("WMPINT_ADDR");
  string WMPINT_DATA    ("WMPINT_DATA");
  string WMPINT_TOGGLEEN("WMPINT_TOGGLEEN");
  string RMPINT         ("RMPINT");

  ostringstream oss;
  oss << port;
  string suffix(oss.str());

  confirm_no_export_state_connected(ci, WMPINT_ADDR);
  confirm_no_export_state_connected(ci, WMPINT_DATA);
  confirm_no_export_state_connected(ci, WMPINT_TOGGLEEN);
  confirm_no_lookup_connected      (ci, RMPINT);

  confirm_input_exists_and_is_not_connected (di, WMPINT_ADDR    +suffix);
  confirm_input_exists_and_is_not_connected (di, WMPINT_DATA    +suffix);
  confirm_input_exists_and_is_not_connected (di, WMPINT_TOGGLEEN+suffix);
  confirm_lookup_exists_and_is_not_connected(di, RMPINT         +suffix);

  ci.export_state_connected[WMPINT_ADDR]        = true;
  ci.export_state_connected[WMPINT_DATA]        = true;
  ci.export_state_connected[WMPINT_TOGGLEEN]    = true;
  ci.lookup_connected      [RMPINT]             = true;

  di.inputs_connected [WMPINT_ADDR    +suffix]  = true;
  di.inputs_connected [WMPINT_DATA    +suffix]  = true;
  di.inputs_connected [WMPINT_TOGGLEEN+suffix]  = true;
  di.lookups_connected[RMPINT         +suffix]  = true;

  XTSC_DEBUG(logger, "connecting core '" << core_name << "' to port #" << port << " of distributor '" << distributor_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  di.p_distributor->connect(*ci.p_core, port);
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << core_name << " to " << distributor_name << endl;
  *oss_main[w] << tab2 << distributor_name << "->connect(*" << core_name << ", " << port << ");" << endl;
}



void connect_core_distributor(const string& core_name,
                              const string& output_name,
                              const string& input_name,
                              const string& distributor_name)
{
  XTSC_TRACE(logger, "enter connect_core_distributor()");
  core_info&         ci = find_or_infer_core(core_name, "");
  distributor_info&  di = find_or_infer_distributor(distributor_name);
  string c_port("output");
  string d_port("input");
  bool is_lookup = di.p_distributor->has_lookup(input_name.c_str());
  bool is_export_state = false;
  if (is_lookup) {
    confirm_no_lookup_connected(ci, output_name);
    confirm_lookup_exists_and_is_not_connected(di, input_name);
    ci.lookup_connected[output_name] = true;
    di.lookups_connected[input_name] = true;
    d_port = c_port = "lookup";
  }
  else {
    confirm_input_exists_and_is_not_connected(di, input_name);
    if (ci.p_core->has_export_state(output_name.c_str())) {
      confirm_no_export_state_connected(ci, output_name);
      ci.export_state_connected[output_name] = true;
      is_export_state = true;
    }
    else if (ci.p_core->has_system_output_wire(output_name.c_str())) {
      confirm_no_system_output_connected(ci, output_name);
      ci.system_output_connected[output_name] = true;
    }
    else {
      ostringstream oss;
      oss << "Core '" << core_name << "' has no TIE export state or system-level output named '" << output_name << "': ";
      command_info(oss);
      throw xtsc_exception(oss.str());
    }
    di.inputs_connected[input_name] = true;
  }
  XTSC_DEBUG(logger, "connecting " << c_port << " \"" << output_name << "\" of core '" << core_name << "' to " << d_port <<
                     " '" << input_name << "' of distributor '" << distributor_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  di.p_distributor->connect(*ci.p_core, output_name.c_str(), input_name.c_str());
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << core_name << " to " << distributor_name << endl;
  *oss_main[w] << tab2 << distributor_name << "->connect(*" << core_name << ", \"" << output_name << "\", \"" << input_name << "\");"
                       << endl;
}



void connect_core_loader(const string& core_name, const string& iface, const string& loader_name) {
  XTSC_TRACE(logger, "enter connect_core_loader()");
  loader_info& li = find_or_infer_loader(loader_name);
  core_info&   ci = find_or_infer_core(core_name, "");
  string iface_lc(iface);
  transform(iface.begin(), iface.end(), iface_lc.begin(), ::tolower);
  if (iface_lc == "tx_xfer_out") {
    confirm_no_xfer_out_connected(ci);
    confirm_no_last_tx_connected(li);
    XTSC_DEBUG(logger, "connecting output XFER of core '" << core_name << "' to XFER input of loader '" << loader_name << "'.");
    li.p_loader->connect(*ci.p_core, "tx_xfer_out");
    ci.tx_xfer_out_connected = true;
    li.last_tx_connected = true;
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Connect output XFER interface of " << core_name << " to XFER input of " << loader_name << endl;
    *oss_main[w] << tab2 << loader_name << "->connect(*" << core_name << ", \"tx_xfer_out\");" << endl;
  }
  else {
    // Ensure core has such an output queue
    try { ci.p_core->get_output_queue(iface.c_str()); } catch (xtsc_exception& xe) {
      ostringstream oss;
      oss << xe.what() << endl;
      oss << "Command: ";
      command_info(oss);
      throw xtsc_exception(oss.str());
    }
    confirm_no_output_queue_connected(ci, iface);
    XTSC_DEBUG(logger, "connecting TIE output queue port '" << iface <<
                       "' of core '" << core_name << "' to loader '" << loader_name << "'.");
    // Bit-width mismatch will be detected by XTSC
    li.p_loader->connect(*ci.p_core, iface.c_str());
    li.producer_connected = true;
    ci.output_queue_connected[iface] = true;
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Connect TIE output queue of " << core_name << " to " << loader_name << endl;
    *oss_main[w] << tab2 << loader_name << "->connect(*" << core_name << ", \"" << iface << "\");" << endl;
  }
}



void connect_core_logic(const string& core_name, const string& output_name, const string& input_name, const string& logic_name) {
  XTSC_TRACE(logger, "enter connect_core_logic()");
  core_info&  ci = find_or_infer_core(core_name, "");
  logic_info& li = find_or_infer_logic(logic_name);
  // Ensure core has such an export state or system-level output
  bool is_export_state;
  if (ci.p_core->has_export_state(output_name.c_str())) {
    confirm_no_export_state_connected(ci, output_name);
    ci.export_state_connected[output_name] = true;
    is_export_state = true;
  }
  else if (ci.p_core->has_system_output_wire(output_name.c_str())) {
    confirm_no_system_output_connected(ci, output_name);
    ci.system_output_connected[output_name] = true;
    is_export_state = false;
  }
  else {
    ostringstream oss;
    oss << "Core '" << core_name << "' has no TIE export state or system-level output named '" << output_name << "'." << endl;
    try { ci.p_core->get_export_state      (output_name.c_str()); } catch (xtsc_exception& xe) { oss << xe.what(); }
    try { ci.p_core->get_system_output_wire(output_name.c_str()); } catch (xtsc_exception& xe) { oss << xe.what(); }
    oss << "Command: ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  XTSC_DEBUG(logger, "connecting " << (is_export_state ? "TIE export state" : "system-level output") << " '" << output_name <<
                     "' of core '" << core_name << "' to logic '" << logic_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  li.p_logic->connect(*ci.p_core, output_name.c_str(), input_name.c_str());
  li.inputs_connected[input_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << core_name << " to " << logic_name << endl;
  *oss_main[w] << tab2 << logic_name << "->connect(*" << core_name << ", \"" << output_name << "\", \"" << input_name << "\");"
                       << endl;
}



void connect_core_lookup(const string& core_name, const string& tie_name, const string& lookup_name) {
  XTSC_TRACE(logger, "enter connect_core_lookup()");
  core_info& ci = find_or_infer_core(core_name, "");
  map<string,lookup_info*>::iterator il = lookup_map[w]->find(lookup_name);
  if (il == lookup_map[w]->end()) {
    // Does this core have a lookup named tie_name?
    if (!ci.p_core->has_lookup(tie_name.c_str())) {
      ostringstream oss;
      oss << "Cannot find lookup '" << lookup_name << "' and core '" << core_name << "' has no TIE lookup named '" << tie_name
          << "'.";
      throw xtsc_exception(oss.str());
    }
    // Yes it does, so infer a lookup with matching bit widths
    init_lookup_parms();
    create_lookup(lookup_name, tie_name);
    il = lookup_map[w]->find(lookup_name);
    if (il == lookup_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred lookup '" << lookup_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  confirm_no_lookup_connected(ci, tie_name);
  XTSC_DEBUG(logger, "connecting TIE lookup port '" << tie_name <<
                     "' of core '" << core_name << "' to lookup '" << lookup_name << "'.");
  // Duplicate connections and bit width mismatch will be detected by SystemC and XTSC, respectively
  lookup_info& li = *(il->second);
  li.p_lookup->connect(*ci.p_core, tie_name.c_str());
  li.master_connected = true;
  ci.lookup_connected[tie_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << core_name << " to " << lookup_name << endl;
  *oss_main[w] << tab2 << lookup_name << "->connect(*" << core_name << ", \"" << tie_name << "\");" << endl;
}



void connect_core_lookup_pin(const string& core_name, const string& tie_name, const string& lookup_pin_name) {
  XTSC_TRACE(logger, "enter connect_core_lookup_pin()");
  core_info& ci = find_or_infer_core(core_name, "");
  // Does this core have a pin-level lookup named tie_name?
  if (!ci.p_core->has_pin_level_lookup(tie_name.c_str())) {
    ostringstream oss;
    oss << "Core '" << core_name << "' has no pin-level TIE lookup named '" << tie_name << "'.";
    throw xtsc_exception(oss.str());
  }
  map<string,lookup_pin_info*>::iterator il = lookup_pin_map[w]->find(lookup_pin_name);
  if (il == lookup_pin_map[w]->end()) {
    // No such lookup_pin yet exists, so infer a lookup_pin with bit widths to match the core pin-level lookup
    init_lookup_pin_parms();
    create_lookup_pin(lookup_pin_name, tie_name);
    il = lookup_pin_map[w]->find(lookup_pin_name);
    if (il == lookup_pin_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred lookup_pin '" << lookup_pin_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  confirm_no_lookup_connected(ci, tie_name);
  XTSC_DEBUG(logger, "connecting TIE lookup '" << tie_name <<
                     "' of core '" << core_name << "' to lookup_pin '" << lookup_pin_name << "'.");
  // Duplicate connections and bit width mismatch will be detected by SystemC and XTSC, respectively
  lookup_pin_info& li = *(il->second);
  confirm_no_master_connected(li);
  string out_name = "TIE_" + tie_name + "_Out";
  string req_name = "TIE_" + tie_name + "_Out_Req";
  string in_name  = "TIE_" + tie_name + "_In";
  string rdy_name = "TIE_" + tie_name + "_Rdy";
  ci.p_core->get_output_pin(out_name.c_str())(li.address);
  ci.p_core->get_output_pin(req_name.c_str())(li.req);
  ci.p_core->get_input_pin (in_name .c_str())(li.data);
  if (li.parms.get_bool("has_ready")) {
  ci.p_core->get_input_pin (rdy_name.c_str())(li.ready);
  }
  li.master_connected = true;
  ci.lookup_connected[tie_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create signals for " << lookup_pin_name << endl;
  *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << lookup_pin_name << "__address" << " = new xtsc_signal_sc_bv_base(\""
                       << lookup_pin_name << "__address\", "
                       << li.address_width1 << ");" << endl;
  *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << lookup_pin_name << "__req    " << " = new xtsc_signal_sc_bv_base(\""
                       << lookup_pin_name
                       << "__req\",     1);" << endl;
  *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << lookup_pin_name << "__data   " << " = new xtsc_signal_sc_bv_base(\""
                       << lookup_pin_name << "__data\",    "
                       << li.data_width1 << ");" << endl;
  if (li.parms.get_bool("has_ready")) {
  *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << lookup_pin_name << "__ready  " << " = new xtsc_signal_sc_bv_base(\""
                       << lookup_pin_name
                       << "__ready\",   1);" << endl;
  }
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect signals to " << lookup_pin_name << endl;
  *oss_main[w] << tab2 << lookup_pin_name << "->m_address(*" << lookup_pin_name << "__address);" << endl;
  *oss_main[w] << tab2 << lookup_pin_name << "->m_req    (*" << lookup_pin_name << "__req    );" << endl;
  *oss_main[w] << tab2 << lookup_pin_name << "->m_data   (*" << lookup_pin_name << "__data   );" << endl;
  if (li.parms.get_bool("has_ready")) {
  *oss_main[w] << tab2 << lookup_pin_name << "->m_ready  (*" << lookup_pin_name << "__ready  );" << endl;
  }
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << core_name << " to " << lookup_pin_name << " signals " << endl;
  *oss_main[w] << tab2 << core_name << "->get_output_pin(\"" << out_name << "\")(*" << lookup_pin_name << "__address);" << endl;
  *oss_main[w] << tab2 << core_name << "->get_output_pin(\"" << req_name << "\")(*" << lookup_pin_name << "__req    );" << endl;
  *oss_main[w] << tab2 << core_name << "->get_input_pin (\"" << in_name << "\" )(*" << lookup_pin_name << "__data   );" << endl;
  if (li.parms.get_bool("has_ready")) {
  *oss_main[w] << tab2 << core_name << "->get_input_pin (\"" << rdy_name << "\")(*" << lookup_pin_name << "__ready  );" << endl;
  }
}



void connect_core_memory(const string& core_name, u32 memory_port, const string& memory_name) {
  XTSC_TRACE(logger, "enter connect_core_memory()");
  core_info&   ci = find_or_infer_core(core_name, memory_name);
  memory_info& mi = find_or_infer_memory(memory_name, &ci.parms);
  confirm_no_memory_connected(ci, mi.mem_port);
  confirm_no_master_connected(mi, memory_port);
  const char *memory_port_name = xtsc_core::get_memory_port_name(mi.mem_port);
  XTSC_DEBUG(logger, "connecting memory port '" << memory_port_name << "' of core '" << core_name << 
                     "' to port " << memory_port << " of memory '" << memory_name << "'.");
  u32 num_connected = mi.p_memory->connect(*ci.p_core, memory_port_name, memory_port);
  ci.memory_connected[mi.mem_port] = true;
  mi.master_connected[memory_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << core_name << " to port " << memory_port;
  if (num_connected == 2) {
    ci.memory_connected[mi.mem_port+1] = true;
    mi.master_connected[memory_port+1] = true;
    *oss_main[w] << " and port " << (memory_port+1);
  }
  *oss_main[w] << " of " << memory_name << endl;
  *oss_main[w] << tab2 << memory_name << "->connect(*" << core_name << ", \"" << memory_port_name << "\", " << memory_port << ");"
                       << endl;
}



void connect_core_memory_trace(const string& core_name, xtsc_core::memory_port mem_port, u32 trace_port, const string& trace_name) {
  XTSC_TRACE(logger, "enter connect_core_memory_trace()");
  core_info&         ci = find_or_infer_core(core_name, "");
  memory_trace_info& mi = find_or_infer_memory_trace(trace_name);
  confirm_no_memory_connected(ci, mem_port);
  confirm_no_master_connected(mi, trace_port);
  const char *memory_port_name = xtsc_core::get_memory_port_name(mem_port);
  XTSC_DEBUG(logger, "connecting memory port '" << memory_port_name << "' of core '" << core_name << 
                     "' to memory_trace '" << trace_name << "'.");
  u32 num_connected = mi.p_memory_trace->connect(*ci.p_core, memory_port_name, trace_port);
  ci.memory_connected[mem_port] = true;
  mi.master_connected[trace_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << core_name << " to port " << trace_port;
  if (num_connected == 2) {
    ci.memory_connected[mem_port+1] = true;
    mi.master_connected[trace_port+1] = true;
    *oss_main[w] << " and port " << (trace_port+1);
  }
  *oss_main[w] << " of " << trace_name << endl;
  *oss_main[w] << tab2 << trace_name << "->connect(*" << core_name << ", \"" << memory_port_name << "\", " << trace_port
                       << ");" << endl;
}



void connect_core_mmio(const string& core_name, xtsc_core::memory_port mem_port, const string& mmio_name) {
  XTSC_TRACE(logger, "enter connect_core_mmio() for memory interface");
  core_info&  ci = find_or_infer_core(core_name, "");
  mmio_info&  mi = find_or_infer_mmio(mmio_name);
  confirm_no_memory_connected(ci, mem_port);
  confirm_no_master_connected(mi);
  const char *memory_port_name = xtsc_core::get_memory_port_name(mem_port);
  XTSC_DEBUG(logger, "connecting memory port '" << memory_port_name << "' of core '" << core_name << 
                     "' to memory interface of mmio '" << mmio_name << "'.");
  mi.p_mmio->connect(*ci.p_core, memory_port_name);
  ci.memory_connected[mem_port] = true;
  mi.master_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << core_name << " to " << mmio_name << endl;
  *oss_main[w] << tab2 << mmio_name << "->connect(*" << core_name << ", \"" << memory_port_name << "\");" << endl;
}



void connect_core_mmio(const string& core_name, const string& output_name, const string& input_name, const string& mmio_name) {
  XTSC_TRACE(logger, "enter connect_core_mmio() for wire interface");
  core_info& ci = find_or_infer_core(core_name, "");
  mmio_info& mi = find_or_infer_mmio(mmio_name);
  // Ensure core has such an export state or system-level output
  bool is_export_state;
  u32 bit_width;
  if (ci.p_core->has_export_state(output_name.c_str())) {
    confirm_no_export_state_connected(ci, output_name);
    ci.export_state_connected[output_name] = true;
    is_export_state = true;
    bit_width = ci.p_core->get_tie_bit_width(output_name.c_str());
  }
  else if (ci.p_core->has_system_output_wire(output_name.c_str())) {
    confirm_no_system_output_connected(ci, output_name);
    ci.system_output_connected[output_name] = true;
    is_export_state = false;
    bit_width = ci.p_core->get_sysio_bit_width(output_name.c_str());
  }
  else {
    ostringstream oss;
    oss << "Core '" << core_name << "' has no TIE export state or system-level output named '" << output_name << "'." << endl;
    try { ci.p_core->get_export_state      (output_name.c_str()); } catch (xtsc_exception& xe) { oss << xe.what(); }
    try { ci.p_core->get_system_output_wire(output_name.c_str()); } catch (xtsc_exception& xe) { oss << xe.what(); }
    oss << "Command: ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  XTSC_DEBUG(logger, "connecting " << (is_export_state ? "TIE export state" : "system-level output") << " '" << output_name <<
                     "' of core '" << core_name << "' to mmio '" << mmio_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  mi.p_mmio->connect(*ci.p_core, output_name.c_str(), input_name.c_str());
  mi.inputs_connected[input_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << core_name << " to " << mmio_name << endl;
  *oss_main[w] << tab2 << mmio_name << "->connect(*" << core_name << ", \"" << output_name << "\", \"" << input_name << "\");"
                       << endl;
}



// Connect pin-level TIE output queue, TIE export state, TIE lookup, or system-level output interface to proxy
void connect_core_proxy(const string& core_name, const string& iface, const string& name_prefix, const string& proxy_name) {
  XTSC_TRACE(logger, "enter connect_core_proxy()");
  core_info&  ci = find_or_infer_core(core_name, "");
  proxy_info& pi = find_or_infer_proxy(proxy_name);
  XTSC_DEBUG(logger, "connecting core " << core_name << " to proxy " << proxy_name << ".");
  if (!ci.p_core->has_pin_level_interface(iface.c_str())) {
    ostringstream oss;
    oss << "core '" << core_name << "' has no pin-level interface named '" << iface << "': ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }

  vector<string> pins;
  string type;

  if (ci.p_core->has_pin_level_output_queue(iface.c_str())) {
    confirm_no_output_queue_connected(ci, iface);
    ci.output_queue_connected[iface] = true;
    type = "TIE output queue";
    pins.push_back("TIE_" + iface);
    pins.push_back("TIE_" + iface + "_PushReq");
    pins.push_back("TIE_" + iface + "_Full");
  }
  else if (ci.p_core->has_pin_level_export_state(iface.c_str())) {
    confirm_no_export_state_connected(ci, iface);
    ci.export_state_connected[iface] = true;
    type = "TIE export state";
    pins.push_back("TIE_" + iface);
  }
  else if (ci.p_core->has_pin_level_lookup(iface.c_str())) {
    confirm_no_lookup_connected(ci, iface);
    ci.lookup_connected[iface] = true;
    type = "TIE lookup";
    pins.push_back("TIE_" + iface + "_Out");
    pins.push_back("TIE_" + iface + "_Out_Req");
    pins.push_back("TIE_" + iface + "_In");
    if (ci.p_core->has_input_pin(("TIE_" + iface + "_Rdy").c_str())) {
      pins.push_back("TIE_" + iface + "_Rdy");
    }
  }
  else if (ci.p_core->has_output_pin(iface.c_str())) {
    confirm_no_system_output_connected(ci, iface);
    ci.system_output_connected[iface] = true;
    type = "system-level output";
    pins.push_back(iface);
  }
  else {
    ostringstream oss;
    oss << "core '" << core_name << "' has no pin-level output queue, lookup, export state, or system-level output interface named '"
        << iface << "': ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << type << " '" << iface << "' of core '" << ci.name << "' to " << pi.module_name
                       << " proxy '" << proxy_name << "':" << endl;

  ostringstream tran, sig, trace, core2tran, tran2sig, proxy2sig;

  u32 nc = 0;
  for (vector<string>::const_iterator ip = pins.begin(); ip != pins.end(); ++ip) {
    nc = max(nc, ip->length());
  }

  for (vector<string>::const_iterator ip = pins.begin(); ip != pins.end(); ++ip) {

    string cname(*ip);                          // core pin name
    string pname(name_prefix + cname);          // proxy port name
    string sname(ci.name + "_" + pname);        // signal name
    string aname(sname + "_adapter");           // adapter name

    u32    bits(ci.p_core->get_pin_bit_width(cname.c_str()));
    bool   input(ci.p_core->has_input_pin(cname.c_str()));

    add_proxy_io(pi, pname, bits, !input, true, false);

    const char *spc = space(nc - min(nc, cname.length()));

    add_adapter(tran, aname, bits, input, nc+ci.name.length()+9+name_prefix.length());
    add_signal(sig, sname, bits, nc+ci.name.length()+1+name_prefix.length());

    trace << tab2 << "sc_trace(" << pi.trace_identifier << ", " << sname << ", " << spc << "\"" << sname << "\"" << spc << ");"
          << endl;

    core2tran << tab2 << ci.name << "->" << (input ? "get_input_pin " : "get_output_pin") << "(\"" << cname << "\"" << spc << ")("
              << aname << spc << ".m_sc_export);" << endl;

    tran2sig << tab2 << aname << spc << ".m_sc_" << (input ? "in " : "out") << "(" << sname << spc << ");" << endl;

    proxy2sig << tab2 << proxy_name << "." << pname << spc << "(" << sname << spc << ");" << endl;
  }

  string s(pins.size() == 1 ? "" : "s");

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create adapter" << s << " for connecting " << type << " '" << iface << "' of core '" << ci.name
                       << "' and "
                       << pi.module_name << " proxy '" << proxy_name << "':" << endl;
  *oss_main[w] << tran.str();

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create signal" << s << " for connecting " << type << " '" << iface << "' of core '" << ci.name
                       << "' and " << pi.module_name << " proxy '" << proxy_name << "':" << endl;
  *oss_main[w] << sig.str();

  if (pi.trace_identifier != "") {
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Trace signal" << s << " for connecting " << type << " '" << iface << "' of core '" << ci.name
                         << "' and " << pi.module_name << " proxy '" << proxy_name << "':" << endl;
    *oss_main[w] << trace.str();
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << type << " '" << iface << "' of core '" << ci.name << "' to adapter" << s << ":" << endl;
  *oss_main[w] << core2tran.str();

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect adapter" << s << " to signal" << s << ":" << endl;
  *oss_main[w] << tran2sig.str();

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << pi.module_name << " proxy '" << proxy_name << "' to signal" << s << ":" << endl;
  *oss_main[w] << proxy2sig.str();
}



void connect_core_queue(const string& core_name, const string& tie_name, u32 producer_port, const string& queue_name) {
  XTSC_TRACE(logger, "enter connect_core_queue()");
  core_info& ci = find_or_infer_core(core_name, "");
  // Ensure core has such an output queue
  try { ci.p_core->get_output_queue(tie_name.c_str()); } catch (xtsc_exception& xe) {
    ostringstream oss;
    oss << xe.what() << endl;
    oss << "Command: ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  map<string,queue_info*>::iterator iq = queue_map[w]->find(queue_name);
  if (iq == queue_map[w]->end()) {
    init_queue_parms();
    update_parm_u32(*p_queue_parms, "bit_width", ci.p_core->get_tie_bit_width(tie_name.c_str()), oss_queue_parms, name_queue_parms);
    create_queue(queue_name, "");
    iq = queue_map[w]->find(queue_name);
    if (iq == queue_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred queue '" << queue_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  confirm_no_producer_connected(*iq->second, producer_port);
  confirm_no_output_queue_connected(ci, tie_name);
  XTSC_DEBUG(logger, "connecting TIE output queue port '" << tie_name <<
                     "' of core '" << core_name << "' to producer port #" << producer_port << " of queue '" << queue_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  iq->second->p_queue->connect(*ci.p_core, tie_name.c_str(), producer_port);
  iq->second->producer_connected[producer_port] = true;
  ci.output_queue_connected[tie_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << core_name << " to " << queue_name << endl;
  *oss_main[w] << tab2 << queue_name << "->connect(*" << core_name << ", \"" << tie_name << "\", " << producer_port << ");" << endl;
}



void connect_core_queue_pin(const string& core_name, const string& tie_name, const string& queue_pin_name) {
  XTSC_TRACE(logger, "enter connect_core_queue_pin()");
  core_info& ci = find_or_infer_core(core_name, "");
  // Ensure core has such an output queue
  if (!ci.p_core->has_pin_level_output_queue(tie_name.c_str())) {
    ostringstream oss;
    oss << "Core '" << core_name << "' has no pin-level TIE output queue named '" << tie_name << "'." << endl;
    oss << "Command: ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  // We don't use find_or_infer_queue_pin because we may get the bit width from the core
  map<string,queue_pin_info*>::iterator iq = queue_pin_map[w]->find(queue_pin_name);
  if (iq == queue_pin_map[w]->end()) {
    init_queue_pin_parms();
    update_parm_u32(*p_queue_pin_parms, "bit_width", ci.p_core->get_pin_bit_width(("TIE_" + tie_name).c_str()),
                    oss_queue_pin_parms, name_queue_pin_parms);
    create_queue_pin(queue_pin_name, "");
    iq = queue_pin_map[w]->find(queue_pin_name);
    if (iq == queue_pin_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred queue_pin '" << queue_pin_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  confirm_no_output_queue_connected(ci, tie_name);
  XTSC_DEBUG(logger, "connecting pin-level interface of TIE output queue '" << tie_name <<
                     "' of core '" << core_name << "' to queue_pin '" << queue_pin_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  queue_pin_info& qi = *(iq->second);
  confirm_no_producer_connected(qi);
  string data_name = "TIE_" + tie_name;
  string push_name = "TIE_" + tie_name + "_PushReq";
  string full_name = "TIE_" + tie_name + "_Full";
  ci.p_core->get_output_pin(data_name.c_str())(qi.data_in);
  ci.p_core->get_output_pin(push_name.c_str())(qi.push);
  ci.p_core->get_input_pin (full_name.c_str())(qi.full);
  qi.bind_producer_signals();
  qi.producer_connected = true;
  ci.output_queue_connected[tie_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create signals for " << queue_pin_name << endl;
  *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << queue_pin_name << "__data_in" << " = new xtsc_signal_sc_bv_base(\""
                       << queue_pin_name << "__data_in\", " << qi.width1 << ");" << endl;
  *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << queue_pin_name << "__push   " << " = new xtsc_signal_sc_bv_base(\""
                       << queue_pin_name << "__push\",    1);" << endl;
  *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << queue_pin_name << "__full   " << " = new xtsc_signal_sc_bv_base(\""
                       << queue_pin_name << "__full\",    1);" << endl;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect signals to " << queue_pin_name << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_data_in(*" << queue_pin_name << "__data_in);" << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_push   (*" << queue_pin_name << "__push   );" << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_full   (*" << queue_pin_name << "__full   );" << endl;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << core_name << " to " << queue_pin_name << " signals " << endl;
  *oss_main[w] << tab2 << core_name << "->get_output_pin(\"" << data_name << "\"        )(*" << queue_pin_name << "__data_in);"
                       << endl;
  *oss_main[w] << tab2 << core_name << "->get_output_pin(\"" << push_name << "\")(*"         << queue_pin_name << "__push   );"
                       << endl;
  *oss_main[w] << tab2 << core_name << "->get_input_pin (\"" << full_name << "\"   )(*"      << queue_pin_name << "__full   );"
                       << endl;
}



void connect_queue_core(const string& queue_name, u32 consumer_port, const string& tie_name, const string& core_name) {
  XTSC_TRACE(logger, "enter connect_queue_core()");
  core_info& ci = find_or_infer_core(core_name, "");
  // Ensure core has such an input queue
  try { ci.p_core->get_input_queue(tie_name.c_str()); } catch (xtsc_exception& xe) {
    ostringstream oss;
    oss << xe.what() << endl;
    oss << "Command: ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  map<string,queue_info*>::iterator iq = queue_map[w]->find(queue_name);
  if (iq == queue_map[w]->end()) {
    init_queue_parms();
    update_parm_u32(*p_queue_parms, "bit_width", ci.p_core->get_tie_bit_width(tie_name.c_str()), oss_queue_parms, name_queue_parms);
    create_queue(queue_name, "");
    iq = queue_map[w]->find(queue_name);
    if (iq == queue_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred queue '" << queue_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  confirm_no_consumer_connected(*iq->second, consumer_port);
  confirm_no_input_queue_connected(ci, tie_name);
  XTSC_DEBUG(logger, "connecting consumer port " << consumer_port << " of queue '" << queue_name <<
                     "' to TIE input queue port '" << tie_name << "' of core '" << core_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  iq->second->p_queue->connect(*ci.p_core, tie_name.c_str(), consumer_port);
  iq->second->consumer_connected[consumer_port] = true;
  ci.input_queue_connected[tie_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << queue_name << " to " << core_name << endl;
  *oss_main[w] << tab2 << queue_name << "->connect(*" << core_name << ", \"" << tie_name << "\", " << consumer_port << ");" << endl;
}



void connect_queue_pin_core(const string& queue_pin_name, const string& tie_name, const string& core_name) {
  XTSC_TRACE(logger, "enter connect_queue_pin_core()");
  core_info& ci = find_or_infer_core(core_name, "");
  // Ensure core has such an input queue
  if (!ci.p_core->has_pin_level_input_queue(tie_name.c_str())) {
    ostringstream oss;
    oss << "Core '" << core_name << "' has no pin-level TIE input queue named '" << tie_name << "'." << endl;
    oss << "Command: ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  // We don't use find_or_infer_queue_pin because we may get the bit width from the core
  map<string,queue_pin_info*>::iterator iq = queue_pin_map[w]->find(queue_pin_name);
  if (iq == queue_pin_map[w]->end()) {
    init_queue_pin_parms();
    update_parm_u32(*p_queue_pin_parms, "bit_width", ci.p_core->get_pin_bit_width(("TIE_" + tie_name).c_str()),
                    oss_queue_pin_parms, name_queue_pin_parms);
    create_queue_pin(queue_pin_name, "");
    iq = queue_pin_map[w]->find(queue_pin_name);
    if (iq == queue_pin_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred queue_pin '" << queue_pin_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  queue_pin_info& qi = *(iq->second);
  confirm_no_input_queue_connected(ci, tie_name);
  XTSC_DEBUG(logger, "connecting queue_pin '" << queue_pin_name << "' to pin-level interface of TIE input queue '" << tie_name <<
                     "' of core '" << core_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  confirm_no_consumer_connected(qi);
  string data_name  = "TIE_" + tie_name;
  string pop_name   = "TIE_" + tie_name + "_PopReq";
  string empty_name = "TIE_" + tie_name + "_Empty";
  ci.p_core->get_input_pin (data_name .c_str())(qi.data_out);
  ci.p_core->get_output_pin(pop_name  .c_str())(qi.pop);
  ci.p_core->get_input_pin (empty_name.c_str())(qi.empty);
  qi.bind_consumer_signals();
  qi.consumer_connected = true;
  ci.input_queue_connected[tie_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create signals for " << queue_pin_name << endl;
  *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << queue_pin_name << "__data_out" << " = new xtsc_signal_sc_bv_base(\""
                       << queue_pin_name << "__data_out\", " << qi.width1 << ");" << endl;
  *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << queue_pin_name << "__pop     " << " = new xtsc_signal_sc_bv_base(\""
                       << queue_pin_name << "__pop\",      1);" << endl;
  *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << queue_pin_name << "__empty   " << " = new xtsc_signal_sc_bv_base(\""
                       << queue_pin_name << "__empty\",    1);" << endl;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect signals to " << queue_pin_name << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_data_out(*" << queue_pin_name << "__data_out);" << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_pop     (*" << queue_pin_name << "__pop     );" << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_empty   (*" << queue_pin_name << "__empty   );" << endl;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << core_name << " to " << queue_pin_name << " signals " << endl;
  *oss_main[w] << tab2 << core_name << "->get_input_pin (\"" << data_name  << "\"       )(*" << queue_pin_name << "__data_out);"
                       << endl;
  *oss_main[w] << tab2 << core_name << "->get_output_pin(\"" << pop_name   << "\")(*"        << queue_pin_name << "__pop     );"
                       << endl;
  *oss_main[w] << tab2 << core_name << "->get_input_pin (\"" << empty_name << "\" )(*"       << queue_pin_name << "__empty   );"
                       << endl;
}



void connect_core_router(const string& core_name, xtsc_core::memory_port mem_port, const string& router_name) {
  XTSC_TRACE(logger, "enter connect_core_router()");
  core_info&   ci = find_or_infer_core(core_name, "");
  router_info& ri = find_or_infer_router(router_name);
  confirm_no_memory_connected(ci, mem_port);
  confirm_no_master_connected(ri);
  const char *memory_port_name = xtsc_core::get_memory_port_name(mem_port);
  XTSC_DEBUG(logger, "connecting core '" << core_name << "' memory port '" << memory_port_name <<
                     "' to router '" << router_name << "'.");
  ri.p_router->connect(*ci.p_core, memory_port_name);
  ci.memory_connected[mem_port] = true;
  ri.master_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << core_name << " to " << router_name << endl;
  *oss_main[w] << tab2 << router_name << "->connect(*" << core_name << ", \"" << memory_port_name << "\");" << endl;
}



void connect_core_signal(const string& core_name, const string& output_pin_name, const string& signal_name) {
  XTSC_TRACE(logger, "enter connect_core_signal()");
  core_info& ci = find_or_infer_core(core_name, "");
  if (!ci.p_core->has_output_pin(output_pin_name.c_str())) {
    ostringstream oss;
    oss << "Core '" << core_name << "' has no output pin named '" << output_pin_name;
    if (ci.p_core->has_output_pin(("TIE_" + output_pin_name).c_str())) {
      oss << "' (did you forget to use the \"TIE_\" prefix on the pin name in the connect command): ";
    }
    else {
      oss << "' (did you remember to add it to the core's \"SimPinLevelInterfaces\" parameter): ";
    }
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  u32 output_pin_width1 = ci.p_core->get_pin_bit_width(output_pin_name.c_str());
  signal_info& si = find_or_infer_signal(signal_name, output_pin_width1);
  u32 signal_width1 = si.bit_width;
  if (output_pin_width1 != signal_width1) {
    ostringstream oss;
    oss << "Can't connect output pin '" << output_pin_name << "' with bit width=" << output_pin_width1 << " to signal '"
        << signal_name << "' with bit width=" << signal_width1;
    throw xtsc_exception(oss.str());
  }
  XTSC_DEBUG(logger, "connecting output pin '" << output_pin_name << "' of core '" << core_name <<
                     "' to signal '" << signal_name << "'.");
  // Duplicate connections will be detected by SystemC 
  ci.p_core->get_output_pin(output_pin_name.c_str())(*si.p_signal);
  si.source_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect output pin " << output_pin_name << " of core " << core_name << " to signal " << signal_name
                       << endl;
  *oss_main[w] << tab2 << core_name << "->get_output_pin(\"" << output_pin_name << "\")(*" << signal_name << ");" << endl;
}



void connect_core_slave(const string& core_name, xtsc_core::memory_port mem_port, const string& slave_name) {
  XTSC_TRACE(logger, "enter connect_core_slave()");
  core_info&   ci = find_or_infer_core(core_name, "");
  slave_info&  si = find_or_infer_slave(slave_name);
  confirm_no_memory_connected(ci, mem_port);
  confirm_no_master_connected(si);
  const char *memory_port_name = xtsc_core::get_memory_port_name(mem_port);
  XTSC_DEBUG(logger, "connecting memory port '" << memory_port_name << "' of core '" << core_name << 
                     "' to slave '" << slave_name << "'.");
  si.p_slave->connect(*ci.p_core, memory_port_name);
  ci.memory_connected[mem_port] = true;
  si.master_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << core_name << " to " << slave_name << endl;
  *oss_main[w] << tab2 << slave_name << "->connect(*" << core_name << ", \"" << memory_port_name << "\");" << endl;
}



void connect_core_tlm2pin(const string& core_name, xtsc_core::memory_port mem_port, u32 tlm2pin_port, const string& tlm2pin_name) {
  XTSC_TRACE(logger, "enter connect_core_tlm2pin()");
  core_info&    ci = find_or_infer_core(core_name, "");
  tlm2pin_info& ti = find_or_infer_tlm2pin(tlm2pin_name);
  confirm_no_memory_connected(ci, mem_port);
  confirm_no_master_connected(ti, tlm2pin_port);
  const char *memory_port_name = xtsc_core::get_memory_port_name(mem_port);
  XTSC_DEBUG(logger, "connecting memory port '" << memory_port_name << "' of core '" << core_name << 
                     "' to tlm2pin '" << tlm2pin_name << "'.");
  u32 num_connected = ti.p_tlm2pin->connect(*ci.p_core, memory_port_name, tlm2pin_port);
  ci.memory_connected[mem_port] = true;
  ti.master_connected[tlm2pin_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << core_name << " to port " << tlm2pin_port;
  if (num_connected == 2) {
    ci.memory_connected[mem_port+1] = true;
    ti.master_connected[tlm2pin_port+1] = true;
    *oss_main[w] << " and port " << (tlm2pin_port+1);
  }
  *oss_main[w] << " of " << tlm2pin_name << endl;
  *oss_main[w] << tab2 << tlm2pin_name << "->connect(*" << core_name << ", \"" << memory_port_name << "\", " << tlm2pin_port
                       << ");" << endl;
}



void connect_core_wire(const string& core_name, const string& output_name, const string& wire_name) {
  XTSC_TRACE(logger, "enter connect_core_wire()");
  core_info& ci = find_or_infer_core(core_name, "");
  // Ensure core has such an export state or system-level output
  bool is_export_state;
  u32 bit_width;
  if (ci.p_core->has_export_state(output_name.c_str())) {
    is_export_state = true;
    bit_width = ci.p_core->get_tie_bit_width(output_name.c_str());
    confirm_no_export_state_connected(ci, output_name);
    ci.export_state_connected[output_name] = true;
  }
  else if (ci.p_core->has_system_output_wire(output_name.c_str())) {
    is_export_state = false;
    bit_width = ci.p_core->get_sysio_bit_width(output_name.c_str());
    confirm_no_system_output_connected(ci, output_name);
    ci.system_output_connected[output_name] = true;
  }
  else {
    ostringstream oss;
    oss << "Core '" << core_name << "' has no TIE export state or system-level output named '" << output_name << "'." << endl;
    try { ci.p_core->get_export_state      (output_name.c_str()); } catch (xtsc_exception& xe) { oss << xe.what(); }
    try { ci.p_core->get_system_output_wire(output_name.c_str()); } catch (xtsc_exception& xe) { oss << xe.what(); }
    oss << "Command: ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  map<string,wire_info*>::iterator iw = wire_map[w]->find(wire_name);
  if (iw == wire_map[w]->end()) {
    init_wire_parms();
    update_parm_u32(*p_wire_parms, "bit_width", bit_width, oss_wire_parms, name_wire_parms);
    create_wire(wire_name, "");
    iw = wire_map[w]->find(wire_name);
    if (iw == wire_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred wire '" << wire_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  XTSC_DEBUG(logger, "connecting " << (is_export_state ? "TIE export state" : "system-level output") << " '" << output_name <<
                     "' of core '" << core_name << "' to wire '" << wire_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  iw->second->p_wire->connect(*ci.p_core, output_name.c_str());
  iw->second->source_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << core_name << " to " << wire_name << endl;
  *oss_main[w] << tab2 << wire_name << "->connect(*" << core_name << ", \"" << output_name << "\");" << endl;
}



// Connect pin-level TIE output queue, TIE export state, TIE lookup, or system-level output interface to wrapper
void connect_core_wrapper(const string& core_name, const string& iface, const string& name_prefix) {
  XTSC_TRACE(logger, "enter connect_core_wrapper()");
  core_info&    ci = find_or_infer_core(core_name, "");
  confirm_a_wrapper_is_defined();
  XTSC_DEBUG(logger, "connecting core " << core_name << " to wrapper " << p_current_wrapper->name << ".");
  if (!ci.p_core->has_pin_level_interface(iface.c_str())) {
    ostringstream oss;
    oss << "core '" << core_name << "' has no pin-level interface named '" << iface << "': ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }

  vector<string> pins;
  string type;

  if (ci.p_core->has_pin_level_output_queue(iface.c_str())) {
    confirm_no_output_queue_connected(ci, iface);
    ci.output_queue_connected[iface] = true;
    type = "TIE output queue";
    pins.push_back("TIE_" + iface);
    pins.push_back("TIE_" + iface + "_PushReq");
    pins.push_back("TIE_" + iface + "_Full");
  }
  else if (ci.p_core->has_pin_level_export_state(iface.c_str())) {
    confirm_no_export_state_connected(ci, iface);
    ci.export_state_connected[iface] = true;
    type = "TIE export state";
    pins.push_back("TIE_" + iface);
  }
  else if (ci.p_core->has_pin_level_lookup(iface.c_str())) {
    confirm_no_lookup_connected(ci, iface);
    ci.lookup_connected[iface] = true;
    type = "TIE lookup";
    pins.push_back("TIE_" + iface + "_Out");
    pins.push_back("TIE_" + iface + "_Out_Req");
    pins.push_back("TIE_" + iface + "_In");
    if (ci.p_core->has_input_pin(("TIE_" + iface + "_Rdy").c_str())) {
      pins.push_back("TIE_" + iface + "_Rdy");
    }
  }
  else if (ci.p_core->has_output_pin(iface.c_str())) {
    confirm_no_system_output_connected(ci, iface);
    ci.system_output_connected[iface] = true;
    type = "system-level output";
    pins.push_back(iface);
  }
  else {
    ostringstream oss;
    oss << "core '" << core_name << "' has no pin-level output queue, lookup, export state, or system-level output interface named '"
        << iface << "': ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << type << " '" << iface << "' of core '" << ci.name << "' to wrapper:" << endl;

  ostringstream tran, core2tran, tran2wrapper;

  u32 nc = 0;
  for (vector<string>::const_iterator ip = pins.begin(); ip != pins.end(); ++ip) {
    nc = max(nc, ip->length());
  }

  for (vector<string>::const_iterator ip = pins.begin(); ip != pins.end(); ++ip) {

    string pname(*ip);                          // Xtensa pin name
    string wname(name_prefix + pname);          // wrapper port name
    string aname(wname + "_adapter");           // adapter name

    u32    bits(ci.p_core->get_pin_bit_width(pname.c_str()));
    bool   input(ci.p_core->has_input_pin(pname.c_str()));

    add_wrapper_io(wname, bits, input, true);

    const char *spc = space(nc - min(nc, ip->length()));

    add_adapter(tran, aname, bits, input, nc+8);

    core2tran << tab2 << ci.name << "->" << (input ? "get_input_pin " : "get_output_pin") << "(\"" << pname << "\"" << spc << ")("
              << aname << spc << "->m_sc_export);" << endl;

    tran2wrapper << tab2 << aname << spc << "->m_sc_" << (input ? "in " : "out") << "(" << wname << spc << ");" << endl;
  }

  string s(pins.size() == 1 ? "" : "s");

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create adapter" << s << " for connecting " << type << " '" << iface << "' of core '" << ci.name
                       << "' and wrapper:" << endl;
  *oss_main[w] << tran.str();

  if (pins.size() > 1) {
    *oss_main[w] << endl;
  }
  *oss_main[w] << tab2 << "// Connect " << type << " '" << iface << "' of core '" << ci.name << "' to adapter" << s << ":" << endl;
  *oss_main[w] << core2tran.str();

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect adapter" << s << " to wrapper:" << endl;
  *oss_main[w] << tran2wrapper.str();
}



void connect_distributor_core(const string& distributor_name, u32 port, const string& input_name, const string& core_name) {
  XTSC_TRACE(logger, "enter connect_distributor_core()");
  distributor_info& di = find_or_infer_distributor(distributor_name);
  core_info&        ci = find_or_infer_core(core_name, "");
  ostringstream oss;
  oss << "PROCINT" << port;
  string output_name(oss.str());
  confirm_output_exists_and_is_not_connected(di, output_name);
  confirm_no_system_input_connected(ci, input_name);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of distributor '" << distributor_name <<
                     "' to input '" << input_name << "' of core '" << core_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  ci.p_core->connect(*di.p_distributor, port, input_name.c_str());
  di.outputs_connected[output_name] = true;
  ci.system_input_connected[input_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << distributor_name << " to " << core_name << endl;
  *oss_main[w] << tab2 << core_name << "->connect(*" << distributor_name << ", " << port << ", \"" << input_name << "\");"
                       << endl;
}



void connect_distributor_logic(const string& distributor_name,
                               const string& output_name,
                               const string& input_name,
                               const string& logic_name)
{
  XTSC_TRACE(logger, "enter connect_distributor_logic()");
  distributor_info& di = find_or_infer_distributor(distributor_name);
  logic_info&       li = find_or_infer_logic(logic_name);
  confirm_output_exists_and_is_not_connected(di, output_name);
  confirm_input_exists_and_is_not_connected(li, input_name);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of distributor '" << distributor_name <<
                     "' to input '" << input_name << "' of logic '" << logic_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  li.p_logic->connect(*di.p_distributor, output_name.c_str(), input_name.c_str());
  di.outputs_connected[output_name] = true;
  li.inputs_connected[input_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << distributor_name << " to " << logic_name << endl;
  *oss_main[w] << tab2 << logic_name << "->connect(*" << distributor_name << ", \"" << output_name << "\", \"" << input_name << "\");"
                       << endl;
}



void connect_distributor_mmio(const string& distributor_name,
                              const string& output_name,
                              const string& input_name,
                              const string& mmio_name)
{
  XTSC_TRACE(logger, "enter connect_distributor_mmio()");
  distributor_info& di = find_or_infer_distributor(distributor_name);
  mmio_info&        mi = find_or_infer_mmio(mmio_name);
  confirm_output_exists_and_is_not_connected(di, output_name);
  confirm_input_exists_and_is_not_connected(mi, input_name);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of distributor '" << distributor_name <<
                     "' to input '" << input_name << "' of mmio '" << mmio_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  mi.p_mmio->connect(*di.p_distributor, output_name.c_str(), input_name.c_str());
  di.outputs_connected[output_name] = true;
  mi.inputs_connected[input_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << distributor_name << " to " << mmio_name << endl;
  *oss_main[w] << tab2 << mmio_name << "->connect(*" << distributor_name << ", \"" << output_name << "\", \"" << input_name << "\");"
                       << endl;
}



void connect_distributor_wire(const string& distributor_name, const string& output_name, const string& wire_name) {
  XTSC_TRACE(logger, "enter connect_distributor_wire()");
  distributor_info& di = find_or_infer_distributor(distributor_name);
  wire_info&        wi = find_or_infer_wire(wire_name);
  confirm_output_exists_and_is_not_connected(di, output_name);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of distributor '" << distributor_name <<
                     "' to wire '" << wire_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  wi.p_wire->connect(*di.p_distributor, output_name.c_str());
  di.outputs_connected[output_name] = true;
  wi.source_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << distributor_name << " to " << wire_name << endl;
  *oss_main[w] << tab2 << wire_name << "->connect(*" << distributor_name << ", \"" << output_name << "\");" << endl;
}



void connect_dma_arbiter(const string& dma_name, u32 arbiter_port, const string& arbiter_name) {
  XTSC_TRACE(logger, "enter connect_dma_arbiter()");
  dma_info&     di = find_or_infer_dma(dma_name);
  arbiter_info& ai = find_or_infer_arbiter(arbiter_name);
  confirm_no_slave_connected(di);
  confirm_valid_port(ai, arbiter_port);
  XTSC_DEBUG(logger, "connecting master port of dma '" << dma_name << "' to slave port #" << arbiter_port << " of arbiter '" <<
                     arbiter_name << "'.");
  ai.p_arbiter->connect(*di.p_dma, arbiter_port);
  di.slave_connected = true;
  ai.num_master_connected += 1;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << dma_name << " to " << arbiter_name << endl;
  *oss_main[w] << tab2 << arbiter_name << "->connect(*" << dma_name << ", " << arbiter_port << ");" << endl;
}



void connect_dma_memory(const string& dma_name, u32 memory_port, const string& memory_name) {
  XTSC_TRACE(logger, "enter connect_dma_memory()");
  dma_info&    di = find_or_infer_dma(dma_name);
  memory_info& mi = find_or_infer_memory(memory_name);
  confirm_no_slave_connected(di);
  confirm_no_master_connected(mi, memory_port);
  XTSC_DEBUG(logger, "connecting master port of dma '" << dma_name << "' to port #" << memory_port << " of memory '" <<
                     memory_name << "'.");
  mi.p_memory->connect(*di.p_dma, memory_port);
  di.slave_connected = true;
  mi.master_connected[memory_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << dma_name << " to " << memory_name << endl;
  *oss_main[w] << tab2 << memory_name << "->connect(*" << dma_name << ", " << memory_port << ");" << endl;
}



void connect_dma_memory_trace(const string& dma_name, u32 trace_port, const string& trace_name) {
  XTSC_TRACE(logger, "enter connect_dma_memory_trace()");
  dma_info&          di = find_or_infer_dma(dma_name);
  memory_trace_info& mi = find_or_infer_memory_trace(trace_name);
  confirm_no_slave_connected(di);
  confirm_no_master_connected(mi, trace_port);
  XTSC_DEBUG(logger, "connecting master port of dma '" << dma_name << "' to slave port #" << trace_port <<
                     " of memory_trace '" << trace_name << "'.");
  mi.p_memory_trace->connect(*di.p_dma, trace_port);
  di.slave_connected = true;
  mi.master_connected[trace_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << dma_name << " to " << trace_name << endl;
  *oss_main[w] << tab2 << trace_name << "->connect(*" << dma_name << ", " << trace_port << ");" << endl;
}



void connect_dma_router(const string& dma_name, const string& router_name) {
  XTSC_TRACE(logger, "enter connect_dma_router()");
  dma_info&     di = find_or_infer_dma(dma_name);
  router_info&  ri = find_or_infer_router(router_name);
  confirm_no_slave_connected(di);
  confirm_no_master_connected(ri);
  XTSC_DEBUG(logger, "connecting master port of dma '" << dma_name << "' to slave port of router '" << router_name << "'.");
  ri.p_router->connect(*di.p_dma);
  di.slave_connected = true;
  ri.master_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << dma_name << " to " << router_name << endl;
  *oss_main[w] << tab2 << router_name << "->connect(*" << dma_name << ");" << endl;
}



void connect_driver_distributor(const string& driver_name, const string& lookup_name, const string& distributor_name) {
  XTSC_TRACE(logger, "enter connect_driver_distributor()");
  driver_info&       dri = find_or_infer_driver(driver_name);
  distributor_info&  dis = find_or_infer_distributor(distributor_name);
  confirm_no_lookup_connected(dri);
  confirm_lookup_exists_and_is_not_connected(dis, lookup_name);
  XTSC_DEBUG(logger, "connecting driver '" << driver_name << "' to lookup '" << lookup_name <<
                     "' of distributor '" << distributor_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  dri.p_driver->connect(*dis.p_distributor, lookup_name.c_str());
  dri.lookup_connected = true;
  dis.lookups_connected[lookup_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << driver_name << " to " << distributor_name << endl;
  *oss_main[w] << tab2 << driver_name << "->connect(*" << distributor_name << ", \"" << lookup_name << "\");" << endl;
}



void connect_driver_lookup(const string& driver_name, const string& lookup_name) {
  XTSC_TRACE(logger, "enter connect_driver_lookup()");
  driver_info& di = find_or_infer_driver(driver_name);
  lookup_info& li = find_or_infer_lookup(lookup_name);
  confirm_no_lookup_connected(di);
  XTSC_DEBUG(logger, "connecting driver '" << driver_name << "' to lookup '" << lookup_name << "'.");
  li.p_lookup->connect(*di.p_driver);
  di.lookup_connected = true;
  li.master_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << driver_name << " to " << lookup_name << endl;
  *oss_main[w] << tab2 << lookup_name << "->connect(*" << driver_name << ");" << endl;
}



void connect_driver_lookup_pin(const string& driver_name, const string& lookup_pin_name) {
  XTSC_TRACE(logger, "enter connect_driver_lookup_pin()");
  driver_info&     di = find_or_infer_driver(driver_name);
  lookup_pin_info& li = find_or_infer_lookup_pin(lookup_pin_name);
  confirm_no_lookup_connected(di);
  confirm_no_master_connected(li);
  bool driver_ready = di.parms.get_bool("has_ready");
  bool lookup_ready = li.parms.get_bool("has_ready");
  if (driver_ready != lookup_ready) {
    ostringstream oss;
    oss << "Driver '"<< driver_name << "' " << (driver_ready ? "has" : "does not have") << " a ready signal, but lookup_pin '"
        << lookup_pin_name << "' does" << (lookup_ready ? "." : " not.");
    throw xtsc_exception(oss.str());
  }
  XTSC_DEBUG(logger, "connecting driver '" << driver_name << "' to lookup_pin '" << lookup_pin_name << "'.");
  di.p_driver->m_address  (li.address);
  di.p_driver->m_req  (li.req);
  di.p_driver->m_data(li.data);
  if (driver_ready) {
  di.p_driver->m_ready(li.ready);
  }
  di.lookup_connected = true;
  li.master_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create signals for " << lookup_pin_name << endl;
  *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << lookup_pin_name << "__address" << " = new xtsc_signal_sc_bv_base(\""
                       << lookup_pin_name << "__address\", " << li.address_width1 << ");" << endl;
  *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << lookup_pin_name << "__req    " << " = new xtsc_signal_sc_bv_base(\""
                       << lookup_pin_name << "__req\",     1);" << endl;
  *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << lookup_pin_name << "__data   " << " = new xtsc_signal_sc_bv_base(\""
                       << lookup_pin_name << "__data\",    " << li.data_width1 << ");" << endl;
  if (li.parms.get_bool("has_ready")) {
  *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << lookup_pin_name << "__ready  " << " = new xtsc_signal_sc_bv_base(\""
                       << lookup_pin_name << "__ready\",   1);" << endl;
  }
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect signals to " << lookup_pin_name << endl;
  *oss_main[w] << tab2 << lookup_pin_name << "->m_address(*" << lookup_pin_name << "__address);" << endl;
  *oss_main[w] << tab2 << lookup_pin_name << "->m_req    (*" << lookup_pin_name << "__req    );" << endl;
  *oss_main[w] << tab2 << lookup_pin_name << "->m_data   (*" << lookup_pin_name << "__data   );" << endl;
  if (li.parms.get_bool("has_ready")) {
  *oss_main[w] << tab2 << lookup_pin_name << "->m_ready  (*" << lookup_pin_name << "__ready  );" << endl;
  }
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << driver_name << " to " << lookup_pin_name << " signals " << endl;
  *oss_main[w] << tab2 << driver_name << "->m_address(*" << lookup_pin_name << "__address);" << endl;
  *oss_main[w] << tab2 << driver_name << "->m_req    (*" << lookup_pin_name << "__req    );" << endl;
  *oss_main[w] << tab2 << driver_name << "->m_data   (*" << lookup_pin_name << "__data   );" << endl;
  if (li.parms.get_bool("has_ready")) {
  *oss_main[w] << tab2 << driver_name << "->m_ready  (*" << lookup_pin_name << "__ready  );" << endl;
  }
}



void connect_driver_proxy(const string& driver_name, const string& name_prefix, const string& proxy_name) {
  XTSC_TRACE(logger, "enter connect_driver_proxy()");
  driver_info& di = find_or_infer_driver(driver_name);
  proxy_info&  pi = find_or_infer_proxy(proxy_name);
  confirm_no_lookup_connected(di);
  confirm_pin_level(di);
  XTSC_DEBUG(logger, "connecting driver '" << driver_name << "' to proxy '" << proxy_name << "'.");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect driver " << driver_name << " to " << pi.module_name << " proxy " << proxy_name << ":"
                       << endl;

  string prefix(name_prefix);
  if (prefix == "@") {
    // User has not specified the name prefix, so we need to use the default prefix
    prefix = "TIE_" + pi.module_name;
  }

  // Port names
  string out = prefix + "_Out";
  string req = prefix + "_Out_Req";
  string in  = prefix + "_In";
  string rdy = prefix + "_Rdy";

  // Signal names
  string out_s = driver_name + "_" + out;
  string req_s = driver_name + "_" + req;
  string in_s  = driver_name + "_" + in;
  string rdy_s = driver_name + "_" + rdy;

  // Transactor names
  string out_t  = out_s + "_adapter";
  string req_t  = req_s + "_adapter";
  string in_t   = in_s  + "_adapter";
  string rdy_t  = rdy_s + "_adapter";

  u32 abits = di.parms.get_u32("address_bit_width");
  u32 dbits = di.parms.get_u32("data_bit_width");

  add_proxy_io(pi, out, abits, true,  true, false);
  add_proxy_io(pi, req,     1, true,  true, false);
  add_proxy_io(pi, in,  dbits, false, true, false);
  if (di.parms.get_bool("has_ready")) {
  add_proxy_io(pi, rdy,     1, false, true, false);
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create adapters for connecting driver '" << driver_name << "' and " << pi.module_name << " proxy '"
                       << proxy_name << "':" << endl;
  u32 nc = out_t.length();
  add_adapter(*oss_main[w], out_t, abits, false, nc);
  add_adapter(*oss_main[w], req_t,     1, false, nc);
  add_adapter(*oss_main[w], in_t,  dbits, true,  nc);
  if (di.parms.get_bool("has_ready")) {
  add_adapter(*oss_main[w], rdy_t,     1, true,  nc);
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create signals for connecting driver '" << driver_name << "' and " << pi.module_name << " proxy '"
                       << proxy_name << "':" << endl;
  nc = out_s.length();
  add_signal(*oss_main[w], out_s, abits, nc);
  add_signal(*oss_main[w], req_s,     1, nc);
  add_signal(*oss_main[w], in_s,  dbits, nc);
  if (di.parms.get_bool("has_ready")) {
  add_signal(*oss_main[w], rdy_s,     1, nc);
  }

  if (pi.trace_identifier != "") {
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Trace signals for connecting driver '" << driver_name << "' and " << pi.module_name << " proxy '"
                         << proxy_name << "':" << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << out_s << ", \"" << out_s << "\");" << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << req_s << ", \"" << req_s << "\");" << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << in_s << " , \"" << in_s << "\" );" << endl;
    if (di.parms.get_bool("has_ready")) {
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << rdy_s << ", \"" << rdy_s << "\");" << endl;
    }
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect driver '" << driver_name << "' to adapters:" << endl;
  *oss_main[w] << tab2 << driver_name << "->m_address(" << out_t << ".m_sc_export);" << endl;
  *oss_main[w] << tab2 << driver_name << "->m_req    (" << req_t << ".m_sc_export);" << endl;
  *oss_main[w] << tab2 << driver_name << "->m_data   (" << in_t << " .m_sc_export);" << endl;
  if (di.parms.get_bool("has_ready")) {
  *oss_main[w] << tab2 << driver_name << "->m_ready  (" << rdy_t << ".m_sc_export);" << endl;
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect adapters to signals:" << endl;
  *oss_main[w] << tab2 << out_t << ".m_sc_out(" << out_s << ");" << endl;
  *oss_main[w] << tab2 << req_t << ".m_sc_out(" << req_s << ");" << endl;
  *oss_main[w] << tab2 << in_t  << " .m_sc_in ("<< in_s << " );" << endl;
  if (di.parms.get_bool("has_ready")) {
  *oss_main[w] << tab2 << rdy_t << ".m_sc_in (" << rdy_s << ");" << endl;
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << pi.module_name << " proxy '" << proxy_name << "' to signals:" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << out << "(" << out_s << ");" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << req << "(" << req_s << ");" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << in << " (" << in_s << " );" << endl;
  if (di.parms.get_bool("has_ready")) {
  *oss_main[w] << tab2 << proxy_name << "." << rdy << "(" << rdy_s << ");" << endl;
  }

  di.lookup_connected = true;
}



void connect_driver_wrapper(const string& driver_name, const string& name_prefix) {
  XTSC_TRACE(logger, "enter connect_driver_wrapper()");
  driver_info&  di = find_or_infer_driver(driver_name);
  confirm_a_wrapper_is_defined();
  confirm_no_lookup_connected(di);
  confirm_pin_level(di);
  XTSC_DEBUG(logger, "connecting driver '" << driver_name << "' to wrapper '" << p_current_wrapper->name << "'.");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect driver " << driver_name << " to wrapper:" << endl;

  // Port names
  string out = name_prefix + "_Out";
  string req = name_prefix + "_Out_Req";
  string in  = name_prefix + "_In";
  string rdy = name_prefix + "_Rdy";

  // Transactor names
  string out_t  = out + "_adapter";
  string req_t  = req + "_adapter";
  string in_t   = in  + "_adapter";
  string rdy_t  = rdy + "_adapter";

  u32 abits = di.parms.get_u32("address_bit_width");
  u32 dbits = di.parms.get_u32("data_bit_width");

  add_wrapper_io(out, abits, false, true);
  add_wrapper_io(req,     1, false, true);
  add_wrapper_io(in,  dbits, true,  true);
  if (di.parms.get_bool("has_ready")) {
  add_wrapper_io(rdy,     1, true,  true);
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create adapters for connecting driver '" << driver_name << "' and wrapper:" << endl;
  u32 nc = out_t.length();
  add_adapter(*oss_main[w], out_t, abits, false, nc);
  add_adapter(*oss_main[w], req_t,     1, false, nc);
  add_adapter(*oss_main[w], in_t,  dbits, true,  nc);
  if (di.parms.get_bool("has_ready")) {
  add_adapter(*oss_main[w], rdy_t,     1, true,  nc);
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect driver '" << driver_name << "' to adapters:" << endl;
  *oss_main[w] << tab2 << driver_name << "->m_address(" << out_t << "->m_sc_export);" << endl;
  *oss_main[w] << tab2 << driver_name << "->m_req    (" << req_t << "->m_sc_export);" << endl;
  *oss_main[w] << tab2 << driver_name << "->m_data   (" << in_t << " ->m_sc_export);" << endl;
  if (di.parms.get_bool("has_ready")) {
  *oss_main[w] << tab2 << driver_name << "->m_ready  (" << rdy_t << "->m_sc_export);" << endl;
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect adapters to wrapper:" << endl;
  *oss_main[w] << tab2 << out_t << "->m_sc_out(" << out << ");" << endl;
  *oss_main[w] << tab2 << req_t << "->m_sc_out(" << req << ");" << endl;
  *oss_main[w] << tab2 << in_t  << " ->m_sc_in ("<< in << " );" << endl;
  if (di.parms.get_bool("has_ready")) {
  *oss_main[w] << tab2 << rdy_t << "->m_sc_in (" << rdy << ");" << endl;
  }

  di.lookup_connected = true;
}



void connect_loader_consumer(const string& loader_name, const string& consumer_name) {
  XTSC_TRACE(logger, "enter connect_loader_consumer()");
  loader_info&   li = find_or_infer_loader(loader_name);
  consumer_info& ci = find_or_infer_consumer(consumer_name);
  confirm_no_consumer_connected(li);
  confirm_no_queue_connected(ci);
  bool pin_level = get_pin_level_and_confirm_match(li, ci);
  XTSC_DEBUG(logger, "connecting loader '" << loader_name << "' to consumer '" << consumer_name <<
                     "' (" << (pin_level ? "Pin" : "TLM") << ").");
  if (pin_level) {
    li.create_and_bind_consumer_signals();
    ci.p_consumer->m_data (*li.data_out);
    ci.p_consumer->m_pop  (*li.pop);
    ci.p_consumer->m_empty(*li.empty);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create signals for " << loader_name << endl;
    *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << loader_name << "__data_out" << " = new xtsc_signal_sc_bv_base(\""
                         << loader_name << "__data_out\", 32);" << endl;
    *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << loader_name << "__pop     " << " = new xtsc_signal_sc_bv_base(\""
                         << loader_name << "__pop\",       1);" << endl;
    *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << loader_name << "__empty   " << " = new xtsc_signal_sc_bv_base(\""
                         << loader_name << "__empty\",     1);" << endl;
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Connect signals to " << loader_name << endl;
    *oss_main[w] << tab2 << "(*" << loader_name << "->m_data_out)(*" << loader_name << "__data_out);" << endl;
    *oss_main[w] << tab2 << "(*" << loader_name << "->m_pop     )(*" << loader_name << "__pop     );" << endl;
    *oss_main[w] << tab2 << "(*" << loader_name << "->m_empty   )(*" << loader_name << "__empty   );" << endl;
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Connect " << consumer_name << " to " << loader_name << " signals " << endl;
    *oss_main[w] << tab2 << consumer_name << "->m_data (*" << loader_name << "__data_out);" << endl;
    *oss_main[w] << tab2 << consumer_name << "->m_pop  (*" << loader_name << "__pop     );" << endl;
    *oss_main[w] << tab2 << consumer_name << "->m_empty(*" << loader_name << "__empty   );" << endl;
  }
  else {
    ci.p_consumer->connect(*li.p_loader);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Connect " << loader_name << " to " << consumer_name << endl;
    *oss_main[w] << tab2 << consumer_name << "->connect(*" << loader_name << ");" << endl;
  }
  li.consumer_connected = true;
  ci.queue_connected = true;
}



void connect_loader_core(const string& loader_name, const string& iface, const string& core_name) {
  XTSC_TRACE(logger, "enter connect_loader_core()");
  loader_info& li = find_or_infer_loader(loader_name);
  core_info&   ci = find_or_infer_core(core_name, "");
  string iface_lc(iface);
  transform(iface.begin(), iface.end(), iface_lc.begin(), ::tolower);
  if (iface_lc == "tx_xfer_in") {
    confirm_no_first_tx_connected(li);
    confirm_no_xfer_in_connected(ci);
    XTSC_DEBUG(logger, "connecting XFER output of loader '" << loader_name << "' to XFER input of core '" << core_name << "'.");
    ci.p_core->connect(*li.p_loader, "tx_xfer_in");
    li.first_tx_connected = true;
    ci.tx_xfer_in_connected = true;
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Connect XFER output of " << loader_name << " to XFER input of " << core_name << endl;
    *oss_main[w] << tab2 << core_name << "->connect(*" << loader_name << ", \"tx_xfer_in\");" << endl;
  }
  else {
    // Ensure core has such an input queue
    try { ci.p_core->get_input_queue(iface.c_str()); } catch (xtsc_exception& xe) {
      ostringstream oss;
      oss << xe.what() << endl;
      oss << "Command: ";
      command_info(oss);
      throw xtsc_exception(oss.str());
    }
    confirm_no_input_queue_connected(ci, iface);
    XTSC_DEBUG(logger, "connecting loader '" << loader_name << "' to TIE input queue port '" << iface << "' of core '" << core_name <<
                       "'.");
    // Bit-width mismatch will be detected by XTSC
    ci.p_core->connect(*li.p_loader, iface.c_str());
    li.producer_connected = true;
    ci.input_queue_connected[iface] = true;
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Connect " << loader_name << " to TIE input queue of " << core_name << endl;
    *oss_main[w] << tab2 << core_name << "->connect(*" << loader_name << ", \"" << iface << "\");" << endl;
  }
}



void connect_loader_logic(const string& loader_name, const string& output_name, const string& input_name, const string& logic_name) {
  XTSC_TRACE(logger, "enter connect_loader_logic()");
  loader_info& li = find_or_infer_loader(loader_name);
  logic_info&  gi = find_or_infer_logic(logic_name);
  XTSC_DEBUG(logger, "connecting output '" << output_name << "' of loader '" << loader_name << "' to input \"" << input_name <<
                     "\" of logic '" << logic_name << "'.");
  confirm_output_exists_and_is_not_connected(li, output_name);
  confirm_input_exists_and_is_not_connected(gi, input_name);
  // Bit-width mismatch will be detected by XTSC
  gi.p_logic->connect(*li.p_loader, output_name.c_str(), input_name.c_str());
  li.outputs_connected[output_name] = true;
  gi.inputs_connected[input_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << loader_name << " to " << logic_name << endl;
  *oss_main[w] << tab2 << logic_name << "->connect(*" << loader_name << ", \"" << output_name << "\", \"" << input_name << "\");"
                       << endl;
}



void connect_loader_wire(const string& loader_name, const string& output_name, const string& wire_name) {
  XTSC_TRACE(logger, "enter connect_loader_wire()");
  loader_info& li = find_or_infer_loader(loader_name);
  wire_info&   wi = find_or_infer_wire(wire_name);
  XTSC_DEBUG(logger, "connecting output '" << output_name << "' of loader '" << loader_name << "' to wire '" << wire_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  confirm_output_exists_and_is_not_connected(li, output_name);
  wi.p_wire->connect(*li.p_loader, output_name.c_str());
  li.outputs_connected[output_name] = true;
  wi.source_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << loader_name << " to " << wire_name << endl;
  *oss_main[w] << tab2 << wire_name << "->connect(*" << loader_name << ", \"" << output_name << "\");" << endl;
}



void connect_logic_cohctrl(const string& logic_name, const string& output_name, u32 port, const string& cohctrl_name) {
  XTSC_TRACE(logger, "enter connect_logic_cohctrl()");
  logic_info&   li = find_or_infer_logic(logic_name);
  cohctrl_info& ci = find_or_infer_cohctrl(cohctrl_name);
  confirm_output_exists_and_is_not_connected(li, output_name);
  confirm_no_ccon_connected(ci, port);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of logic '" << logic_name << "' to m_ccon_exports[" <<
                     port << "] of cohctrl '" << cohctrl_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  li.p_logic->connect(*ci.p_cohctrl, port, output_name.c_str());
  li.outputs_connected[output_name] = true;
  ci.ccon_connected[port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << logic_name << " to " << cohctrl_name << endl;
  *oss_main[w] << tab2 << logic_name << "->connect(*" << cohctrl_name << ", \"" << port << "\", \"" << output_name << "\");"
                       << endl;
}



void connect_logic_core(const string& logic_name, const string& output_name, const string& input_name, const string& core_name) {
  XTSC_TRACE(logger, "enter connect_logic_core()");
  core_info&  ci = find_or_infer_core(core_name, "");
  logic_info& li = find_or_infer_logic(logic_name);
  // Ensure core has such a system-level input
  try { ci.p_core->get_system_input_wire(input_name.c_str()); } catch (xtsc_exception& xe) {
    ostringstream oss;
    oss << xe.what() << endl;
    oss << "Command: ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  confirm_output_exists_and_is_not_connected(li, output_name);
  confirm_no_system_input_connected(ci, input_name);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of logic '" << logic_name << "' to system-level input '" <<
                     input_name << "' of core '" << core_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  li.p_logic->connect(*ci.p_core, input_name.c_str(), output_name.c_str());
  li.outputs_connected[output_name] = true;
  ci.system_input_connected[input_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << logic_name << " to " << core_name << endl;
  *oss_main[w] << tab2 << logic_name << "->connect(*" << core_name << ", \"" << input_name << "\", \"" << output_name << "\");"
                       << endl;
}



void connect_logic_distributor(const string& logic_name,
                               const string& output_name,
                               const string& input_name,
                               const string& distributor_name)
{
  XTSC_TRACE(logger, "enter connect_logic_distributor()");
  logic_info&        li = find_or_infer_logic(logic_name);
  distributor_info&  di = find_or_infer_distributor(distributor_name);
  confirm_output_exists_and_is_not_connected(li, output_name);
  confirm_input_exists_and_is_not_connected(di, input_name);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of logic '" << logic_name << "' to input '" << input_name <<
                     "' of distributor '" << distributor_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  li.p_logic->connect(*di.p_distributor, input_name.c_str(), output_name.c_str());
  li.outputs_connected[output_name] = true;
  di.inputs_connected[input_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << logic_name << " to " << distributor_name << endl;
  *oss_main[w] << tab2 << logic_name << "->connect(*" << distributor_name << ", \"" << input_name << "\", \"" << output_name << "\");"
                       << endl;
}



void connect_logic_logic(const string& source_name, const string& output_name, const string& input_name, const string& sink_name) {
  XTSC_TRACE(logger, "enter connect_logic_logic()");
  logic_info& si = find_or_infer_logic(sink_name);
  logic_info& li = find_or_infer_logic(source_name);
  confirm_output_exists_and_is_not_connected(li, output_name);
  confirm_input_exists_and_is_not_connected(si, input_name);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of logic '" << source_name << "' to input '" << input_name <<
                     "' of logic '" << sink_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  si.p_logic->connect(*li.p_logic, output_name.c_str(), input_name.c_str());
  li.outputs_connected[output_name] = true;
  si.inputs_connected[input_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << source_name << " to " << sink_name << endl;
  *oss_main[w] << tab2 << sink_name << "->connect(*" << source_name << ", \"" << output_name << "\", \"" << input_name << "\");"
                       << endl;
}



void connect_logic_master(const string& logic_name, const string& output_name, const string& master_name) {
  XTSC_TRACE(logger, "enter connect_logic_master()");
  master_info& mi = find_or_infer_master(master_name);
  logic_info&  li = find_or_infer_logic(logic_name);
  confirm_output_exists_and_is_not_connected(li, output_name);
  confirm_control_exists_and_is_not_connected(mi);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of logic '" << logic_name << "' to control input of master '" <<
                     master_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  mi.p_master->connect(*li.p_logic, output_name.c_str());
  li.outputs_connected[output_name] = true;
  mi.control_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << logic_name << " to " << master_name << endl;
  *oss_main[w] << tab2 << master_name << "->connect(*" << logic_name << ", \"" << output_name << "\");" << endl;
}



void connect_logic_mmio(const string& logic_name, const string& output_name, const string& input_name, const string& mmio_name) {
  XTSC_TRACE(logger, "enter connect_logic_mmio()");
  mmio_info&  mi = find_or_infer_mmio(mmio_name);
  logic_info& li = find_or_infer_logic(logic_name);
  confirm_output_exists_and_is_not_connected(li, output_name);
  confirm_input_exists_and_is_not_connected(mi, input_name);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of logic '" << logic_name << "' to input '" << input_name <<
                     "' of mmio '" << mmio_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  mi.p_mmio->connect(*li.p_logic, output_name.c_str(), input_name.c_str());
  li.outputs_connected[output_name] = true;
  mi.inputs_connected[input_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << logic_name << " to " << mmio_name << endl;
  *oss_main[w] << tab2 << mmio_name << "->connect(*" << logic_name << ", \"" << output_name << "\", \"" << input_name << "\");"
                       << endl;
}



void connect_logic_producer(const string& logic_name, const string& output_name, const string& producer_name) {
  XTSC_TRACE(logger, "enter connect_logic_producer()");
  producer_info& pi = find_or_infer_producer(producer_name);
  logic_info&    li = find_or_infer_logic(logic_name);
  confirm_output_exists_and_is_not_connected(li, output_name);
  confirm_control_exists_and_is_not_connected(pi);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of logic '" << logic_name << "' to control input of producer '" <<
                     producer_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  pi.p_producer->connect(*li.p_logic, output_name.c_str());
  li.outputs_connected[output_name] = true;
  pi.control_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << logic_name << " to " << producer_name << endl;
  *oss_main[w] << tab2 << producer_name << "->connect(*" << logic_name << ", \"" << output_name << "\");" << endl;
}



void connect_logic_proxy(const string& logic_name, const string& output_name, const string& input_name, const string& proxy_name) {
  XTSC_TRACE(logger, "enter connect_logic_proxy()");
  logic_info& li = find_or_infer_logic(logic_name);
  proxy_info& pi = find_or_infer_proxy(proxy_name);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of logic '" << logic_name << "' to input '" << input_name <<
                     "' of proxy '" << proxy_name << "'.");
  confirm_output_exists_and_is_not_connected(li, output_name);

  string sig  = logic_name + "_" + output_name;
  string tran = sig + "_transactor";

  u32 bits = li.p_logic->get_bit_width(output_name.c_str());

  add_proxy_io(pi, input_name, bits, true, true, false);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create transactor for connecting output \"" << output_name << "\" of logic '" << logic_name
                       << "' to input '" << input_name << "' of " << pi.module_name << " proxy '" << proxy_name << "':" << endl;
  if (bits > 1) {
    *oss_main[w] << tab2 << "xtsc_tlm2pin_wire_transactor<" << bits << ", sc_bv<" << bits << "> > "
                         << tran << "(\"" << tran << "\");" << endl;
  }
  else {
    *oss_main[w] << tab2 << "xtsc_tlm2pin_wire_transactor<1, bool> "
                         << tran << "(\"" << tran << "\");" << endl;
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create signal for connecting output \"" << output_name << "\" of logic '" << logic_name
                       << "' to input '" << input_name << "' of " << pi.module_name << " proxy '" << proxy_name << "':" << endl;
  add_signal(*oss_main[w], sig, bits, sig.length());

  if (pi.trace_identifier != "") {
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Trace signal for connecting output \"" << output_name << "\" of logic '" << logic_name
                         << "' to input '" << input_name << "' of " << pi.module_name << " proxy '" << proxy_name << "':" << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << sig << ", \"" << sig << "\");" << endl;
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect output \"" << output_name << "\" of logic '" << logic_name << "' to transactor;" << endl;
  *oss_main[w] << tab2 << logic_name << "->get_output(\"" << output_name << "\")(" << tran << ".m_sc_export);" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect transactor to signal:" << endl;
  *oss_main[w] << tab2 << tran << ".m_sc_out(" << sig << ");" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect input '" << input_name << "' of " << pi.module_name << " proxy '" << proxy_name
                       << "' to signal:" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << input_name << "(" << sig << ");" << endl;

  li.outputs_connected[output_name] = true;

}



void connect_logic_source(const string& logic_name, const string& output_name, const string& source_name) {
  XTSC_TRACE(logger, "enter connect_logic_source()");
  source_info& si = find_or_infer_source(source_name);
  logic_info&  li = find_or_infer_logic(logic_name);
  confirm_output_exists_and_is_not_connected(li, output_name);
  confirm_control_exists_and_is_not_connected(si);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of logic '" << logic_name << "' to control input of source '" <<
                     source_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  si.p_source->connect(*li.p_logic, output_name.c_str());
  li.outputs_connected[output_name] = true;
  si.control_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << logic_name << " to " << source_name << endl;
  *oss_main[w] << tab2 << source_name << "->connect(*" << logic_name << ", \"" << output_name << "\");" << endl;
}



void connect_logic_wire(const string& logic_name, const string& output_name, const string& wire_name) {
  XTSC_TRACE(logger, "enter connect_logic_wire()");
  logic_info& li = find_or_infer_logic(logic_name);
  wire_info&  wi = find_or_infer_wire(wire_name);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of logic '" << logic_name << "' to wire '" << wire_name << "'.");
  confirm_output_exists_and_is_not_connected(li, output_name);
  u32 logic_width1 = li.p_logic->get_bit_width(output_name.c_str());
  u32 wire_width1 = wi.p_wire->nb_get_bit_width();
  if (logic_width1 != wire_width1) {
    ostringstream oss;
    oss << "Can't connect output \"" << output_name << "\" of logic '" << logic_name << "' with bit width=" << logic_width1
        << " to wire '" << wire_name << "' with bit width=" << wire_width1;
    throw xtsc_exception(oss.str());
  }
  wi.p_wire->connect(*li.p_logic, output_name.c_str());
  li.outputs_connected[output_name] = true;
  wi.source_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << logic_name << " to " << wire_name << endl;
  *oss_main[w] << tab2 << wire_name << "->connect(*" << logic_name << ", \"" << output_name <<"\");" << endl;
}



void connect_logic_wrapper(const string& logic_name, const string& logic_output_name, const string& wrapper_output_name) {
  XTSC_TRACE(logger, "enter connect_logic_wrapper()");
  logic_info& li = find_or_infer_logic(logic_name);
  confirm_a_wrapper_is_defined();
  XTSC_DEBUG(logger, "connecting output \"" << logic_output_name << "\" of logic '" << logic_name << "' to output '" <<
                     wrapper_output_name << "' of wrapper.");
  confirm_output_exists_and_is_not_connected(li, logic_output_name);

  string tran = wrapper_output_name + "_transactor";

  u32 bits = li.p_logic->get_bit_width(logic_output_name.c_str());

  add_wrapper_io(wrapper_output_name, bits, false, true);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create transactor for connecting output \"" << logic_output_name << "\" of logic '" << logic_name
                       << "' to output '" << wrapper_output_name << "' of wrapper:" << endl;
  ostringstream type;
  if (bits > 1) {
    type << "xtsc_tlm2pin_wire_transactor<" << bits << ", sc_bv<" << bits << "> >";
  }
  else {
    type << "xtsc_tlm2pin_wire_transactor<1, bool>";
  }
  *oss_main[w] << tab2 << type.str() << " *" << tran << " = new " << endl;
  *oss_main[w] << tab2 << type.str() << "(\"" << tran << "\"" << ");" << endl;
  *oss_main[w] << endl;

  *oss_main[w] << tab2 << "// Connect output \"" << logic_output_name << "\" of logic '" << logic_name << "' to transactor;" << endl;
  *oss_main[w] << tab2 << logic_name << "->get_output(\"" << logic_output_name << "\")(" << tran << "->m_sc_export);" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect transactor to output '" << wrapper_output_name << "' of wrapper:" << endl;
  *oss_main[w] << tab2 << tran << "->m_sc_out(" << wrapper_output_name << ");" << endl;

  li.outputs_connected[logic_output_name] = true;

}



void connect_master_arbiter(const string& master_name, u32 port, const string& arbiter_name) {
  XTSC_TRACE(logger, "enter connect_master_arbiter()");
  master_info&  mi = find_or_infer_master(master_name);
  arbiter_info& ai = find_or_infer_arbiter(arbiter_name);
  confirm_no_slave_connected(mi);
  confirm_valid_port(ai, port);
  XTSC_DEBUG(logger, "connecting master '" << master_name << "' to slave arbiter '" << 
                     arbiter_name << "' port " << port << ".");
  ai.p_arbiter->connect(*mi.p_master, port);
  mi.slave_connected = true;
  ai.num_master_connected += 1;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << master_name << " to " << arbiter_name << endl;
  *oss_main[w] << tab2 << arbiter_name << "->connect(*" << master_name << ", " << port << ");" << endl;
}



void connect_master_cohctrl(const string& master_name, u32 cohctrl_port, const string& cohctrl_name) {
  XTSC_TRACE(logger, "enter connect_master_cohctrl()");
  master_info&  mi = find_or_infer_master(master_name);
  cohctrl_info& ci = find_or_infer_cohctrl(cohctrl_name);
  confirm_no_master_connected(ci, cohctrl_port);
  confirm_no_slave_connected(mi);
  XTSC_DEBUG(logger, "connecting master '" << master_name << "' to port " << cohctrl_port <<
                     " of cohctrl '" << cohctrl_name << "'.");
  mi.p_master->connect(*ci.p_cohctrl, cohctrl_port);
  ci.master_connected[cohctrl_port] = true;
  mi.slave_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << master_name << " to port " << cohctrl_port << " of "<< cohctrl_name << endl;
  *oss_main[w] << tab2 << master_name << "->connect(*" << cohctrl_name << ", " << cohctrl_port << ");" << endl;
}



void connect_master_core(const string& master_name, const string& port_name, const string& core_name) {
  XTSC_TRACE(logger, "enter connect_master_core()");
  master_info& mi = find_or_infer_master(master_name);
  core_info&   ci = find_or_infer_core(core_name, "");
  confirm_no_slave_connected(mi);
  confirm_valid_inbound_name(port_name);
  if (port_name == "snoop") {
    confirm_no_snoop_connected(ci);
    ci.snoop_connected = true;
  }
  else {
    confirm_no_inbound_connected(ci);
    ci.inbound_connected = true;
  }
  XTSC_DEBUG(logger, "connecting master '" << master_name << "' to " << port_name << " of core '" << core_name << "'.");
  mi.p_master->connect(*ci.p_core, port_name.c_str());
  mi.slave_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << master_name << " to " << core_name << endl;
  *oss_main[w] << tab2 << master_name << "->connect(*" << core_name << ", \"" << port_name << "\");" << endl;
}



void connect_master_dma(const string& master_name, u32 dma_port, const string& dma_name) {
  XTSC_TRACE(logger, "enter connect_master_dma()");
  master_info& mi = find_or_infer_master(master_name);
  dma_info&    di = find_or_infer_dma(dma_name);
  confirm_no_slave_connected(mi);
  confirm_no_master_connected(di, dma_port);
  XTSC_DEBUG(logger, "connecting master '" << master_name << "' to port " << dma_port << " of dma '" << dma_name << "'.");
  di.p_dma->connect(*mi.p_master, dma_port);
  mi.slave_connected = true;
  di.master_connected[dma_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << master_name << " to port " << dma_port << " of " << dma_name << endl;
  *oss_main[w] << tab2 << dma_name << "->connect(*" << master_name << ", " << dma_port << ");" << endl;
}



void connect_master_memory(const string& master_name, u32 memory_port, const string& memory_name) {
  XTSC_TRACE(logger, "enter connect_master_memory()");
  master_info& pi = find_or_infer_master(master_name);
  memory_info& mi = find_or_infer_memory(memory_name);
  confirm_no_slave_connected(pi);
  confirm_no_master_connected(mi, memory_port);
  XTSC_DEBUG(logger, "connecting master '" << master_name << "' to port " << memory_port << " of memory '" << memory_name << "'.");
  mi.p_memory->connect(*pi.p_master, memory_port);
  pi.slave_connected = true;
  mi.master_connected[memory_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << master_name << " to port " << memory_port << " of " << memory_name << endl;
  *oss_main[w] << tab2 << memory_name << "->connect(*" << master_name << ", " << memory_port << ");" << endl;
}



void connect_master_memory_trace(const string& master_name, u32 trace_port, const string& trace_name) {
  XTSC_TRACE(logger, "enter connect_master_memory_trace()");
  master_info&       mi = find_or_infer_master(master_name);
  memory_trace_info& ti = find_or_infer_memory_trace(trace_name);
  confirm_no_slave_connected(mi);
  confirm_no_master_connected(ti, trace_port);
  XTSC_DEBUG(logger, "connecting master '" << master_name << "' to port " << trace_port << " of memory_trace '" << trace_name <<
                     "'.");
  ti.p_memory_trace->connect(*mi.p_master, trace_port);
  mi.slave_connected = true;
  ti.master_connected[trace_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << master_name << " to port " << trace_port << " of " << trace_name << endl;
  *oss_main[w] << tab2 << trace_name << "->connect(*" << master_name << ", " << trace_port << ");" << endl;
}



void connect_master_mmio(const string& master_name, const string& mmio_name) {
  XTSC_TRACE(logger, "enter connect_master_mmio()");
  master_info& mi = find_or_infer_master(master_name);
  mmio_info&   si = find_or_infer_mmio(mmio_name);
  confirm_no_slave_connected(mi);
  confirm_no_master_connected(si);
  XTSC_DEBUG(logger, "connecting master '" << master_name << "' to mmio '" << mmio_name << "'.");
  si.p_mmio->connect(*mi.p_master);
  mi.slave_connected = true;
  si.master_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << master_name << " to " << mmio_name << endl;
  *oss_main[w] << tab2 << mmio_name << "->connect(*" << master_name << ");" << endl;
}



void connect_master_router(const string& master_name, const string& router_name) {
  XTSC_TRACE(logger, "enter connect_master_router()");
  master_info& mi = find_or_infer_master(master_name);
  router_info& ri = find_or_infer_router(router_name);
  confirm_no_slave_connected(mi);
  confirm_no_master_connected(ri);
  XTSC_DEBUG(logger, "connecting master '" << master_name << "' to router '" << router_name << "'.");
  ri.p_router->connect(*mi.p_master);
  mi.slave_connected = true;
  ri.master_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << master_name << " to " << router_name << endl;
  *oss_main[w] << tab2 << router_name << "->connect(*" << master_name << ");" << endl;
}



void connect_master_slave(const string& master_name, const string& slave_name) {
  XTSC_TRACE(logger, "enter connect_master_slave()");
  master_info& mi = find_or_infer_master(master_name);
  slave_info&  si = find_or_infer_slave(slave_name);
  confirm_no_slave_connected(mi);
  confirm_no_master_connected(si);
  XTSC_DEBUG(logger, "connecting master '" << master_name << "' to slave '" << slave_name << "'.");
  si.p_slave->connect(*mi.p_master);
  mi.slave_connected = true;
  si.master_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << master_name << " to " << slave_name << endl;
  *oss_main[w] << tab2 << slave_name << "->connect(*" << master_name << ");" << endl;
}



void connect_master_tlm2pin(const string& master_name, u32 tlm2pin_port, const string& tlm2pin_name) {
  XTSC_TRACE(logger, "enter connect_master_tlm2pin()");
  master_info&  mi = find_or_infer_master(master_name);
  tlm2pin_info& ti = find_or_infer_tlm2pin(tlm2pin_name);
  confirm_no_slave_connected(mi);
  confirm_no_master_connected(ti, tlm2pin_port);
  XTSC_DEBUG(logger, "connecting master '" << master_name << "' to tlm2pin '" << tlm2pin_name << "'.");
  ti.p_tlm2pin->connect(*mi.p_master, tlm2pin_port);
  mi.slave_connected = true;
  ti.master_connected[tlm2pin_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << master_name << " to " << tlm2pin_name << endl;
  *oss_main[w] << tab2 << tlm2pin_name << "->connect(*" << master_name << ", " << tlm2pin_port << ");" << endl;
}



void connect_memory_trace_arbiter(const string& trace_name, u32 trace_port, u32 arbiter_port, const string& arbiter_name) {
  XTSC_TRACE(logger, "enter connect_memory_trace_arbiter()");
  memory_trace_info& mi = find_or_infer_memory_trace(trace_name);
  arbiter_info&      ai = find_or_infer_arbiter(arbiter_name);
  confirm_no_slave_connected(mi, trace_port);
  confirm_valid_port(ai, arbiter_port);
  XTSC_DEBUG(logger, "connecting memory_trace '" << trace_name << "' port " << trace_port << " to arbiter '" << 
                     arbiter_name << "' port " << arbiter_port << ".");
  ai.p_arbiter->connect(*mi.p_memory_trace, trace_port, arbiter_port);
  ai.num_master_connected += 1;
  mi.slave_connected[trace_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << trace_name << " to " << arbiter_name << endl;
  *oss_main[w] << tab2 << arbiter_name << "->connect(*" << trace_name << ", " << trace_port << ", " << arbiter_port << ");" << endl;
}



void connect_memory_trace_cohctrl(const string& trace_name, u32 trace_port, u32 cohctrl_port, const string& cohctrl_name) {
  XTSC_TRACE(logger, "enter connect_memory_trace_cohctrl()");
  memory_trace_info&  mi = find_or_infer_memory_trace(trace_name);
  cohctrl_info&       ci = find_or_infer_cohctrl(cohctrl_name);
  confirm_no_master_connected(ci, cohctrl_port);
  confirm_no_slave_connected(mi, trace_port);
  XTSC_DEBUG(logger, "connecting port " << trace_port << " of memory_trace '" << trace_name << "' to port " << cohctrl_port <<
                     " of cohctrl '" << cohctrl_name << "'.");
  mi.p_memory_trace->connect(*ci.p_cohctrl, xtsc_cohctrl::PT_CLIENT, cohctrl_port, trace_port);
  ci.master_connected[cohctrl_port] = true;
  mi.slave_connected[trace_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect port " << trace_port << " of " << trace_name << " to port " << cohctrl_port
                       << " of "<< cohctrl_name << endl;
  *oss_main[w] << tab2 << trace_name << "->connect(*" << cohctrl_name << ", xtsc_cohctrl::PT_CLIENT, " << cohctrl_port << ", "
                       << trace_port << ");" << endl;
}



void connect_memory_trace_core(const string& trace_name, u32 trace_port, const string& port_name, const string& core_name) {
  XTSC_TRACE(logger, "enter connect_memory_trace_core()");
  memory_trace_info& mi = find_or_infer_memory_trace(trace_name);
  core_info&         ci = find_or_infer_core(core_name, "");
  confirm_no_slave_connected(mi, trace_port);
  confirm_valid_inbound_name(port_name);
  if (port_name == "snoop") {
    confirm_no_snoop_connected(ci);
    ci.snoop_connected = true;
  }
  else {
    confirm_no_inbound_connected(ci);
    ci.inbound_connected = true;
  }
  XTSC_DEBUG(logger, "connecting memory_trace '" << trace_name << "' port " << trace_port << " to " << port_name << " of core '" <<
                     core_name << "'.");
  mi.p_memory_trace->connect(*ci.p_core, port_name.c_str(), trace_port);
  mi.slave_connected[trace_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << trace_name << " to " << core_name << endl;
  *oss_main[w] << tab2 << trace_name << "->connect(*" << core_name << ", \"" << port_name << "\", " << trace_port << ");" << endl;
}



void connect_memory_trace_dma(const string& trace_name, u32 trace_port, u32 dma_port, const string& dma_name) {
  XTSC_TRACE(logger, "enter connect_memory_trace_dma()");
  memory_trace_info& ti = find_or_infer_memory_trace(trace_name);
  dma_info&          di = find_or_infer_dma(dma_name);
  confirm_no_master_connected(di, dma_port);
  confirm_no_slave_connected(ti, trace_port);
  XTSC_DEBUG(logger, "connecting master port " << trace_port << " of memory_trace '" << trace_name << "' to slave port " <<
                     dma_port << " of dma '" << dma_name << "'.");
  u32 num_connected = di.p_dma->connect(*ti.p_memory_trace, trace_port, dma_port);
  for (u32 i = 0; i < num_connected; ++i) {
    di.master_connected[dma_port + i] = true;
    ti.slave_connected[trace_port + i] = true;
  }
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect port " << trace_port << " of " << trace_name << " to port " << dma_port << " of "
                       << dma_name << endl;
  *oss_main[w] << tab2 << dma_name << "->connect(*" << trace_name << ", " << trace_port << ", " << dma_port << ");" << endl;
}



void connect_memory_trace_memory(const string& trace_name, u32 trace_port, u32 memory_port, const string& memory_name) {
  XTSC_TRACE(logger, "enter connect_memory_trace_memory()");
  memory_trace_info& ti = find_or_infer_memory_trace(trace_name);
  xtsc_core_parms *p_cp = get_newest_core_parms();
  memory_info&       mi = find_or_infer_memory(memory_name, p_cp);
  confirm_no_master_connected(mi, memory_port);
  confirm_no_slave_connected(ti, trace_port);
  XTSC_DEBUG(logger, "connecting port " << trace_port << " of memory_trace '" << trace_name << "' to port " << memory_port <<
                     " of memory '" << memory_name << "'.");
  u32 num_connected = mi.p_memory->connect(*ti.p_memory_trace, trace_port, memory_port);
  for (u32 i = 0; i < num_connected; ++i) {
    mi.master_connected[memory_port + i] = true;
    ti.slave_connected[trace_port + i] = true;
  }
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect port " << trace_port << " of " << trace_name << " to port " << memory_port << " of "
                       << memory_name << endl;
  *oss_main[w] << tab2 << memory_name << "->connect(*" << trace_name << ", " << trace_port << ", " << memory_port << ");" << endl;
}



void connect_memory_trace_mmio(const string& trace_name, u32 trace_port, const string& mmio_name) {
  XTSC_TRACE(logger, "enter connect_memory_trace_mmio()");
  memory_trace_info& ti = find_or_infer_memory_trace(trace_name);
  mmio_info&         mi = find_or_infer_mmio(mmio_name);
  confirm_no_master_connected(mi);
  confirm_no_slave_connected(ti, trace_port);
  XTSC_DEBUG(logger, "connecting memory_trace '" << trace_name << "' port " << trace_port << " to mmio '" << mmio_name << "'.");
  mi.p_mmio->connect(*ti.p_memory_trace, trace_port);
  mi.master_connected = true;
  ti.slave_connected[trace_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << trace_name << " to " << mmio_name << endl;
  *oss_main[w] << tab2 << mmio_name << "->connect(*" << trace_name << ", " << trace_port << ");" << endl;
}



void connect_memory_trace_router(const string& trace_name, u32 trace_port, const string& router_name) {
  XTSC_TRACE(logger, "enter connect_memory_trace_router()");
  memory_trace_info& mi = find_or_infer_memory_trace(trace_name);
  router_info&       ri = find_or_infer_router(router_name);
  confirm_no_master_connected(ri);
  confirm_no_slave_connected(mi, trace_port);
  XTSC_DEBUG(logger, "connecting memory_trace '" << trace_name << "' port " << trace_port << " to router '" <<
                     router_name << "'.");
  ri.p_router->connect(*mi.p_memory_trace, trace_port);
  ri.master_connected = true;
  mi.slave_connected[trace_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << trace_name << " to " << router_name << endl;
  *oss_main[w] << tab2 << router_name << "->connect(*" << trace_name << ", " << trace_port << ");" << endl;
}



void connect_memory_trace_slave(const string& trace_name, u32 trace_port, const string& slave_name) {
  XTSC_TRACE(logger, "enter connect_memory_trace_slave()");
  memory_trace_info& mi = find_or_infer_memory_trace(trace_name);
  slave_info&        si = find_or_infer_slave(slave_name);
  confirm_no_master_connected(si);
  confirm_no_slave_connected(mi, trace_port);
  XTSC_DEBUG(logger, "connecting memory_trace '" << trace_name << "' port " << trace_port << " to slave '" << slave_name << "'.");
  si.p_slave->connect(*mi.p_memory_trace, trace_port);
  si.master_connected = true;
  mi.slave_connected[trace_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << trace_name << " to " << slave_name << endl;
  *oss_main[w] << tab2 << slave_name << "->connect(*" << trace_name << ", " << trace_port << ");" << endl;
}



void connect_memory_trace_tlm2pin(const string& trace_name, u32 trace_port, u32 tlm2pin_port, const string& tlm2pin_name) {
  XTSC_TRACE(logger, "enter connect_memory_trace_tlm2pin()");
  memory_trace_info& mi = find_or_infer_memory_trace(trace_name);
  tlm2pin_info&      ti = find_or_infer_tlm2pin(tlm2pin_name);
  confirm_no_master_connected(ti, tlm2pin_port);
  confirm_no_slave_connected(mi, trace_port);
  XTSC_DEBUG(logger, "connecting port " << trace_port << " of memory_trace '" << trace_name << "' to port " << tlm2pin_port <<
                     " of tlm2pin '" << tlm2pin_name << "'.");
  u32 num_connected = ti.p_tlm2pin->connect(*mi.p_memory_trace, trace_port, tlm2pin_port);
  for (u32 i = 0; i < num_connected; ++i) {
    ti.master_connected[tlm2pin_port + i] = true;
    mi.slave_connected[trace_port + i] = true;
  }
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect port " << trace_port << " of " << trace_name << " to port " << tlm2pin_port << " of "
                       << tlm2pin_name << endl;
  *oss_main[w] << tab2 << tlm2pin_name << "->connect(*" << trace_name << ", " << trace_port << ", " << tlm2pin_port << ");" << endl;
}




void connect_mmio_core(const string& mmio_name, const string& output_name, const string& input_name, const string& core_name) {
  XTSC_TRACE(logger, "enter connect_mmio_core()");
  core_info& ci = find_or_infer_core(core_name, "");
  mmio_info& mi = find_or_infer_mmio(mmio_name);
  // Ensure core has such a system-level input
  try { ci.p_core->get_system_input_wire(input_name.c_str()); } catch (xtsc_exception& xe) {
    ostringstream oss;
    oss << xe.what() << endl;
    oss << "Command: ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  confirm_output_exists_and_is_not_connected(mi, output_name);
  confirm_no_system_input_connected(ci, input_name);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of mmio '" << mmio_name << "' to system-level input '" <<
                     input_name << "' of core '" << core_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  mi.p_mmio->connect(*ci.p_core, input_name.c_str(), output_name.c_str());
  mi.outputs_connected[output_name] = true;
  ci.system_input_connected[input_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << mmio_name << " to " << core_name << endl;
  *oss_main[w] << tab2 << mmio_name << "->connect(*" << core_name << ", \"" << input_name << "\", \"" << output_name << "\");"
                       << endl;
}



void connect_mmio_distributor(const string& mmio_name,
                              const string& output_name,
                              const string& input_name,
                              const string& distributor_name)
{
  XTSC_TRACE(logger, "enter connect_mmio_distributor()");
  mmio_info&         mi = find_or_infer_mmio(mmio_name);
  distributor_info&  di = find_or_infer_distributor(distributor_name);
  confirm_output_exists_and_is_not_connected(mi, output_name);
  confirm_input_exists_and_is_not_connected(di, input_name);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of mmio '" << mmio_name << "' to input '" << input_name <<
                     "' of distributor '" << distributor_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  mi.p_mmio->connect(*di.p_distributor, input_name.c_str(), output_name.c_str());
  mi.outputs_connected[output_name] = true;
  di.inputs_connected[input_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << mmio_name << " to " << distributor_name << endl;
  *oss_main[w] << tab2 << mmio_name << "->connect(*" << distributor_name << ", \"" << input_name << "\", \"" << output_name << "\");"
                       << endl;
}



void connect_mmio_logic(const string& mmio_name, const string& output_name, const string& input_name, const string& logic_name) {
  XTSC_TRACE(logger, "enter connect_mmio_logic()");
  logic_info& li = find_or_infer_logic(logic_name);
  mmio_info&  mi = find_or_infer_mmio(mmio_name);
  confirm_output_exists_and_is_not_connected(mi, output_name);
  confirm_input_exists_and_is_not_connected(li, input_name);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of mmio '" << mmio_name << "' to input '" << input_name <<
                     "' of logic '" << logic_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  li.p_logic->connect(*mi.p_mmio, output_name.c_str(), input_name.c_str());
  mi.outputs_connected[output_name] = true;
  li.inputs_connected[input_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << mmio_name << " to " << logic_name << endl;
  *oss_main[w] << tab2 << logic_name << "->connect(*" << mmio_name << ", \"" << output_name << "\", \"" << input_name << "\");"
                       << endl;
}



void connect_mmio_master(const string& mmio_name, const string& output_name, const string& master_name) {
  XTSC_TRACE(logger, "enter connect_mmio_master()");
  master_info& ni = find_or_infer_master(master_name);
  mmio_info&   mi = find_or_infer_mmio(mmio_name);
  confirm_output_exists_and_is_not_connected(mi, output_name);
  confirm_control_exists_and_is_not_connected(ni);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of mmio '" << mmio_name << "' to control input of master '" <<
                     master_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  ni.p_master->connect(*mi.p_mmio, output_name.c_str());
  mi.outputs_connected[output_name] = true;
  ni.control_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << mmio_name << " to " << master_name << endl;
  *oss_main[w] << tab2 << master_name << "->connect(*" << mmio_name << ", \"" << output_name << "\");" << endl;
}



void connect_mmio_mmio(const string& source_name, const string& output_name, const string& input_name, const string& sink_name) {
  XTSC_TRACE(logger, "enter connect_mmio_mmio()");
  mmio_info& si = find_or_infer_mmio(sink_name);
  mmio_info& mi = find_or_infer_mmio(source_name);
  confirm_output_exists_and_is_not_connected(mi, output_name);
  confirm_input_exists_and_is_not_connected(si, input_name);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of mmio '" << source_name << "' to input '" << input_name <<
                     "' of mmio '" << sink_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  si.p_mmio->connect(*mi.p_mmio, output_name.c_str(), input_name.c_str());
  mi.outputs_connected[output_name] = true;
  si.inputs_connected[input_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << source_name << " to " << sink_name << endl;
  *oss_main[w] << tab2 << sink_name << "->connect(*" << source_name << ", \"" << output_name << "\", \"" << input_name << "\");"
                       << endl;
}



void connect_mmio_producer(const string& mmio_name, const string& output_name, const string& producer_name) {
  XTSC_TRACE(logger, "enter connect_mmio_producer()");
  producer_info& pi = find_or_infer_producer(producer_name);
  mmio_info&     mi = find_or_infer_mmio(mmio_name);
  confirm_output_exists_and_is_not_connected(mi, output_name);
  confirm_control_exists_and_is_not_connected(pi);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of mmio '" << mmio_name << "' to control input of producer '" <<
                     producer_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  pi.p_producer->connect(*mi.p_mmio, output_name.c_str());
  mi.outputs_connected[output_name] = true;
  pi.control_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << mmio_name << " to " << producer_name << endl;
  *oss_main[w] << tab2 << producer_name << "->connect(*" << mmio_name << ", \"" << output_name << "\");" << endl;
}



void connect_mmio_proxy(const string& mmio_name, const string& output_name, const string& input_name, const string& proxy_name) {
  XTSC_TRACE(logger, "enter connect_mmio_proxy()");
  mmio_info&  mi = find_or_infer_mmio(mmio_name);
  proxy_info& pi = find_or_infer_proxy(proxy_name);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of mmio '" << mmio_name << "' to input '" << input_name <<
                     "' of proxy '" << proxy_name << "'.");
  confirm_output_exists_and_is_not_connected(mi, output_name);

  string sig  = mmio_name + "_" + output_name;
  string tran = sig + "_transactor";

  u32 bits = mi.p_mmio->get_bit_width(output_name.c_str());

  add_proxy_io(pi, input_name, bits, true, true, false);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create transactor for connecting output \"" << output_name << "\" of mmio '" << mmio_name
                       << "' to input '" << input_name << "' of " << pi.module_name << " proxy '" << proxy_name << "':" << endl;
  if (bits > 1) {
    *oss_main[w] << tab2 << "xtsc_tlm2pin_wire_transactor<" << bits << ", sc_bv<" << bits << "> > "
                         << tran << "(\"" << tran << "\");" << endl;
  }
  else {
    *oss_main[w] << tab2 << "xtsc_tlm2pin_wire_transactor<1, bool> "
                         << tran << "(\"" << tran << "\");" << endl;
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create signal for connecting output \"" << output_name << "\" of mmio '" << mmio_name << "' to input '"
                       << input_name << "' of " << pi.module_name << " proxy '" << proxy_name << "':" << endl;
  add_signal(*oss_main[w], sig, bits, sig.length());

  if (pi.trace_identifier != "") {
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Trace signal for connecting output \"" << output_name << "\" of mmio '" << mmio_name << "' to input '"
                         << input_name << "' of " << pi.module_name << " proxy '" << proxy_name << "':" << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << sig << ", \"" << sig << "\");" << endl;
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect output \"" << output_name << "\" of mmio '" << mmio_name << "' to transactor;" << endl;
  *oss_main[w] << tab2 << mmio_name << "->get_output(\"" << output_name << "\")(" << tran << ".m_sc_export);" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect transactor to signal:" << endl;
  *oss_main[w] << tab2 << tran << ".m_sc_out(" << sig << ");" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect input '" << input_name << "' of " << pi.module_name << " proxy '" << proxy_name
                       << "' to signal:" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << input_name << "(" << sig << ");" << endl;

  mi.outputs_connected[output_name] = true;

}



void connect_mmio_source(const string& mmio_name, const string& output_name, const string& source_name) {
  XTSC_TRACE(logger, "enter connect_mmio_source()");
  source_info& si = find_or_infer_source(source_name);
  mmio_info&   mi = find_or_infer_mmio(mmio_name);
  confirm_output_exists_and_is_not_connected(mi, output_name);
  confirm_control_exists_and_is_not_connected(si);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of mmio '" << mmio_name << "' to control input of source '" <<
                     source_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  si.p_source->connect(*mi.p_mmio, output_name.c_str());
  mi.outputs_connected[output_name] = true;
  si.control_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << mmio_name << " to " << source_name << endl;
  *oss_main[w] << tab2 << source_name << "->connect(*" << mmio_name << ", \"" << output_name << "\");" << endl;
}



void connect_mmio_wire(const string& mmio_name, const string& output_name, const string& wire_name) {
  XTSC_TRACE(logger, "enter connect_mmio_wire()");
  mmio_info& mi = find_or_infer_mmio(mmio_name);
  wire_info& wi = find_or_infer_wire(wire_name);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of mmio '" << mmio_name << "' to wire '" << wire_name << "'.");
  confirm_output_exists_and_is_not_connected(mi, output_name);
  u32 mmio_width1 = mi.p_mmio->get_bit_width(output_name.c_str());
  u32 wire_width1 = wi.p_wire->nb_get_bit_width();
  if (mmio_width1 != wire_width1) {
    ostringstream oss;
    oss << "Can't connect output \"" << output_name << "\" of mmio '" << mmio_name << "' with bit width=" << mmio_width1
        << " to wire '" << wire_name << "' with bit width=" << wire_width1;
    throw xtsc_exception(oss.str());
  }
  wi.p_wire->connect(*mi.p_mmio, output_name.c_str());
  mi.outputs_connected[output_name] = true;
  wi.source_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << mmio_name << " to " << wire_name << endl;
  *oss_main[w] << tab2 << wire_name << "->connect(*" << mmio_name << ", \"" << output_name <<"\");" << endl;
}



void connect_mmio_wrapper(const string& mmio_name, const string& mmio_output_name, const string& wrapper_output_name) {
  XTSC_TRACE(logger, "enter connect_mmio_wrapper()");
  mmio_info& mi = find_or_infer_mmio(mmio_name);
  confirm_a_wrapper_is_defined();
  XTSC_DEBUG(logger, "connecting output \"" << mmio_output_name << "\" of mmio '" << mmio_name << "' to output '" <<
                     wrapper_output_name << "' of wrapper.");
  confirm_output_exists_and_is_not_connected(mi, mmio_output_name);

  string tran = wrapper_output_name + "_transactor";

  u32 bits = mi.p_mmio->get_bit_width(mmio_output_name.c_str());

  add_wrapper_io(wrapper_output_name, bits, false, true);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create transactor for connecting output \"" << mmio_output_name << "\" of mmio '" << mmio_name
                       << "' to output '" << wrapper_output_name << "' of wrapper:" << endl;
  ostringstream type;
  if (bits > 1) {
    type << "xtsc_tlm2pin_wire_transactor<" << bits << ", sc_bv<" << bits << "> >";
  }
  else {
    type << "xtsc_tlm2pin_wire_transactor<1, bool>";
  }
  *oss_main[w] << tab2 << type.str() << " *" << tran << " = new " << endl;
  *oss_main[w] << tab2 << type.str() << "(\"" << tran << "\"" << ");" << endl;
  *oss_main[w] << endl;

  *oss_main[w] << tab2 << "// Connect output \"" << mmio_output_name << "\" of mmio '" << mmio_name << "' to transactor;" << endl;
  *oss_main[w] << tab2 << mmio_name << "->get_output(\"" << mmio_output_name << "\")(" << tran << "->m_sc_export);" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect transactor to output '" << wrapper_output_name << "' of wrapper:" << endl;
  *oss_main[w] << tab2 << tran << "->m_sc_out(" << wrapper_output_name << ");" << endl;

  mi.outputs_connected[mmio_output_name] = true;

}



void connect_producer_loader(const string& producer_name, const string& loader_name) {
  XTSC_TRACE(logger, "enter connect_producer_loader()");
  producer_info& pi = find_or_infer_producer(producer_name);
  loader_info&   li = find_or_infer_loader(loader_name);
  confirm_no_queue_connected(pi);
  confirm_no_producer_connected(li);
  bool pin_level = get_pin_level_and_confirm_match(pi, li);
  XTSC_DEBUG(logger, "connecting producer '" << producer_name << "' to loader '" << loader_name <<
                     "' (" << (pin_level ? "Pin" : "TLM") << ").");
  if (pin_level) {
    li.create_and_bind_producer_signals();
    pi.p_producer->m_data(*li.data_in);
    pi.p_producer->m_push(*li.push);
    pi.p_producer->m_full(*li.full);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create signals for " << loader_name << endl;
    *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << loader_name << "__data_in" << " = new xtsc_signal_sc_bv_base(\""
                         << loader_name << "__data_in\", 32);" << endl;
    *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << loader_name << "__push   " << " = new xtsc_signal_sc_bv_base(\""
                         << loader_name << "__push\",     1);" << endl;
    *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << loader_name << "__full   " << " = new xtsc_signal_sc_bv_base(\""
                         << loader_name << "__full\",     1);" << endl;
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Connect signals to " << loader_name << endl;
    *oss_main[w] << tab2 << "(*" << loader_name << "->m_data_in)(*" << loader_name << "__data_in);" << endl;
    *oss_main[w] << tab2 << "(*" << loader_name << "->m_push   )(*" << loader_name << "__push   );" << endl;
    *oss_main[w] << tab2 << "(*" << loader_name << "->m_full   )(*" << loader_name << "__full   );" << endl;
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Connect " << producer_name << " to " << loader_name << " signals " << endl;
    *oss_main[w] << tab2 << producer_name << "->m_data(*" << loader_name << "__data_in);" << endl;
    *oss_main[w] << tab2 << producer_name << "->m_push(*" << loader_name << "__push   );" << endl;
    *oss_main[w] << tab2 << producer_name << "->m_full(*" << loader_name << "__full   );" << endl;
  }
  else {
    pi.p_producer->connect(*li.p_loader);
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Connect producer " << producer_name << " to queue input of " << loader_name << endl;
    *oss_main[w] << tab2 << producer_name << "->connect(*" << loader_name << ");" << endl;
  }
  pi.queue_connected = true;
  li.producer_connected = true;
}



void connect_producer_proxy(const string& producer_name, const string& name_prefix, const string& proxy_name) {
  XTSC_TRACE(logger, "enter connect_producer_proxy()");
  producer_info& qi = find_or_infer_producer(producer_name);
  proxy_info&    pi = find_or_infer_proxy(proxy_name);
  confirm_no_queue_connected(qi);
  confirm_pin_level(qi);
  XTSC_DEBUG(logger, "connecting producer '" << producer_name << "' to proxy '" << proxy_name << "'.");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect producer " << producer_name << " to " << pi.module_name << " proxy " << proxy_name << ":"
                       << endl;

  string prefix(name_prefix);
  if (prefix == "@") {
    // User has not specified the name prefix, so we need to use the default prefix
    prefix = "TIE_" + pi.module_name;
  }

  // Port names
  string data = prefix + "";
  string push = prefix + "_PushReq";
  string full = prefix + "_Full";

  // Signal names
  string data_s = producer_name + "_" + data;
  string push_s = producer_name + "_" + push;
  string full_s = producer_name + "_" + full;

  // Transactor names
  string data_t  = data_s + "_adapter";
  string push_t  = push_s + "_adapter";
  string full_t  = full_s + "_adapter";

  u32 bits = qi.parms.get_u32("bit_width");

  add_proxy_io(pi, data, bits, true,  true, false);
  add_proxy_io(pi, push,    1, true,  true, false);
  add_proxy_io(pi, full,    1, false, true, false);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create adapters for connecting producer '" << producer_name << "' and " << pi.module_name
                       << " proxy '" << proxy_name << "':" << endl;
  u32 nc = push_t.length();
  add_adapter(*oss_main[w], data_t, bits, false, nc);
  add_adapter(*oss_main[w], push_t,    1, false, nc);
  add_adapter(*oss_main[w], full_t,    1, true,  nc);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create signals for connecting producer '" << producer_name << "' and " << pi.module_name << " proxy '"
                       << proxy_name << "':" << endl;
  nc = push_s.length();
  add_signal(*oss_main[w], data_s, bits, nc);
  add_signal(*oss_main[w], push_s,    1, nc);
  add_signal(*oss_main[w], full_s,    1, nc);

  if (pi.trace_identifier != "") {
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Trace signals for connecting producer '" << producer_name << "' and " << pi.module_name << " proxy '"
                         << proxy_name << "':" << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << data_s << ",         \"" << data_s << "\"        );"
                         << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << push_s <<         ", \"" << push_s <<         "\");"
                         << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << full_s <<      ",    \"" << full_s <<      "\"   );"
                         << endl;
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect producer '" << producer_name << "' to adapters;" << endl;
  *oss_main[w] << tab2 << producer_name << "->m_data(" << data_t << ".        m_sc_export);" << endl;
  *oss_main[w] << tab2 << producer_name << "->m_push(" << push_t << ".m_sc_export);"         << endl;
  *oss_main[w] << tab2 << producer_name << "->m_full(" << full_t << ".   m_sc_export);"      << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect adapters to signals:" << endl;
  *oss_main[w] << tab2 << data_t << ".        m_sc_out(" << data_s << "        );" << endl;
  *oss_main[w] << tab2 << push_t << ".m_sc_out("         << push_s <<         ");" << endl;
  *oss_main[w] << tab2 << full_t << ".   m_sc_in ("      << full_s <<      "   );" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << pi.module_name << " proxy '" << proxy_name << "' to signals:" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << data << "        (" << data_s << "        );" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << push << "("         << push_s << ");"         << endl;
  *oss_main[w] << tab2 << proxy_name << "." << full << "   ("      << full_s << "   );"      << endl;

  qi.queue_connected = true;
}



void connect_producer_queue(const string& producer_name, u32 producer_port, const string& queue_name) {
  XTSC_TRACE(logger, "enter connect_producer_queue()");
  producer_info& pi = find_or_infer_producer(producer_name);
  queue_info&    qi = find_or_infer_queue(queue_name);
  confirm_no_queue_connected(pi);
  confirm_no_producer_connected(qi, producer_port);
  XTSC_DEBUG(logger, "connecting producer '" << producer_name << "' to producer port " << producer_port <<
                     " of queue '" << queue_name << "'.");
  qi.p_queue->connect(*pi.p_producer, producer_port);
  pi.queue_connected = true;
  qi.producer_connected[producer_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << producer_name << " to " << queue_name << endl;
  *oss_main[w] << tab2 << queue_name << "->connect(*" << producer_name << ", " << producer_port << ");" << endl;
}



void connect_producer_queue_pin(const string& producer_name, const string& queue_pin_name) {
  XTSC_TRACE(logger, "enter connect_producer_queue_pin()");
  producer_info&  pi = find_or_infer_producer(producer_name);
  queue_pin_info& qi = find_or_infer_queue_pin(queue_pin_name);
  confirm_no_queue_connected(pi);
  confirm_no_producer_connected(qi);
  XTSC_DEBUG(logger, "connecting producer '" << producer_name << "' to queue_pin '" << queue_pin_name << "'.");
  pi.p_producer->m_data(qi.data_in);
  pi.p_producer->m_push(qi.push);
  pi.p_producer->m_full(qi.full);
  qi.bind_producer_signals();
  pi.queue_connected = true;
  qi.producer_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create signals for " << queue_pin_name << endl;
  *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << queue_pin_name << "__data_in" << " = new xtsc_signal_sc_bv_base(\""
                       << queue_pin_name << "__data_in\", " << qi.width1 << ");" << endl;
  *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << queue_pin_name << "__push   " << " = new xtsc_signal_sc_bv_base(\""
                       << queue_pin_name << "__push\",    1);" << endl;
  *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << queue_pin_name << "__full   " << " = new xtsc_signal_sc_bv_base(\""
                       << queue_pin_name << "__full\",    1);" << endl;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect signals to " << queue_pin_name << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_data_in(*" << queue_pin_name << "__data_in);" << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_push   (*" << queue_pin_name << "__push   );" << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_full   (*" << queue_pin_name << "__full   );" << endl;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << producer_name << " to " << queue_pin_name << " signals " << endl;
  *oss_main[w] << tab2 << producer_name << "->m_data(*" << queue_pin_name << "__data_in);" << endl;
  *oss_main[w] << tab2 << producer_name << "->m_push(*" << queue_pin_name << "__push   );" << endl;
  *oss_main[w] << tab2 << producer_name << "->m_full(*" << queue_pin_name << "__full   );" << endl;
}



void connect_producer_wrapper(const string& producer_name, const string& name_prefix) {
  XTSC_TRACE(logger, "enter connect_producer_wrapper()");
  producer_info& pi = find_or_infer_producer(producer_name);
  confirm_a_wrapper_is_defined();
  confirm_no_queue_connected(pi);
  confirm_pin_level(pi);
  XTSC_DEBUG(logger, "connecting producer '" << producer_name << "' to wrapper '" << p_current_wrapper->name << "'.");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect producer " << producer_name << " to wrapper:" << endl;

  // Port names
  string data = name_prefix + "";
  string push = name_prefix + "_PushReq";
  string full = name_prefix + "_Full";

  // Transactor names
  string data_t  = data + "_adapter";
  string push_t  = push + "_adapter";
  string full_t  = full + "_adapter";

  u32 bits = pi.parms.get_u32("bit_width");

  add_wrapper_io(data, bits, false, true);
  add_wrapper_io(push,    1, false, true);
  add_wrapper_io(full,    1, true,  true);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create adapters for connecting producer '" << producer_name << "' and wrapper:" << endl;
  u32 nc = push_t.length();
  add_adapter(*oss_main[w], data_t, bits, false, nc);
  add_adapter(*oss_main[w], push_t,    1, false, nc);
  add_adapter(*oss_main[w], full_t,    1, true,  nc);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect producer '" << producer_name << "' to adapters;" << endl;
  *oss_main[w] << tab2 << producer_name << "->m_data(" << data_t << "->        m_sc_export);" << endl;
  *oss_main[w] << tab2 << producer_name << "->m_push(" << push_t << "->m_sc_export);"         << endl;
  *oss_main[w] << tab2 << producer_name << "->m_full(" << full_t << "->   m_sc_export);"      << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect adapters to wrapper:" << endl;
  *oss_main[w] << tab2 << data_t << "->        m_sc_out(" << data << "        );" << endl;
  *oss_main[w] << tab2 << push_t << "->m_sc_out("         << push <<         ");" << endl;
  *oss_main[w] << tab2 << full_t << "->   m_sc_in ("      << full <<      "   );" << endl;

  pi.queue_connected = true;
}



void connect_pin2tlm_arbiter(const string& pin2tlm_name, u32 pin2tlm_port, u32 arbiter_port, const string& arbiter_name) {
  XTSC_TRACE(logger, "enter connect_pin2tlm_arbiter()");
  pin2tlm_info& pi = find_or_infer_pin2tlm(pin2tlm_name);
  arbiter_info& ai = find_or_infer_arbiter(arbiter_name);
  confirm_no_slave_connected(pi, pin2tlm_port);
  confirm_valid_port(ai, arbiter_port);
  XTSC_DEBUG(logger, "connecting master pin2tlm '" << pin2tlm_name << "' port " << pin2tlm_port << " to slave arbiter '" << 
                     arbiter_name << "' port " << arbiter_port << ".");
  ai.p_arbiter->connect(*pi.p_pin2tlm, pin2tlm_port, arbiter_port);
  ai.num_master_connected += 1;
  pi.slave_connected[pin2tlm_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << pin2tlm_name << " to " << arbiter_name << endl;
  *oss_main[w] << tab2 << arbiter_name << "->connect(*" << pin2tlm_name << ", " << pin2tlm_port << ", " << arbiter_port << ");"
                       << endl;
}



void connect_pin2tlm_cohctrl(const string& pin2tlm_name, u32 pin2tlm_port, u32 cohctrl_port, const string& cohctrl_name) {
  XTSC_TRACE(logger, "enter connect_pin2tlm_cohctrl()");
  pin2tlm_info& pi = find_or_infer_pin2tlm(pin2tlm_name);
  cohctrl_info& ci = find_or_infer_cohctrl(cohctrl_name);
  confirm_no_slave_connected(pi, pin2tlm_port);
  confirm_no_master_connected(ci, cohctrl_port);
  XTSC_DEBUG(logger, "connecting pin2tlm '" << pin2tlm_name << "' TLM port " << pin2tlm_port << " to cohctrl '" << 
                     cohctrl_name << "' client port " << cohctrl_port << ".");
  pi.p_pin2tlm->connect(*ci.p_cohctrl, cohctrl_port, pin2tlm_port);
  ci.master_connected[cohctrl_port] = true;
  pi.slave_connected[pin2tlm_port]  = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << pin2tlm_name << " to " << cohctrl_name << endl;
  *oss_main[w] << tab2 << pin2tlm_name << "->connect(*" << cohctrl_name << ", " << cohctrl_port << ", " << pin2tlm_port << ");"
                       << endl;
}



void connect_pin2tlm_core(const string& pin2tlm_name, u32 pin2tlm_port, const string& core_name) {
  XTSC_TRACE(logger, "enter connect_pin2tlm_core()");
  pin2tlm_info& pi = find_or_infer_pin2tlm(pin2tlm_name);
  core_info&    ci = find_or_infer_core(core_name, "");
  confirm_no_slave_connected(pi, pin2tlm_port);
  confirm_no_inbound_connected(ci);
  XTSC_DEBUG(logger, "connecting pin2tlm '" << pin2tlm_name << "' port " << pin2tlm_port << " to inbound PIF/snoop of core '" <<
                     core_name << "'.");
  pi.p_pin2tlm->connect(*ci.p_core, pin2tlm_port);
  pi.slave_connected[pin2tlm_port] = true;
  ci.inbound_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << pin2tlm_name << " to " << core_name << endl;
  *oss_main[w] << tab2 << pin2tlm_name << "->connect(*" << core_name << ", " << pin2tlm_port << ");" << endl;
}



void connect_pin2tlm_memory(const string& pin2tlm_name, u32 pin2tlm_port, u32 memory_port, const string& memory_name) {
  XTSC_TRACE(logger, "enter connect_pin2tlm_memory()");
  pin2tlm_info& pi = find_or_infer_pin2tlm(pin2tlm_name);
  xtsc_core_parms *p_cp = get_newest_core_parms();
  memory_info&  mi = find_or_infer_memory(memory_name, p_cp);
  confirm_no_master_connected(mi, memory_port);
  confirm_no_slave_connected(pi, pin2tlm_port);
  XTSC_DEBUG(logger, "connecting port " << pin2tlm_port << " of pin2tlm '" << pin2tlm_name << "' to port " << memory_port <<
                     " of memory '" << memory_name << "'.");
  u32 num_connected = mi.p_memory->connect(*pi.p_pin2tlm, pin2tlm_port, memory_port);
  for (u32 i = 0; i < num_connected; ++i) {
    mi.master_connected[memory_port + i] = true;
    pi.slave_connected[pin2tlm_port + i] = true;
  }
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect port " << pin2tlm_port << " of " << pin2tlm_name << " to port " << memory_port << " of "
                       << memory_name << endl;
  *oss_main[w] << tab2 << memory_name << "->connect(*" << pin2tlm_name << ", " << pin2tlm_port << ", " << memory_port << ");" << endl;
}



void connect_pin2tlm_memory_trace(const string& pin2tlm_name, u32 pin2tlm_port, u32 trace_port, const string& trace_name) {
  XTSC_TRACE(logger, "enter connect_pin2tlm_memory_trace()");
  pin2tlm_info&       pi = find_or_infer_pin2tlm(pin2tlm_name);
  memory_trace_info&  mi = find_or_infer_memory_trace(trace_name);
  confirm_no_master_connected(mi, trace_port);
  confirm_no_slave_connected(pi, pin2tlm_port);
  XTSC_DEBUG(logger, "connecting port " << pin2tlm_port << " of pin2tlm '" << pin2tlm_name << "' to port " << trace_port <<
                     " of memory_trace '" << trace_name << "'.");
  u32 num_connected = mi.p_memory_trace->connect(*pi.p_pin2tlm, pin2tlm_port, trace_port);
  for (u32 i = 0; i < num_connected; ++i) {
    mi.master_connected[trace_port   + i] = true;
    pi.slave_connected [pin2tlm_port + i] = true;
  }
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect port " << pin2tlm_port << " of " << pin2tlm_name << " to port " << trace_port << " of "
                       << trace_name << endl;
  *oss_main[w] << tab2 << trace_name << "->connect(*" << pin2tlm_name << ", " << pin2tlm_port << ", " << trace_port << ");" << endl;
}



void connect_pin2tlm_mmio(const string& pin2tlm_name, u32 pin2tlm_port, const string& mmio_name) {
  XTSC_TRACE(logger, "enter connect_pin2tlm_mmio()");
  pin2tlm_info& pi = find_or_infer_pin2tlm(pin2tlm_name);
  mmio_info&    mi = find_or_infer_mmio(mmio_name);
  confirm_no_master_connected(mi);
  confirm_no_slave_connected(pi, pin2tlm_port);
  XTSC_DEBUG(logger, "connecting pin2tlm '" << pin2tlm_name << "' port " << pin2tlm_port << " to mmio '" << mmio_name << "'.");
  mi.p_mmio->connect(*pi.p_pin2tlm, pin2tlm_port);
  mi.master_connected = true;
  pi.slave_connected[pin2tlm_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << pin2tlm_name << " to " << mmio_name << endl;
  *oss_main[w] << tab2 << mmio_name << "->connect(*" << pin2tlm_name << ", " << pin2tlm_port << ");" << endl;
}



void connect_pin2tlm_router(const string& pin2tlm_name, u32 pin2tlm_port, const string& router_name) {
  XTSC_TRACE(logger, "enter connect_pin2tlm_router()");
  pin2tlm_info& pi = find_or_infer_pin2tlm(pin2tlm_name);
  router_info&  ri = find_or_infer_router(router_name);
  confirm_no_master_connected(ri);
  confirm_no_slave_connected(pi, pin2tlm_port);
  XTSC_DEBUG(logger, "connecting master pin2tlm '" << pin2tlm_name << "' port " << pin2tlm_port << " to slave router '" <<
                     router_name << "'.");
  ri.p_router->connect(*pi.p_pin2tlm, pin2tlm_port);
  ri.master_connected = true;
  pi.slave_connected[pin2tlm_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << pin2tlm_name << " to " << router_name << endl;
  *oss_main[w] << tab2 << router_name << "->connect(*" << pin2tlm_name << ", " << pin2tlm_port << ");" << endl;
}



void connect_pin2tlm_slave(const string& pin2tlm_name, u32 pin2tlm_port, const string& slave_name) {
  XTSC_TRACE(logger, "enter connect_pin2tlm_slave()");
  pin2tlm_info& pi = find_or_infer_pin2tlm(pin2tlm_name);
  slave_info&   si = find_or_infer_slave(slave_name);
  confirm_no_master_connected(si);
  confirm_no_slave_connected(pi, pin2tlm_port);
  XTSC_DEBUG(logger, "connecting pin2tlm '" << pin2tlm_name << "' port " << pin2tlm_port << " to slave '" << slave_name << "'.");
  si.p_slave->connect(*pi.p_pin2tlm, pin2tlm_port);
  si.master_connected = true;
  pi.slave_connected[pin2tlm_port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << pin2tlm_name << " to " << slave_name << endl;
  *oss_main[w] << tab2 << slave_name << "->connect(*" << pin2tlm_name << ", " << pin2tlm_port << ");" << endl;
}



void connect_proxy_cohctrl(const string& proxy_name, const string& output_name, u32 cohctrl_port, const string& cohctrl_name) {
  XTSC_TRACE(logger, "enter connect_proxy_cohctrl()");
  proxy_info&   pi = find_or_infer_proxy(proxy_name);
  cohctrl_info& ci = find_or_infer_cohctrl(cohctrl_name);
  XTSC_DEBUG(logger, "connecting output '" << output_name << "' of proxy '" << proxy_name << "' to m_ccon_exports[" <<
                     cohctrl_port << "] of cohctrl '" << cohctrl_name << "'.");
  confirm_no_ccon_connected(ci, cohctrl_port);

  ostringstream oss;
  oss << cohctrl_name << "_m_ccon_exports_" << cohctrl_port;
  string sig  = oss.str();
  string tran = sig + "_transactor";

  add_proxy_io(pi, output_name, 1, false, true, false);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create signal for connecting output '" << output_name << "' of " << pi.module_name << " proxy '"
                       << proxy_name << "' to m_ccon_exports[" << cohctrl_port << "] of cohctrl '" << cohctrl_name << "':" << endl;
  add_signal(*oss_main[w], sig, 1, sig.length());

  if (pi.trace_identifier != "") {
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Trace signal for connecting output '" << output_name << "' of " << pi.module_name << " proxy '"
                         << proxy_name << "' to m_ccon_exports[" << cohctrl_port << "] of cohctrl '" << cohctrl_name << "':" << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << sig << ", \"" << sig << "\");" << endl;
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create transactor for connecting output '" << output_name << "' of " << pi.module_name << " proxy '"
                       << proxy_name << "' to m_ccon_exports[" << cohctrl_port << "] of cohctrl '" << cohctrl_name << "':" << endl;

  *oss_main[w] << tab2 << "xtsc_pin2tlm_wire_transactor<1, bool> " << tran << "(\"" << tran << "\");" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect output '" << output_name << "' of " << pi.module_name << " proxy '" << proxy_name
                       << "' to signal:" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << output_name << "(" << sig << ");" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect transactor to signal:" << endl;
  *oss_main[w] << tab2 << tran << ".m_sc_in(" << sig << ");" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect transactor to m_ccon_exports[" << cohctrl_port << "] of cohctrl '" << cohctrl_name << "':"
                       << endl;
  *oss_main[w] << tab2 << tran << ".m_sc_port(*" << cohctrl_name << "->m_ccon_exports[" << cohctrl_port << "]);" << endl;

  ci.ccon_connected[cohctrl_port] = true;

}



void connect_proxy_consumer(const string& proxy_name, const string& name_prefix, const string& consumer_name) {
  XTSC_TRACE(logger, "enter connect_proxy_consumer()");
  proxy_info&    pi = find_or_infer_proxy(proxy_name);
  consumer_info& ci = find_or_infer_consumer(consumer_name);
  confirm_no_queue_connected(ci);
  confirm_pin_level(ci);
  XTSC_DEBUG(logger, "connecting proxy '" << proxy_name << "' to consumer '" << consumer_name << "'.");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << pi.module_name << " proxy " << proxy_name << " to consumer " << consumer_name << ":"
                       << endl;

  string prefix(name_prefix);
  if (prefix == "@") {
    // User has not specified the name prefix, so we need to use the default prefix
    prefix = "TIE_" + pi.module_name;
  }

  // Port names
  string data  = prefix + "";
  string pop   = prefix + "_PopReq";
  string empty = prefix + "_Empty";

  // Signal names
  string data_s  = consumer_name + "_" + data;
  string pop_s   = consumer_name + "_" + pop;
  string empty_s = consumer_name + "_" + empty;

  // Transactor names
  string data_t   = data_s  + "_adapter";
  string pop_t    = pop_s   + "_adapter";
  string empty_t  = empty_s + "_adapter";

  u32 bits = ci.parms.get_u32("bit_width");

  add_proxy_io(pi, data, bits, false, true, false);
  add_proxy_io(pi, pop,     1, true,  true, false);
  add_proxy_io(pi, empty,   1, false, true, false);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create adapters for connecting " << pi.module_name << " proxy '" << proxy_name << "' and consumer '"
                       << consumer_name << "':" << endl;
  u32 nc = pop_t.length();
  add_adapter(*oss_main[w], data_t,  bits, true,  nc);
  add_adapter(*oss_main[w], pop_t,      1, false, nc);
  add_adapter(*oss_main[w], empty_t,    1, true,  nc);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create signals for connecting " << pi.module_name << " proxy '" << proxy_name << "' and consumer '"
                       << consumer_name << "':" << endl;
  nc = pop_s.length();
  add_signal(*oss_main[w], data_s,  bits, nc);
  add_signal(*oss_main[w], pop_s,      1, nc);
  add_signal(*oss_main[w], empty_s,    1, nc);

  if (pi.trace_identifier != "") {
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Trace signals for connecting " << pi.module_name << " proxy '" << proxy_name << "' and consumer '"
                         << consumer_name << "':" << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << data_s  << ",        \"" << data_s  << "\"       );"
                         << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << pop_s   <<        ", \"" << pop_s   <<        "\");"
                         << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << empty_s <<       ",  \"" << empty_s <<       "\" );"
                         << endl;
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect consumer '" << consumer_name << "' to adapters:" << endl;
  *oss_main[w] << tab2 << consumer_name << "->m_data (" << data_t  << ".       m_sc_export);" << endl;
  *oss_main[w] << tab2 << consumer_name << "->m_pop  (" << pop_t   << ".m_sc_export);"        << endl;
  *oss_main[w] << tab2 << consumer_name << "->m_empty(" << empty_t << ". m_sc_export);"       << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect adapters to signals:" << endl;
  *oss_main[w] << tab2 << data_t  << ".       m_sc_in (" << data_s  << "       );" << endl;
  *oss_main[w] << tab2 << pop_t   <<        ".m_sc_out(" << pop_s   <<        ");" << endl;
  *oss_main[w] << tab2 << empty_t <<       ". m_sc_in (" << empty_s <<       " );" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << pi.module_name << " proxy '" << proxy_name << "' to signals:" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << data  << "       (" << data_s  << "       );" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << pop   <<        "(" << pop_s   <<        ");" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << empty <<       " (" << empty_s <<       " );" << endl;

  ci.queue_connected = true;
}



// Connect pin-level TIE input queue, TIE import wire, or system-level input interface to proxy
void connect_proxy_core(const string& proxy_name, const string& name_prefix, const string& iface, const string& core_name) {
  XTSC_TRACE(logger, "enter connect_proxy_core()");
  proxy_info& pi = find_or_infer_proxy(proxy_name);
  core_info&  ci = find_or_infer_core(core_name, "");
  XTSC_DEBUG(logger, "connecting proxy '" << proxy_name << "' to core '" << core_name << "'.");
  if (!ci.p_core->has_pin_level_interface(iface.c_str())) {
    ostringstream oss;
    oss << "core '" << core_name << "' has no pin-level interface named '" << iface << "': ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }

  vector<string> pins;
  string type;

  if (ci.p_core->has_pin_level_input_queue(iface.c_str())) {
    confirm_no_input_queue_connected(ci, iface);
    ci.input_queue_connected[iface] = true;
    type = "TIE input queue";
    pins.push_back("TIE_" + iface);
    pins.push_back("TIE_" + iface + "_PopReq");
    pins.push_back("TIE_" + iface + "_Empty");
  }
  else if (ci.p_core->has_pin_level_import_wire(iface.c_str())) {
    confirm_no_import_wire_connected(ci, iface);
    ci.import_wire_connected[iface] = true;
    type = "TIE import wire";
    pins.push_back("TIE_" + iface);
  }
  else if (ci.p_core->has_input_pin(iface.c_str())) {
    confirm_no_system_input_connected(ci, iface);
    ci.system_input_connected[iface] = true;
    type = "system-level input";
    pins.push_back(iface);
  }
  else {
    ostringstream oss;
    oss << "core '" << core_name << "' has no pin-level input queue, import wire, or system-level input interface named '"
        << iface << "': ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << pi.module_name << " proxy " << proxy_name << " to " << type << " \"" << iface
                       << "\" of core " << ci.name << ":" << endl;

  ostringstream tran, sig, trace, core2tran, tran2sig, proxy2sig;

  u32 nc = 0;
  for (vector<string>::const_iterator ip = pins.begin(); ip != pins.end(); ++ip) {
    nc = max(nc, ip->length());
  }

  for (vector<string>::const_iterator ip = pins.begin(); ip != pins.end(); ++ip) {

    string cname(*ip);                          // core pin name
    string pname(name_prefix + cname);          // proxy port name
    string sname(ci.name + "_" + pname);        // signal name
    string aname(sname + "_adapter");           // adapter name

    u32    bits(ci.p_core->get_pin_bit_width(cname.c_str()));
    bool   input(ci.p_core->has_input_pin(cname.c_str()));

    add_proxy_io(pi, pname, bits, !input, true, false);

    const char *spc = space(nc - min(nc, cname.length()));

    add_adapter(tran, aname, bits, input, nc+ci.name.length()+9+name_prefix.length());
    add_signal(sig, sname, bits, nc+ci.name.length()+1+name_prefix.length());

    trace << tab2 << "sc_trace(" << pi.trace_identifier << ", " << sname << ", " << spc << "\"" << sname << "\"" << spc << ");"
          << endl;

    core2tran << tab2 << ci.name << "->" << (input ? "get_input_pin " : "get_output_pin") << "(\"" << cname << "\"" << spc << ")("
              << aname << spc << ".m_sc_export);" << endl;

    tran2sig << tab2 << aname << spc << ".m_sc_" << (input ? "in " : "out") << "(" << sname << spc << ");" << endl;

    proxy2sig << tab2 << proxy_name << "." << pname << spc << "(" << sname << spc << ");" << endl;
  }

  string s(pins.size() == 1 ? "" : "s");

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create signal" << s << " for connecting " << pi.module_name << " proxy " << proxy_name << " and "
                       << type << " \"" << iface << "\" of core " << ci.name << ":" << endl;
  *oss_main[w] << sig.str();

  if (pi.trace_identifier != "") {
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Trace signal" << s << " for connecting " << pi.module_name << " proxy " << proxy_name << " and "
                         << type << " \"" << iface << "\" of core " << ci.name << ":" << endl;
    *oss_main[w] << trace.str();
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create adapter" << s << " for connecting " << pi.module_name << " proxy " << proxy_name << " and "
                       << type << " \"" << iface << "\" of core " << ci.name << ":" << endl;
  *oss_main[w] << tran.str();

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << pi.module_name << " proxy " << proxy_name << " to signal" << s << ":" << endl;
  *oss_main[w] << proxy2sig.str();

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect signal" << s << " to adapter" << s << ":" << endl;
  *oss_main[w] << tran2sig.str();

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect adapter" << s << " to " << type << " \"" << iface << "\" of core " << ci.name << ":" << endl;
  *oss_main[w] << core2tran.str();

}



void connect_proxy_loader(const string& proxy_name, const string& name_prefix, const string& loader_name) {
  XTSC_TRACE(logger, "enter connect_proxy_loader()");
  proxy_info&  pi = find_or_infer_proxy(proxy_name);
  loader_info& li = find_or_infer_loader(loader_name);
  XTSC_DEBUG(logger, "connecting proxy '" << proxy_name << "' to loader '" << loader_name << "'.");

  confirm_pin_level(li);

  bool something_connected = false;
  string prefix(name_prefix);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << pi.module_name << " proxy " << proxy_name << " to loader " << loader_name << ":" << endl;

  if (!li.producer_connected) {
    something_connected = true;
    XTSC_DEBUG(logger, "connecting proxy '" << proxy_name << "' to command queue of loader '" << loader_name << "'.");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Command Queue:  Connect " << pi.module_name << " proxy " << proxy_name << " to loader "
                         << loader_name << ":" << endl;

    // Port names
    string data = prefix + "QueueDataIn";
    string push = prefix + "Push";
    string full = prefix + "Full";

    // Signal names
    string data_s = loader_name + "_" + data;
    string push_s = loader_name + "_" + push;
    string full_s = loader_name + "_" + full;

    // Transactor names
    string data_t = data_s + "_adapter";
    string push_t = push_s + "_adapter";
    string full_t = full_s + "_adapter";

    u32 bits = 32;

    add_proxy_io(pi, data, bits, false, true, false);
    add_proxy_io(pi, push,    1, false, true, false);
    add_proxy_io(pi, full,    1, true,  true, false);

    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Command Queue:  Create adapters for connecting " << pi.module_name << " proxy '" << proxy_name
                         << "' and loader '" << loader_name << "':" << endl;
    u32 nc = data_t.length();
    add_adapter(*oss_main[w], data_t, bits, true,  nc);
    add_adapter(*oss_main[w], push_t,    1, true,  nc);
    add_adapter(*oss_main[w], full_t,    1, false, nc);

    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Command Queue:  Create signals for connecting " << pi.module_name << " proxy '" << proxy_name
                         << "' and loader '" << loader_name << "':" << endl;
    nc = data_s.length();
    add_signal(*oss_main[w], data_s, bits, nc);
    add_signal(*oss_main[w], push_s,    1, nc);
    add_signal(*oss_main[w], full_s,    1, nc);

    if (pi.trace_identifier != "") {
      *oss_main[w] << endl;
      *oss_main[w] << tab2 << "// Command Queue:  Trace signals for connecting " << pi.module_name << " proxy '" << proxy_name
                           << "' and loader '" << loader_name << "':" << endl;
      *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << data_s <<        ", \"" << data_s <<        "\");"
                           << endl;
      *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << push_s << ",        \"" << push_s << "\"       );"
                           << endl;
      *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << full_s << ",        \"" << full_s << "\"       );"
                           << endl;
    }

    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Command Queue:  Connect loader '" << loader_name << "' to adapters:" << endl;
    *oss_main[w] << tab2 << "(*" << loader_name << "->m_data_in)(" << data_t <<        ".m_sc_export);" << endl;
    *oss_main[w] << tab2 << "(*" << loader_name << "->m_push   )(" << push_t << "       .m_sc_export);" << endl;
    *oss_main[w] << tab2 << "(*" << loader_name << "->m_full   )(" << full_t << "       .m_sc_export);" << endl;

    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Command Queue:  Connect adapters to signals:" << endl;
    *oss_main[w] << tab2 << data_t <<        ".m_sc_in (" << data_s <<        ");" << endl;
    *oss_main[w] << tab2 << push_t << "       .m_sc_in (" << push_s << "       );" << endl;
    *oss_main[w] << tab2 << full_t << "       .m_sc_out(" << full_s << "       );" << endl;

    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Command Queue:  Connect " << pi.module_name << " proxy '" << proxy_name << "' to signals:" << endl;
    *oss_main[w] << tab2 << proxy_name << "." << data <<        "(" << data_s <<        ");" << endl;
    *oss_main[w] << tab2 << proxy_name << "." << push << "       (" << push_s << "       );" << endl;
    *oss_main[w] << tab2 << proxy_name << "." << full << "       (" << full_s << "       );" << endl;

    li.producer_connected = true;
  }

  if (!li.consumer_connected) {
    something_connected = true;
    XTSC_DEBUG(logger, "connecting proxy '" << proxy_name << "' to read queue of loader '" << loader_name << "'.");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Read Queue:  Connect " << pi.module_name << " proxy " << proxy_name << " to loader "
                         << loader_name << ":" << endl;

    // Port names
    string data  = prefix + "RdData";
    string pop   = prefix + "Pop";
    string empty = prefix + "RdEmpty";

    // Signal names
    string data_s  = loader_name + "_" + data;
    string pop_s   = loader_name + "_" + pop;
    string empty_s = loader_name + "_" + empty;

    // Transactor names
    string data_t  = data_s  + "_adapter";
    string pop_t   = pop_s   + "_adapter";
    string empty_t = empty_s + "_adapter";

    u32 bits = 32;

    add_proxy_io(pi, data, bits, true,  true, false);
    add_proxy_io(pi, pop,     1, false, true, false);
    add_proxy_io(pi, empty,   1, true,  true, false);

    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Read Queue:  Create adapters for connecting loader '" << loader_name << "' and " << pi.module_name
                         << " proxy '" << proxy_name << "':" << endl;
    u32 nc = empty_t.length();
    add_adapter(*oss_main[w], data_t, bits, false, nc);
    add_adapter(*oss_main[w], pop_t,     1, true,  nc);
    add_adapter(*oss_main[w], empty_t,   1, false, nc);

    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Read Queue:  Create signals for connecting loader '" << loader_name << "' and " << pi.module_name
                         << " proxy '" << proxy_name << "':" << endl;
    nc = empty_s.length();
    add_signal(*oss_main[w], data_s, bits, nc);
    add_signal(*oss_main[w], pop_s,     1, nc);
    add_signal(*oss_main[w], empty_s,   1, nc);

    if (pi.trace_identifier != "") {
      *oss_main[w] << endl;
      *oss_main[w] << tab2 << "// Read Queue:  Trace signals for connecting loader '" << loader_name << "' and " << pi.module_name
                           << " proxy '" << proxy_name << "':" << endl;
      *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << data_s  <<    ",  \"" << data_s  <<     "\" );"
                           << endl;
      *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << pop_s   << ",     \"" << pop_s   <<  "\"    );"
                           << endl;
      *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << empty_s <<     ", \"" << empty_s <<      "\");"
                           << endl;
    }

    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Read Queue:  Connect loader '" << loader_name << "' to adapters;" << endl;
    *oss_main[w] << tab2 << "(*" << loader_name << "->m_data_out)(" << data_t  <<    " .m_sc_export);" << endl;
    *oss_main[w] << tab2 << "(*" << loader_name << "->m_pop     )(" << pop_t   << "    .m_sc_export);" << endl;
    *oss_main[w] << tab2 << "(*" << loader_name << "->m_empty   )(" << empty_t <<     ".m_sc_export);" << endl;

    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Read Queue:  Connect adapters to signals:" << endl;
    *oss_main[w] << tab2 << data_t  <<    " .m_sc_out(" << data_s  <<    " );" << endl;
    *oss_main[w] << tab2 << pop_t   << "    .m_sc_in (" << pop_s   << "    );" << endl;
    *oss_main[w] << tab2 << empty_t <<     ".m_sc_out(" << empty_s <<     ");" << endl;

    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Read Queue:  Connect " << pi.module_name << " proxy '" << proxy_name << "' to signals:" << endl;
    *oss_main[w] << tab2 << proxy_name << "." << data  <<    " (" << data_s  <<    " );" << endl;
    *oss_main[w] << tab2 << proxy_name << "." << pop   << "    (" << pop_s   << "    );" << endl;
    *oss_main[w] << tab2 << proxy_name << "." << empty <<     "(" << empty_s <<     ");" << endl;

    li.consumer_connected = true;
  }

  for (map<string,bool>::iterator io = li.outputs_connected.begin(); io != li.outputs_connected.end(); ++io) {
    if (io->second) continue;
    something_connected = true;
    string output_name(io->first);
    string input_name(prefix+io->first);
    string loader_cpp_name("m_" + io->first);
    transform(loader_cpp_name.begin(), loader_cpp_name.end(), loader_cpp_name.begin(), ::tolower);

    string sig  = loader_name + "_" + output_name;
    string tran = sig + "_transactor";

    u32 bits = ((output_name == "Mode") ? 3 : 1);

    add_proxy_io(pi, input_name, bits, true, true, false);

    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// " << output_name << ":  Create transactor for connecting output of loader '" << loader_name
                         << "' to input '" << input_name << "' of " << pi.module_name << " proxy '" << proxy_name << "':" << endl;
    if (bits > 1) {
      *oss_main[w] << tab2 << "xtsc_tlm2pin_wire_transactor<" << bits << ", sc_bv<" << bits << "> > "
                           << tran << "(\"" << tran << "\");" << endl;
    }
    else {
      *oss_main[w] << tab2 << "xtsc_tlm2pin_wire_transactor<1, bool> "
                           << tran << "(\"" << tran << "\");" << endl;
    }

    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// " << output_name << ":  Create signal for connecting output of loader '" << loader_name
                         << "' to input '" << input_name << "' of " << pi.module_name << " proxy '" << proxy_name << "':" << endl;
    add_signal(*oss_main[w], sig, bits, sig.length());

    if (pi.trace_identifier != "") {
      *oss_main[w] << endl;
      *oss_main[w] << tab2 << "// " << output_name << ":  Trace signal for connecting output of loader '" << loader_name
                           << "' to input '" << input_name << "' of " << pi.module_name << " proxy '" << proxy_name << "':" << endl;
      *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << sig << ", \"" << sig << "\");" << endl;
    }

    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// " << output_name << ":  Connect output of loader '" << loader_name << "' to transactor;" << endl;
    *oss_main[w] << tab2 << loader_name << "->" << loader_cpp_name << "(" << tran << ".m_sc_export);" << endl;

    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// " << output_name << ":  Connect transactor to signal:" << endl;
    *oss_main[w] << tab2 << tran << ".m_sc_out(" << sig << ");" << endl;

    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// " << output_name << ":  Connect input '" << input_name << "' of " << pi.module_name << " proxy '"
                         << proxy_name << "' to signal:" << endl;
    *oss_main[w] << tab2 << proxy_name << "." << input_name << "(" << sig << ");" << endl;

    li.outputs_connected[output_name] = true;
  }

  if (!something_connected) {
    ostringstream oss;
    oss << "loader '" << loader_name
        << "' has no unconnected queue or wire ports so cannot connect to Verilog as requested in command: ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void connect_proxy_logic(const string& proxy_name, const string& output_name, const string& input_name, const string& logic_name) {
  XTSC_TRACE(logger, "enter connect_proxy_logic()");
  proxy_info& pi = find_or_infer_proxy(proxy_name);
  logic_info& li = find_or_infer_logic(logic_name);
  XTSC_DEBUG(logger, "connecting output '" << output_name << "' of proxy '" << proxy_name << "' to input \"" << input_name <<
                      "\" of logic '" << logic_name << "'.");
  confirm_input_exists_and_is_not_connected(li, input_name);

  string sig  = logic_name + "_" + input_name;
  string tran = sig + "_transactor";

  u32 bits = li.p_logic->get_bit_width(input_name.c_str());

  add_proxy_io(pi, output_name, bits, false, true, false);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create signal for connecting output '" << output_name << "' of " << pi.module_name << " proxy '"
                       << proxy_name << "' to input \"" << input_name << "\" of logic '" << logic_name << "':" << endl;
  add_signal(*oss_main[w], sig, bits, sig.length());

  if (pi.trace_identifier != "") {
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Trace signal for connecting output '" << output_name << "' of " << pi.module_name << " proxy '"
                         << proxy_name << "' to input \"" << input_name << "\" of logic '" << logic_name << "':" << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << sig << ", \"" << sig << "\");" << endl;
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create transactor for connecting output '" << output_name << "' of " << pi.module_name << " proxy '"
                       << proxy_name << "' to input \"" << input_name << "\" of logic '" << logic_name << "':" << endl;

  if (bits > 1) {
    *oss_main[w] << tab2 << "xtsc_pin2tlm_wire_transactor<" << bits << ", sc_bv<" << bits << "> > "
                         << tran << "(\"" << tran << "\");" << endl;
  }
  else {
    *oss_main[w] << tab2 << "xtsc_pin2tlm_wire_transactor<1, bool> "
                         << tran << "(\"" << tran << "\");" << endl;
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect output '" << output_name << "' of " << pi.module_name << " proxy '" << proxy_name
                       << "' to signal:" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << output_name << "(" << sig << ");" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect transactor to signal:" << endl;
  *oss_main[w] << tab2 << tran << ".m_sc_in(" << sig << ");" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect transactor to input \"" << input_name << "\" of logic '" << logic_name << "':" << endl;
  *oss_main[w] << tab2 << tran << ".m_sc_port(" << logic_name << "->get_input(\"" << input_name << "\"));" << endl;

  li.inputs_connected[input_name] = true;

}



void connect_proxy_lookup_pin(const string& proxy_name, const string& name_prefix, const string& lookup_pin_name) {
  XTSC_TRACE(logger, "enter connect_proxy_lookup_pin()");
  proxy_info&      pi = find_or_infer_proxy(proxy_name);
  lookup_pin_info& li = find_or_infer_lookup_pin(lookup_pin_name);
  confirm_no_master_connected(li);
  XTSC_DEBUG(logger, "connecting proxy '" << proxy_name << "' to lookup_pin '" << lookup_pin_name << "'.");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << pi.module_name << " proxy " << proxy_name << " to lookup_pin " << lookup_pin_name << ":"
                       << endl;

  string prefix(name_prefix);
  if (prefix == "@") {
    // User has not specified the name prefix, so we need to use the default prefix
    prefix = "TIE_" + pi.module_name;
  }

  // Port names
  string out = prefix + "_Out";
  string req = prefix + "_Out_Req";
  string in  = prefix + "_In";
  string rdy = prefix + "_Rdy";

  // Signal names
  string out_s = lookup_pin_name + "_" + out;
  string req_s = lookup_pin_name + "_" + req;
  string in_s  = lookup_pin_name + "_" + in;
  string rdy_s = lookup_pin_name + "_" + rdy;

  // Transactor names
  string out_t  = out_s + "_adapter";
  string req_t  = req_s + "_adapter";
  string in_t   = in_s  + "_adapter";
  string rdy_t  = rdy_s + "_adapter";

  u32 abits = li.parms.get_u32("address_bit_width");
  u32 dbits = li.parms.get_u32("data_bit_width");

  add_proxy_io(pi, out, abits, false, true, false);
  add_proxy_io(pi, req,     1, false, true, false);
  add_proxy_io(pi, in,  dbits, true,  true, false);
  if (li.parms.get_bool("has_ready")) {
  add_proxy_io(pi, rdy,     1, true,  true, false);
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create adapters for connecting " << pi.module_name << " proxy '" << proxy_name << "' and lookup_pin '"
                       << lookup_pin_name << "':" << endl;
  u32 nc = out_t.length();
  add_adapter(*oss_main[w], out_t, abits, true,  nc);
  add_adapter(*oss_main[w], req_t,     1, true,  nc);
  add_adapter(*oss_main[w], in_t,  dbits, false, nc);
  if (li.parms.get_bool("has_ready")) {
  add_adapter(*oss_main[w], rdy_t,     1, false, nc);
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create signals for connecting " << pi.module_name << " proxy '" << proxy_name << "' and lookup_pin '"
                       << lookup_pin_name << "':" << endl;
  nc = out_s.length();
  add_signal(*oss_main[w], out_s, abits, nc);
  add_signal(*oss_main[w], req_s,     1, nc);
  add_signal(*oss_main[w], in_s,  dbits, nc);
  if (li.parms.get_bool("has_ready")) {
  add_signal(*oss_main[w], rdy_s,     1, nc);
  }

  if (pi.trace_identifier != "") {
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Trace signals for connecting " << pi.module_name << " proxy '" << proxy_name << "' and lookup_pin '"
                         << lookup_pin_name << "':" << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << out_s << ", \"" << out_s << "\");" << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << req_s << ", \"" << req_s << "\");" << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << in_s << " , \"" << in_s << "\" );" << endl;
    if (li.parms.get_bool("has_ready")) {
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << rdy_s << ", \"" << rdy_s << "\");" << endl;
    }
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect lookup_pin '" << lookup_pin_name << "' to adapters:" << endl;
  *oss_main[w] << tab2 << lookup_pin_name << "->m_address(" << out_t << ".m_sc_export);" << endl;
  *oss_main[w] << tab2 << lookup_pin_name << "->m_req    (" << req_t << ".m_sc_export);" << endl;
  *oss_main[w] << tab2 << lookup_pin_name << "->m_data   (" << in_t << " .m_sc_export);" << endl;
  if (li.parms.get_bool("has_ready")) {
  *oss_main[w] << tab2 << lookup_pin_name << "->m_ready  (" << rdy_t << ".m_sc_export);" << endl;
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect adapters to signals:" << endl;
  *oss_main[w] << tab2 << out_t << ".m_sc_in (" << out_s << ");" << endl;
  *oss_main[w] << tab2 << req_t << ".m_sc_in (" << req_s << ");" << endl;
  *oss_main[w] << tab2 << in_t  << " .m_sc_out("<< in_s << " );" << endl;
  if (li.parms.get_bool("has_ready")) {
  *oss_main[w] << tab2 << rdy_t << ".m_sc_out(" << rdy_s << ");" << endl;
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << pi.module_name << " proxy '" << proxy_name << "' to signals:" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << out << "(" << out_s << ");" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << req << "(" << req_s << ");" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << in << " (" << in_s << " );" << endl;
  if (li.parms.get_bool("has_ready")) {
  *oss_main[w] << tab2 << proxy_name << "." << rdy << "(" << rdy_s << ");" << endl;
  }

  li.master_connected = true;
}



void connect_proxy_memory_pin(const string& proxy_name, const string& name_prefix, u32 port, const string& memory_name) {
  XTSC_TRACE(logger, "enter connect_proxy_memory_pin()");
  memory_pin_info& mi = find_or_infer_memory_pin(memory_name);
  proxy_info&      pi = find_or_infer_proxy(proxy_name);
  if ((port >= mi.num_ports) || mi.master_connected[port]) {
    ostringstream oss;
    oss << "<MemoryPort> #" << port << " of memory_pin '" << mi.name << "' is out-or-range or already connected in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  XTSC_DEBUG(logger, "connecting proxy '" << proxy_name << "' to memory_pin '" << memory_name << "'.");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << pi.module_name << " proxy " << proxy_name << " to memory_pin " << memory_name << ":"
                       << endl;
  u32 lo_port = port;
  u32 hi_port = mi.num_ports - 1;
  for (u32 p=lo_port; p<=hi_port && !mi.master_connected[p]; ++p) {
    connect_module_to_proxy("memory_pin", *mi.p_memory_pin, memory_name, p, name_prefix, pi);
    mi.master_connected[p] = true;
    pi.connected_memory_pin_list.push_back(make_pair(&mi, p));
  }
}



void connect_proxy_mmio(const string& proxy_name, const string& output_name, const string& input_name, const string& mmio_name) {
  XTSC_TRACE(logger, "enter connect_proxy_mmio()");
  proxy_info& pi = find_or_infer_proxy(proxy_name);
  mmio_info&  mi = find_or_infer_mmio(mmio_name);
  XTSC_DEBUG(logger, "connecting output '" << output_name << "' of proxy '" << proxy_name << "' to input \"" << input_name <<
                      "\" of mmio '" << mmio_name << "'.");
  confirm_input_exists_and_is_not_connected(mi, input_name);

  string sig  = mmio_name + "_" + input_name;
  string tran = sig + "_transactor";

  u32 bits = mi.p_mmio->get_bit_width(input_name.c_str());

  add_proxy_io(pi, output_name, bits, false, true, false);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create signal for connecting output '" << output_name << "' of " << pi.module_name << " proxy '"
                       << proxy_name << "' to input \"" << input_name << "\" of mmio '" << mmio_name << "':" << endl;
  add_signal(*oss_main[w], sig, bits, sig.length());

  if (pi.trace_identifier != "") {
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Trace signal for connecting output '" << output_name << "' of " << pi.module_name << " proxy '"
                         << proxy_name << "' to input \"" << input_name << "\" of mmio '" << mmio_name << "':" << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << sig << ", \"" << sig << "\");" << endl;
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create transactor for connecting output '" << output_name << "' of " << pi.module_name << " proxy '"
                       << proxy_name << "' to input \"" << input_name << "\" of mmio '" << mmio_name << "':" << endl;

  if (bits > 1) {
    *oss_main[w] << tab2 << "xtsc_pin2tlm_wire_transactor<" << bits << ", sc_bv<" << bits << "> > "
                         << tran << "(\"" << tran << "\");" << endl;
  }
  else {
    *oss_main[w] << tab2 << "xtsc_pin2tlm_wire_transactor<1, bool> "
                         << tran << "(\"" << tran << "\");" << endl;
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect output '" << output_name << "' of " << pi.module_name << " proxy '" << proxy_name
                       << "' to signal:" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << output_name << "(" << sig << ");" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect transactor to signal:" << endl;
  *oss_main[w] << tab2 << tran << ".m_sc_in(" << sig << ");" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect transactor to input \"" << input_name << "\" of mmio '" << mmio_name << "':" << endl;
  *oss_main[w] << tab2 << tran << ".m_sc_port(" << mmio_name << "->get_input(\"" << input_name << "\"));" << endl;

  mi.inputs_connected[input_name] = true;

}



void connect_proxy_pin2tlm(const string& proxy_name, const string& name_prefix, u32 port, const string& pin2tlm_name) {
  XTSC_TRACE(logger, "enter connect_proxy_pin2tlm()");
  pin2tlm_info& ti = find_or_infer_pin2tlm(pin2tlm_name);
  proxy_info&   pi = find_or_infer_proxy(proxy_name);
  if ((port >= ti.num_ports) || ti.master_connected[port]) {
    ostringstream oss;
    oss << "<MemoryPort> #" << port << " of pin2tlm '" << ti.name << "' is out-or-range or already connected in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  XTSC_DEBUG(logger, "connecting proxy '" << proxy_name << "' to pin2tlm '" << pin2tlm_name << "'.");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << pi.module_name << " proxy " << proxy_name << " to pin2tlm " << pin2tlm_name << ":"
                       << endl;
  u32 lo_port = port;
  u32 hi_port = ti.num_ports - 1;
  for (u32 p=lo_port; p<=hi_port && !ti.master_connected[p]; ++p) {
    connect_module_to_proxy("pin2tlm", *ti.p_pin2tlm, pin2tlm_name, p, name_prefix, pi);
    ti.master_connected[p] = true;
    pi.connected_pin2tlm_list.push_back(make_pair(&ti, p));
  }
}



void connect_proxy_queue_pin(const string& proxy_name, const string& name_prefix, const string& queue_pin_name) {
  XTSC_TRACE(logger, "enter connect_proxy_queue_pin()");
  proxy_info&     pi = find_or_infer_proxy(proxy_name);
  queue_pin_info& qi = find_or_infer_queue_pin(queue_pin_name);
  confirm_no_producer_connected(qi);
  XTSC_DEBUG(logger, "connecting proxy '" << proxy_name << "' to queue_pin '" << queue_pin_name << "'.");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << pi.module_name << " proxy " << proxy_name << " to queue_pin " << queue_pin_name << ":"
                       << endl;

  string prefix(name_prefix);
  if (prefix == "@") {
    // User has not specified the name prefix, so we need to use the default prefix
    prefix = "TIE_" + pi.module_name;
  }

  // Port names
  string data = prefix + "";
  string push = prefix + "_PushReq";
  string full = prefix + "_Full";

  // Signal names
  string data_s = queue_pin_name + "_" + data;
  string push_s = queue_pin_name + "_" + push;
  string full_s = queue_pin_name + "_" + full;

  // Transactor names
  string data_t = data_s + "_adapter";
  string push_t = push_s + "_adapter";
  string full_t = full_s + "_adapter";

  u32 bits = qi.parms.get_u32("bit_width");

  add_proxy_io(pi, data, bits, false, true, false);
  add_proxy_io(pi, push,    1, false, true, false);
  add_proxy_io(pi, full,    1, true,  true, false);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create adapters for connecting " << pi.module_name << " proxy '" << proxy_name << "' and queue_pin '"
                       << queue_pin_name << "':" << endl;
  u32 nc = push_t.length();
  add_adapter(*oss_main[w], data_t, bits, true,  nc);
  add_adapter(*oss_main[w], push_t,    1, true,  nc);
  add_adapter(*oss_main[w], full_t,    1, false, nc);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create signals for connecting " << pi.module_name << " proxy '" << proxy_name << "' and queue_pin '"
                       << queue_pin_name << "':" << endl;
  nc = push_s.length();
  add_signal(*oss_main[w], data_s, bits, nc);
  add_signal(*oss_main[w], push_s,    1, nc);
  add_signal(*oss_main[w], full_s,    1, nc);

  if (pi.trace_identifier != "") {
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Trace signals for connecting " << pi.module_name << " proxy '" << proxy_name << "' and queue_pin '"
                         << queue_pin_name << "':" << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << data_s << ",         \"" << data_s << "\"        );"
                         << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << push_s <<         ", \"" << push_s <<         "\");"
                         << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << full_s <<      ",    \"" << full_s <<      "\"   );"
                         << endl;
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect queue_pin '" << queue_pin_name << "' to adapters:" << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_data_in(" << data_t << ".        m_sc_export);" << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_push   (" << push_t << ".m_sc_export);"         << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_full   (" << full_t << ".   m_sc_export);"      << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect adapters to signals:" << endl;
  *oss_main[w] << tab2 << data_t << ".        m_sc_in (" << data_s << "        );" << endl;
  *oss_main[w] << tab2 << push_t <<         ".m_sc_in (" << push_s <<         ");" << endl;
  *oss_main[w] << tab2 << full_t <<      ".   m_sc_out(" << full_s <<      "   );" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << pi.module_name << " proxy '" << proxy_name << "' to signals:" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << data  << "        (" << data_s  << "        );" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << push  <<         "(" << push_s  <<         ");" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << full <<       "   (" << full_s <<       "   );" << endl;

  qi.producer_connected = true;
}



void connect_proxy_wire(const string& proxy_name, const string& output_name, const string& wire_name) {
  XTSC_TRACE(logger, "enter connect_proxy_wire()");
  proxy_info& pi = find_or_infer_proxy(proxy_name);
  wire_info&  wi = find_or_infer_wire(wire_name);
  XTSC_DEBUG(logger, "connecting output '" << output_name << "' of proxy '" << proxy_name << "' to wire '" << wire_name << "'.");

  string sig  = proxy_name + "_" + output_name;
  if (output_name != wire_name) {
    sig  += "_" + wire_name;
  }
  string tran = sig + "_transactor";

  u32 bits = wi.parms.get_u32("bit_width");

  add_proxy_io(pi, output_name, bits, false, true, false);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create signal for connecting output '" << output_name << "' of " << pi.module_name << " proxy '"
                       << proxy_name << "' to wire '" << wire_name << "':" << endl;
  add_signal(*oss_main[w], sig, bits, sig.length());

  if (pi.trace_identifier != "") {
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Trace signal for connecting output '" << output_name << "' of " << pi.module_name << " proxy '"
                         << proxy_name << "' to wire '" << wire_name << "':" << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << sig << ", \"" << sig << "\");" << endl;
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create transactor for connecting output '" << output_name << "' of " << pi.module_name << " proxy '"
                       << proxy_name << "' to wire '" << wire_name << "':" << endl;

  if (bits > 1) {
    *oss_main[w] << tab2 << "xtsc_pin2tlm_wire_transactor<" << bits << ", sc_bv<" << bits << "> > "
                         << tran << "(\"" << tran << "\");" << endl;
  }
  else {
    *oss_main[w] << tab2 << "xtsc_pin2tlm_wire_transactor<1, bool> "
                         << tran << "(\"" << tran << "\");" << endl;
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect output '" << output_name << "' of " << pi.module_name << " proxy '" << proxy_name
                       << "' to signal:" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << output_name << "(" << sig << ");" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect transactor to signal:" << endl;
  *oss_main[w] << tab2 << tran << ".m_sc_in(" << sig << ");" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect transactor to wire '" << wire_name << "':" << endl;
  *oss_main[w] << tab2 << tran << ".m_sc_port(*" << wire_name << ");" << endl;

  wi.source_connected = true;

}



void connect_queue_consumer(const string& queue_name, u32 consumer_port, const string& consumer_name) {
  XTSC_TRACE(logger, "enter connect_queue_consumer()");
  queue_info&    qi = find_or_infer_queue(queue_name);
  consumer_info& ci = find_or_infer_consumer(consumer_name);
  confirm_no_consumer_connected(qi, consumer_port);
  confirm_no_queue_connected(ci);
  XTSC_DEBUG(logger, "connecting consumer port " << consumer_port << " of queue '" << queue_name <<
                     "' to consumer '" << consumer_name << "'.");
  qi.p_queue->connect(*ci.p_consumer, consumer_port);
  qi.consumer_connected[consumer_port] = true;
  ci.queue_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << queue_name << " to " << consumer_name << endl;
  *oss_main[w] << tab2 << queue_name << "->connect(*" << consumer_name << ", " << consumer_port << ");" << endl;
}



void connect_queue_pin_consumer(const string& queue_pin_name, const string& consumer_name) {
  XTSC_TRACE(logger, "enter connect_queue_pin_consumer()");
  queue_pin_info& qi = find_or_infer_queue_pin(queue_pin_name);
  consumer_info&  ci = find_or_infer_consumer(consumer_name);
  confirm_no_consumer_connected(qi);
  confirm_no_queue_connected(ci);
  XTSC_DEBUG(logger, "connecting queue_pin '" << queue_pin_name << "' to consumer '" << consumer_name << "'.");
  ci.p_consumer->m_data (qi.data_out);
  ci.p_consumer->m_pop  (qi.pop);
  ci.p_consumer->m_empty(qi.empty);
  qi.bind_consumer_signals();
  qi.consumer_connected = true;
  ci.queue_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create signals for " << queue_pin_name << endl;
  *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << queue_pin_name << "__data_out" << " = new xtsc_signal_sc_bv_base(\""
                       << queue_pin_name << "__data_out\", " << qi.width1 << ");" << endl;
  *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << queue_pin_name << "__pop     " << " = new xtsc_signal_sc_bv_base(\""
                       << queue_pin_name << "__pop\",      1);" << endl;
  *oss_main[w] << tab2 << "xtsc_signal_sc_bv_base *" << queue_pin_name << "__empty   " << " = new xtsc_signal_sc_bv_base(\""
                       << queue_pin_name << "__empty\",    1);" << endl;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect signals to " << queue_pin_name << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_data_out(*" << queue_pin_name << "__data_out);" << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_pop     (*" << queue_pin_name << "__pop     );" << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_empty   (*" << queue_pin_name << "__empty   );" << endl;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << consumer_name << " to " << queue_pin_name << " signals " << endl;
  *oss_main[w] << tab2 << consumer_name << "->m_data (*" << queue_pin_name << "__data_out);" << endl;
  *oss_main[w] << tab2 << consumer_name << "->m_pop  (*" << queue_pin_name << "__pop     );" << endl;
  *oss_main[w] << tab2 << consumer_name << "->m_empty(*" << queue_pin_name << "__empty   );" << endl;
}



void connect_queue_pin_proxy(const string& queue_pin_name, const string& name_prefix, const string& proxy_name) {
  XTSC_TRACE(logger, "enter connect_queue_pin_proxy()");
  queue_pin_info& qi = find_or_infer_queue_pin(queue_pin_name);
  proxy_info&     pi = find_or_infer_proxy(proxy_name);
  confirm_no_consumer_connected(qi);
  XTSC_DEBUG(logger, "connecting queue_pin '" << queue_pin_name << "' to proxy '" << proxy_name << "'.");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect queue_pin " << queue_pin_name << " to " << pi.module_name << " proxy " << proxy_name << ":"
                       << endl;

  string prefix(name_prefix);
  if (prefix == "@") {
    // User has not specified the name prefix, so we need to use the default prefix
    prefix = "TIE_" + pi.module_name;
  }

  // Port names
  string data  = prefix + "";
  string pop   = prefix + "_PopReq";
  string empty = prefix + "_Empty";

  // Signal names
  string data_s  = queue_pin_name + "_" + data;
  string pop_s   = queue_pin_name + "_" + pop;
  string empty_s = queue_pin_name + "_" + empty;

  // Transactor names
  string data_t  = data_s  + "_adapter";
  string pop_t   = pop_s   + "_adapter";
  string empty_t = empty_s + "_adapter";

  u32 bits = qi.parms.get_u32("bit_width");

  add_proxy_io(pi, data, bits, true,  true, false);
  add_proxy_io(pi, pop,     1, false, true, false);
  add_proxy_io(pi, empty,   1, true,  true, false);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create adapters for connecting queue_pin '" << queue_pin_name << "' and " << pi.module_name
                       << " proxy '" << proxy_name << "':" << endl;
  u32 nc = pop_t.length();
  add_adapter(*oss_main[w], data_t, bits, false, nc);
  add_adapter(*oss_main[w], pop_t,     1, true,  nc);
  add_adapter(*oss_main[w], empty_t,   1, false, nc);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create signals for connecting queue_pin '" << queue_pin_name << "' and " << pi.module_name << " proxy '"
                       << proxy_name << "':" << endl;
  nc = pop_s.length();
  add_signal(*oss_main[w], data_s, bits, nc);
  add_signal(*oss_main[w], pop_s,    1, nc);
  add_signal(*oss_main[w], empty_s,    1, nc);

  if (pi.trace_identifier != "") {
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Trace signals for connecting queue_pin '" << queue_pin_name << "' and " << pi.module_name
                         << " proxy '" << proxy_name << "':" << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << data_s << ",        \"" << data_s << "\"       );"
                         << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << pop_s <<         ", \"" << pop_s <<         "\");"
                         << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << empty_s <<      ",  \"" << empty_s <<      "\" );"
                         << endl;
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect queue_pin '" << queue_pin_name << "' to adapters;" << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_data_out(" << data_t  << ".       m_sc_export);" << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_pop     (" << pop_t   << ".m_sc_export);"         << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_empty   (" << empty_t << ". m_sc_export);"      << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect adapters to signals:" << endl;
  *oss_main[w] << tab2 << data_t  << ".       m_sc_out(" << data_s  << "       );" << endl;
  *oss_main[w] << tab2 << pop_t   << ".m_sc_in ("        << pop_s   <<        ");" << endl;
  *oss_main[w] << tab2 << empty_t << ". m_sc_out("       << empty_s <<       " );" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << pi.module_name << " proxy '" << proxy_name << "' to signals:" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << data  << "       (" << data_s  << "       );" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << pop   <<        "(" << pop_s   <<        ");" << endl;
  *oss_main[w] << tab2 << proxy_name << "." << empty <<       " (" << empty_s <<       " );" << endl;

  qi.consumer_connected = true;
}



void connect_queue_pin_wrapper(const string& queue_pin_name, const string& name_prefix) {
  XTSC_TRACE(logger, "enter connect_queue_pin_wrapper()");
  queue_pin_info& qi = find_or_infer_queue_pin(queue_pin_name);
  confirm_a_wrapper_is_defined();
  confirm_no_consumer_connected(qi);
  XTSC_DEBUG(logger, "connecting queue_pin '" << queue_pin_name << "' to wrapper '" << p_current_wrapper->name << "'.");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect queue_pin " << queue_pin_name << " to wrapper:" << endl;

  // Port names
  string data  = name_prefix + "";
  string pop   = name_prefix + "_PopReq";
  string empty = name_prefix + "_Empty";

  // Transactor names
  string data_t   = data  + "_adapter";
  string pop_t    = pop   + "_adapter";
  string empty_t  = empty + "_adapter";

  u32 bits = qi.parms.get_u32("bit_width");

  add_wrapper_io(data, bits, false, true);
  add_wrapper_io(pop,     1, true,  true);
  add_wrapper_io(empty,   1, false, true);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create adapters for connecting queue_pin '" << queue_pin_name << "' and wrapper:" << endl;
  u32 nc = pop_t.length();
  add_adapter(*oss_main[w], data_t,  bits, false, nc);
  add_adapter(*oss_main[w], pop_t,      1, true,  nc);
  add_adapter(*oss_main[w], empty_t,    1, false, nc);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect queue_pin '" << queue_pin_name << "' to adapters;" << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_data_out(" << data_t  << "->       m_sc_export);" << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_pop     (" << pop_t   << "->m_sc_export);"        << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_empty   (" << empty_t << "-> m_sc_export);"       << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect adapters to wrapper:" << endl;
  *oss_main[w] << tab2 << data_t  << "->       m_sc_out(" << data  << "       );" << endl;
  *oss_main[w] << tab2 << pop_t   <<        "->m_sc_in (" << pop   <<        ");" << endl;
  *oss_main[w] << tab2 << empty_t <<       "-> m_sc_out(" << empty <<       " );" << endl;

  qi.consumer_connected = true;
}



void connect_router_arbiter(const string& router_name, u32 router_port, u32 arbiter_port, const string& arbiter_name) {
  XTSC_TRACE(logger, "enter connect_router_arbiter()");
  router_info&  ri = find_or_infer_router(router_name);
  arbiter_info& ai = find_or_infer_arbiter(arbiter_name);
  confirm_valid_port(ri, router_port);
  confirm_valid_port(ai, arbiter_port);
  XTSC_DEBUG(logger, "connecting master router '" << router_name << "' port " << router_port << " to slave arbiter '" << 
                     arbiter_name << "' port " << arbiter_port << ".");
  ai.p_arbiter->connect(*ri.p_router, router_port, arbiter_port);
  ai.num_master_connected += 1;
  ri.num_slave_connected  += 1;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << router_name << " to " << arbiter_name << endl;
  *oss_main[w] << tab2 << arbiter_name << "->connect(*" << router_name << ", " << router_port << ", " << arbiter_port << ");" << endl;
}



void connect_router_cohctrl(const string& router_name, u32 router_port, u32 cohctrl_port, const string& cohctrl_name) {
  XTSC_TRACE(logger, "enter connect_router_cohctrl()");
  router_info&  ri = find_or_infer_router(router_name);
  cohctrl_info& ci = find_or_infer_cohctrl(cohctrl_name);
  confirm_no_master_connected(ci, cohctrl_port);
  confirm_valid_port(ri, router_port);
  XTSC_DEBUG(logger, "connecting port " << router_port << " of router '" << router_name << "' to port " << cohctrl_port <<
                     " of cohctrl '" << cohctrl_name << "'.");
  ri.p_router->connect(*ci.p_cohctrl, xtsc_cohctrl::PT_CLIENT, cohctrl_port, router_port);
  ci.master_connected[cohctrl_port] = true;
  ri.num_slave_connected += 1;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect port " << router_port << " of " << router_name << " to port " << cohctrl_port
                       << " of "<< cohctrl_name << endl;
  *oss_main[w] << tab2 << router_name << "->connect(*" << cohctrl_name << ", xtsc_cohctrl::PT_CLIENT, " << cohctrl_port << ", "
                       << router_port << ");" << endl;
}



void connect_router_core(const string& router_name, u32 port, const string& port_name, const string& core_name) {
  XTSC_TRACE(logger, "enter connect_router_core()");
  router_info& ri = find_or_infer_router(router_name);
  core_info&   ci = find_or_infer_core(core_name, "");
  confirm_valid_port(ri, port);
  confirm_valid_inbound_name(port_name);
  if (port_name == "snoop") {
    confirm_no_snoop_connected(ci);
    ci.snoop_connected = true;
  }
  else {
    confirm_no_inbound_connected(ci);
    ci.inbound_connected = true;
  }
  XTSC_DEBUG(logger, "connecting router '" << router_name << "' port " << port << " to " << port_name << " of core '" <<
                     core_name << "'.");
  ri.p_router->connect(*ci.p_core, port_name.c_str(), port);
  ri.num_slave_connected += 1;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << router_name << " to " << core_name << endl;
  *oss_main[w] << tab2 << router_name << "->connect(*" << core_name << ", \"" << port_name << "\", " << port << ");" << endl;
}



void connect_router_dma(const string& router_name, u32 router_port, u32 dma_port, const string& dma_name) {
  XTSC_TRACE(logger, "enter connect_router_dma()");
  router_info& ri = find_or_infer_router(router_name);
  dma_info&    di = find_or_infer_dma(dma_name);
  confirm_no_master_connected(di, dma_port);
  confirm_valid_port(ri, router_port);
  XTSC_DEBUG(logger, "connecting master port " << router_port << " of router '" << router_name << "' to slave port " << dma_port <<
                     " of dma '" << dma_name << "'.");
  di.p_dma->connect(*ri.p_router, router_port, dma_port);
  di.master_connected[dma_port] = true;
  ri.num_slave_connected += 1;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << router_name << " to port " << dma_port << " of " << dma_name << endl;
  *oss_main[w] << tab2 << dma_name << "->connect(*" << router_name << ", " << router_port << ", " << dma_port << ");" << endl;
}



void connect_router_memory(const string& router_name, u32 router_port, u32 memory_port, const string& memory_name) {
  XTSC_TRACE(logger, "enter connect_router_memory()");
  router_info& ri = find_or_infer_router(router_name);
  xtsc_core_parms *p_cp = get_newest_core_parms();
  memory_info& mi = find_or_infer_memory(memory_name, p_cp);
  confirm_no_master_connected(mi, memory_port);
  confirm_valid_port(ri, router_port);
  XTSC_DEBUG(logger, "connecting port " << router_port << " of router '" << router_name << "' to port " << memory_port <<
                     " of memory '" << memory_name << "'.");
  mi.p_memory->connect(*ri.p_router, router_port, memory_port);
  mi.master_connected[memory_port] = true;
  ri.num_slave_connected += 1;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << router_name << " to port " << memory_port << " of " << memory_name << endl;
  *oss_main[w] << tab2 << memory_name << "->connect(*" << router_name << ", " << router_port << ", " << memory_port << ");" << endl;
}



void connect_router_memory_trace(const string& router_name, u32 router_port, u32 trace_port, const string& trace_name) {
  XTSC_TRACE(logger, "enter connect_router_memory_trace()");
  router_info&       ri = find_or_infer_router(router_name);
  memory_trace_info& mi = find_or_infer_memory_trace(trace_name);
  confirm_no_master_connected(mi, trace_port);
  confirm_valid_port(ri, router_port);
  XTSC_DEBUG(logger, "connecting port " << router_port << " of router '" << router_name << "' to port " << trace_port <<
                     " of memory_trace '" << trace_name << "'.");
  mi.p_memory_trace->connect(*ri.p_router, router_port, trace_port);
  mi.master_connected[trace_port] = true;
  ri.num_slave_connected += 1;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << router_name << " to port " << trace_port << " of " << trace_name << endl;
  *oss_main[w] << tab2 << trace_name << "->connect(*" << router_name << ", " << router_port << ", " << trace_port << ");" << endl;
}



void connect_router_mmio(const string& router_name, u32 port, const string& mmio_name) {
  XTSC_TRACE(logger, "enter connect_router_mmio()");
  router_info& ri = find_or_infer_router(router_name);
  mmio_info&   mi = find_or_infer_mmio(mmio_name);
  confirm_no_master_connected(mi);
  confirm_valid_port(ri, port);
  XTSC_DEBUG(logger, "connecting router '" << router_name << "' port " << port << " to mmio '" << mmio_name << "'.");
  mi.p_mmio->connect(*ri.p_router, port);
  mi.master_connected = true;
  ri.num_slave_connected += 1;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << router_name << " to " << mmio_name << endl;
  *oss_main[w] << tab2 << mmio_name << "->connect(*" << router_name << ", " << port << ");" << endl;
}



void connect_router_router(const string& master_name, u32 port, const string& slave_name) {
  XTSC_TRACE(logger, "enter connect_router_router()");
  router_info& mi = find_or_infer_router(master_name);
  router_info& si = find_or_infer_router(slave_name);
  confirm_no_master_connected(si);
  confirm_valid_port(mi, port);
  XTSC_DEBUG(logger, "connecting master router '" << master_name << "' port " << port << " to slave router '" << slave_name << "'.");
  si.p_router->connect(*mi.p_router, port);
  si.master_connected = true;
  mi.num_slave_connected += 1;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << master_name << " to " << slave_name << endl;
  *oss_main[w] << tab2 << slave_name << "->connect(*" << master_name << ", " << port << ");" << endl;
}



void connect_router_slave(const string& router_name, u32 port, const string& slave_name) {
  XTSC_TRACE(logger, "enter connect_router_slave()");
  router_info& ri = find_or_infer_router(router_name);
  slave_info&  si = find_or_infer_slave(slave_name);
  confirm_no_master_connected(si);
  confirm_valid_port(ri, port);
  XTSC_DEBUG(logger, "connecting router '" << router_name << "' port " << port << " to slave '" << slave_name << "'.");
  si.p_slave->connect(*ri.p_router, port);
  si.master_connected = true;
  ri.num_slave_connected += 1;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << router_name << " to " << slave_name << endl;
  *oss_main[w] << tab2 << slave_name << "->connect(*" << router_name << ", " << port << ");" << endl;
}



void connect_router_tlm2pin(const string& router_name, u32 router_port, u32 tlm2pin_port, const string& tlm2pin_name) {
  XTSC_TRACE(logger, "enter connect_router_tlm2pin()");
  router_info&  ri = find_or_infer_router(router_name);
  tlm2pin_info& ti = find_or_infer_tlm2pin(tlm2pin_name);
  confirm_no_master_connected(ti, tlm2pin_port);
  confirm_valid_port(ri, router_port);
  XTSC_DEBUG(logger, "connecting router '" << router_name << "' port " << router_port << " to tlm2pin '" << tlm2pin_name <<
                     "' port " << tlm2pin_port << ".");
  ti.p_tlm2pin->connect(*ri.p_router, router_port, tlm2pin_port);
  ti.master_connected[tlm2pin_port] = true;
  ri.num_slave_connected += 1;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << router_name << " to " << tlm2pin_name << endl;
  *oss_main[w] << tab2 << tlm2pin_name << "->connect(*" << router_name << ", " << router_port << ", " << tlm2pin_port << ");"
                       << endl;
}



void connect_signal_core(const string& signal_name, const string& input_pin_name, const string& core_name) {
  XTSC_TRACE(logger, "enter connect_signal_core()");
  core_info& ci = find_or_infer_core(core_name, "");
  if (!ci.p_core->has_input_pin(input_pin_name.c_str())) {
    ostringstream oss;
    oss << "Core '" << core_name << "' has no input pin named '" << input_pin_name;
    if (ci.p_core->has_input_pin(("TIE_" + input_pin_name).c_str())) {
      oss << "' (did you forget to use the \"TIE_\" prefix on the pin name in the connect command): ";
    }
    else {
      oss << "' (did you remember to add it to the core's \"SimPinLevelInterfaces\" parameter): ";
    }
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  u32 input_pin_width1 = ci.p_core->get_pin_bit_width(input_pin_name.c_str());
  signal_info& si = find_or_infer_signal(signal_name, input_pin_width1);
  u32 signal_width1 = si.bit_width;
  if (input_pin_width1 != signal_width1) {
    ostringstream oss;
    oss << "Can't connect input pin '" << input_pin_name << "' with bit width=" << input_pin_width1 << " to signal '"
        << signal_name << "' with bit width=" << signal_width1;
    throw xtsc_exception(oss.str());
  }
  XTSC_DEBUG(logger, "connecting signal '" << signal_name << "' to input pin '" << input_pin_name << "' of core '" <<
                     core_name << ".");
  // Duplicate connections will be detected by SystemC 
  ci.p_core->get_input_pin(input_pin_name.c_str())(*si.p_signal);
  si.sink_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect signal " << signal_name << " to input pin " << input_pin_name << " of core " << core_name
                       << endl;
  *oss_main[w] << tab2 << core_name << "->get_input_pin(\"" << input_pin_name << "\")(*" << signal_name << ");" << endl;
}



void connect_source_cohctrl(const string& source_name, const string& output_name, u32 port, const string& cohctrl_name) {
  XTSC_TRACE(logger, "enter connect_source_cohctrl()");
  source_info&  si = find_or_infer_source(source_name);
  cohctrl_info& ci = find_or_infer_cohctrl(cohctrl_name);
  confirm_output_exists_and_is_not_connected(si, output_name);
  confirm_no_ccon_connected(ci, port);
  XTSC_DEBUG(logger, "connecting output \"" << output_name << "\" of source '" << source_name << "' to m_ccon_exports[" <<
                     port << "] of cohctrl '" << cohctrl_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  si.p_source->connect(*ci.p_cohctrl, port, output_name.c_str());
  si.outputs_connected[output_name] = true;
  ci.ccon_connected[port] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << source_name << " to " << cohctrl_name << endl;
  *oss_main[w] << tab2 << source_name << "->connect(*" << cohctrl_name << ", \"" << port << "\", \"" << output_name << "\");"
                       << endl;
}



void connect_source_core(const string& source_name, const string& output_name, const string& input_name, const string& core_name) {
  XTSC_TRACE(logger, "enter connect_source_core()");
  core_info& ci = find_or_infer_core(core_name, "");
  // Ensure core has such a system-level input
  try { ci.p_core->get_system_input_wire(input_name.c_str()); } catch (xtsc_exception& xe) {
    ostringstream oss;
    oss << xe.what() << endl;
    oss << "Command: ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  map<string,source_info*>::iterator is = source_map[w]->find(source_name);
  if (is == source_map[w]->end()) {
    init_source_parms();
    update_parm_u32(*p_source_parms, "bit_width", ci.p_core->get_sysio_bit_width(input_name.c_str()),
                    oss_source_parms, name_source_parms);
    create_source(source_name);
    is = source_map[w]->find(source_name);
    if (is == source_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred source '" << source_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  source_info& si = *is->second;
  string output((output_name != "") ? output_name.c_str() : si.p_source->get_default_output_name());
  confirm_output_exists_and_is_not_connected(si, output);
  confirm_no_system_input_connected(ci, input_name);
  XTSC_DEBUG(logger, "connecting output '" << output << "' of source '" << source_name << "' to system-level input '" <<
                     input_name << "' of core '" << core_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  si.p_source->connect(*ci.p_core, input_name.c_str(), output.c_str());
  si.outputs_connected[output] = true;
  ci.system_input_connected[input_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << source_name << " to " << core_name << endl;
  *oss_main[w] << tab2 << source_name << "->connect(*" << core_name << ", \"" << input_name << "\", \"" << output << "\");"
                       << endl;
}



void connect_source_distributor(const string& source_name,
                                const string& output_name,
                                const string& input_name,
                                const string& distributor_name)
{
  XTSC_TRACE(logger, "enter connect_source_distributor()");
  source_info&       si = find_or_infer_source(source_name);
  distributor_info&  di = find_or_infer_distributor(distributor_name);
  string output((output_name != "") ? output_name.c_str() : si.p_source->get_default_output_name());
  confirm_output_exists_and_is_not_connected(si, output);
  confirm_input_exists_and_is_not_connected(di, input_name);
  XTSC_DEBUG(logger, "connecting output \"" << output << "\" of source '" << source_name << "' to input '" << input_name <<
                     "' of distributor '" << distributor_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  si.p_source->connect(*di.p_distributor, input_name.c_str(), output.c_str());
  si.outputs_connected[output] = true;
  di.inputs_connected[input_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << source_name << " to " << distributor_name << endl;
  *oss_main[w] << tab2 << source_name << "->connect(*" << distributor_name << ", \"" << input_name << "\", \"" << output
                       << "\");" << endl;
}




void connect_source_logic(const string& source_name, const string& output_name, const string& input_name, const string& logic_name) {
  XTSC_TRACE(logger, "enter connect_source_logic()");
  source_info& si = find_or_infer_source(source_name);
  logic_info&  li = find_or_infer_logic(logic_name);
  string output((output_name != "") ? output_name.c_str() : si.p_source->get_default_output_name());
  XTSC_DEBUG(logger, "connecting output '" << output << "' of source '" << source_name << "' to input \"" << input_name <<
                     "\" of logic '" << logic_name << "'.");
  confirm_input_exists_and_is_not_connected(li, input_name);
  // Bit-width mismatch will be detected by XTSC
  confirm_output_exists_and_is_not_connected(si, output);
  li.p_logic->connect(*si.p_source, output.c_str(), input_name.c_str());
  si.outputs_connected[output] = true;
  li.inputs_connected[input_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << source_name << " to " << logic_name << endl;
  *oss_main[w] << tab2 << logic_name << "->connect(*" << source_name << ", \"" << output << "\", \"" << input_name << "\");"
                       << endl;
}



void connect_source_mmio(const string& source_name, const string& output_name, const string& input_name, const string& mmio_name) {
  XTSC_TRACE(logger, "enter connect_source_mmio()");
  source_info& si = find_or_infer_source(source_name);
  mmio_info&   mi = find_or_infer_mmio(mmio_name);
  string output((output_name != "") ? output_name.c_str() : si.p_source->get_default_output_name());
  XTSC_DEBUG(logger, "connecting output '" << output << "' of source '" << source_name << "' to input \"" << input_name <<
                     "\" of mmio '" << mmio_name << "'.");
  confirm_input_exists_and_is_not_connected(mi, input_name);
  confirm_output_exists_and_is_not_connected(si, output);
  // Bit-width mismatch will be detected by XTSC
  mi.p_mmio->connect(*si.p_source, output.c_str(), input_name.c_str());
  si.outputs_connected[output] = true;
  mi.inputs_connected[input_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << source_name << " to " << mmio_name << endl;
  *oss_main[w] << tab2 << mmio_name << "->connect(*" << source_name << ", \"" << output << "\", \"" << input_name << "\");"
                       << endl;
}



void connect_source_proxy(const string& source_name, const string& output_name, const string& port_name, const string& proxy_name) {
  XTSC_TRACE(logger, "enter connect_source_proxy()");
  source_info& si = find_or_infer_source(source_name);
  proxy_info&  pi = find_or_infer_proxy(proxy_name);
  string output((output_name != "") ? output_name.c_str() : si.p_source->get_default_output_name());
  confirm_output_exists_and_is_not_connected(si, output);
  confirm_pin_level(si);
  string port((port_name != "") ? port_name : output);
  XTSC_DEBUG(logger, "connecting output '" << output << "' of source '" << source_name << "' to proxy '" << proxy_name << "'.");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect source " << source_name << " to " << pi.module_name << " proxy " << proxy_name << ":" << endl;

  string sig  = source_name;
  if (source_name != output) {
    sig  += "_" + output;
  }
  sig  += "_" + port;
  if (port != proxy_name) {
    sig  += "_" + proxy_name;
  }
  string tran = sig + "_adapter";

  u32 bits = si.p_source->get_bit_width(output.c_str());

  add_proxy_io(pi, port, bits, true, true, false);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create adapter for connecting output " << output << " of source '" << source_name << "' to port "
                       << port << " of " << pi.module_name << " proxy '" << proxy_name << "':" << endl;
  add_adapter(*oss_main[w], tran, bits, false, tran.length());

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create signal for connecting output " << output << " of source '" << source_name << "' to port "
                       << port << " of " << pi.module_name << " proxy '" << proxy_name << "':" << endl;
  add_signal(*oss_main[w], sig, bits, sig.length());

  if (pi.trace_identifier != "") {
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Trace signal for connecting output " << output << " of source '" << source_name << "' to port "
                         << port << " of " << pi.module_name << " proxy '" << proxy_name << "':" << endl;
    *oss_main[w] << tab2 << "sc_trace(" << pi.trace_identifier << ", " << sig << ", \"" << sig << "\");" << endl;
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect source '" << source_name << "' to adapter;" << endl;
  *oss_main[w] << tab2 << source_name << "->get_output_pin(\"" << output << "\")(" << tran << ".m_sc_export);" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect adapter to signal:" << endl;
  *oss_main[w] << tab2 << tran << ".m_sc_out(" << sig << ");" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect port " << port << " of " << pi.module_name << " proxy '" << proxy_name << "' to signal:"
                       << endl;
  *oss_main[w] << tab2 << proxy_name << "." << port << "(" << sig << ");" << endl;

  si.outputs_connected[output] = true;
}



void connect_source_signal(const string& source_name, const string& output_name, const string& signal_name) {
  XTSC_TRACE(logger, "enter connect_source_signal()");
  source_info& si = find_or_infer_source(source_name);
  string output((output_name != "") ? output_name.c_str() : si.p_source->get_default_output_name());
  u32 source_width1 = si.p_source->get_bit_width(output.c_str());
  signal_info& sig = find_or_infer_signal(signal_name, source_width1);
  XTSC_DEBUG(logger, "connecting output '" << output << "' of source '" << source_name << "' to signal '" << signal_name << "'.");
  u32 signal_width1 = sig.bit_width;
  if (source_width1 != signal_width1) {
    ostringstream oss;
    oss << "Can't connect output '" << output << "' of source '" << source_name << "' with bit width=" << source_width1
        << " to signal '" << signal_name << "' with bit width=" << signal_width1;
    throw xtsc_exception(oss.str());
  }
  confirm_output_exists_and_is_not_connected(si, output);
  si.p_source->get_output_pin(output.c_str())(*sig.p_signal);
  si.outputs_connected[output] = true;
  sig.source_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << source_name << " to " << signal_name << endl;
  *oss_main[w] << tab2 << source_name << "->get_output_pin(\"" << output << "\")(*" << signal_name << ");" << endl;
}



void connect_source_wire(const string& source_name, const string& output_name, const string& wire_name) {
  XTSC_TRACE(logger, "enter connect_source_wire()");
  source_info& si = find_or_infer_source(source_name);
  wire_info&   wi = find_or_infer_wire(wire_name);
  string output((output_name != "") ? output_name.c_str() : si.p_source->get_default_output_name());
  XTSC_DEBUG(logger, "connecting output '" << output << "' of source '" << source_name << "' to wire '" << wire_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  confirm_output_exists_and_is_not_connected(si, output);
  wi.p_wire->connect(*si.p_source, output.c_str());
  si.outputs_connected[output] = true;
  wi.source_connected = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << source_name << " to " << wire_name << endl;
  *oss_main[w] << tab2 << wire_name << "->connect(*" << source_name << ", \"" << output << "\");" << endl;
}



void connect_source_wrapper(const string& source_name, const string& output_name, const string& wrapper_output_name) {
  XTSC_TRACE(logger, "enter connect_source_wrapper()");
  source_info&  si = find_or_infer_source(source_name);
  confirm_a_wrapper_is_defined();
  string output((output_name != "") ? output_name.c_str() : si.p_source->get_default_output_name());
  confirm_output_exists_and_is_not_connected(si, output);
  confirm_pin_level(si);
  string w_output_name((wrapper_output_name != "") ? wrapper_output_name : output);
  XTSC_DEBUG(logger, "connecting output '" << output << "' of source '" << source_name << "' to wrapper '" <<
                     p_current_wrapper->name << "'.");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect source " << source_name << " to wrapper:"
                       << endl;

  string tran = w_output_name + "_adapter";

  u32 bits = si.p_source->get_bit_width(output.c_str());

  add_wrapper_io(w_output_name, bits, false, true);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create adapter for connecting output " << output << " of source '" << source_name << "' to port "
                       << w_output_name << " of wrapper:" << endl;
  add_adapter(*oss_main[w], tran, bits, false, tran.length());

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect source '" << source_name << "' to adapter;" << endl;
  *oss_main[w] << tab2 << source_name << "->get_output_pin(\"" << output << "\")(" << tran << "->m_sc_export);" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect adapter to wrapper:" << endl;
  *oss_main[w] << tab2 << tran << "->m_sc_out(" << w_output_name << ");" << endl;

  si.outputs_connected[output] = true;
}



void connect_tlm2pin_memory_pin(const string& tlm2pin_name, u32 tlm2pin_port, u32 memory_port, const string& memory_pin_name) {
  XTSC_TRACE(logger, "enter connect_tlm2pin_memory_pin()");
  tlm2pin_info&    ti = find_or_infer_tlm2pin(tlm2pin_name);
  memory_pin_info& mi = find_or_infer_memory_pin(memory_pin_name);
  confirm_no_slave_connected(ti, tlm2pin_port);
  confirm_no_master_connected(mi, memory_port);
  XTSC_DEBUG(logger, "connecting port " << tlm2pin_port << " of tlm2pin '" << tlm2pin_name <<
                     "' to port " << memory_port << " of memory_pin '" << memory_pin_name << "'.");
  u32 num_connected = mi.p_memory_pin->connect(*ti.p_tlm2pin);
  ti.slave_connected[tlm2pin_port] = true;
  mi.master_connected[memory_port] = true;
  *oss_main[w] << endl;
  if (num_connected == 2) {
    ti.slave_connected[tlm2pin_port+1] = true;
    mi.master_connected[memory_port+1] = true;
    *oss_main[w] << tab2 << "// Connect " << tlm2pin_name << " ports " << tlm2pin_port << " and " << (tlm2pin_port+1) << " to "
                         << memory_pin_name << " ports " << memory_port << " and " << (memory_port+1) << endl;
  }
  else {
    *oss_main[w] << tab2 << "// Connect " << tlm2pin_name << " port " << tlm2pin_port << " to "
                         << memory_pin_name << " port " << memory_port << endl;
  }
  *oss_main[w] << tab2 << memory_pin_name << "->connect(*" << tlm2pin_name << ", " << tlm2pin_port << ", " << memory_port << ");"
                       << endl;
}



void connect_tlm2pin_pin2tlm(const string& tlm2pin_name, u32 tlm2pin_port, u32 pin2tlm_port, const string& pin2tlm_name) {
  XTSC_TRACE(logger, "enter connect_tlm2pin_pin2tlm()");
  tlm2pin_info& ti = find_or_infer_tlm2pin(tlm2pin_name);
  pin2tlm_info& pi = find_or_infer_pin2tlm(pin2tlm_name);
  confirm_no_slave_connected(ti, tlm2pin_port);
  confirm_no_master_connected(pi, pin2tlm_port);
  XTSC_DEBUG(logger, "connecting port " << tlm2pin_port << " of tlm2pin '" << tlm2pin_name <<
                     "' to port " << pin2tlm_port << " of pin2tlm '" << pin2tlm_name << "'.");
  u32 num_connected = pi.p_pin2tlm->connect(*ti.p_tlm2pin);
  ti.slave_connected[tlm2pin_port] = true;
  pi.master_connected[pin2tlm_port] = true;
  *oss_main[w] << endl;

  if (num_connected == 2) {
    ti.slave_connected[tlm2pin_port+1] = true;
    pi.master_connected[pin2tlm_port+1] = true;
    *oss_main[w] << tab2 << "// Connect " << tlm2pin_name << " ports " << tlm2pin_port << " and " << (tlm2pin_port+1) << " to "
                         << pin2tlm_name << " ports " << pin2tlm_port << " and " << (pin2tlm_port+1) << endl;
  }
  else {
    *oss_main[w] << tab2 << "// Connect " << tlm2pin_name << " port " << tlm2pin_port << " to "
                         << pin2tlm_name << " port " << pin2tlm_port << endl;
  }
  *oss_main[w] << tab2 << pin2tlm_name << "->connect(*" << tlm2pin_name << ", " << tlm2pin_port << ", " << pin2tlm_port << ");"
                       << endl;
}



void connect_tlm2pin_proxy(const string& tlm2pin_name, u32 port, const string& name_prefix, const string& proxy_name) {
  XTSC_TRACE(logger, "enter connect_tlm2pin_proxy()");
  tlm2pin_info& ti = find_or_infer_tlm2pin(tlm2pin_name);
  proxy_info&   pi = find_or_infer_proxy(proxy_name);
  if ((port >= ti.num_ports) || ti.slave_connected[port]) {
    ostringstream oss;
    oss << "<MemoryPort> #" << port << " of tlm2pin '" << ti.name << "' is out-or-range or already connected in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  XTSC_DEBUG(logger, "connecting tlm2pin '" << tlm2pin_name << "' to proxy '" << proxy_name << "'.");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect tlm2pin " << tlm2pin_name << " to " << pi.module_name << " proxy " << proxy_name << ":" << endl;
  u32 lo_port = port;
  u32 hi_port = ti.num_ports - 1;
  for (u32 p=lo_port; p<=hi_port && !ti.slave_connected[p]; ++p) {
    connect_module_to_proxy("tlm2pin", *ti.p_tlm2pin, tlm2pin_name, p, name_prefix, pi);
    ti.slave_connected[p] = true;
    pi.connected_tlm2pin_list.push_back(make_pair(&ti, p));
  }
}



void connect_tlm2pin_wrapper(const string& tlm2pin_name, u32 port, const string& name_prefix) {
  XTSC_TRACE(logger, "enter connect_tlm2pin_wrapper()");
  tlm2pin_info& ti = find_or_infer_tlm2pin(tlm2pin_name);
  confirm_a_wrapper_is_defined();
  wrapper_info& wi = *p_current_wrapper;
  if ((port >= ti.num_ports) || ti.slave_connected[port]) {
    ostringstream oss;
    oss << "<MemoryPort> #" << port << " of tlm2pin '" << ti.name << "' is out-or-range or already connected in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  XTSC_DEBUG(logger, "connecting tlm2pin '" << tlm2pin_name << "' to wrapper '" << p_current_wrapper->name << "'.");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect tlm2pin " << tlm2pin_name << " to wrapper:" << endl;
  u32 lo_port = port;
  u32 hi_port = ti.num_ports - 1;
  for (u32 p=lo_port; p<=hi_port && !ti.slave_connected[p]; ++p) {
    connect_module_to_wrapper("tlm2pin", *ti.p_tlm2pin, tlm2pin_name, name_prefix, p);
    ti.slave_connected[p] = true;
    wi.connected_tlm2pin_list.push_back(make_pair(&ti, p));
  }
}



void connect_wire_core(const string& wire_name, const string& tie_name, const string& core_name) {
  XTSC_TRACE(logger, "enter connect_wire_core()");
  core_info& ci = find_or_infer_core(core_name, "");
  // Ensure core has such an import wire
  try { ci.p_core->get_import_wire(tie_name.c_str()); } catch (xtsc_exception& xe) {
    ostringstream oss;
    oss << xe.what() << endl;
    oss << "Command: ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  map<string,wire_info*>::iterator iw = wire_map[w]->find(wire_name);
  if (iw == wire_map[w]->end()) {
    init_wire_parms();
    update_parm_u32(*p_wire_parms, "bit_width", ci.p_core->get_tie_bit_width(tie_name.c_str()), oss_wire_parms, name_wire_parms);
    create_wire(wire_name, "");
    iw = wire_map[w]->find(wire_name);
    if (iw == wire_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred wire '" << wire_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  confirm_no_import_wire_connected(ci, tie_name);
  XTSC_DEBUG(logger, "connecting wire '" << wire_name << "' to TIE import wire '" << tie_name <<
                     "' of core '" << core_name << "'.");
  // Bit-width mismatch will be detected by XTSC
  iw->second->p_wire->connect(*ci.p_core, tie_name.c_str());
  iw->second->sink_connected = true;
  ci.import_wire_connected[tie_name] = true;
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect " << wire_name << " to " << core_name << endl;
  *oss_main[w] << tab2 << wire_name << "->connect(*" << core_name << ", \"" << tie_name << "\");" << endl;
}



void connect_wrapper_cohctrl(const string& input_name, u32 cohctrl_port, const string& cohctrl_name) {
  XTSC_TRACE(logger, "enter connect_wrapper_cohctrl()");
  confirm_a_wrapper_is_defined();
  cohctrl_info& ci = find_or_infer_cohctrl(cohctrl_name);
  XTSC_DEBUG(logger, "connecting input '" << input_name << "' of wrapper '" << p_current_wrapper->name << "' to m_ccon_exports[" <<
                     cohctrl_port << "] of cohctrl '" << cohctrl_name << "'.");
  confirm_no_ccon_connected(ci, cohctrl_port);

  string tran = input_name + "_transactor";

  add_wrapper_io(input_name, 1, true, true);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create transactor for connecting input '" << input_name << "' of wrapper to m_ccon_exports["
                       << cohctrl_port << "] of cohctrl '" << cohctrl_name << "':" << endl;
  string type("xtsc_pin2tlm_wire_transactor<1, bool>");
  *oss_main[w] << tab2 << type << " *" << tran << " = new " << endl;
  *oss_main[w] << tab2 << type << "(\"" << tran << "\"" << ");" << endl;
  *oss_main[w] << endl;

  *oss_main[w] << tab2 << "// Connect input '" << input_name << "' of wrapper to transactor:" << endl;
  *oss_main[w] << tab2 << tran << "->m_sc_in(" << input_name << ");" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect transactor to m_ccon_exports[" << cohctrl_port << "] of cohctrl '" << cohctrl_name << "':"
                       << endl;
  *oss_main[w] << tab2 << tran << "->m_sc_port(*" << cohctrl_name << "->m_ccon_exports[" << cohctrl_port << "]);" << endl;

  ci.ccon_connected[cohctrl_port] = true;

}



void connect_wrapper_consumer(const string& name_prefix, const string& consumer_name) {
  XTSC_TRACE(logger, "enter connect_wrapper_consumer()");
  confirm_a_wrapper_is_defined();
  consumer_info& ci = find_or_infer_consumer(consumer_name);
  confirm_no_queue_connected(ci);
  confirm_pin_level(ci);
  XTSC_DEBUG(logger, "connecting wrapper '" << p_current_wrapper->name << "' to consumer '" << consumer_name << "'.");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect wrapper to consumer " << consumer_name << ":"
                       << endl;

  // Port names
  string data  = name_prefix + "";
  string pop   = name_prefix + "_PopReq";
  string empty = name_prefix + "_Empty";

  // Transactor names
  string data_t   = data  + "_adapter";
  string pop_t    = pop   + "_adapter";
  string empty_t  = empty + "_adapter";

  u32 bits = ci.parms.get_u32("bit_width");

  add_wrapper_io(data, bits, true,  true);
  add_wrapper_io(pop,     1, false, true);
  add_wrapper_io(empty,   1, true,  true);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create adapters for connecting wrapper and consumer '" << consumer_name << "':" << endl;
  u32 nc = pop_t.length();
  add_adapter(*oss_main[w], data_t,  bits, true,  nc);
  add_adapter(*oss_main[w], pop_t,      1, false, nc);
  add_adapter(*oss_main[w], empty_t,    1, true,  nc);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect consumer '" << consumer_name << "' to adapters:" << endl;
  *oss_main[w] << tab2 << consumer_name << "->m_data (" << data_t  << "->       m_sc_export);" << endl;
  *oss_main[w] << tab2 << consumer_name << "->m_pop  (" << pop_t   << "->m_sc_export);"        << endl;
  *oss_main[w] << tab2 << consumer_name << "->m_empty(" << empty_t << "-> m_sc_export);"       << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect adapters to wrapper:" << endl;
  *oss_main[w] << tab2 << data_t  << "->       m_sc_in (" << data  << "       );" << endl;
  *oss_main[w] << tab2 << pop_t   <<        "->m_sc_out(" << pop   <<        ");" << endl;
  *oss_main[w] << tab2 << empty_t <<       "-> m_sc_in (" << empty <<       " );" << endl;

  ci.queue_connected = true;
}



// Connect pin-level TIE input queue, TIE import wire, or system-level input interface to wrapper
void connect_wrapper_core(const string& name_prefix, const string& iface, const string& core_name) {
  XTSC_TRACE(logger, "enter connect_wrapper_core()");
  confirm_a_wrapper_is_defined();
  core_info& ci = find_or_infer_core(core_name, "");
  XTSC_DEBUG(logger, "connecting wrapper '" << p_current_wrapper->name << "' to core '" << core_name << "'.");
  if (!ci.p_core->has_pin_level_interface(iface.c_str())) {
    ostringstream oss;
    oss << "core '" << core_name << "' has no pin-level interface named '" << iface << "': ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }

  vector<string> pins;
  string type;

  if (ci.p_core->has_pin_level_input_queue(iface.c_str())) {
    confirm_no_input_queue_connected(ci, iface);
    ci.input_queue_connected[iface] = true;
    type = "TIE input queue";
    pins.push_back("TIE_" + iface);
    pins.push_back("TIE_" + iface + "_PopReq");
    pins.push_back("TIE_" + iface + "_Empty");
  }
  else if (ci.p_core->has_pin_level_import_wire(iface.c_str())) {
    confirm_no_import_wire_connected(ci, iface);
    ci.import_wire_connected[iface] = true;
    type = "TIE import wire";
    pins.push_back("TIE_" + iface);
  }
  else if (ci.p_core->has_input_pin(iface.c_str())) {
    confirm_no_system_input_connected(ci, iface);
    ci.system_input_connected[iface] = true;
    type = "system-level input";
    pins.push_back(iface);
  }
  else {
    ostringstream oss;
    oss << "core '" << core_name << "' has no pin-level input queue, import wire, or system-level input interface named '"
        << iface << "': ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect wrapper to " << type << " \"" << iface
                       << "\" of core " << ci.name << ":" << endl;

  ostringstream tran, tran2core, wrapper2tran;

  u32 nc = 0;
  for (vector<string>::const_iterator ip = pins.begin(); ip != pins.end(); ++ip) {
    nc = max(nc, ip->length());
  }

  for (vector<string>::const_iterator ip = pins.begin(); ip != pins.end(); ++ip) {

    string pname(*ip);                          // Xtensa pin name
    string wname(name_prefix + pname);          // wrapper port name
    string aname(wname + "_adapter");           // adapter name

    u32    bits(ci.p_core->get_pin_bit_width(pname.c_str()));
    bool   input(ci.p_core->has_input_pin(pname.c_str()));

    add_wrapper_io(wname, bits, input, true);

    const char *spc = space(nc - min(nc, ip->length()));

    add_adapter(tran, aname, bits, input, nc+8);

    tran2core << tab2 << ci.name << "->" << (input ? "get_input_pin " : "get_output_pin") << "(\"" << pname << "\"" << spc << ")("
              << aname << spc << "->m_sc_export);" << endl;

    wrapper2tran << tab2 << aname << spc << "->m_sc_" << (input ? "in " : "out") << "(" << wname << spc << ");" << endl;
  }

  string s(pins.size() == 1 ? "" : "s");

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create adapter" << s << " for connecting wrapper and "
                       << type << " \"" << iface << "\" of core " << ci.name << ":" << endl;
  *oss_main[w] << tran.str();

  if (pins.size() > 1) {
    *oss_main[w] << endl;
  }
  *oss_main[w] << tab2 << "// Connect wrapper to adapter" << s << ":" << endl;
  *oss_main[w] << wrapper2tran.str();

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect adapter" << s << " to " << type << " \"" << iface << "\" of core " << ci.name << ":" << endl;
  *oss_main[w] << tran2core.str();

}



void connect_wrapper_loader(const string& name_prefix, const string& loader_name) {
  XTSC_TRACE(logger, "enter connect_wrapper_loader()");
  confirm_a_wrapper_is_defined();
  loader_info& li = find_or_infer_loader(loader_name);
  XTSC_DEBUG(logger, "connecting wrapper '" << p_current_wrapper->name << "' to loader '" << loader_name << "'.");

  confirm_pin_level(li);

  bool something_connected = false;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect wrapper to loader " << loader_name << ":" << endl;

  if (!li.producer_connected) {
    something_connected = true;
    XTSC_DEBUG(logger, "connecting wrapper '" << p_current_wrapper->name << "' to command queue of loader '" << loader_name << "'.");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Command Queue:  Connect wrapper to loader " << loader_name << ":" << endl;

    // Port names
    string data = name_prefix + "QueueDataIn";
    string push = name_prefix + "Push";
    string full = name_prefix + "Full";

    // Transactor names
    string data_t  = data + "_adapter";
    string push_t  = push + "_adapter";
    string full_t  = full + "_adapter";

    u32 bits = 32;

    add_wrapper_io(data, bits, true,  true);
    add_wrapper_io(push,    1, true,  true);
    add_wrapper_io(full,    1, false, true);

    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Command Queue: Create adapters for connecting wrapper and loader '" << loader_name << "':" << endl;
    u32 nc = data_t.length();
    add_adapter(*oss_main[w], data_t, bits, true,  nc);
    add_adapter(*oss_main[w], push_t,    1, true,  nc);
    add_adapter(*oss_main[w], full_t,    1, false, nc);

    *oss_main[w] << tab2 << "// Command Queue: Connect loader '" << loader_name << "' to adapters:" << endl;
    *oss_main[w] << tab2 << "(*" << loader_name << "->m_data_in)(" << data_t <<        "->m_sc_export);" << endl;
    *oss_main[w] << tab2 << "(*" << loader_name << "->m_push   )(" << push_t << "       ->m_sc_export);" << endl;
    *oss_main[w] << tab2 << "(*" << loader_name << "->m_full   )(" << full_t << "       ->m_sc_export);" << endl;

    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Command Queue: Connect adapters to wrapper:" << endl;
    *oss_main[w] << tab2 << data_t <<        "->m_sc_in (" << data <<        ");" << endl;
    *oss_main[w] << tab2 << push_t << "       ->m_sc_in (" << push << "       );" << endl;
    *oss_main[w] << tab2 << full_t << "       ->m_sc_out(" << full << "       );" << endl;

    li.producer_connected = true;
  }

  if (!li.consumer_connected) {
    something_connected = true;
    XTSC_DEBUG(logger, "connecting wrapper to read queue of loader '" << loader_name << "'.");
    XTSC_DEBUG(logger, "connecting wrapper '" << p_current_wrapper->name << "' to read queue of loader '" << loader_name << "'.");
    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Read Queue:  Connect wrapper to loader " << loader_name << ":" << endl;


    // Port names
    string data  = name_prefix + "RdData";
    string pop   = name_prefix + "Pop";
    string empty = name_prefix + "RdEmpty";

    // Transactor names
    string data_t   = data  + "_adapter";
    string pop_t    = pop   + "_adapter";
    string empty_t  = empty + "_adapter";

    u32 bits = 32;

    add_wrapper_io(data, bits, false, true);
    add_wrapper_io(pop,     1, true,  true);
    add_wrapper_io(empty,   1, false, true);

    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Read Queue:  Create adapters for connecting loader '" << loader_name << "' and wrapper:" << endl;
    u32 nc = empty_t.length();
    add_adapter(*oss_main[w], data_t,  bits, false, nc);
    add_adapter(*oss_main[w], pop_t,      1, true,  nc);
    add_adapter(*oss_main[w], empty_t,    1, false, nc);

    *oss_main[w] << tab2 << "// Read Queue:  Connect loader '" << loader_name << "' to adapters;" << endl;
    *oss_main[w] << tab2 << "(*" << loader_name << "->m_data_out)(" << data_t  <<    " ->m_sc_export);" << endl;
    *oss_main[w] << tab2 << "(*" << loader_name << "->m_pop     )(" << pop_t   << "    ->m_sc_export);" << endl;
    *oss_main[w] << tab2 << "(*" << loader_name << "->m_empty   )(" << empty_t <<     "->m_sc_export);" << endl;

    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Read Queue:  Connect adapters to wrapper:" << endl;
    *oss_main[w] << tab2 << data_t  <<    " ->m_sc_out(" << data  <<    " );" << endl;
    *oss_main[w] << tab2 << pop_t   << "    ->m_sc_in (" << pop   << "    );" << endl;
    *oss_main[w] << tab2 << empty_t <<     "->m_sc_out(" << empty <<     ");" << endl;

    li.consumer_connected = true;
  }

  for (map<string,bool>::iterator io = li.outputs_connected.begin(); io != li.outputs_connected.end(); ++io) {
    if (io->second) continue;
    something_connected = true;
    string loader_output_name(io->first);
    string wrapper_output_name(name_prefix+io->first);
    string loader_cpp_name("m_" + io->first);
    transform(loader_cpp_name.begin(), loader_cpp_name.end(), loader_cpp_name.begin(), ::tolower);

    string sig  = loader_name + "_" + loader_output_name;
    string tran = sig + "_transactor";

    u32 bits = ((loader_output_name == "Mode") ? 3 : 1);

    add_wrapper_io(wrapper_output_name, bits, false, true);

    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// Create transactor for connecting output \"" << loader_output_name << "\" of loader '" << loader_name
                         << "' to output '" << wrapper_output_name << "' of wrapper:" << endl;
    ostringstream type;
    if (bits > 1) {
      type << "xtsc_tlm2pin_wire_transactor<" << bits << ", sc_bv<" << bits << "> >";
    }
    else {
      type << "xtsc_tlm2pin_wire_transactor<1, bool>";
    }
    *oss_main[w] << tab2 << type.str() << " *" << tran << " = new " << endl;
    *oss_main[w] << tab2 << type.str() << "(\"" << tran << "\"" << ");" << endl;
    *oss_main[w] << endl;

    *oss_main[w] << tab2 << "// " << loader_output_name << ":  Connect output \"" << loader_output_name << "\" of loader '"
                         << loader_name << "' to transactor;" << endl;
    *oss_main[w] << tab2 << loader_name << "->" << loader_cpp_name << "(" << tran << "->m_sc_export);" << endl;

    *oss_main[w] << endl;
    *oss_main[w] << tab2 << "// " << loader_output_name << ":  Connect transactor to output '" << wrapper_output_name
                         << "' of wrapper:" << endl;
    *oss_main[w] << tab2 << tran << "->m_sc_out(" << wrapper_output_name << ");" << endl;

    li.outputs_connected[loader_output_name] = true;
  }

  if (!something_connected) {
    ostringstream oss;
    oss << "loader '" << loader_name
        << "' has no unconnected queue or wire ports so cannot connect to Verilog as requested in command: ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
}



void connect_wrapper_logic(const string& wrapper_input_name, const string& logic_input_name, const string& logic_name) {
  XTSC_TRACE(logger, "enter connect_wrapper_logic()");
  confirm_a_wrapper_is_defined();
  logic_info& li = find_or_infer_logic(logic_name);
  XTSC_DEBUG(logger, "connecting input '" << wrapper_input_name << "' of wrapper '" << p_current_wrapper->name << "' to input \"" <<
                     logic_input_name << "\" of logic '" << logic_name << "'.");
  confirm_input_exists_and_is_not_connected(li, logic_input_name);

  string tran = wrapper_input_name + "_transactor";

  u32 bits = li.p_logic->get_bit_width(logic_input_name.c_str());

  add_wrapper_io(wrapper_input_name, bits, true, true);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create transactor for connecting input '" << wrapper_input_name << "' of wrapper to input \""
                       << logic_input_name << "\" of logic '" << logic_name << "':" << endl;
  ostringstream type;
  if (bits > 1) {
    type << "xtsc_pin2tlm_wire_transactor<" << bits << ", sc_bv<" << bits << "> >";
  }
  else {
    type << "xtsc_pin2tlm_wire_transactor<1, bool>";
  }
  *oss_main[w] << tab2 << type.str() << " *" << tran << " = new " << endl;
  *oss_main[w] << tab2 << type.str() << "(\"" << tran << "\"" << ");" << endl;
  *oss_main[w] << endl;

  *oss_main[w] << tab2 << "// Connect input '" << wrapper_input_name << "' of wrapper to transactor:" << endl;
  *oss_main[w] << tab2 << tran << "->m_sc_in(" << wrapper_input_name << ");" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect transactor to input \"" << logic_input_name << "\" of logic '" << logic_name << "':" << endl;
  *oss_main[w] << tab2 << tran << "->m_sc_port(" << logic_name << "->get_input(\"" << logic_input_name << "\"));" << endl;

  li.inputs_connected[logic_input_name] = true;

}



void connect_wrapper_lookup_pin(const string& name_prefix, const string& lookup_pin_name) {
  XTSC_TRACE(logger, "enter connect_wrapper_lookup_pin()");
  confirm_a_wrapper_is_defined();
  lookup_pin_info& li = find_or_infer_lookup_pin(lookup_pin_name);
  confirm_no_master_connected(li);
  XTSC_DEBUG(logger, "connecting wrapper '" << p_current_wrapper->name << "' to lookup_pin '" << lookup_pin_name << "'.");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect wrapper to lookup_pin " << lookup_pin_name << ":" << endl;

  // Port names
  string out = name_prefix + "_Out";
  string req = name_prefix + "_Out_Req";
  string in  = name_prefix + "_In";
  string rdy = name_prefix + "_Rdy";

  // Transactor names
  string out_t  = out + "_adapter";
  string req_t  = req + "_adapter";
  string in_t   = in  + "_adapter";
  string rdy_t  = rdy + "_adapter";

  u32 abits = li.parms.get_u32("address_bit_width");
  u32 dbits = li.parms.get_u32("data_bit_width");

  add_wrapper_io(out, abits, true,  true);
  add_wrapper_io(req,     1, true,  true);
  add_wrapper_io(in,  dbits, false, true);
  if (li.parms.get_bool("has_ready")) {
  add_wrapper_io(rdy,     1, false, true);
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create adapters for connecting wrapper and lookup_pin '" << lookup_pin_name << "':" << endl;
  u32 nc = out_t.length();
  add_adapter(*oss_main[w], out_t, abits, true,  nc);
  add_adapter(*oss_main[w], req_t,     1, true,  nc);
  add_adapter(*oss_main[w], in_t,  dbits, false, nc);
  if (li.parms.get_bool("has_ready")) {
  add_adapter(*oss_main[w], rdy_t,     1, false, nc);
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect lookup_pin '" << lookup_pin_name << "' to adapters:" << endl;
  *oss_main[w] << tab2 << lookup_pin_name << "->m_address(" << out_t << "->m_sc_export);" << endl;
  *oss_main[w] << tab2 << lookup_pin_name << "->m_req    (" << req_t << "->m_sc_export);" << endl;
  *oss_main[w] << tab2 << lookup_pin_name << "->m_data   (" << in_t << " ->m_sc_export);" << endl;
  if (li.parms.get_bool("has_ready")) {
  *oss_main[w] << tab2 << lookup_pin_name << "->m_ready  (" << rdy_t << "->m_sc_export);" << endl;
  }

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect adapters to wrapper:" << endl;
  *oss_main[w] << tab2 << out_t << "->m_sc_in (" << out << ");" << endl;
  *oss_main[w] << tab2 << req_t << "->m_sc_in (" << req << ");" << endl;
  *oss_main[w] << tab2 << in_t  << " ->m_sc_out("<< in << " );" << endl;
  if (li.parms.get_bool("has_ready")) {
  *oss_main[w] << tab2 << rdy_t << "->m_sc_out(" << rdy << ");" << endl;
  }

  li.master_connected = true;
}



void connect_wrapper_memory_pin(const string& name_prefix, u32 port, const string& memory_name) {
  XTSC_TRACE(logger, "enter connect_wrapper_memory_pin()");
  memory_pin_info& mi = find_or_infer_memory_pin(memory_name);
  confirm_a_wrapper_is_defined();
  wrapper_info&    wi = *p_current_wrapper;
  if ((port >= mi.num_ports) || mi.master_connected[port]) {
    ostringstream oss;
    oss << "<MemoryPort> #" << port << " of memory_pin '" << mi.name << "' is out-or-range or already connected in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  XTSC_DEBUG(logger, "connecting wrapper '" << p_current_wrapper->name << "' to memory_pin '" << memory_name << "'.");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect wrapper to memory_pin " << memory_name << ":"
                       << endl;
  u32 lo_port = port;
  u32 hi_port = mi.num_ports - 1;
  for (u32 p=lo_port; p<=hi_port && !mi.master_connected[p]; ++p) {
    connect_module_to_wrapper("memory_pin", *mi.p_memory_pin, memory_name, name_prefix, p);
    mi.master_connected[p] = true;
    wi.connected_memory_pin_list.push_back(make_pair(&mi, p));
  }
}



void connect_wrapper_mmio(const string& wrapper_input_name, const string& mmio_input_name, const string& mmio_name) {
  XTSC_TRACE(logger, "enter connect_wrapper_mmio()");
  confirm_a_wrapper_is_defined();
  mmio_info&    mi = find_or_infer_mmio(mmio_name);
  XTSC_DEBUG(logger, "connecting input '" << wrapper_input_name << "' of wrapper '" << p_current_wrapper->name << "' to input \"" <<
                     mmio_input_name << "\" of mmio '" << mmio_name << "'.");
  confirm_input_exists_and_is_not_connected(mi, mmio_input_name);

  string tran = wrapper_input_name + "_transactor";

  u32 bits = mi.p_mmio->get_bit_width(mmio_input_name.c_str());

  add_wrapper_io(wrapper_input_name, bits, true, true);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create transactor for connecting input '" << wrapper_input_name << "' of wrapper to input \""
                       << mmio_input_name << "\" of mmio '" << mmio_name << "':" << endl;
  ostringstream type;
  if (bits > 1) {
    type << "xtsc_pin2tlm_wire_transactor<" << bits << ", sc_bv<" << bits << "> >";
  }
  else {
    type << "xtsc_pin2tlm_wire_transactor<1, bool>";
  }
  *oss_main[w] << tab2 << type.str() << " *" << tran << " = new " << endl;
  *oss_main[w] << tab2 << type.str() << "(\"" << tran << "\"" << ");" << endl;
  *oss_main[w] << endl;

  *oss_main[w] << tab2 << "// Connect input '" << wrapper_input_name << "' of wrapper to transactor:" << endl;
  *oss_main[w] << tab2 << tran << "->m_sc_in(" << wrapper_input_name << ");" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect transactor to input \"" << mmio_input_name << "\" of mmio '" << mmio_name << "':" << endl;
  *oss_main[w] << tab2 << tran << "->m_sc_port(" << mmio_name << "->get_input(\"" << mmio_input_name << "\"));" << endl;

  mi.inputs_connected[mmio_input_name] = true;

}



void connect_wrapper_pin2tlm(const string& name_prefix, u32 port, const string& pin2tlm_name) {
  XTSC_TRACE(logger, "enter connect_wrapper_pin2tlm()");
  pin2tlm_info& ti = find_or_infer_pin2tlm(pin2tlm_name);
  confirm_a_wrapper_is_defined();
  wrapper_info& wi = *p_current_wrapper;
  if ((port >= ti.num_ports) || ti.master_connected[port]) {
    ostringstream oss;
    oss << "<MemoryPort> #" << port << " of pin2tlm '" << ti.name << "' is out-or-range or already connected in command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }
  XTSC_DEBUG(logger, "connecting wrapper '" << p_current_wrapper->name << "' to pin2tlm '" << pin2tlm_name << "'.");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect wrapper to pin2tlm " << pin2tlm_name << ":"
                       << endl;
  u32 lo_port = port;
  u32 hi_port = ti.num_ports - 1;
  for (u32 p=lo_port; p<=hi_port && !ti.master_connected[p]; ++p) {
    connect_module_to_wrapper("pin2tlm", *ti.p_pin2tlm, pin2tlm_name, name_prefix, p);
    ti.master_connected[p] = true;
    wi.connected_pin2tlm_list.push_back(make_pair(&ti, p));
  }
}



void connect_wrapper_queue_pin(const string& name_prefix, const string& queue_pin_name) {
  XTSC_TRACE(logger, "enter connect_wrapper_queue_pin()");
  confirm_a_wrapper_is_defined();
  queue_pin_info& qi = find_or_infer_queue_pin(queue_pin_name);
  confirm_no_producer_connected(qi);
  XTSC_DEBUG(logger, "connecting wrapper '" << p_current_wrapper->name << "' to queue_pin '" << queue_pin_name << "'.");
  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect wrapper to queue_pin " << queue_pin_name << ":" << endl;

  // Port names
  string data = name_prefix + "";
  string push = name_prefix + "_PushReq";
  string full = name_prefix + "_Full";

  // Transactor names
  string data_t  = data + "_adapter";
  string push_t  = push + "_adapter";
  string full_t  = full + "_adapter";

  u32 bits = qi.parms.get_u32("bit_width");

  add_wrapper_io(data, bits, true,  true);
  add_wrapper_io(push,    1, true,  true);
  add_wrapper_io(full,    1, false, true);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create adapters for connecting wrapper and queue_pin '" << queue_pin_name << "':" << endl;
  u32 nc = push_t.length();
  add_adapter(*oss_main[w], data_t, bits, true,  nc);
  add_adapter(*oss_main[w], push_t,    1, true,  nc);
  add_adapter(*oss_main[w], full_t,    1, false, nc);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect queue_pin '" << queue_pin_name << "' to adapters:" << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_data_in(" << data_t << "->        m_sc_export);" << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_push   (" << push_t << "->m_sc_export);"         << endl;
  *oss_main[w] << tab2 << queue_pin_name << "->m_full   (" << full_t << "->   m_sc_export);"      << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect adapters to wrapper:" << endl;
  *oss_main[w] << tab2 << data_t << "->        m_sc_in (" << data << "        );" << endl;
  *oss_main[w] << tab2 << push_t << "->m_sc_in ("         << push <<         ");" << endl;
  *oss_main[w] << tab2 << full_t << "->   m_sc_out("      << full <<      "   );" << endl;

  qi.producer_connected = true;
}



void connect_wrapper_wire(const string& wrapper_input_name, const string& wire_name) {
  XTSC_TRACE(logger, "enter connect_wrapper_wire()");
  confirm_a_wrapper_is_defined();
  wire_info& wi = find_or_infer_wire(wire_name);
  XTSC_DEBUG(logger, "connecting input '" << wrapper_input_name << "' of wrapper '" << p_current_wrapper->name << "' to wire '" <<
                     wire_name << "'.");

  string tran = wrapper_input_name + "_transactor";

  u32 bits = wi.parms.get_u32("bit_width");

  add_wrapper_io(wrapper_input_name, bits, true, true);

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Create transactor for connecting input '" << wrapper_input_name << "' of wrapper to wire '"
                       << wire_name << "':" << endl;
  ostringstream type;
  if (bits > 1) {
    type << "xtsc_pin2tlm_wire_transactor<" << bits << ", sc_bv<" << bits << "> >";
  }
  else {
    type << "xtsc_pin2tlm_wire_transactor<1, bool>";
  }
  *oss_main[w] << tab2 << type.str() << " *" << tran << " = new " << endl;
  *oss_main[w] << tab2 << type.str() << "(\"" << tran << "\"" << ");" << endl;
  *oss_main[w] << endl;

  *oss_main[w] << tab2 << "// Connect input '" << wrapper_input_name << "' of wrapper to transactor:" << endl;
  *oss_main[w] << tab2 << tran << "->m_sc_in(" << wrapper_input_name << ");" << endl;

  *oss_main[w] << endl;
  *oss_main[w] << tab2 << "// Connect transactor to wire '" << wire_name << "':" << endl;
  *oss_main[w] << tab2 << tran << "->m_sc_port(*" << wire_name << ");" << endl;

  wi.source_connected = true;

}



// Step 24:  Define the 6 standard methods you declared in Step 12 (plus any additional ones you declared there).

void init_arbiter_parms() {
  XTSC_TRACE(logger, "enter init_arbiter_parms()");
  if (!p_arbiter_parms) {
    confirm_building_system();
    name_arbiter_parms = "arbiter_parms__@";
    p_arbiter_parms = new xtsc_arbiter_parms();
  }
}



void show_arbiter_parms() {
  XTSC_TRACE(logger, "enter show_arbiter_parms()");
  init_arbiter_parms();
  cout << "Parameters for arbiter: " << endl;
  p_arbiter_parms->dump(cout);
}



void add_arbiter_parm() {
  XTSC_TRACE(logger, "enter add_arbiter_parm()");
  init_arbiter_parms();
  parm_split(*p_arbiter_parms);
  p_oss_parms = &oss_arbiter_parms;
  p_name_module_parms = &name_arbiter_parms;
  add_parm(*p_arbiter_parms);
}



void create_arbiter(const string& name) {
  XTSC_TRACE(logger, "enter create_arbiter()");
  init_arbiter_parms();
  string arbiter_name = (name == "" ? "arbiter" : name);
  validate_name(arbiter_name, "arbiter");
  if (arbiter_map[w]->find(arbiter_name) != arbiter_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create arbiter with the same name as an already existing arbiter: " << arbiter_name;
    throw xtsc_exception(oss.str());
  }
  (*arbiter_map[w])[arbiter_name] = new arbiter_info(arbiter_name, *p_arbiter_parms);
  fini_arbiter_parms();
}



void fini_arbiter_parms() {
  XTSC_TRACE(logger, "enter fini_arbiter_parms()");
  if (p_arbiter_parms) {
    delete p_arbiter_parms;
    p_arbiter_parms = NULL;
    oss_arbiter_parms.str("");
  }
}



arbiter_info& find_or_infer_arbiter(const string& arbiter_name) {
  XTSC_TRACE(logger, "enter find_or_infer_arbiter()");
  map<string,arbiter_info*>::iterator ia = arbiter_map[w]->find(arbiter_name);
  if (ia == arbiter_map[w]->end()) {
    // Infer a arbiter with this name
    create_arbiter(arbiter_name);
    ia = arbiter_map[w]->find(arbiter_name);
    if (ia == arbiter_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred arbiter '" << arbiter_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *ia->second;
}



void init_clock_parms() {
  XTSC_TRACE(logger, "enter init_clock_parms()");
  if (!p_clock_parms) {
    confirm_building_system();
    name_clock_parms = "clock_parms__@";
    p_clock_parms = new clock_parms();
  }
}



void show_clock_parms() {
  XTSC_TRACE(logger, "enter show_clock_parms()");
  init_clock_parms();
  cout << "Parameters for clock: " << endl;
  p_clock_parms->dump(cout);
}



void add_clock_parm() {
  XTSC_TRACE(logger, "enter add_clock_parm()");
  init_clock_parms();
  parm_split(*p_clock_parms);
  p_oss_parms = &oss_clock_parms;
  p_name_module_parms = &name_clock_parms;
  add_parm(*p_clock_parms);
}



void create_clock(const string& name) {
  XTSC_TRACE(logger, "enter create_clock()");
  init_clock_parms();
  string clock_name = (name == "" ? "CLK" : name);
  validate_name(clock_name, "clock");
  if (clock_map[w]->find(clock_name) != clock_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create clock with the same name as an already existing clock: " << clock_name;
    throw xtsc_exception(oss.str());
  }
  (*clock_map[w])[clock_name] = new clock_info(clock_name, *p_clock_parms);
  fini_clock_parms();
}



void fini_clock_parms() {
  XTSC_TRACE(logger, "enter fini_clock_parms()");
  if (p_clock_parms) {
    delete p_clock_parms;
    p_clock_parms = NULL;
    oss_clock_parms.str("");
  }
}



clock_info& find_or_infer_clock(const string& clock_name) {
  XTSC_TRACE(logger, "enter find_or_infer_clock()");
  map<string,clock_info*>::iterator ic = clock_map[w]->find(clock_name);
  if (ic == clock_map[w]->end()) {
    // Infer a clock with this name
    create_clock(clock_name);
    ic = clock_map[w]->find(clock_name);
    if (ic == clock_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred clock '" << clock_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *ic->second;
}



void init_consumer_parms() {
  XTSC_TRACE(logger, "enter init_consumer_parms()");
  if (!p_consumer_parms) {
    confirm_building_system();
    name_consumer_parms = "consumer_parms__@";
    p_consumer_parms = new xtsc_queue_consumer_parms();
  }
}



void show_consumer_parms() {
  XTSC_TRACE(logger, "enter show_consumer_parms()");
  init_consumer_parms();
  cout << "Parameters for consumer: " << endl;
  p_consumer_parms->dump(cout);
}



void add_consumer_parm() {
  XTSC_TRACE(logger, "enter add_consumer_parm()");
  init_consumer_parms();
  parm_split(*p_consumer_parms);
  p_oss_parms = &oss_consumer_parms;
  p_name_module_parms = &name_consumer_parms;
  add_parm(*p_consumer_parms);
}



void create_consumer(const string& name) {
  XTSC_TRACE(logger, "enter create_consumer()");
  init_consumer_parms();
  string consumer_name = (name == "" ? "consumer" : name);
  validate_name(consumer_name, "consumer");
  if (consumer_map[w]->find(consumer_name) != consumer_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create consumer with the same name as an already existing consumer: " << consumer_name;
    throw xtsc_exception(oss.str());
  }
  (*consumer_map[w])[consumer_name] = new consumer_info(consumer_name, *p_consumer_parms);
  fini_consumer_parms();
}



void fini_consumer_parms() {
  XTSC_TRACE(logger, "enter fini_consumer_parms()");
  if (p_consumer_parms) {
    delete p_consumer_parms;
    p_consumer_parms = NULL;
    oss_consumer_parms.str("");
  }
}



consumer_info& find_or_infer_consumer(const string& consumer_name) {
  XTSC_TRACE(logger, "enter find_or_infer_consumer()");
  map<string,consumer_info*>::iterator ic = consumer_map[w]->find(consumer_name);
  if (ic == consumer_map[w]->end()) {
    // Infer a consumer with this name
    create_consumer(consumer_name);
    ic = consumer_map[w]->find(consumer_name);
    if (ic == consumer_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred consumer '" << consumer_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *ic->second;
}



void init_cohctrl_parms() {
  XTSC_TRACE(logger, "enter init_cohctrl_parms()");
  if (!p_cohctrl_parms) {
    confirm_building_system();
    name_cohctrl_parms = "cohctrl_parms__@";
    p_cohctrl_parms = new xtsc_cohctrl_parms(1);  // 1 is illegal; "num_transfers" must be set explicitly by user.
  }
}



void show_cohctrl_parms() {
  XTSC_TRACE(logger, "enter show_cohctrl_parms()");
  init_cohctrl_parms();
  cout << "Parameters for cohctrl: " << endl;
  p_cohctrl_parms->dump(cout);
}



void add_cohctrl_parm() {
  XTSC_TRACE(logger, "enter add_cohctrl_parm()");
  init_cohctrl_parms();
  parm_split(*p_cohctrl_parms);
  p_oss_parms = &oss_cohctrl_parms;
  p_name_module_parms = &name_cohctrl_parms;
  add_parm(*p_cohctrl_parms);
}



void create_cohctrl(const string& name) {
  XTSC_TRACE(logger, "enter create_cohctrl()");
  init_cohctrl_parms();
  string cohctrl_name = (name == "" ? "cohctrl" : name);
  validate_name(cohctrl_name, "cohctrl");
  if (cohctrl_map[w]->find(cohctrl_name) != cohctrl_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create cohctrl with the same name as an already existing cohctrl: " << cohctrl_name;
    throw xtsc_exception(oss.str());
  }
  (*cohctrl_map[w])[cohctrl_name] = new cohctrl_info(cohctrl_name, *p_cohctrl_parms);
  fini_cohctrl_parms();
}



void fini_cohctrl_parms() {
  XTSC_TRACE(logger, "enter fini_cohctrl_parms()");
  if (p_cohctrl_parms) {
    delete p_cohctrl_parms;
    p_cohctrl_parms = NULL;
    oss_cohctrl_parms.str("");
  }
}



cohctrl_info& find_or_infer_cohctrl(const string& cohctrl_name) {
  XTSC_TRACE(logger, "enter find_or_infer_cohctrl()");
  map<string,cohctrl_info*>::iterator ia = cohctrl_map[w]->find(cohctrl_name);
  if (ia == cohctrl_map[w]->end()) {
    // Infer a cohctrl with this name
    create_cohctrl(cohctrl_name);
    ia = cohctrl_map[w]->find(cohctrl_name);
    if (ia == cohctrl_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred cohctrl '" << cohctrl_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *ia->second;
}



// Infer a core instantiation if there are outstanding core parms
// (including a core program name, program args, core_debug, core_client)
void infer_create_core(const string& core_name) {
  XTSC_TRACE(logger, "enter infer_create_core(\"" << core_name << "\")");
  if (explicit_core_parm_set) {
    create_core(core_name, "");
  }
}



// "if_able" => If both XTENSA_CORE and XTENSA_SYSTEM have been defined AND no core parameter lookups have occurred
void redo_core_parms_if_able() {
  XTSC_TRACE(logger, "enter redo_core_parms_if_able()");
  redo_core_parms_called = true;
  confirm_no_core_parameter_lookups();
  if ((XTENSA_CORE && XTENSA_CORE[0]) && (XTENSA_SYSTEM && XTENSA_SYSTEM[0])) {
    fini_core_parms();
    try { init_core_parms(); } catch (...) {}
  }
}



void init_core_parms(bool redefine_use_memport) {
  XTSC_TRACE(logger, "enter init_core_parms()");
  if (!p_core_parms) {
    confirm_building_system();
    name_core_parms = "core_parms__@";
    p_core_parms = new xtsc_core_parms(XTENSA_CORE, XTENSA_SYSTEM, XTENSA_PARAMS);
    explicit_core_parm_set = false;
    core_debug             = false;
    core_debug_start_port  = 0;
    core_debug_wait        = true;
    core_debug_sync        = false;
    // If we're using the default memory port (MEM_PIF), make sure this core has a PIF
    if (redefine_use_memport && (use_memport == xtsc_core::MEM_PIF) && (!p_core_parms->get_bool("HasPIF"))) {
           if (p_core_parms->get_u32("DataRAMCount"))    use_memport = xtsc_core::MEM_DRAM0LS0;
      else if (p_core_parms->get_u32("UnifiedRAMCount")) use_memport = xtsc_core::MEM_URAM0;
      else                                               use_memport = xtsc_core::MEM_XLMI0LS0;
    }
    // If we're using the default pin-level memory port (MEM_PIF), make sure this core has a PIF
    if (redefine_use_memport && (use_memport_pin == xtsc_core::MEM_PIF) && (!p_core_parms->get_bool("HasPIF"))) {
           if (p_core_parms->get_u32("DataRAMCount"))    use_memport_pin = xtsc_core::MEM_DRAM0LS0;
      else if (p_core_parms->get_u32("UnifiedRAMCount")) use_memport_pin = xtsc_core::MEM_URAM0;
      else                                               use_memport_pin = xtsc_core::MEM_XLMI0LS0;
    }
    char const * const *p_c_str_array = p_core_parms->get_c_str_array("XTENSA_PARAMS");
    char const *        p_c_str = NULL;
    if (p_c_str_array)  p_c_str =  p_c_str_array[0];
    XTSC_DEBUG(logger, "init_core_parms: p_core_parms=" << p_core_parms << " from" <<
                       " XTENSA_CORE="   << p_core_parms->get_c_str      ("XTENSA_CORE") <<
                       " XTENSA_SYSTEM=" << p_core_parms->get_c_str_array("XTENSA_SYSTEM")[0] <<
                       " XTENSA_PARAMS=" << (p_c_str ?  p_c_str : ""));
  }
}



void show_core_parms() {
  XTSC_TRACE(logger, "enter show_core_parms()");
  init_core_parms();
  cout << "Parameters for core: " << endl;
  p_core_parms->dump(cout);
}



void add_core_parm() {
  XTSC_TRACE(logger, "enter add_core_parm()");
  confirm_no_core_parameter_lookups();
  init_core_parms();
  parm_split(*p_core_parms);
  explicit_core_parm_set = true;
  p_oss_parms = &oss_core_parms;
  p_name_module_parms = &name_core_parms;
  if (parm_name == "SimClients") {
    const char * const *p_sim_clients = p_core_parms->get_c_str_array("SimClients");
    if (p_sim_clients && p_sim_clients[0]) {
      XTSC_WARN(logger, "Warning: core parameter \"SimClients\" is being set multiple times, but only the last one counts.");
      XTSC_WARN(logger, "         To set multiple clients, use one --set_core_parm=SimClients command and separate the clients");
      XTSC_WARN(logger, "         with a comma and no space.  Alternatively, use either the --core_client command (which can be");
      XTSC_WARN(logger, "         repeated) or use the --set_core_parm=SimClientFile=<FileName> command.");
    }
  }
  add_parm(*p_core_parms);
}



void create_core(const string& name, const string& memory_name) {
  XTSC_TRACE(logger, "enter create_core(\"" << name << "\", \"" << memory_name << "\")");
  // Infer --create_memory=PortName for an outstanding memory specification (if any)
  if (p_memory_parms) {
    create_memory(memory_name);
  }
  init_core_parms();
  string core_name = ((name == "") ?  ((XTENSA_CORE && XTENSA_CORE[0]) ? XTENSA_CORE : "core") : name);
  validate_name(core_name, "core");
  if (core_map[w]->find(core_name) != core_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create core with the same name as an already existing core: " << core_name;
    throw xtsc_exception(oss.str());
  }
  (*core_map[w])[core_name] = new core_info(core_name, *p_core_parms);
  last_core_created = core_name;
  fini_core_parms();
  explicit_core_parm_set = false;
}



void fini_core_parms() {
  XTSC_TRACE(logger, "enter fini_core_parms(): p_core_parms=" << p_core_parms);
  if (p_core_parms) {
    delete p_core_parms;
    p_core_parms = NULL;
    oss_core_parms.str("");
  }
}



core_info& find_or_infer_core(const string& core_name, const string& memory_name) {
  XTSC_TRACE(logger, "enter find_or_infer_core()");
  map<string,core_info*>::iterator ic = core_map[w]->find(core_name);
  if (ic == core_map[w]->end()) {
    // Infer a core with this name
    init_core_parms();
    create_core(core_name, memory_name);
    ic = core_map[w]->find(last_core_created);
    if (ic == core_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred core '" << last_core_created << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *ic->second;
}



void init_distributor_parms() {
  XTSC_TRACE(logger, "enter init_distributor_parms()");
  if (!p_distributor_parms) {
    confirm_building_system();
    name_distributor_parms = "distributor_parms__@";
    p_distributor_parms = new xtsc_interrupt_distributor_parms(0, 0);
  }
}



void show_distributor_parms() {
  XTSC_TRACE(logger, "enter show_distributor_parms()");
  init_distributor_parms();
  cout << "Parameters for distributor: " << endl;
  p_distributor_parms->dump(cout);
}



void add_distributor_parm() {
  XTSC_TRACE(logger, "enter add_distributor_parm()");
  init_distributor_parms();
  parm_split(*p_distributor_parms);
  p_oss_parms = &oss_distributor_parms;
  p_name_module_parms = &name_distributor_parms;
  add_parm(*p_distributor_parms);
}



void create_distributor(const string& name) {
  XTSC_TRACE(logger, "enter create_distributor()");
  init_distributor_parms();
  string distributor_name = (name == "" ? "distributor" : name);
  validate_name(distributor_name, "distributor");
  if (distributor_map[w]->find(distributor_name) != distributor_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create distributor with the same name as an already existing distributor: " << distributor_name;
    throw xtsc_exception(oss.str());
  }
  (*distributor_map[w])[distributor_name] = new distributor_info(distributor_name, *p_distributor_parms);
  fini_distributor_parms();
}



void fini_distributor_parms() {
  XTSC_TRACE(logger, "enter fini_distributor_parms()");
  if (p_distributor_parms) {
    delete p_distributor_parms;
    p_distributor_parms = NULL;
    oss_distributor_parms.str("");
  }
}



distributor_info& find_or_infer_distributor(const string& distributor_name) {
  XTSC_TRACE(logger, "enter find_or_infer_distributor()");
  map<string,distributor_info*>::iterator id = distributor_map[w]->find(distributor_name);
  if (id == distributor_map[w]->end()) {
    // Infer a distributor with this name
    create_distributor(distributor_name);
    id = distributor_map[w]->find(distributor_name);
    if (id == distributor_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred distributor '" << distributor_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *id->second;
}



void init_dma_parms() {
  XTSC_TRACE(logger, "enter init_dma_parms()");
  if (!p_dma_parms) {
    confirm_building_system();
    name_dma_parms = "dma_parms__@";
    p_dma_parms = new xtsc_dma_engine_parms(0x00000000);
  }
}



void show_dma_parms() {
  XTSC_TRACE(logger, "enter show_dma_parms()");
  init_dma_parms();
  cout << "Parameters for dma: " << endl;
  p_dma_parms->dump(cout);
}



void add_dma_parm() {
  XTSC_TRACE(logger, "enter add_dma_parm()");
  init_dma_parms();
  parm_split(*p_dma_parms);
  p_oss_parms = &oss_dma_parms;
  p_name_module_parms = &name_dma_parms;
  add_parm(*p_dma_parms);
}



void create_dma(const string& name) {
  XTSC_TRACE(logger, "enter create_dma()");
  init_dma_parms();
  string dma_name = (name == "" ? "dma" : name);
  validate_name(dma_name, "dma");
  if (dma_map[w]->find(dma_name) != dma_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create dma with the same name as an already existing dma: " << dma_name;
    throw xtsc_exception(oss.str());
  }
  (*dma_map[w])[dma_name] = new dma_info(dma_name, *p_dma_parms);
  fini_dma_parms();
}



void fini_dma_parms() {
  XTSC_TRACE(logger, "enter fini_dma_parms()");
  if (p_dma_parms) {
    delete p_dma_parms;
    p_dma_parms = NULL;
    oss_dma_parms.str("");
  }
}



dma_info& find_or_infer_dma(const string& dma_name) {
  XTSC_TRACE(logger, "enter find_or_infer_dma()");
  map<string,dma_info*>::iterator id = dma_map[w]->find(dma_name);
  if (id == dma_map[w]->end()) {
    // Infer a dma with this name
    create_dma(dma_name);
    id = dma_map[w]->find(dma_name);
    if (id == dma_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred dma '" << dma_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *id->second;
}



void init_driver_parms() {
  XTSC_TRACE(logger, "enter init_driver_parms()");
  if (!p_driver_parms) {
    confirm_building_system();
    name_driver_parms = "driver_parms__@";
    p_driver_parms = new xtsc_lookup_driver_parms(0, 0, false);
  }
}



void show_driver_parms() {
  XTSC_TRACE(logger, "enter show_driver_parms()");
  init_driver_parms();
  cout << "Parameters for driver: " << endl;
  p_driver_parms->dump(cout);
}



void add_driver_parm() {
  XTSC_TRACE(logger, "enter add_driver_parm()");
  init_driver_parms();
  parm_split(*p_driver_parms);
  p_oss_parms = &oss_driver_parms;
  p_name_module_parms = &name_driver_parms;
  add_parm(*p_driver_parms);
}



void create_driver(const string& name) {
  XTSC_TRACE(logger, "enter create_driver()");
  init_driver_parms();
  string driver_name = (name == "" ? "driver" : name);
  validate_name(driver_name, "driver");
  if (driver_map[w]->find(driver_name) != driver_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create driver with the same name as an already existing driver: " << driver_name;
    throw xtsc_exception(oss.str());
  }
  (*driver_map[w])[driver_name] = new driver_info(driver_name, *p_driver_parms);
  fini_driver_parms();
}



void fini_driver_parms() {
  XTSC_TRACE(logger, "enter fini_driver_parms()");
  if (p_driver_parms) {
    delete p_driver_parms;
    p_driver_parms = NULL;
    oss_driver_parms.str("");
  }
}



driver_info& find_or_infer_driver(const string& driver_name) {
  XTSC_TRACE(logger, "enter find_or_infer_driver()");
  map<string,driver_info*>::iterator id = driver_map[w]->find(driver_name);
  if (id == driver_map[w]->end()) {
    // Infer a driver with this name
    create_driver(driver_name);
    id = driver_map[w]->find(driver_name);
    if (id == driver_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred driver '" << driver_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *id->second;
}



void init_loader_parms() {
  XTSC_TRACE(logger, "enter init_loader_parms()");
  if (!p_loader_parms) {
    confirm_building_system();
    name_loader_parms = "loader_parms__@";
    p_loader_parms = new xtsc_tx_loader_parms();
  }
}



void show_loader_parms() {
  XTSC_TRACE(logger, "enter show_loader_parms()");
  init_loader_parms();
  cout << "Parameters for loader: " << endl;
  p_loader_parms->dump(cout);
}



void add_loader_parm() {
  XTSC_TRACE(logger, "enter add_loader_parm()");
  init_loader_parms();
  parm_split(*p_loader_parms);
  p_oss_parms = &oss_loader_parms;
  p_name_module_parms = &name_loader_parms;
  add_parm(*p_loader_parms);
}



void create_loader(const string& name) {
  XTSC_TRACE(logger, "enter create_loader()");
  init_loader_parms();
  string loader_name = (name == "" ? "loader" : name);
  validate_name(loader_name, "loader");
  if (loader_map[w]->find(loader_name) != loader_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create loader with the same name as an already existing loader: " << loader_name;
    throw xtsc_exception(oss.str());
  }
  (*loader_map[w])[loader_name] = new loader_info(loader_name, *p_loader_parms);
  fini_loader_parms();
}



void fini_loader_parms() {
  XTSC_TRACE(logger, "enter fini_loader_parms()");
  if (p_loader_parms) {
    delete p_loader_parms;
    p_loader_parms = NULL;
    oss_loader_parms.str("");
  }
}



loader_info& find_or_infer_loader(const string& loader_name) {
  XTSC_TRACE(logger, "enter find_or_infer_loader()");
  map<string,loader_info*>::iterator ia = loader_map[w]->find(loader_name);
  if (ia == loader_map[w]->end()) {
    // Infer a loader with this name
    create_loader(loader_name);
    ia = loader_map[w]->find(loader_name);
    if (ia == loader_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred loader '" << loader_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *ia->second;
}



void init_logic_parms() {
  XTSC_TRACE(logger, "enter init_logic_parms()");
  if (!p_logic_parms) {
    confirm_building_system();
    name_logic_parms = "logic_parms__@";
    p_logic_parms = new xtsc_wire_logic_parms("");
  }
}



void show_logic_parms() {
  XTSC_TRACE(logger, "enter show_logic_parms()");
  init_logic_parms();
  cout << "Parameters for logic: " << endl;
  p_logic_parms->dump(cout);
}



void add_logic_parm() {
  XTSC_TRACE(logger, "enter add_logic_parm()");
  init_logic_parms();
  parm_split(*p_logic_parms);
  p_oss_parms = &oss_logic_parms;
  p_name_module_parms = &name_logic_parms;
  add_parm(*p_logic_parms);
}



void create_logic(const string& name) {
  XTSC_TRACE(logger, "enter create_logic()");
  init_logic_parms();
  string logic_name = (name == "" ? "logic" : name);
  validate_name(logic_name, "logic");
  if (logic_map[w]->find(logic_name) != logic_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create logic with the same name as an already existing logic: " << logic_name;
    throw xtsc_exception(oss.str());
  }
  (*logic_map[w])[logic_name] = new logic_info(logic_name, *p_logic_parms);
  fini_logic_parms();
}



void fini_logic_parms() {
  XTSC_TRACE(logger, "enter fini_logic_parms()");
  if (p_logic_parms) {
    delete p_logic_parms;
    p_logic_parms = NULL;
    oss_logic_parms.str("");
  }
}



logic_info& find_or_infer_logic(const string& logic_name) {
  XTSC_TRACE(logger, "enter find_or_infer_logic()");
  map<string,logic_info*>::iterator ia = logic_map[w]->find(logic_name);
  if (ia == logic_map[w]->end()) {
    // Infer a logic with this name
    create_logic(logic_name);
    ia = logic_map[w]->find(logic_name);
    if (ia == logic_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred logic '" << logic_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *ia->second;
}



void init_lookup_parms() {
  XTSC_TRACE(logger, "enter init_lookup_parms()");
  if (!p_lookup_parms) {
    confirm_building_system();
    name_lookup_parms = "lookup_parms__@";
    p_lookup_parms = new xtsc_lookup_parms(0, 0, false);
  }
}



void show_lookup_parms() {
  XTSC_TRACE(logger, "enter show_lookup_parms()");
  init_lookup_parms();
  cout << "Parameters for lookup: " << endl;
  p_lookup_parms->dump(cout);
}



void add_lookup_parm() {
  XTSC_TRACE(logger, "enter add_lookup_parm()");
  init_lookup_parms();
  parm_split(*p_lookup_parms);
  p_oss_parms = &oss_lookup_parms;
  p_name_module_parms = &name_lookup_parms;
  add_parm(*p_lookup_parms);
}



void create_lookup(const string& name, const string& tie_name) {
  XTSC_TRACE(logger, "enter create_lookup()");
  init_lookup_parms();
  string lookup_name = (name == "" ? "lookup" : name);
  validate_name(lookup_name, "lookup");
  if (lookup_map[w]->find(lookup_name) != lookup_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create lookup with the same name as an already existing lookup: " << lookup_name;
    throw xtsc_exception(oss.str());
  }
  string tie = ((tie_name == "") ? name : tie_name);
  // If address or data bit width is 0, then get the bit width from the last core created
  if (!p_lookup_parms->get_u32("address_bit_width") || !p_lookup_parms->get_u32("data_bit_width")) {
    XTSC_DEBUG(logger, "create_lookup() called with address_bit_width or data_bit_width of 0.  " <<
                       "Attempting to find lookup in last core created.");
    if (last_core_created == "") {
      ostringstream oss;
      oss << "ERROR: \"address_bit_width\" or \"data_bit_width\" parameters haven't been defined "
          << "and no core has been created to find TIE lookup port '" << tie << "' on in command ";
      command_info(oss);
      throw xtsc_exception(oss.str());
    }
    map<string,core_info*>::iterator ic = core_map[w]->find(last_core_created);
    if (ic == core_map[w]->end()) {
      ostringstream oss;
      oss << "PROGRAM BUG: Can't find last created core '" << last_core_created << "'.";
      throw xtsc_exception(oss.str());
    }
    // Does this core have a lookup named TIE?
    if (!ic->second->p_core->has_lookup(tie.c_str())) {
      ostringstream oss;
      oss << "Core '" << last_core_created << "' has no TIE lookup named '" << tie << "'.";
      throw xtsc_exception(oss.str());
    }
    // Yes, so replace the 0 widths and the "has_ready" parameter with values from the core
    if (!p_lookup_parms->get_u32("address_bit_width")) {
      update_parm_u32(*p_lookup_parms, "address_bit_width", ic->second->p_core->get_lookup_address_bit_width(tie.c_str()),
                      oss_lookup_parms, name_lookup_parms);
    }
    if (!p_lookup_parms->get_u32("data_bit_width")) {
      update_parm_u32(*p_lookup_parms, "data_bit_width", ic->second->p_core->get_lookup_data_bit_width(tie.c_str()),
                      oss_lookup_parms, name_lookup_parms);
    }
    update_parm_bool(*p_lookup_parms, "has_ready", ic->second->p_core->has_lookup_ready(tie.c_str()),
                      oss_lookup_parms, name_lookup_parms);
  }
  (*lookup_map[w])[lookup_name] = new lookup_info(lookup_name, *p_lookup_parms);
  fini_lookup_parms();
}



void fini_lookup_parms() {
  XTSC_TRACE(logger, "enter fini_lookup_parms()");
  if (p_lookup_parms) {
    delete p_lookup_parms;
    p_lookup_parms = NULL;
    oss_lookup_parms.str("");
  }
}



lookup_info& find_or_infer_lookup(const string& lookup_name) {
  XTSC_TRACE(logger, "enter find_or_infer_lookup()");
  map<string,lookup_info*>::iterator il = lookup_map[w]->find(lookup_name);
  if (il == lookup_map[w]->end()) {
    // Infer a lookup with this name
    create_lookup(lookup_name, "");
    il = lookup_map[w]->find(lookup_name);
    if (il == lookup_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred lookup '" << lookup_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *il->second;
}



void init_lookup_pin_parms() {
  XTSC_TRACE(logger, "enter init_lookup_pin_parms()");
  if (!p_lookup_pin_parms) {
    confirm_building_system();
    name_lookup_pin_parms = "lookup_pin_parms__@";
    p_lookup_pin_parms = new xtsc_lookup_pin_parms(0, 0, false);
  }
}



void show_lookup_pin_parms() {
  XTSC_TRACE(logger, "enter show_lookup_pin_parms()");
  init_lookup_pin_parms();
  cout << "Parameters for lookup_pin: " << endl;
  p_lookup_pin_parms->dump(cout);
}



void add_lookup_pin_parm() {
  XTSC_TRACE(logger, "enter add_lookup_pin_parm()");
  init_lookup_pin_parms();
  parm_split(*p_lookup_pin_parms);
  p_oss_parms = &oss_lookup_pin_parms;
  p_name_module_parms = &name_lookup_pin_parms;
  add_parm(*p_lookup_pin_parms);
}



void create_lookup_pin(const string& name, const string& tie_name) {
  XTSC_TRACE(logger, "enter create_lookup_pin()");
  init_lookup_pin_parms();
  string lookup_pin_name = (name == "" ? "lookup_pin" : name);
  validate_name(lookup_pin_name, "lookup_pin");
  if (lookup_pin_map[w]->find(lookup_pin_name) != lookup_pin_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create lookup_pin with the same name as an already existing lookup_pin: " << lookup_pin_name;
    throw xtsc_exception(oss.str());
  }
  string tie = ((tie_name == "") ? name : tie_name);
  // If either address or data bit width is 0, then get its bit width from the last core created and also set "has_ready" parm
  if (!p_lookup_pin_parms->get_u32("address_bit_width") || !p_lookup_pin_parms->get_u32("data_bit_width")) {
    if (last_core_created == "") {
      ostringstream oss;
      oss << "ERROR: \"address_bit_width\" or \"data_bit_width\" are not properly defined and no core has been created"
          << " to find TIE lookup port '" << tie << "' on in command ";
      command_info(oss);
      throw xtsc_exception(oss.str());
    }
    map<string,core_info*>::iterator ic = core_map[w]->find(last_core_created);
    if (ic == core_map[w]->end()) {
      ostringstream oss;
      oss << "PROGRAM BUG: Can't find last created core '" << last_core_created << "'.";
      throw xtsc_exception(oss.str());
    }
    xtsc_core& core = *ic->second->p_core;
    // Does this core have a pin-level lookup named TIE?
    if (!core.has_pin_level_lookup(tie.c_str())) {
      ostringstream oss;
      oss << "Core '" << last_core_created << "' has no pin-level TIE lookup named '" << tie
          << "' so can't determine \"address_bit_width\" and/or \"data_bit_width\".";
      throw xtsc_exception(oss.str());
    }
    // Yes, so replace the 0 widths with values from the core
    if (!p_lookup_pin_parms->get_u32("address_bit_width")) {
      update_parm_u32(*p_lookup_pin_parms, "address_bit_width", core.get_pin_bit_width(("TIE_" + tie + "_Out").c_str()),
                      oss_lookup_pin_parms, name_lookup_pin_parms);
    }
    if (!p_lookup_pin_parms->get_u32("data_bit_width")) {
      update_parm_u32(*p_lookup_pin_parms, "data_bit_width", core.get_pin_bit_width(("TIE_" + tie + "_In").c_str()),
                      oss_lookup_pin_parms, name_lookup_pin_parms);
    }
    update_parm_bool(*p_lookup_pin_parms, "has_ready", core.has_input_pin(("TIE_" + tie +"_Rdy").c_str()),
                    oss_lookup_pin_parms, name_lookup_pin_parms);
  }
  (*lookup_pin_map[w])[lookup_pin_name] = new lookup_pin_info(lookup_pin_name, *p_lookup_pin_parms);
  fini_lookup_pin_parms();
}



void fini_lookup_pin_parms() {
  XTSC_TRACE(logger, "enter fini_lookup_pin_parms()");
  if (p_lookup_pin_parms) {
    delete p_lookup_pin_parms;
    p_lookup_pin_parms = NULL;
    oss_lookup_pin_parms.str("");
  }
}



lookup_pin_info& find_or_infer_lookup_pin(const string& lookup_pin_name) {
  XTSC_TRACE(logger, "enter find_or_infer_lookup_pin()");
  map<string,lookup_pin_info*>::iterator il = lookup_pin_map[w]->find(lookup_pin_name);
  if (il == lookup_pin_map[w]->end()) {
    // Infer a lookup_pin with this name
    create_lookup_pin(lookup_pin_name, "");
    il = lookup_pin_map[w]->find(lookup_pin_name);
    if (il == lookup_pin_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred lookup_pin '" << lookup_pin_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *il->second;
}



void init_make_parms() {
  XTSC_TRACE(logger, "enter init_make_parms()");
  if (!p_make_parms) {
    name_make_parms = "make_parms__@";
    p_make_parms = new make_parms();
  }
}



void show_make_parms() {
  XTSC_TRACE(logger, "enter show_make_parms()");
  init_make_parms();
  cout << "Parameters for make: ";
  if (verilog_on_top || systemc_on_top) {
    cout << "(--cosim=" << (verilog_on_top ? "verilog" : "systemc") << "," << vendor << "," << vendor_version << ","
         << gcc_version << ")";
  }
  cout << endl;
  p_make_parms->dump(cout);
}



void add_make_parm() {
  XTSC_TRACE(logger, "enter add_make_parm()");
  init_make_parms();
  parm_split(*p_make_parms);
  p_oss_parms = &oss_make_parms;
  p_name_module_parms = &name_make_parms;
  add_parm(*p_make_parms);
}



void init_master_parms() {
  XTSC_TRACE(logger, "enter init_master_parms()");
  if (!p_master_parms) {
    confirm_building_system();
    name_master_parms = "master_parms__@";
    p_master_parms = new xtsc_master_parms("");
  }
}



void show_master_parms() {
  XTSC_TRACE(logger, "enter show_master_parms()");
  init_master_parms();
  cout << "Parameters for master: " << endl;
  p_master_parms->dump(cout);
}



void add_master_parm() {
  XTSC_TRACE(logger, "enter add_master_parm()");
  init_master_parms();
  parm_split(*p_master_parms);
  p_oss_parms = &oss_master_parms;
  p_name_module_parms = &name_master_parms;
  add_parm(*p_master_parms);
}



void create_master(const string& name) {
  XTSC_TRACE(logger, "enter create_master()");
  init_master_parms();
  string master_name = (name == "" ? "master" : name);
  validate_name(master_name, "master");
  if (master_map[w]->find(master_name) != master_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create master with the same name as an already existing master: " << master_name;
    throw xtsc_exception(oss.str());
  }
  (*master_map[w])[master_name] = new master_info(master_name, *p_master_parms);
  fini_master_parms();
}



void fini_master_parms() {
  XTSC_TRACE(logger, "enter fini_master_parms()");
  if (p_master_parms) {
    delete p_master_parms;
    p_master_parms = NULL;
    oss_master_parms.str("");
  }
}



master_info& find_or_infer_master(const string& master_name) {
  XTSC_TRACE(logger, "enter find_or_infer_master()");
  map<string,master_info*>::iterator ia = master_map[w]->find(master_name);
  if (ia == master_map[w]->end()) {
    // Infer a master with this name
    create_master(master_name);
    ia = master_map[w]->find(master_name);
    if (ia == master_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred master '" << master_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *ia->second;
}



void throw_no_such_memory_port() {
  XTSC_TRACE(logger, "enter throw_no_such_memory_port()");
  ostringstream oss;
  oss << "ERROR: config '" << XTENSA_CORE << "' has no " << xtsc_core::get_memory_port_name(use_memport) << " memory port.";
  throw xtsc_exception(oss.str());
}



void init_memory_parms(xtsc_core_parms *p_cp, bool redefine_use_memport) {
  XTSC_TRACE(logger, "enter init_memory_parms(" << p_cp << "): p_memory_parms=" << p_memory_parms);
  if (!p_memory_parms) {
    confirm_building_system();
    if (!p_cp) {
      if ((XTENSA_CORE && XTENSA_CORE[0])) {
        init_core_parms(redefine_use_memport);
        p_cp = p_core_parms;
      }
      else {
        name_memory_parms = "memory_parms__@";
        p_memory_parms = new xtsc_memory_parms(0);
        memory_parms_args = "";
        return;
      }
    }

    bool zero_based        = !p_cp->get_bool("SimFullLocalMemAddress");  // N.A. for PIF and XLMI

    u32  delay             = ((p_cp->get_u32("LocalMemoryLatency") == 2) ? 1 : 0);
    u32  width8            = 0;
    u32  start_address8    = 0;
    u32  size8             = 0;
    u32  num_ports         = 1;
    u32  read_only         = false;

    switch (use_memport) {
      case xtsc_core::MEM_PIF: {
        if (!p_cp->get_bool("HasPIF")) throw_no_such_memory_port();
        width8          = p_cp->get_u32("PIFByteWidth");
        delay           = delay + 1;
        break;
      }
      case xtsc_core::MEM_IRAM0: {
        if (p_cp->get_u32("InstRAMCount") < 1) throw_no_such_memory_port();
        width8          = p_cp->get_u32("InstFetchByteWidth");
        start_address8  = zero_based ? 0 : p_cp->get_u32("InstRAM0BaseAddress");
        size8           = p_cp->get_u32("InstRAM0ByteSize");
        break;
      }
      case xtsc_core::MEM_IRAM1: {
        if (p_cp->get_u32("InstRAMCount") < 2) throw_no_such_memory_port();
        width8          = p_cp->get_u32("InstFetchByteWidth");
        start_address8  = zero_based ? 0 : p_cp->get_u32("InstRAM1BaseAddress");
        size8           = p_cp->get_u32("InstRAM1ByteSize");
        break;
      }
      case xtsc_core::MEM_IROM0: {
        if (p_cp->get_u32("InstROMCount") < 1) throw_no_such_memory_port();
        width8          = p_cp->get_u32("InstFetchByteWidth");
        start_address8  = zero_based ? 0 : p_cp->get_u32("InstROM0BaseAddress");
        size8           = p_cp->get_u32("InstROM0ByteSize");
        read_only       = true;
        break;
      }
      case xtsc_core::MEM_DRAM0LS1:
      case xtsc_core::MEM_DRAM0LS0: {
        if (p_cp->get_u32("DataRAMCount") < 1) throw_no_such_memory_port();
        width8          = p_cp->get_u32("LoadStoreByteWidth");
        start_address8  = zero_based ? 0 : p_cp->get_u32("DataRAM0BaseAddress");
        size8           = p_cp->get_u32("DataRAM0ByteSize");
        if (!use_memport_had_ls) {
          num_ports     = (((p_cp->get_u32("LoadStoreUnitCount") == 2) && !p_cp->get_bool("HasCBox")) ? 2 : 1);
        }
        break;
      }
      case xtsc_core::MEM_DRAM1LS1:
      case xtsc_core::MEM_DRAM1LS0: {
        if (p_cp->get_u32("DataRAMCount") < 2) throw_no_such_memory_port();
        width8          = p_cp->get_u32("LoadStoreByteWidth");
        start_address8  = zero_based ? 0 : p_cp->get_u32("DataRAM1BaseAddress");
        size8           = p_cp->get_u32("DataRAM1ByteSize");
        if (!use_memport_had_ls) {
          num_ports     = (((p_cp->get_u32("LoadStoreUnitCount") == 2) && !p_cp->get_bool("HasCBox")) ? 2 : 1);
        }
        break;
      }
      case xtsc_core::MEM_DROM0LS1:
      case xtsc_core::MEM_DROM0LS0: {
        if (p_cp->get_u32("DataROMCount") < 1) throw_no_such_memory_port();
        width8          = p_cp->get_u32("LoadStoreByteWidth");
        start_address8  = zero_based ? 0 : p_cp->get_u32("DataROM0BaseAddress");
        size8           = p_cp->get_u32("DataROM0ByteSize");
        if (!use_memport_had_ls) {
          num_ports     = (((p_cp->get_u32("LoadStoreUnitCount") == 2) && !p_cp->get_bool("HasCBox")) ? 2 : 1);
        }
        read_only       = true;
        break;
      }
      case xtsc_core::MEM_URAM0: {
        if (p_cp->get_u32("UnifiedRAMCount") < 1) throw_no_such_memory_port();
        width8          = p_cp->get_u32("InstFetchByteWidth");
        start_address8  = zero_based ? 0 : p_cp->get_u32("UnifiedRAM0BaseAddress");
        size8           = p_cp->get_u32("UnifiedRAM0ByteSize");
        break;
      }
      case xtsc_core::MEM_XLMI0LS1:
      case xtsc_core::MEM_XLMI0LS0: {
        if (p_cp->get_u32("XLMICount") < 1) throw_no_such_memory_port();
        width8          = p_cp->get_u32("LoadStoreByteWidth");
        start_address8  = p_cp->get_u32("XLMI0BaseAddress");
        size8           = p_cp->get_u32("XLMI0ByteSize");
        if (!use_memport_had_ls) {
          num_ports     = p_cp->get_u32("LoadStoreUnitCount");
        }
        break;
      }
      default: {
        ostringstream oss;
        oss << "ERROR: Unrecognized memory port number (" << use_memport << ") in init_memory_parms().";
        throw xtsc_exception(oss.str());
      }
    }

    name_memory_parms = "memory_parms__@";
    p_memory_parms = new xtsc_memory_parms(width8, delay, start_address8, size8, num_ports);
    ostringstream args;
    args << "(" << width8 << ", " << delay << ", 0x" << hex << start_address8 << ", 0x" << size8 << dec << ", " << num_ports << ")";
    memory_parms_args = args.str();

    if (use_memport == xtsc_core::MEM_PIF) {
      p_memory_parms->set("check_alignment", true);
      oss_memory_parms << tab2 << name_memory_parms << ".set(\"check_alignment\", true);" << endl;
    }
    if (read_only) {
      p_memory_parms->set("read_only", true);
      oss_memory_parms << tab2 << name_memory_parms << ".set(\"read_only\", true);" << endl;
    }
  }
}



void show_memory_parms() {
  XTSC_TRACE(logger, "enter show_memory_parms()");
  init_memory_parms();
  cout << "Parameters for memory (interface=" << xtsc_core::get_memory_port_name(use_memport, !use_memport_had_ls) << "): " << endl;
  p_memory_parms->dump(cout);
  show_memory_parms_called = true;
}



void add_memory_parm() {
  XTSC_TRACE(logger, "enter add_memory_parm()");
  init_memory_parms();
  parm_split(*p_memory_parms);
  p_oss_parms = &oss_memory_parms;
  p_name_module_parms = &name_memory_parms;
  add_parm(*p_memory_parms);
  add_memory_parm_called = true;
}



void create_memory(const string& name, xtsc_core_parms *p_cp) {
  XTSC_TRACE(logger, "enter create_memory(\"" << name << "\", " << p_cp << ")");
  init_memory_parms(p_cp);
  string memory_name = ((name == "") ?  xtsc_core::get_memory_port_name(use_memport, !use_memport_had_ls) : name);
  validate_name(memory_name, "memory");
  if (memory_map[w]->find(memory_name) != memory_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create memory with the same name as an already existing memory: " << memory_name;
    throw xtsc_exception(oss.str());
  }
  (*memory_map[w])[memory_name] = new memory_info(memory_name, *p_memory_parms, use_memport);
  fini_memory_parms();
}



void fini_memory_parms() {
  XTSC_TRACE(logger, "enter fini_memory_parms(): p_memory_parms=" << p_memory_parms);
  if (p_memory_parms) {
    delete p_memory_parms;
    p_memory_parms = NULL;
    oss_memory_parms.str("");
  }
}



memory_info& find_or_infer_memory(const string& memory_name, xtsc_core_parms *p_cp) {
  XTSC_TRACE(logger, "enter find_or_infer_memory(\"" << memory_name << "\", " << p_cp << ")");
  map<string,memory_info*>::iterator im = memory_map[w]->find(memory_name);
  if (im == memory_map[w]->end()) {
    // Infer a memory with this name
    init_memory_parms(p_cp);
    create_memory(memory_name, p_cp);
    im = memory_map[w]->find(memory_name);
    if (im == memory_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred memory '" << memory_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *im->second;
}



void throw_no_such_memory_port_pin() {
  XTSC_TRACE(logger, "enter throw_no_such_memory_port_pin()");
  ostringstream oss;
  oss << "ERROR: config '" << XTENSA_CORE << "' has no " << xtsc_core::get_memory_port_name(use_memport_pin) << " memory port.";
  throw xtsc_exception(oss.str());
}



void init_memory_pin_parms() {
  XTSC_TRACE(logger, "enter init_memory_pin_parms()");
  if (!p_memory_pin_parms) {
    confirm_building_system();
    if (!XTENSA_CORE || !XTENSA_CORE[0]) {
      name_memory_pin_parms = "memory_pin_parms__@";
      p_memory_pin_parms = new xtsc_memory_pin_parms();
      memory_pin_parms_args = "";
      return;
    }

    init_core_parms(false);
    xtsc_core_parms * p_cp = p_core_parms;

    const char *memory_interface        = xtsc_core::get_memory_port_name(use_memport_pin, true);
    bool        big_endian              = p_cp->get_bool("IsBigEndian");
    u32         num_ports               = 1;
    u32         byte_width              = 0;
    u32         start_byte_address      = 0;
    u32         memory_byte_size        = 0;
    bool        has_busy                = false;
    bool        has_lock                = false;
    u32         address_bits            = 32;
    u32         delay                   = ((p_cp->get_u32("LocalMemoryLatency") == 2) ? 1 : 0);
    u32         check_bits              = 0;
    bool        has_pif_attribute       = false;
    bool        cbox                    = false;

    switch (use_memport_pin) {
      case xtsc_core::MEM_PIF: {
        if (!p_cp->get_bool("HasPIF")) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("PIFByteWidth");
        delay                   = p_cp->get_u32("LocalMemoryLatency");
        has_pif_attribute       = (p_cp->get_u32("PIFVersion") >= 32);
        break;
      }
      case xtsc_core::MEM_IRAM0: {
        if (p_cp->get_u32("InstRAMCount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("InstFetchByteWidth");
        start_byte_address      = p_cp->get_u32("InstRAM0BaseAddress");
        memory_byte_size        = p_cp->get_u32("InstRAM0ByteSize");
        address_bits            = compute_address_bits(memory_byte_size, byte_width);
        has_busy                = p_cp->get_bool("InstRAM0HasBusy");
        check_bits              = p_cp->get_bool("InstRAM0HasECC") ? byte_width*7/4 : p_cp->get_bool("InstRAM0HasParity") ? 1 : 0;
        break;
      }
      case xtsc_core::MEM_IRAM1: {
        if (p_cp->get_u32("InstRAMCount") < 2) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("InstFetchByteWidth");
        start_byte_address      = p_cp->get_u32("InstRAM1BaseAddress");
        memory_byte_size        = p_cp->get_u32("InstRAM1ByteSize");
        address_bits            = compute_address_bits(memory_byte_size, byte_width);
        has_busy                = p_cp->get_bool("InstRAM1HasBusy");
        check_bits              = p_cp->get_bool("InstRAM1HasECC") ? byte_width*7/4 : p_cp->get_bool("InstRAM1HasParity") ? 1 : 0;
        break;
      }
      case xtsc_core::MEM_IROM0: {
        if (p_cp->get_u32("InstROMCount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("InstFetchByteWidth");
        start_byte_address      = p_cp->get_u32("InstROM0BaseAddress");
        memory_byte_size        = p_cp->get_u32("InstROM0ByteSize");
        address_bits            = compute_address_bits(memory_byte_size, byte_width);
        has_busy                = p_cp->get_bool("InstROM0HasBusy");
        break;
      }
      case xtsc_core::MEM_DRAM0LS1:
      case xtsc_core::MEM_DRAM0LS0: {
        if (p_cp->get_u32("DataRAMCount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("LoadStoreByteWidth");
        start_byte_address      = p_cp->get_u32("DataRAM0BaseAddress");
        memory_byte_size        = p_cp->get_u32("DataRAM0ByteSize");
        address_bits            = compute_address_bits(memory_byte_size, byte_width);
        has_busy                = p_cp->get_bool("DataRAM0HasBusy");
        has_lock                = p_cp->get_bool("DataRAM0HasRCW");
        check_bits              = p_cp->get_bool("DataRAM0HasECC") ? byte_width*5 : p_cp->get_bool("DataRAM0HasParity") ? 1 : 0;
        cbox                    = p_cp->get_bool("HasCBox");
        if (!use_memport_pin_had_ls && !cbox) {
          num_ports             = p_cp->get_u32("LoadStoreUnitCount");
        }
        break;
      }
      case xtsc_core::MEM_DRAM1LS1:
      case xtsc_core::MEM_DRAM1LS0: {
        if (p_cp->get_u32("DataRAMCount") < 2) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("LoadStoreByteWidth");
        start_byte_address      = p_cp->get_u32("DataRAM1BaseAddress");
        memory_byte_size        = p_cp->get_u32("DataRAM1ByteSize");
        address_bits            = compute_address_bits(memory_byte_size, byte_width);
        has_busy                = p_cp->get_bool("DataRAM1HasBusy");
        has_lock                = p_cp->get_bool("DataRAM1HasRCW");
        check_bits              = p_cp->get_bool("DataRAM1HasECC") ? byte_width*5 : p_cp->get_bool("DataRAM1HasParity") ? 1 : 0;
        cbox                    = p_cp->get_bool("HasCBox");
        if (!use_memport_pin_had_ls && !cbox) {
          num_ports             = p_cp->get_u32("LoadStoreUnitCount");
        }
        break;
      }
      case xtsc_core::MEM_DROM0LS1:
      case xtsc_core::MEM_DROM0LS0: {
        if (p_cp->get_u32("DataROMCount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("LoadStoreByteWidth");
        start_byte_address      = p_cp->get_u32("DataROM0BaseAddress");
        memory_byte_size        = p_cp->get_u32("DataROM0ByteSize");
        address_bits            = compute_address_bits(memory_byte_size, byte_width);
        has_busy                = p_cp->get_bool("DataROM0HasBusy");
        cbox                    = p_cp->get_bool("HasCBox");
        if (!use_memport_pin_had_ls && !cbox) {
          num_ports             = p_cp->get_u32("LoadStoreUnitCount");
        }
        break;
      }
      case xtsc_core::MEM_URAM0: {
        if (p_cp->get_u32("UnifiedRAMCount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("InstFetchByteWidth");
        start_byte_address      = p_cp->get_u32("UnifiedRAM0BaseAddress");
        memory_byte_size        = p_cp->get_u32("UnifiedRAM0ByteSize");
        address_bits            = compute_address_bits(memory_byte_size, byte_width);
        has_busy                = p_cp->get_bool("UnifiedRAM0HasBusy");
        num_ports               = p_cp->get_u32("LoadStoreUnitCount");
        break;
      }
      case xtsc_core::MEM_XLMI0LS1:
      case xtsc_core::MEM_XLMI0LS0: {
        if (p_cp->get_u32("XLMICount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("LoadStoreByteWidth");
        start_byte_address      = p_cp->get_u32("XLMI0BaseAddress");
        memory_byte_size        = p_cp->get_u32("XLMI0ByteSize");
        has_busy                = p_cp->get_bool("XLMI0HasBusy");
        if (!use_memport_pin_had_ls) {
          num_ports             = p_cp->get_u32("LoadStoreUnitCount");
        }
        break;
      }
      default: {
        ostringstream oss;
        oss << "ERROR: Unrecognized memory port number (" << use_memport_pin << ") in init_memory_pin_parms().";
        throw xtsc_exception(oss.str());
      }
    }

    name_memory_pin_parms = "memory_pin_parms__@";
    p_memory_pin_parms = new xtsc_memory_pin_parms(memory_interface, byte_width, address_bits, delay, num_ports);
    ostringstream args;
    args << "(" << "\"" << memory_interface << "\", " << byte_width << ", " << address_bits << ", " << delay << ", " << num_ports
         << ")";
    memory_pin_parms_args = args.str();

    p_memory_pin_parms->set("big_endian",               big_endian);
    p_memory_pin_parms->set("start_byte_address",       start_byte_address);
    p_memory_pin_parms->set("memory_byte_size",         memory_byte_size);
    p_memory_pin_parms->set("has_busy",                 has_busy);
    p_memory_pin_parms->set("has_lock",                 has_lock);
    p_memory_pin_parms->set("check_bits",               check_bits);
    p_memory_pin_parms->set("has_pif_attribute",        has_pif_attribute);
    p_memory_pin_parms->set("cbox",                     cbox);

    oss_memory_pin_parms << tab2 << name_memory_pin_parms << ".set(\"big_endian\",         " << boolalpha << big_endian << ");"
                         << endl;
    oss_memory_pin_parms << tab2 << name_memory_pin_parms << ".set(\"start_byte_address\", 0x" << hex << start_byte_address << ");"
                         << endl;
    oss_memory_pin_parms << tab2 << name_memory_pin_parms << ".set(\"memory_byte_size\",   0x" << hex << memory_byte_size << ");"
                         << endl;
    oss_memory_pin_parms << tab2 << name_memory_pin_parms << ".set(\"has_busy\",           " << boolalpha << has_busy << ");" << endl;
    oss_memory_pin_parms << tab2 << name_memory_pin_parms << ".set(\"has_lock\",           " << boolalpha << has_lock << ");" << endl;
    oss_memory_pin_parms << tab2 << name_memory_pin_parms << ".set(\"check_bits\",         " << dec       << check_bits     << ");" << endl;
    oss_memory_pin_parms << tab2 << name_memory_pin_parms << ".set(\"has_pif_attribute\",  " << boolalpha << has_pif_attribute << ");" << endl;
    oss_memory_pin_parms << tab2 << name_memory_pin_parms << ".set(\"cbox\",               " << boolalpha << cbox << ");" << endl;
  }
}



void show_memory_pin_parms() {
  XTSC_TRACE(logger, "enter show_memory_pin_parms()");
  init_memory_pin_parms();
  cout << "Parameters for memory_pin: " << endl;
  p_memory_pin_parms->dump(cout);
}



void add_memory_pin_parm() {
  XTSC_TRACE(logger, "enter add_memory_pin_parm()");
  init_memory_pin_parms();
  parm_split(*p_memory_pin_parms);
  p_oss_parms = &oss_memory_pin_parms;
  p_name_module_parms = &name_memory_pin_parms;
  add_parm(*p_memory_pin_parms);
}



void create_memory_pin(const string& name) {
  XTSC_TRACE(logger, "enter create_memory_pin()");
  init_memory_pin_parms();
  string memory_pin_name = (name == "" ? p_memory_pin_parms->get_c_str("memory_interface") : name);
  validate_name(memory_pin_name, "memory_pin");
  if (memory_pin_map[w]->find(memory_pin_name) != memory_pin_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create memory_pin with the same name as an already existing memory_pin: " << memory_pin_name;
    throw xtsc_exception(oss.str());
  }
  (*memory_pin_map[w])[memory_pin_name] = new memory_pin_info(memory_pin_name, *p_memory_pin_parms);
  fini_memory_pin_parms();
}



void fini_memory_pin_parms() {
  XTSC_TRACE(logger, "enter fini_memory_pin_parms()");
  if (p_memory_pin_parms) {
    delete p_memory_pin_parms;
    p_memory_pin_parms = NULL;
    oss_memory_pin_parms.str("");
  }
}



memory_pin_info& find_or_infer_memory_pin(const string& memory_pin_name) {
  XTSC_TRACE(logger, "enter find_or_infer_memory_pin()");
  map<string,memory_pin_info*>::iterator is = memory_pin_map[w]->find(memory_pin_name);
  if (is == memory_pin_map[w]->end()) {
    // Infer a memory_pin with this name
    create_memory_pin(memory_pin_name);
    is = memory_pin_map[w]->find(memory_pin_name);
    if (is == memory_pin_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred memory_pin '" << memory_pin_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *is->second;
}



void init_memory_trace_parms() {
  XTSC_TRACE(logger, "enter init_memory_trace_parms()");
  if (!p_memory_trace_parms) {
    confirm_building_system();
    if (!XTENSA_CORE || !XTENSA_CORE[0]) {
      name_memory_trace_parms = "memory_trace_parms__@";
      p_memory_trace_parms = new xtsc_memory_trace_parms();
      memory_trace_parms_args = "";
      return;
    }

    init_core_parms(false);
    xtsc_core_parms * p_cp = p_core_parms;

    u32         byte_width              = 0;
    bool        big_endian              = p_cp->get_bool("IsBigEndian");
    u32         num_ports               = 1;
    bool        cbox                    = false;

    switch (use_memport) {
      case xtsc_core::MEM_PIF: {
        if (!p_cp->get_bool("HasPIF")) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("PIFByteWidth");
        break;
      }
      case xtsc_core::MEM_IRAM0: {
        if (p_cp->get_u32("InstRAMCount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("InstFetchByteWidth");
        break;
      }
      case xtsc_core::MEM_IRAM1: {
        if (p_cp->get_u32("InstRAMCount") < 2) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("InstFetchByteWidth");
        break;
      }
      case xtsc_core::MEM_IROM0: {
        if (p_cp->get_u32("InstROMCount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("InstFetchByteWidth");
        break;
      }
      case xtsc_core::MEM_DRAM0LS1:
      case xtsc_core::MEM_DRAM0LS0: {
        if (p_cp->get_u32("DataRAMCount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("LoadStoreByteWidth");
        cbox                    = p_cp->get_bool("HasCBox");
        if (!use_memport_pin_had_ls && !cbox) {
          num_ports             = p_cp->get_u32("LoadStoreUnitCount");
        }
        break;
      }
      case xtsc_core::MEM_DRAM1LS1:
      case xtsc_core::MEM_DRAM1LS0: {
        if (p_cp->get_u32("DataRAMCount") < 2) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("LoadStoreByteWidth");
        cbox                    = p_cp->get_bool("HasCBox");
        if (!use_memport_pin_had_ls && !cbox) {
          num_ports             = p_cp->get_u32("LoadStoreUnitCount");
        }
        break;
      }
      case xtsc_core::MEM_DROM0LS1:
      case xtsc_core::MEM_DROM0LS0: {
        if (p_cp->get_u32("DataROMCount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("LoadStoreByteWidth");
        cbox                    = p_cp->get_bool("HasCBox");
        if (!use_memport_pin_had_ls && !cbox) {
          num_ports             = p_cp->get_u32("LoadStoreUnitCount");
        }
        break;
      }
      case xtsc_core::MEM_URAM0: {
        if (p_cp->get_u32("UnifiedRAMCount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("InstFetchByteWidth");
        num_ports               = p_cp->get_u32("LoadStoreUnitCount");
        break;
      }
      case xtsc_core::MEM_XLMI0LS1:
      case xtsc_core::MEM_XLMI0LS0: {
        if (p_cp->get_u32("XLMICount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("LoadStoreByteWidth");
        if (!use_memport_pin_had_ls) {
          num_ports             = p_cp->get_u32("LoadStoreUnitCount");
        }
        break;
      }
      default: {
        ostringstream oss;
        oss << "ERROR: Unrecognized memory port number (" << use_memport << ") in init_memory_trace_parms().";
        throw xtsc_exception(oss.str());
      }
    }

    name_memory_trace_parms = "memory_trace_parms__@";
    p_memory_trace_parms = new xtsc_memory_trace_parms(byte_width, big_endian, 0, num_ports);
    ostringstream args;
    args << "(" << byte_width << ", " << big_endian << ", 0, " << num_ports << ")";
    memory_trace_parms_args = args.str();
  }
}



void show_memory_trace_parms() {
  XTSC_TRACE(logger, "enter show_memory_trace_parms()");
  init_memory_trace_parms();
  cout << "Parameters for memory_trace: " << endl;
  p_memory_trace_parms->dump(cout);
}



void add_memory_trace_parm() {
  XTSC_TRACE(logger, "enter add_memory_trace_parm()");
  init_memory_trace_parms();
  parm_split(*p_memory_trace_parms);
  p_oss_parms = &oss_memory_trace_parms;
  p_name_module_parms = &name_memory_trace_parms;
  add_parm(*p_memory_trace_parms);
}



void create_memory_trace(const string& name) {
  XTSC_TRACE(logger, "enter create_memory_trace()");
  init_memory_trace_parms();
  string trace_name = (name == "" ? p_memory_trace_parms->get_c_str("memory_interface") : name);
  validate_name(trace_name, "memory_trace");
  if (memory_trace_map[w]->find(trace_name) != memory_trace_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create memory_trace with the same name as an already existing memory_trace: " << trace_name;
    throw xtsc_exception(oss.str());
  }
  (*memory_trace_map[w])[trace_name] = new memory_trace_info(trace_name, *p_memory_trace_parms);
  fini_memory_trace_parms();
}



void fini_memory_trace_parms() {
  XTSC_TRACE(logger, "enter fini_memory_trace_parms()");
  if (p_memory_trace_parms) {
    delete p_memory_trace_parms;
    p_memory_trace_parms = NULL;
    oss_memory_trace_parms.str("");
  }
}



memory_trace_info& find_or_infer_memory_trace(const string& trace_name) {
  XTSC_TRACE(logger, "enter find_or_infer_memory_trace()");
  map<string,memory_trace_info*>::iterator is = memory_trace_map[w]->find(trace_name);
  if (is == memory_trace_map[w]->end()) {
    // Infer a memory_trace with this name
    create_memory_trace(trace_name);
    is = memory_trace_map[w]->find(trace_name);
    if (is == memory_trace_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred memory_trace '" << trace_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *is->second;
}



void init_mmio_parms() {
  XTSC_TRACE(logger, "enter init_mmio_parms()");
  if (!p_mmio_parms) {
    confirm_building_system();
    name_mmio_parms = "mmio_parms__@";
    p_mmio_parms = new xtsc_mmio_parms("");
  }
}



void show_mmio_parms() {
  XTSC_TRACE(logger, "enter show_mmio_parms()");
  init_mmio_parms();
  cout << "Parameters for mmio: " << endl;
  p_mmio_parms->dump(cout);
}



void add_mmio_parm() {
  XTSC_TRACE(logger, "enter add_mmio_parm()");
  init_mmio_parms();
  parm_split(*p_mmio_parms);
  p_oss_parms = &oss_mmio_parms;
  p_name_module_parms = &name_mmio_parms;
  add_parm(*p_mmio_parms);
}



void create_mmio(const string& name) {
  XTSC_TRACE(logger, "enter create_mmio()");
  init_mmio_parms();
  string mmio_name = (name == "" ? "mmio" : name);
  validate_name(mmio_name, "mmio");
  if (mmio_map[w]->find(mmio_name) != mmio_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create mmio with the same name as an already existing mmio: " << mmio_name;
    throw xtsc_exception(oss.str());
  }
  (*mmio_map[w])[mmio_name] = new mmio_info(mmio_name, *p_mmio_parms);
  fini_mmio_parms();
}



void fini_mmio_parms() {
  XTSC_TRACE(logger, "enter fini_mmio_parms()");
  if (p_mmio_parms) {
    delete p_mmio_parms;
    p_mmio_parms = NULL;
    oss_mmio_parms.str("");
  }
}



mmio_info& find_or_infer_mmio(const string& mmio_name) {
  XTSC_TRACE(logger, "enter find_or_infer_mmio()");
  map<string,mmio_info*>::iterator ia = mmio_map[w]->find(mmio_name);
  if (ia == mmio_map[w]->end()) {
    // Infer a mmio with this name
    create_mmio(mmio_name);
    ia = mmio_map[w]->find(mmio_name);
    if (ia == mmio_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred mmio '" << mmio_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *ia->second;
}



void init_pin2tlm_parms() {
  XTSC_TRACE(logger, "enter init_pin2tlm_parms()");
  if (!p_pin2tlm_parms) {
    confirm_building_system();
    if (!XTENSA_CORE || !XTENSA_CORE[0]) {
      name_pin2tlm_parms = "pin2tlm_parms__@";
      p_pin2tlm_parms = new xtsc_pin2tlm_memory_transactor_parms();
      pin2tlm_parms_args = "";
      return;
    }

    init_core_parms();
    xtsc_core_parms * p_cp = p_core_parms;

    const char *memory_interface        = xtsc_core::get_memory_port_name(use_memport_pin, true);
    bool        big_endian              = p_cp->get_bool("IsBigEndian");
    u32         num_ports               = 1;
    u32         byte_width              = 0;
    u32         start_byte_address      = 0;
    u32         memory_byte_size        = 0;
    bool        has_busy                = false;
    bool        has_lock                = false;
    u32         address_bits            = 32;
    u32         check_bits              = 0;
    bool        has_pif_attribute       = false;
    bool        cbox                    = false;

    switch (use_memport_pin) {
      case xtsc_core::MEM_PIF: {
        if (!p_cp->get_bool("HasPIF")) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("PIFByteWidth");
        has_pif_attribute       = (p_cp->get_u32("PIFVersion") >= 32);
        break;
      }
      case xtsc_core::MEM_IRAM0: {
        if (p_cp->get_u32("InstRAMCount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("InstFetchByteWidth");
        start_byte_address      = p_cp->get_u32("InstRAM0BaseAddress");
        memory_byte_size        = p_cp->get_u32("InstRAM0ByteSize");
        address_bits            = compute_address_bits(memory_byte_size, byte_width);
        has_busy                = p_cp->get_bool("InstRAM0HasBusy");
        check_bits              = p_cp->get_bool("InstRAM0HasECC") ? byte_width*7/4 : p_cp->get_bool("InstRAM0HasParity") ? 1 : 0;
        break;
      }
      case xtsc_core::MEM_IRAM1: {
        if (p_cp->get_u32("InstRAMCount") < 2) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("InstFetchByteWidth");
        start_byte_address      = p_cp->get_u32("InstRAM1BaseAddress");
        memory_byte_size        = p_cp->get_u32("InstRAM1ByteSize");
        address_bits            = compute_address_bits(memory_byte_size, byte_width);
        has_busy                = p_cp->get_bool("InstRAM1HasBusy");
        check_bits              = p_cp->get_bool("InstRAM1HasECC") ? byte_width*7/4 : p_cp->get_bool("InstRAM1HasParity") ? 1 : 0;
        break;
      }
      case xtsc_core::MEM_IROM0: {
        if (p_cp->get_u32("InstROMCount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("InstFetchByteWidth");
        start_byte_address      = p_cp->get_u32("InstROM0BaseAddress");
        memory_byte_size        = p_cp->get_u32("InstROM0ByteSize");
        address_bits            = compute_address_bits(memory_byte_size, byte_width);
        has_busy                = p_cp->get_bool("InstROM0HasBusy");
        break;
      }
      case xtsc_core::MEM_DRAM0LS1:
      case xtsc_core::MEM_DRAM0LS0: {
        if (p_cp->get_u32("DataRAMCount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("LoadStoreByteWidth");
        start_byte_address      = p_cp->get_u32("DataRAM0BaseAddress");
        memory_byte_size        = p_cp->get_u32("DataRAM0ByteSize");
        address_bits            = compute_address_bits(memory_byte_size, byte_width);
        has_busy                = p_cp->get_bool("DataRAM0HasBusy");
        has_lock                = p_cp->get_bool("DataRAM0HasRCW");
        check_bits              = p_cp->get_bool("DataRAM0HasECC") ? byte_width*5 : p_cp->get_bool("DataRAM0HasParity") ? 1 : 0;
        cbox                    = p_cp->get_bool("HasCBox");
        if (!use_memport_pin_had_ls && !cbox) {
          num_ports             = p_cp->get_u32("LoadStoreUnitCount");
        }
        break;
      }
      case xtsc_core::MEM_DRAM1LS1:
      case xtsc_core::MEM_DRAM1LS0: {
        if (p_cp->get_u32("DataRAMCount") < 2) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("LoadStoreByteWidth");
        start_byte_address      = p_cp->get_u32("DataRAM1BaseAddress");
        memory_byte_size        = p_cp->get_u32("DataRAM1ByteSize");
        address_bits            = compute_address_bits(memory_byte_size, byte_width);
        has_busy                = p_cp->get_bool("DataRAM1HasBusy");
        has_lock                = p_cp->get_bool("DataRAM1HasRCW");
        check_bits              = p_cp->get_bool("DataRAM1HasECC") ? byte_width*5 : p_cp->get_bool("DataRAM1HasParity") ? 1 : 0;
        cbox                    = p_cp->get_bool("HasCBox");
        if (!use_memport_pin_had_ls && !cbox) {
          num_ports             = p_cp->get_u32("LoadStoreUnitCount");
        }
        break;
      }
      case xtsc_core::MEM_DROM0LS1:
      case xtsc_core::MEM_DROM0LS0: {
        if (p_cp->get_u32("DataROMCount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("LoadStoreByteWidth");
        start_byte_address      = p_cp->get_u32("DataROM0BaseAddress");
        memory_byte_size        = p_cp->get_u32("DataROM0ByteSize");
        address_bits            = compute_address_bits(memory_byte_size, byte_width);
        has_busy                = p_cp->get_bool("DataROM0HasBusy");
        cbox                    = p_cp->get_bool("HasCBox");
        if (!use_memport_pin_had_ls && !cbox) {
          num_ports             = p_cp->get_u32("LoadStoreUnitCount");
        }
        break;
      }
      case xtsc_core::MEM_URAM0: {
        if (p_cp->get_u32("UnifiedRAMCount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("InstFetchByteWidth");
        start_byte_address      = p_cp->get_u32("UnifiedRAM0BaseAddress");
        memory_byte_size        = p_cp->get_u32("UnifiedRAM0ByteSize");
        address_bits            = compute_address_bits(memory_byte_size, byte_width);
        has_busy                = p_cp->get_bool("UnifiedRAM0HasBusy");
        num_ports               = p_cp->get_u32("LoadStoreUnitCount");
        break;
      }
      case xtsc_core::MEM_XLMI0LS1:
      case xtsc_core::MEM_XLMI0LS0: {
        if (p_cp->get_u32("XLMICount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("LoadStoreByteWidth");
        start_byte_address      = p_cp->get_u32("XLMI0BaseAddress");
        memory_byte_size        = p_cp->get_u32("XLMI0ByteSize");
        has_busy                = p_cp->get_bool("XLMI0HasBusy");
        if (!use_memport_pin_had_ls) {
          num_ports             = p_cp->get_u32("LoadStoreUnitCount");
        }
        break;
      }
      default: {
        ostringstream oss;
        oss << "ERROR: Unrecognized memory port number (" << use_memport_pin << ") in init_pin2tlm_parms().";
        throw xtsc_exception(oss.str());
      }
    }

    name_pin2tlm_parms = "pin2tlm_parms__@";
    p_pin2tlm_parms = new xtsc_pin2tlm_memory_transactor_parms(memory_interface, byte_width, address_bits, num_ports);
    ostringstream args;
    args << "(" << "\"" << memory_interface << "\", " << byte_width << ", " << address_bits << ", " << num_ports << ")";
    pin2tlm_parms_args = args.str();

    p_pin2tlm_parms->set("big_endian",               big_endian);
    p_pin2tlm_parms->set("start_byte_address",       start_byte_address);
    p_pin2tlm_parms->set("memory_byte_size",         memory_byte_size);
    p_pin2tlm_parms->set("has_busy",                 has_busy);
    p_pin2tlm_parms->set("has_lock",                 has_lock);
    p_pin2tlm_parms->set("check_bits",               check_bits);
    p_pin2tlm_parms->set("has_pif_attribute",        has_pif_attribute);
    p_pin2tlm_parms->set("cbox",                     cbox);

    oss_pin2tlm_parms << tab2 << name_pin2tlm_parms << ".set(\"big_endian\",         " << boolalpha << big_endian << ");" << endl;
    oss_pin2tlm_parms << tab2 << name_pin2tlm_parms << ".set(\"start_byte_address\", 0x" << hex << start_byte_address << ");" << endl;
    oss_pin2tlm_parms << tab2 << name_pin2tlm_parms << ".set(\"memory_byte_size\",   0x" << hex << memory_byte_size << ");" << endl;
    oss_pin2tlm_parms << tab2 << name_pin2tlm_parms << ".set(\"has_busy\",           " << boolalpha << has_busy << ");" << endl;
    oss_pin2tlm_parms << tab2 << name_pin2tlm_parms << ".set(\"has_lock\",           " << boolalpha << has_lock << ");" << endl;
    oss_pin2tlm_parms << tab2 << name_pin2tlm_parms << ".set(\"check_bits\",         " << dec       << check_bits     << ");" << endl;
    oss_pin2tlm_parms << tab2 << name_pin2tlm_parms << ".set(\"has_pif_attribute\",  " << boolalpha << has_pif_attribute << ");" << endl;
    oss_pin2tlm_parms << tab2 << name_pin2tlm_parms << ".set(\"cbox\",               " << boolalpha << cbox << ");" << endl;
  }
}



void show_pin2tlm_parms() {
  XTSC_TRACE(logger, "enter show_pin2tlm_parms()");
  init_pin2tlm_parms();
  cout << "Parameters for pin2tlm: " << endl;
  p_pin2tlm_parms->dump(cout);
}



void add_pin2tlm_parm() {
  XTSC_TRACE(logger, "enter add_pin2tlm_parm()");
  init_pin2tlm_parms();
  parm_split(*p_pin2tlm_parms);
  p_oss_parms = &oss_pin2tlm_parms;
  p_name_module_parms = &name_pin2tlm_parms;
  add_parm(*p_pin2tlm_parms);
}



void create_pin2tlm(const string& name) {
  XTSC_TRACE(logger, "enter create_pin2tlm()");
  init_pin2tlm_parms();
  string interface_name = p_pin2tlm_parms->get_c_str("memory_interface");
  string pin2tlm_name = (name == "" ? (interface_name + "_pin2tlm") : name);
  validate_name(pin2tlm_name, "pin2tlm");
  if (pin2tlm_map[w]->find(pin2tlm_name) != pin2tlm_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create pin2tlm with the same name as an already existing pin2tlm: " << pin2tlm_name;
    throw xtsc_exception(oss.str());
  }
  (*pin2tlm_map[w])[pin2tlm_name] = new pin2tlm_info(pin2tlm_name, *p_pin2tlm_parms);
  fini_pin2tlm_parms();
}



void fini_pin2tlm_parms() {
  XTSC_TRACE(logger, "enter fini_pin2tlm_parms()");
  if (p_pin2tlm_parms) {
    delete p_pin2tlm_parms;
    p_pin2tlm_parms = NULL;
    oss_pin2tlm_parms.str("");
  }
}



pin2tlm_info& find_or_infer_pin2tlm(const string& pin2tlm_name) {
  XTSC_TRACE(logger, "enter find_or_infer_pin2tlm()");
  map<string,pin2tlm_info*>::iterator it = pin2tlm_map[w]->find(pin2tlm_name);
  if (it == pin2tlm_map[w]->end()) {
    // Infer a pin2tlm with this name
    create_pin2tlm(pin2tlm_name);
    it = pin2tlm_map[w]->find(pin2tlm_name);
    if (it == pin2tlm_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred pin2tlm '" << pin2tlm_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *it->second;
}



void init_producer_parms() {
  XTSC_TRACE(logger, "enter init_producer_parms()");
  if (!p_producer_parms) {
    confirm_building_system();
    name_producer_parms = "producer_parms__@";
    p_producer_parms = new xtsc_queue_producer_parms();
  }
}



void show_producer_parms() {
  XTSC_TRACE(logger, "enter show_producer_parms()");
  init_producer_parms();
  cout << "Parameters for producer: " << endl;
  p_producer_parms->dump(cout);
}



void add_producer_parm() {
  XTSC_TRACE(logger, "enter add_producer_parm()");
  init_producer_parms();
  parm_split(*p_producer_parms);
  p_oss_parms = &oss_producer_parms;
  p_name_module_parms = &name_producer_parms;
  add_parm(*p_producer_parms);
}



void create_producer(const string& name) {
  XTSC_TRACE(logger, "enter create_producer()");
  init_producer_parms();
  string producer_name = (name == "" ? "producer" : name);
  validate_name(producer_name, "producer");
  if (producer_map[w]->find(producer_name) != producer_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create producer with the same name as an already existing producer: " << producer_name;
    throw xtsc_exception(oss.str());
  }
  (*producer_map[w])[producer_name] = new producer_info(producer_name, *p_producer_parms);
  fini_producer_parms();
}



void fini_producer_parms() {
  XTSC_TRACE(logger, "enter fini_producer_parms()");
  if (p_producer_parms) {
    delete p_producer_parms;
    p_producer_parms = NULL;
    oss_producer_parms.str("");
  }
}



producer_info& find_or_infer_producer(const string& producer_name) {
  XTSC_TRACE(logger, "enter find_or_infer_producer()");
  map<string,producer_info*>::iterator ip = producer_map[w]->find(producer_name);
  if (ip == producer_map[w]->end()) {
    // Infer a producer with this name
    create_producer(producer_name);
    ip = producer_map[w]->find(producer_name);
    if (ip == producer_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred producer '" << producer_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *ip->second;
}



void init_proxy_parms(bool require_cosim) {
  XTSC_TRACE(logger, "enter init_proxy_parms()");
  if (require_cosim) { confirm_systemc_on_top(); }
  if (!p_proxy_parms) {
    if (require_cosim) { confirm_building_system(); }
    name_proxy_parms = "proxy_parms__@";
    p_proxy_parms = new proxy_parms();
  }
}



void show_proxy_parms() {
  XTSC_TRACE(logger, "enter show_proxy_parms()");
  init_proxy_parms(false);
  cout << "Parameters for Verilog proxy: " << endl;
  p_proxy_parms->dump(cout);
  cout << "Note: The proxy parameters are documented under --show_proxy_parms in Section IV" << endl;
  cout << "      of the xtsc-run RM (available by typing 'xtsc-run --man')." << endl;
}



void add_proxy_parm() {
  XTSC_TRACE(logger, "enter add_proxy_parm()");
  init_proxy_parms(true);
  parm_split(*p_proxy_parms);
  p_oss_parms = &oss_proxy_parms;
  p_name_module_parms = &name_proxy_parms;
  add_parm(*p_proxy_parms);
}



void create_proxy(const string& name) {
  XTSC_TRACE(logger, "enter create_proxy()");
  init_proxy_parms(true);
  string proxy_name = (name == "" ? "proxy" : name);
  validate_name(proxy_name, "proxy");
  if (proxy_map[w]->find(proxy_name) != proxy_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create proxy with the same name as an already existing proxy: " << proxy_name;
    throw xtsc_exception(oss.str());
  }
  const char *module_name = p_proxy_parms->get_c_str("module_name");
  if (!module_name || !module_name[0]) {
    p_proxy_parms->set("module_name", proxy_name.c_str());
  }
  proxy_info &proxy = *new proxy_info(proxy_name, *p_proxy_parms);
  (*proxy_map[w])[proxy_name] = &proxy;
  add_extra_io_to_proxy(proxy, true);
  add_extra_io_to_proxy(proxy, false);
  fini_proxy_parms();
}



void fini_proxy_parms() {
  XTSC_TRACE(logger, "enter fini_proxy_parms()");
  if (p_proxy_parms) {
    delete p_proxy_parms;
    p_proxy_parms = NULL;
    oss_proxy_parms.str("");
  }
}



proxy_info& find_or_infer_proxy(const string& proxy_name) {
  XTSC_TRACE(logger, "enter find_or_infer_proxy()");
  confirm_systemc_on_top();
  map<string,proxy_info*>::iterator iq = proxy_map[w]->find(proxy_name);
  if (iq == proxy_map[w]->end()) {
    // Infer a proxy with this name
    create_proxy(proxy_name);
    iq = proxy_map[w]->find(proxy_name);
    if (iq == proxy_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred proxy '" << proxy_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *iq->second;
}



void init_queue_parms() {
  XTSC_TRACE(logger, "enter init_queue_parms()");
  if (!p_queue_parms) {
    confirm_building_system();
    name_queue_parms = "queue_parms__@";
    p_queue_parms = new xtsc_queue_parms();
  }
}



void show_queue_parms() {
  XTSC_TRACE(logger, "enter show_queue_parms()");
  init_queue_parms();
  cout << "Parameters for queue: " << endl;
  p_queue_parms->dump(cout);
}



void add_queue_parm() {
  XTSC_TRACE(logger, "enter add_queue_parm()");
  init_queue_parms();
  parm_split(*p_queue_parms);
  p_oss_parms = &oss_queue_parms;
  p_name_module_parms = &name_queue_parms;
  add_parm(*p_queue_parms);
}



void create_queue(const string& name, const string& tie_name) {
  XTSC_TRACE(logger, "enter create_queue()");
  init_queue_parms();
  string queue_name = (name == "" ? "queue" : name);
  validate_name(queue_name, "queue");
  if (queue_map[w]->find(queue_name) != queue_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create queue with the same name as an already existing queue: " << queue_name;
    throw xtsc_exception(oss.str());
  }
  // If tie_name is specified, then match its bit width
  if (tie_name != "") {
    if (last_core_created == "") {
      ostringstream oss;
      oss << "ERROR: No core has been created to find TIE port '" << tie_name << "' on in command ";
      command_info(oss);
      throw xtsc_exception(oss.str());
    }
    map<string,core_info*>::iterator ic = core_map[w]->find(last_core_created);
    if (ic == core_map[w]->end()) {
      ostringstream oss;
      oss << "PROGRAM BUG: Can't find last created core '" << last_core_created << "'.";
      throw xtsc_exception(oss.str());
    }
    // Does this core have a queue named tie_name?
    if (!ic->second->p_core->has_input_queue(tie_name.c_str()) && !ic->second->p_core->has_output_queue(tie_name.c_str())) {
      ostringstream oss;
      oss << "Core '" << last_core_created << "' has no TIE queue named '" << tie_name << "'.";
      throw xtsc_exception(oss.str());
    }
    // Yes, so match its bit width
    update_parm_u32(*p_queue_parms, "bit_width", ic->second->p_core->get_tie_bit_width(tie_name.c_str()),
                    oss_queue_parms, name_queue_parms);
  }
  (*queue_map[w])[queue_name] = new queue_info(queue_name, *p_queue_parms);
  fini_queue_parms();
}



void fini_queue_parms() {
  XTSC_TRACE(logger, "enter fini_queue_parms()");
  if (p_queue_parms) {
    delete p_queue_parms;
    p_queue_parms = NULL;
    oss_queue_parms.str("");
  }
}



queue_info& find_or_infer_queue(const string& queue_name) {
  XTSC_TRACE(logger, "enter find_or_infer_queue()");
  map<string,queue_info*>::iterator iq = queue_map[w]->find(queue_name);
  if (iq == queue_map[w]->end()) {
    // Infer a queue with this name
    create_queue(queue_name, "");
    iq = queue_map[w]->find(queue_name);
    if (iq == queue_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred queue '" << queue_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *iq->second;
}



void init_queue_pin_parms() {
  XTSC_TRACE(logger, "enter init_queue_pin_parms()");
  if (!p_queue_pin_parms) {
    confirm_building_system();
    name_queue_pin_parms = "queue_pin_parms__@";
    p_queue_pin_parms = new xtsc_queue_pin_parms();
  }
}



void show_queue_pin_parms() {
  XTSC_TRACE(logger, "enter show_queue_pin_parms()");
  init_queue_pin_parms();
  cout << "Parameters for queue_pin: " << endl;
  p_queue_pin_parms->dump(cout);
}



void add_queue_pin_parm() {
  XTSC_TRACE(logger, "enter add_queue_pin_parm()");
  init_queue_pin_parms();
  parm_split(*p_queue_pin_parms);
  p_oss_parms = &oss_queue_pin_parms;
  p_name_module_parms = &name_queue_pin_parms;
  add_parm(*p_queue_pin_parms);
}



void create_queue_pin(const string& name, const string& tie_name) {
  XTSC_TRACE(logger, "enter create_queue_pin()");
  init_queue_pin_parms();
  string queue_pin_name = (name == "" ? "queue" : name);
  validate_name(queue_pin_name, "queue_pin");
  if (queue_pin_map[w]->find(queue_pin_name) != queue_pin_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create queue_pin with the same name as an already existing queue_pin: " << queue_pin_name;
    throw xtsc_exception(oss.str());
  }
  // If tie_name is specified, then match its bit width
  if (tie_name != "") {
    if (last_core_created == "") {
      ostringstream oss;
      oss << "ERROR: No core has been created to find TIE port '" << tie_name << "' on in command ";
      command_info(oss);
      throw xtsc_exception(oss.str());
    }
    map<string,core_info*>::iterator ic = core_map[w]->find(last_core_created);
    if (ic == core_map[w]->end()) {
      ostringstream oss;
      oss << "PROGRAM BUG: Can't find last created core '" << last_core_created << "'.";
      throw xtsc_exception(oss.str());
    }
    // Does this core have a queue named tie_name?
    if (!ic->second->p_core->has_pin_level_input_queue (tie_name.c_str()) &&
        !ic->second->p_core->has_pin_level_output_queue(tie_name.c_str()))
    {
      ostringstream oss;
      oss << "Core '" << last_core_created << "' has no pin-level TIE queue named '" << tie_name << "'.";
      throw xtsc_exception(oss.str());
    }
    // Yes, so match its bit width
    update_parm_u32(*p_queue_pin_parms, "bit_width", ic->second->p_core->get_pin_bit_width(("TIE_" + tie_name).c_str()),
                    oss_queue_pin_parms, name_queue_pin_parms);
  }
  (*queue_pin_map[w])[queue_pin_name] = new queue_pin_info(queue_pin_name, *p_queue_pin_parms);
  fini_queue_pin_parms();
}



void fini_queue_pin_parms() {
  XTSC_TRACE(logger, "enter fini_queue_pin_parms()");
  if (p_queue_pin_parms) {
    delete p_queue_pin_parms;
    p_queue_pin_parms = NULL;
    oss_queue_pin_parms.str("");
  }
}



queue_pin_info& find_or_infer_queue_pin(const string& queue_pin_name) {
  XTSC_TRACE(logger, "enter find_or_infer_queue_pin()");
  map<string,queue_pin_info*>::iterator iq = queue_pin_map[w]->find(queue_pin_name);
  if (iq == queue_pin_map[w]->end()) {
    // Infer a queue_pin with this name
    create_queue_pin(queue_pin_name, "");
    iq = queue_pin_map[w]->find(queue_pin_name);
    if (iq == queue_pin_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred queue_pin '" << queue_pin_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *iq->second;
}



void init_router_parms() {
  XTSC_TRACE(logger, "enter init_router_parms()");
  if (!p_router_parms) {
    confirm_building_system();
    name_router_parms = "router_parms__@";
    p_router_parms = new xtsc_router_parms();
  }
}



void show_router_parms() {
  XTSC_TRACE(logger, "enter show_router_parms()");
  init_router_parms();
  cout << "Parameters for router: " << endl;
  p_router_parms->dump(cout);
}



void add_router_parm() {
  XTSC_TRACE(logger, "enter add_router_parm()");
  init_router_parms();
  parm_split(*p_router_parms);
  p_oss_parms = &oss_router_parms;
  p_name_module_parms = &name_router_parms;
  add_parm(*p_router_parms);
}



void create_router(const string& name) {
  XTSC_TRACE(logger, "enter create_router()");
  init_router_parms();
  string router_name = (name == "" ? "router" : name);
  validate_name(router_name, "router");
  if (router_map[w]->find(router_name) != router_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create router with the same name as an already existing router: " << router_name;
    throw xtsc_exception(oss.str());
  }
  (*router_map[w])[router_name] = new router_info(router_name, *p_router_parms);
  fini_router_parms();
}



void fini_router_parms() {
  XTSC_TRACE(logger, "enter fini_router_parms()");
  if (p_router_parms) {
    delete p_router_parms;
    p_router_parms = NULL;
    oss_router_parms.str("");
  }
}



router_info& find_or_infer_router(const string& router_name) {
  XTSC_TRACE(logger, "enter find_or_infer_router()");
  map<string,router_info*>::iterator ir = router_map[w]->find(router_name);
  if (ir == router_map[w]->end()) {
    // Infer a router with this name
    create_router(router_name);
    ir = router_map[w]->find(router_name);
    if (ir == router_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred router '" << router_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *ir->second;
}



void init_signal_parms() {
  XTSC_TRACE(logger, "enter init_signal_parms()");
  if (!p_signal_parms) {
    confirm_building_system();
    name_signal_parms = "signal_parms__@";
    p_signal_parms = new signal_parms();
  }
}



void show_signal_parms() {
  XTSC_TRACE(logger, "enter show_signal_parms()");
  init_signal_parms();
  cout << "Parameters for signal: " << endl;
  p_signal_parms->dump(cout);
}



void add_signal_parm() {
  XTSC_TRACE(logger, "enter add_signal_parm()");
  init_signal_parms();
  parm_split(*p_signal_parms);
  p_oss_parms = &oss_signal_parms;
  p_name_module_parms = &name_signal_parms;
  add_parm(*p_signal_parms);
}



void create_signal(const string& name) {
  XTSC_TRACE(logger, "enter create_signal()");
  init_signal_parms();
  if (signal_map[w]->find(name) != signal_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create signal with the same identifier as an already existing signal: " << name;
    throw xtsc_exception(oss.str());
  }
  (*signal_map[w])[name] = new signal_info(name, *p_signal_parms);
  fini_signal_parms();
}



signal_info& find_or_infer_signal(const string& signal_name, u32 bit_width) {
  XTSC_TRACE(logger, "enter find_or_infer_signal()");
  map<string,signal_info*>::iterator is = signal_map[w]->find(signal_name);
  if (is == signal_map[w]->end()) {
    // Infer a signal with this name
    init_signal_parms();
    p_signal_parms->set("bit_width", bit_width);
    create_signal(signal_name);
    is = signal_map[w]->find(signal_name);
    if (is == signal_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred signal '" << signal_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  else {
    if (is->second->bit_width != bit_width) {
      ostringstream oss;
      oss << "ERROR: Inferred signal '" << signal_name << "' has bit_width=" << bit_width
          << ", but a signal with that name already exists with a bit_width=" << is->second->bit_width;
      throw xtsc_exception(oss.str());
    }
  }
  return *is->second;
}



void fini_signal_parms() {
  XTSC_TRACE(logger, "enter fini_signal_parms()");
  if (p_signal_parms) {
    delete p_signal_parms;
    p_signal_parms = NULL;
    oss_signal_parms.str("");
  }
}



void init_slave_parms() {
  XTSC_TRACE(logger, "enter init_slave_parms()");
  if (!p_slave_parms) {
    confirm_building_system();
    name_slave_parms = "slave_parms__@";
    p_slave_parms = new xtsc_slave_parms();
  }
}



void show_slave_parms() {
  XTSC_TRACE(logger, "enter show_slave_parms()");
  init_slave_parms();
  cout << "Parameters for slave: " << endl;
  p_slave_parms->dump(cout);
}



void add_slave_parm() {
  XTSC_TRACE(logger, "enter add_slave_parm()");
  init_slave_parms();
  parm_split(*p_slave_parms);
  p_oss_parms = &oss_slave_parms;
  p_name_module_parms = &name_slave_parms;
  add_parm(*p_slave_parms);
}



void create_slave(const string& name) {
  XTSC_TRACE(logger, "enter create_slave()");
  init_slave_parms();
  string slave_name = (name == "" ? "slave" : name);
  validate_name(slave_name, "slave");
  if (slave_map[w]->find(slave_name) != slave_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create slave with the same name as an already existing slave: " << slave_name;
    throw xtsc_exception(oss.str());
  }
  (*slave_map[w])[slave_name] = new slave_info(slave_name, *p_slave_parms);
  fini_slave_parms();
}



void fini_slave_parms() {
  XTSC_TRACE(logger, "enter fini_slave_parms()");
  if (p_slave_parms) {
    delete p_slave_parms;
    p_slave_parms = NULL;
    oss_slave_parms.str("");
  }
}



slave_info& find_or_infer_slave(const string& slave_name) {
  XTSC_TRACE(logger, "enter find_or_infer_slave()");
  map<string,slave_info*>::iterator is = slave_map[w]->find(slave_name);
  if (is == slave_map[w]->end()) {
    // Infer a slave with this name
    create_slave(slave_name);
    is = slave_map[w]->find(slave_name);
    if (is == slave_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred slave '" << slave_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *is->second;
}



void init_source_parms() {
  XTSC_TRACE(logger, "enter init_source_parms()");
  if (!p_source_parms) {
    confirm_building_system();
    name_source_parms = "source_parms__@";
    p_source_parms = new xtsc_wire_source_parms(1, "");
  }
}



void show_source_parms() {
  XTSC_TRACE(logger, "enter show_source_parms()");
  init_source_parms();
  cout << "Parameters for source: " << endl;
  p_source_parms->dump(cout);
}



void add_source_parm() {
  XTSC_TRACE(logger, "enter add_source_parm()");
  init_source_parms();
  parm_split(*p_source_parms);
  p_oss_parms = &oss_source_parms;
  p_name_module_parms = &name_source_parms;
  add_parm(*p_source_parms);
}



void create_source(const string& name) {
  XTSC_TRACE(logger, "enter create_source()");
  init_source_parms();
  string source_name = (name == "" ? "source" : name);
  validate_name(source_name, "source");
  if (source_map[w]->find(source_name) != source_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create source with the same name as an already existing source: " << source_name;
    throw xtsc_exception(oss.str());
  }
  (*source_map[w])[source_name] = new source_info(source_name, *p_source_parms);
  fini_source_parms();
}



void fini_source_parms() {
  XTSC_TRACE(logger, "enter fini_source_parms()");
  if (p_source_parms) {
    delete p_source_parms;
    p_source_parms = NULL;
    oss_source_parms.str("");
  }
}



source_info& find_or_infer_source(const string& source_name) {
  XTSC_TRACE(logger, "enter find_or_infer_source()");
  map<string,source_info*>::iterator is = source_map[w]->find(source_name);
  if (is == source_map[w]->end()) {
    // Infer a source with this name
    create_source(source_name);
    is = source_map[w]->find(source_name);
    if (is == source_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred source '" << source_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *is->second;
}



void init_tlm2pin_parms() {
  XTSC_TRACE(logger, "enter init_tlm2pin_parms()");
  if (!p_tlm2pin_parms) {
    confirm_building_system();
    if (!XTENSA_CORE || !XTENSA_CORE[0]) {
      name_tlm2pin_parms = "tlm2pin_parms__@";
      p_tlm2pin_parms = new xtsc_tlm2pin_memory_transactor_parms();
      tlm2pin_parms_args = "";
      return;
    }

    init_core_parms();
    xtsc_core_parms * p_cp = p_core_parms;

    const char *memory_interface        = xtsc_core::get_memory_port_name(use_memport_pin, true);
    bool        big_endian              = p_cp->get_bool("IsBigEndian");
    u32         num_ports               = 1;
    u32         byte_width              = 0;
    u32         start_byte_address      = 0;
    u32         memory_byte_size        = 0;
    bool        has_busy                = false;
    bool        has_lock                = false;
    u32         address_bits            = 32;
    u32         read_delay              = ((p_cp->get_u32("LocalMemoryLatency") == 2) ? 1 : 0);
    u32         check_bits              = 0;
    bool        has_pif_attribute       = false;
    bool        cbox                    = false;
    bool        write_responses         = !p_cp->get_bool("HasPIFWriteResponse");

    switch (use_memport_pin) {
      case xtsc_core::MEM_PIF: {
        if (!p_cp->get_bool("HasPIF")) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("PIFByteWidth");
        read_delay              = p_cp->get_u32("LocalMemoryLatency");
        has_pif_attribute       = (p_cp->get_u32("PIFVersion") >= 32);
        break;
      }
      case xtsc_core::MEM_IRAM0: {
        if (p_cp->get_u32("InstRAMCount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("InstFetchByteWidth");
        start_byte_address      = p_cp->get_u32("InstRAM0BaseAddress");
        memory_byte_size        = p_cp->get_u32("InstRAM0ByteSize");
        address_bits            = compute_address_bits(memory_byte_size, byte_width);
        has_busy                = p_cp->get_bool("InstRAM0HasBusy");
        check_bits              = p_cp->get_bool("InstRAM0HasECC") ? byte_width*7/4 : p_cp->get_bool("InstRAM0HasParity") ? 1 : 0;
        break;
      }
      case xtsc_core::MEM_IRAM1: {
        if (p_cp->get_u32("InstRAMCount") < 2) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("InstFetchByteWidth");
        start_byte_address      = p_cp->get_u32("InstRAM1BaseAddress");
        memory_byte_size        = p_cp->get_u32("InstRAM1ByteSize");
        address_bits            = compute_address_bits(memory_byte_size, byte_width);
        has_busy                = p_cp->get_bool("InstRAM1HasBusy");
        check_bits              = p_cp->get_bool("InstRAM1HasECC") ? byte_width*7/4 : p_cp->get_bool("InstRAM1HasParity") ? 1 : 0;
        break;
      }
      case xtsc_core::MEM_IROM0: {
        if (p_cp->get_u32("InstROMCount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("InstFetchByteWidth");
        start_byte_address      = p_cp->get_u32("InstROM0BaseAddress");
        memory_byte_size        = p_cp->get_u32("InstROM0ByteSize");
        address_bits            = compute_address_bits(memory_byte_size, byte_width);
        has_busy                = p_cp->get_bool("InstROM0HasBusy");
        break;
      }
      case xtsc_core::MEM_DRAM0LS1:
      case xtsc_core::MEM_DRAM0LS0: {
        if (p_cp->get_u32("DataRAMCount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("LoadStoreByteWidth");
        start_byte_address      = p_cp->get_u32("DataRAM0BaseAddress");
        memory_byte_size        = p_cp->get_u32("DataRAM0ByteSize");
        address_bits            = compute_address_bits(memory_byte_size, byte_width);
        has_busy                = p_cp->get_bool("DataRAM0HasBusy");
        has_lock                = p_cp->get_bool("DataRAM0HasRCW");
        check_bits              = p_cp->get_bool("DataRAM0HasECC") ? byte_width*5 : p_cp->get_bool("DataRAM0HasParity") ? 1 : 0;
        cbox                    = p_cp->get_bool("HasCBox");
        if (!use_memport_pin_had_ls && !cbox) {
          num_ports             = p_cp->get_u32("LoadStoreUnitCount");
        }
        break;
      }
      case xtsc_core::MEM_DRAM1LS1:
      case xtsc_core::MEM_DRAM1LS0: {
        if (p_cp->get_u32("DataRAMCount") < 2) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("LoadStoreByteWidth");
        start_byte_address      = p_cp->get_u32("DataRAM1BaseAddress");
        memory_byte_size        = p_cp->get_u32("DataRAM1ByteSize");
        address_bits            = compute_address_bits(memory_byte_size, byte_width);
        has_busy                = p_cp->get_bool("DataRAM1HasBusy");
        has_lock                = p_cp->get_bool("DataRAM1HasRCW");
        check_bits              = p_cp->get_bool("DataRAM1HasECC") ? byte_width*5 : p_cp->get_bool("DataRAM1HasParity") ? 1 : 0;
        cbox                    = p_cp->get_bool("HasCBox");
        if (!use_memport_pin_had_ls && !cbox) {
          num_ports             = p_cp->get_u32("LoadStoreUnitCount");
        }
        break;
      }
      case xtsc_core::MEM_DROM0LS1:
      case xtsc_core::MEM_DROM0LS0: {
        if (p_cp->get_u32("DataROMCount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("LoadStoreByteWidth");
        start_byte_address      = p_cp->get_u32("DataROM0BaseAddress");
        memory_byte_size        = p_cp->get_u32("DataROM0ByteSize");
        address_bits            = compute_address_bits(memory_byte_size, byte_width);
        has_busy                = p_cp->get_bool("DataROM0HasBusy");
        cbox                    = p_cp->get_bool("HasCBox");
        if (!use_memport_pin_had_ls && !cbox) {
          num_ports             = p_cp->get_u32("LoadStoreUnitCount");
        }
        break;
      }
      case xtsc_core::MEM_URAM0: {
        if (p_cp->get_u32("UnifiedRAMCount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("InstFetchByteWidth");
        start_byte_address      = p_cp->get_u32("UnifiedRAM0BaseAddress");
        memory_byte_size        = p_cp->get_u32("UnifiedRAM0ByteSize");
        address_bits            = compute_address_bits(memory_byte_size, byte_width);
        has_busy                = p_cp->get_bool("UnifiedRAM0HasBusy");
        num_ports               = p_cp->get_u32("LoadStoreUnitCount");
        break;
      }
      case xtsc_core::MEM_XLMI0LS1:
      case xtsc_core::MEM_XLMI0LS0: {
        if (p_cp->get_u32("XLMICount") < 1) throw_no_such_memory_port_pin();
        byte_width              = p_cp->get_u32("LoadStoreByteWidth");
        start_byte_address      = p_cp->get_u32("XLMI0BaseAddress");
        memory_byte_size        = p_cp->get_u32("XLMI0ByteSize");
        has_busy                = p_cp->get_bool("XLMI0HasBusy");
        if (!use_memport_pin_had_ls) {
          num_ports             = p_cp->get_u32("LoadStoreUnitCount");
        }
        break;
      }
      default: {
        ostringstream oss;
        oss << "ERROR: Unrecognized memory port number (" << use_memport_pin << ") in init_tlm2pin_parms().";
        throw xtsc_exception(oss.str());
      }
    }

    name_tlm2pin_parms = "tlm2pin_parms__@";
    p_tlm2pin_parms = new xtsc_tlm2pin_memory_transactor_parms(memory_interface, byte_width, address_bits, num_ports);
    ostringstream args;
    args << "(" << "\"" << memory_interface << "\", " << byte_width << ", " << address_bits << ", " << num_ports
         << ")";
    tlm2pin_parms_args = args.str();

    p_tlm2pin_parms->set("big_endian",               big_endian);
    p_tlm2pin_parms->set("start_byte_address",       start_byte_address);
    p_tlm2pin_parms->set("has_busy",                 has_busy);
    p_tlm2pin_parms->set("has_lock",                 has_lock);
    p_tlm2pin_parms->set("read_delay",               read_delay);
    p_tlm2pin_parms->set("check_bits",               check_bits);
    p_tlm2pin_parms->set("has_pif_attribute",        has_pif_attribute);
    p_tlm2pin_parms->set("cbox",                     cbox);
    if (cosim) {
    p_tlm2pin_parms->set("write_responses",          write_responses);
    }

    oss_tlm2pin_parms << tab2 << name_tlm2pin_parms << ".set(\"big_endian\",         " << boolalpha << big_endian     << ");" << endl;
    oss_tlm2pin_parms << tab2 << name_tlm2pin_parms << ".set(\"start_byte_address\", 0x" << hex << start_byte_address << ");" << endl;
    oss_tlm2pin_parms << tab2 << name_tlm2pin_parms << ".set(\"has_busy\",           " << boolalpha << has_busy       << ");" << endl;
    oss_tlm2pin_parms << tab2 << name_tlm2pin_parms << ".set(\"has_lock\",           " << boolalpha << has_lock       << ");" << endl;
    oss_tlm2pin_parms << tab2 << name_tlm2pin_parms << ".set(\"read_delay\",         " << boolalpha << read_delay     << ");" << endl;
    oss_tlm2pin_parms << tab2 << name_tlm2pin_parms << ".set(\"check_bits\",         " << dec       << check_bits     << ");" << endl;
    oss_tlm2pin_parms << tab2 << name_tlm2pin_parms << ".set(\"has_pif_attribute\",  " << boolalpha << has_pif_attribute << ");" << endl;
    oss_tlm2pin_parms << tab2 << name_tlm2pin_parms << ".set(\"cbox\",               " << boolalpha << cbox           << ");" << endl;
    if (cosim) {
    oss_tlm2pin_parms << tab2 << name_tlm2pin_parms << ".set(\"write_responses\",    " << boolalpha << write_responses<< ");" << endl;
    }
  }
}



void show_tlm2pin_parms() {
  XTSC_TRACE(logger, "enter show_tlm2pin_parms()");
  init_tlm2pin_parms();
  cout << "Parameters for tlm2pin: " << endl;
  p_tlm2pin_parms->dump(cout);
}



void add_tlm2pin_parm() {
  XTSC_TRACE(logger, "enter add_tlm2pin_parm()");
  init_tlm2pin_parms();
  parm_split(*p_tlm2pin_parms);
  p_oss_parms = &oss_tlm2pin_parms;
  p_name_module_parms = &name_tlm2pin_parms;
  add_parm(*p_tlm2pin_parms);
}



void create_tlm2pin(const string& name) {
  XTSC_TRACE(logger, "enter create_tlm2pin()");
  init_tlm2pin_parms();
  string interface_name = p_tlm2pin_parms->get_c_str("memory_interface");
  string tlm2pin_name = (name == "" ? (interface_name + "_tlm2pin") : name);
  validate_name(tlm2pin_name, "tlm2pin");
  if (tlm2pin_map[w]->find(tlm2pin_name) != tlm2pin_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create tlm2pin with the same name as an already existing tlm2pin: " << tlm2pin_name;
    throw xtsc_exception(oss.str());
  }
  (*tlm2pin_map[w])[tlm2pin_name] = new tlm2pin_info(tlm2pin_name, *p_tlm2pin_parms);
  fini_tlm2pin_parms();
}



void fini_tlm2pin_parms() {
  XTSC_TRACE(logger, "enter fini_tlm2pin_parms()");
  if (p_tlm2pin_parms) {
    delete p_tlm2pin_parms;
    p_tlm2pin_parms = NULL;
    oss_tlm2pin_parms.str("");
  }
}



tlm2pin_info& find_or_infer_tlm2pin(const string& tlm2pin_name) {
  XTSC_TRACE(logger, "enter find_or_infer_tlm2pin()");
  map<string,tlm2pin_info*>::iterator it = tlm2pin_map[w]->find(tlm2pin_name);
  if (it == tlm2pin_map[w]->end()) {
    // Infer a tlm2pin with this name
    create_tlm2pin(tlm2pin_name);
    it = tlm2pin_map[w]->find(tlm2pin_name);
    if (it == tlm2pin_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred tlm2pin '" << tlm2pin_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *it->second;
}



void init_vcd_parms() {
  XTSC_TRACE(logger, "enter init_vcd_parms()");
  if (!p_vcd_parms) {
    confirm_building_system();
    name_vcd_parms = "vcd_parms__@";
    p_vcd_parms = new vcd_parms();
  }
}



void show_vcd_parms() {
  XTSC_TRACE(logger, "enter show_vcd_parms()");
  init_vcd_parms();
  cout << "Parameters for vcd: " << endl;
  p_vcd_parms->dump(cout);
}



void add_vcd_parm() {
  XTSC_TRACE(logger, "enter add_vcd_parm()");
  init_vcd_parms();
  parm_split(*p_vcd_parms);
  p_oss_parms = &oss_vcd_parms;
  p_name_module_parms = &name_vcd_parms;
  add_parm(*p_vcd_parms);
}



void create_vcd(const string& name) {
  XTSC_TRACE(logger, "enter create_vcd()");
  init_vcd_parms();
  const char *file_name = p_vcd_parms->get_c_str("file_name");
  string vcd_name = (name == "" ? ((file_name && file_name[0]) ? file_name : "waveforms") : name);
  validate_name(vcd_name, "vcd");
  if (vcd_map[w]->find(vcd_name) != vcd_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create vcd with the same identifier as an already existing vcd: " << vcd_name;
    throw xtsc_exception(oss.str());
  }
  (*vcd_map[w])[vcd_name] = new vcd_info(vcd_name, *p_vcd_parms);
  fini_vcd_parms();
}



void fini_vcd_parms() {
  XTSC_TRACE(logger, "enter fini_vcd_parms()");
  if (p_vcd_parms) {
    delete p_vcd_parms;
    p_vcd_parms = NULL;
    oss_vcd_parms.str("");
  }
}



vcd_info& find_or_infer_vcd(const string& vcd_name) {
  XTSC_TRACE(logger, "enter find_or_infer_vcd()");
  map<string,vcd_info*>::iterator iv = vcd_map[w]->find(vcd_name);
  if (iv == vcd_map[w]->end()) {
    // Infer a vcd with this name
    create_vcd(vcd_name);
    iv = vcd_map[w]->find(vcd_name);
    if (iv == vcd_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred vcd '" << vcd_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *iv->second;
}



void init_wire_parms() {
  XTSC_TRACE(logger, "enter init_wire_parms()");
  if (!p_wire_parms) {
    confirm_building_system();
    name_wire_parms = "wire_parms__@";
    p_wire_parms = new xtsc_wire_parms();
  }
}



void show_wire_parms() {
  XTSC_TRACE(logger, "enter show_wire_parms()");
  init_wire_parms();
  cout << "Parameters for wire: " << endl;
  p_wire_parms->dump(cout);
}



void add_wire_parm() {
  XTSC_TRACE(logger, "enter add_wire_parm()");
  init_wire_parms();
  parm_split(*p_wire_parms);
  p_oss_parms = &oss_wire_parms;
  p_name_module_parms = &name_wire_parms;
  add_parm(*p_wire_parms);
}



void create_wire(const string& name, const string& tie_name) {
  XTSC_TRACE(logger, "enter create_wire()");
  init_wire_parms();
  string wire_name = (name == "" ? "wire" : name);
  validate_name(wire_name, "wire");
  if (wire_map[w]->find(wire_name) != wire_map[w]->end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create wire with the same name as an already existing wire: " << wire_name;
    throw xtsc_exception(oss.str());
  }
  // If tie_name is specified, then match its bit width
  if (tie_name != "") {
    if (last_core_created == "") {
      ostringstream oss;
      oss << "ERROR: No core has been created to find TIE port '" << tie_name << "' on in command ";
      command_info(oss);
      throw xtsc_exception(oss.str());
    }
    map<string,core_info*>::iterator ic = core_map[w]->find(last_core_created);
    if (ic == core_map[w]->end()) {
      ostringstream oss;
      oss << "PROGRAM BUG: Can't find last created core '" << last_core_created << "'.";
      throw xtsc_exception(oss.str());
    }
    // Does this core have an export state or import wire named tie_name?
    if (!ic->second->p_core->has_export_state(tie_name.c_str()) && !ic->second->p_core->has_import_wire(tie_name.c_str())) {
      ostringstream oss;
      oss << "Core '" << last_core_created << "' has no TIE export state or import wire named '" << tie_name << "'.";
      throw xtsc_exception(oss.str());
    }
    // Yes, so match its bit width
    update_parm_u32(*p_wire_parms, "bit_width", ic->second->p_core->get_tie_bit_width(tie_name.c_str()),
                    oss_wire_parms, name_wire_parms);
  }
  (*wire_map[w])[wire_name] = new wire_info(wire_name, *p_wire_parms);
  fini_wire_parms();
}



void fini_wire_parms() {
  XTSC_TRACE(logger, "enter fini_wire_parms()");
  if (p_wire_parms) {
    delete p_wire_parms;
    p_wire_parms = NULL;
    oss_wire_parms.str("");
  }
}



wire_info& find_or_infer_wire(const string& wire_name) {
  XTSC_TRACE(logger, "enter find_or_infer_wire()");
  map<string,wire_info*>::iterator iw = wire_map[w]->find(wire_name);
  if (iw == wire_map[w]->end()) {
    // Infer a wire with this name
    create_wire(wire_name, "");
    iw = wire_map[w]->find(wire_name);
    if (iw == wire_map[w]->end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred wire '" << wire_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *iw->second;
}



void init_wrapper_parms(bool require_cosim) {
  XTSC_TRACE(logger, "enter init_wrapper_parms()");
  if (require_cosim) { confirm_verilog_on_top(); }
  if (!p_wrapper_parms) {
    if (wrapper_state == BUILDING_SYSTEM) {
      create_per_wrapper_stuff();
      wrapper_state = DEFINING_WRAPPER;
    }
    name_wrapper_parms = "wrapper_parms__@";
    p_wrapper_parms = new wrapper_parms();
  }
}



void show_wrapper_parms() {
  XTSC_TRACE(logger, "enter show_wrapper_parms()");
  init_wrapper_parms(false);
  cout << "Parameters for SystemC wrapper: " << endl;
  p_wrapper_parms->dump(cout);
  cout << "Note: The wrapper parameters are documented under --show_wrapper_parms in Section IV" << endl;
  cout << "      of the xtsc-run RM (available by typing 'xtsc-run --man')." << endl;
  if (!cosim || !verilog_on_top) {
    exit(0);
  }
}



void add_wrapper_parm() {
  XTSC_TRACE(logger, "enter add_wrapper_parm()");
  init_wrapper_parms(true);
  parm_split(*p_wrapper_parms);
  p_oss_parms = &oss_wrapper_parms;
  p_name_module_parms = &name_wrapper_parms;
  add_parm(*p_wrapper_parms);
}



void create_wrapper(const string& name) {
  XTSC_TRACE(logger, "enter create_wrapper()");
  init_wrapper_parms(true);
  wrapper_state = BUILDING_SYSTEM;
  string wrapper_name = (name == "" ? "wrapper" : name);
  validate_name(wrapper_name, "wrapper");
  if (wrapper_map.find(wrapper_name) != wrapper_map.end()) {
    ostringstream oss;
    oss << "ERROR: Attempt to create wrapper with the same name as an already existing wrapper: " << wrapper_name;
    throw xtsc_exception(oss.str());
  }
  p_current_wrapper = new wrapper_info(wrapper_name, *p_wrapper_parms);
  wrapper_map[wrapper_name] = p_current_wrapper;
  wrapper_list.push_back(wrapper_name);
  fini_wrapper_parms();
  if (p_current_wrapper->vcd_handle != "") {
    string command("--create_vcd=" + p_current_wrapper->vcd_handle);
    XTSC_INFO(logger, "Inferred command: " << command);
    setup_command_variables(command, "(Inferred from wrapper \"vcd_handle\")", 0xFFFFFFFF, "");
    process_command(-1);
  }
}



void fini_wrapper_parms() {
  XTSC_TRACE(logger, "enter fini_wrapper_parms()");
  if (p_wrapper_parms) {
    delete p_wrapper_parms;
    p_wrapper_parms = NULL;
    oss_wrapper_parms.str("");
  }
}



wrapper_info& find_or_infer_wrapper(const string& wrapper_name) {
  XTSC_TRACE(logger, "enter find_or_infer_wrapper()");
  map<string,wrapper_info*>::iterator iq = wrapper_map.find(wrapper_name);
  if (iq == wrapper_map.end()) {
    // Infer a wrapper with this name
    create_wrapper(wrapper_name);
    iq = wrapper_map.find(wrapper_name);
    if (iq == wrapper_map.end()) {
      ostringstream oss;
      oss << "Cannot find newly created inferred wrapper '" << wrapper_name << "'.";
      throw xtsc_exception(oss.str());
    }
  }
  return *iq->second;
}



void show_xtsc_parms() {
  ostringstream oss;
  oss << "Parameters for xtsc_initialize: " << endl;
  p_initialize_parms->dump(oss);
  cout << oss.str();
}



void add_xtsc_parm() {
  parm_split(*p_initialize_parms);
  p_oss_parms = &oss_xtsc_parms;
  p_name_module_parms = &name_xtsc_parms;
  add_parm(*p_initialize_parms);
}



void log_summary(bool verbose) {
  XTSC_TRACE(logger, "enter log_summary()");
  XTSC_NOTE(logger, "");
  XTSC_NOTE(logger, "xtsc-run summary");
  XTSC_NOTE(logger, "------------------------------------");

  if (verbose) {
    XTSC_NOTE(logger, "");
    XTSC_NOTE(logger, "TextLoggers:");
    ostringstream oss;
    oss << "  ";
    xtsc_dump_text_loggers(oss);
    xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
    XTSC_NOTE(logger, "------------------------------------");
  }

  if (verbose) {
    XTSC_NOTE(logger, "");
    XTSC_NOTE(logger, "BinaryLoggers:");
    ostringstream oss;
    oss << "  ";
    xtsc_dump_binary_loggers(oss);
    xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
    XTSC_NOTE(logger, "------------------------------------");
  }

  if (verbose) {
    XTSC_NOTE(logger, "");
    XTSC_NOTE(logger, "SystemC Objects:");
    ostringstream oss;
    oss << "  ";
    xtsc_dump_systemc_objects(oss);
    xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
    XTSC_NOTE(logger, "------------------------------------");
  }


// Step 25:  Add a block of code base on widget_map[w]->size()

  u32 save_w = w;

  for (u32 iw=0; iw<=save_w; ++iw) {
    w = iw;

    if (verilog_on_top && !wrapper_map.size()) break;

    if (verilog_on_top) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "====================================");
      XTSC_NOTE(logger, "Wrapper: " << wrapper_list[w]);
      if (verbose) XTSC_NOTE(logger, "");
    }

    if (arbiter_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "Arbiters:");
      map<string,arbiter_info*>::const_iterator ia = arbiter_map[w]->begin();
      for (; ia != arbiter_map[w]->end(); ++ia) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << ia->second->name);
          XTSC_NOTE(logger, "masters connected:  " << ia->second->num_master_connected);
          XTSC_NOTE(logger, "connected to slave: " << (ia->second->slave_connected ? "YES" : "NO"));
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          ia->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "arbiter name:      " << ia->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (clock_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "Clocks:");
      map<string,clock_info*>::const_iterator ic = clock_map[w]->begin();
      for (; ic != clock_map[w]->end(); ++ic) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << ic->second->name);
          XTSC_NOTE(logger, "sinks connected:  " << ic->second->num_sink_connected);
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          ic->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "clock name:        " << ic->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (cohctrl_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "Cohctrls:");
      map<string,cohctrl_info*>::const_iterator ic = cohctrl_map[w]->begin();
      for (; ic != cohctrl_map[w]->end(); ++ic) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << ic->second->name);
          for (u32 i=0; i<ic->second->num_clients; ++i) {
            XTSC_NOTE(logger, "connected to master " << i << ": " << (ic->second->master_connected[i] ? "YES" : "NO"));
            XTSC_NOTE(logger, "connected to snoop  " << i << ": " << (ic->second->snoop_connected [i] ? "YES" : "NO"));
          }
          XTSC_NOTE(logger, "connected to slave: " << (ic->second->slave_connected ? "YES" : "NO"));
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          ic->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "cohctrl name:      " << ic->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (consumer_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "Consumers:");
      map<string,consumer_info*>::const_iterator ic = consumer_map[w]->begin();
      for (; ic != consumer_map[w]->end(); ++ic) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << ic->second->name);
          XTSC_NOTE(logger, "connected to queue: " << (ic->second->queue_connected ? "YES" : "NO"));
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          ic->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "consumer name:     " << ic->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (core_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "Cores:");
      map<string,core_info*>::const_iterator ic = core_map[w]->begin();
      for (; ic != core_map[w]->end(); ++ic) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << ic->second->name);
          for (xtsc_core::memory_port p=xtsc_core::MEM_FIRST; p<=xtsc_core::MEM_LAST; ++p) {
            if (ic->second->p_core->has_memory_port(p)) {
              XTSC_NOTE(logger, "connected to " << xtsc_core::get_memory_port_name(p) <<
                                ": " << (ic->second->memory_connected[p] ? "YES" : "NO"));
            }
          }
          XTSC_NOTE(logger, "connected to inbound pif: " << (ic->second->inbound_connected ? "YES" : "NO"));
          XTSC_NOTE(logger, "connected to snoop: " << (ic->second->snoop_connected ? "YES" : "NO"));
          XTSC_NOTE(logger, "program: " << ic->second->program_name);
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss1;
          oss1 << "  ";
          ic->second->parms.dump(oss1);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss1.str(), 2);
          XTSC_NOTE(logger, "registers: ");
          ostringstream oss3;
          ic->second->p_core->dump_all_registers(oss3);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss3.str());
          ostringstream oss2;
          ic->second->p_core->dump_core_interfaces_by_type(oss2);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss2.str());
        }
        else {
          XTSC_NOTE(logger, "core name:         " << ic->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (distributor_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "Distributors:");
      map<string,distributor_info*>::const_iterator id = distributor_map[w]->begin();
      for (; id != distributor_map[w]->end(); ++id) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << id->second->name);
          for (icmap ii = id->second->inputs_connected.begin(); ii != id->second->inputs_connected.end(); ++ii) {
            XTSC_NOTE(logger, "input \"" << ii->first << "\" connected: " << (ii->second ? "YES" : "NO"));
          }
          for (icmap il = id->second->lookups_connected.begin(); il != id->second->lookups_connected.end(); ++il) {
            XTSC_NOTE(logger, "lookup \"" << il->first << "\" connected: " << (il->second ? "YES" : "NO"));
          }
          for (icmap io = id->second->outputs_connected.begin(); io != id->second->outputs_connected.end(); ++io) {
            XTSC_NOTE(logger, "output \"" << io->first << "\" connected: " << (io->second ? "YES" : "NO"));
          }
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          id->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "distributor name:  " << id->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (dma_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "DMA's:");
      map<string,dma_info*>::const_iterator id = dma_map[w]->begin();
      for (; id != dma_map[w]->end(); ++id) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << id->second->name);
          for (u32 i=0; i<id->second->num_ports; ++i) {
            XTSC_NOTE(logger, "connected to master " << i << ": " << (id->second->master_connected[i] ? "YES" : "NO"));
          }
          XTSC_NOTE(logger, "connected to slave: " << (id->second->slave_connected ? "YES" : "NO"));
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          id->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "dma name:          " << id->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (driver_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "Drivers:");
      map<string,driver_info*>::const_iterator id = driver_map[w]->begin();
      for (; id != driver_map[w]->end(); ++id) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << id->second->name);
          XTSC_NOTE(logger, "connected to lookup: " << (id->second->lookup_connected ? "YES" : "NO"));
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          id->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "driver name:       " << id->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (loader_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "TX Loaders:");
      map<string,loader_info*>::const_iterator il = loader_map[w]->begin();
      for (; il != loader_map[w]->end(); ++il) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << il->second->name);
          XTSC_NOTE(logger, "connected to first TX: " << (il->second->first_tx_connected ? "YES" : "NO"));
          XTSC_NOTE(logger, "connected to last TX:  " << (il->second->last_tx_connected  ? "YES" : "NO"));
          XTSC_NOTE(logger, "connected to producer: " << (il->second->producer_connected ? "YES" : "NO"));
          XTSC_NOTE(logger, "connected to consumer: " << (il->second->consumer_connected ? "YES" : "NO"));
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          il->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "loader name:       " << il->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (logic_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "Logics:");
      map<string,logic_info*>::const_iterator im = logic_map[w]->begin();
      for (; im != logic_map[w]->end(); ++im) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << im->second->name);
          for (icmap ii = im->second->inputs_connected.begin(); ii != im->second->inputs_connected.end(); ++ii) {
            XTSC_NOTE(logger, "input \"" << ii->first << "\" connected: " << (ii->second ? "YES" : "NO"));
          }
          for (icmap io = im->second->outputs_connected.begin(); io != im->second->outputs_connected.end(); ++io) {
            XTSC_NOTE(logger, "output \"" << io->first << "\" connected: " << (io->second ? "YES" : "NO"));
          }
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          im->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "logic name:        " << im->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (lookup_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "TLM Lookups:");
      map<string,lookup_info*>::const_iterator il = lookup_map[w]->begin();
      for (; il != lookup_map[w]->end(); ++il) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << il->second->name);
          XTSC_NOTE(logger, "connected to master: " << (il->second->master_connected ? "YES" : "NO"));
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          il->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "lookup name:       " << il->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (lookup_pin_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "Pin-level Lookups:");
      map<string,lookup_pin_info*>::const_iterator il = lookup_pin_map[w]->begin();
      for (; il != lookup_pin_map[w]->end(); ++il) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << il->second->name);
          XTSC_NOTE(logger, "connected to master: " << (il->second->master_connected ? "YES" : "NO"));
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          il->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "lookup_pin name:   " << il->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (master_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "Masters:");
      map<string,master_info*>::const_iterator ic = master_map[w]->begin();
      for (; ic != master_map[w]->end(); ++ic) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << ic->second->name);
          XTSC_NOTE(logger, "connected to slave: " << (ic->second->slave_connected ? "YES" : "NO"));
          if (ic->second->has_control) {
            XTSC_NOTE(logger, "Control input connected: " << (ic->second->control_connected ? "YES" : "NO"));
          }
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          ic->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "master name:       " << ic->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (memory_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "TLM Memories:");
      map<string,memory_info*>::const_iterator im = memory_map[w]->begin();
      for (; im != memory_map[w]->end(); ++im) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << im->second->name);
          XTSC_NOTE(logger, "type: " << xtsc_core::get_memory_port_name(im->second->mem_port));
          for (u32 i=0; i<im->second->num_ports; ++i) {
            XTSC_NOTE(logger, "connected to master " << i << ": " << (im->second->master_connected[i] ? "YES" : "NO"));
          }
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          im->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "memory name:       " << im->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (memory_pin_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "Pin-level Memories:");
      map<string,memory_pin_info*>::const_iterator im = memory_pin_map[w]->begin();
      for (; im != memory_pin_map[w]->end(); ++im) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << im->second->name);
          XTSC_NOTE(logger, "type: " << im->second->parms.get_c_str("memory_interface"));
          for (u32 i=0; i<im->second->num_ports; ++i) {
            XTSC_NOTE(logger, "connected to master " << i << ": " << (im->second->master_connected[i] ? "YES" : "NO"));
          }
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          im->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "memory_pin name:   " << im->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (memory_trace_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "Memory traces:");
      map<string,memory_trace_info*>::const_iterator im = memory_trace_map[w]->begin();
      for (; im != memory_trace_map[w]->end(); ++im) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << im->second->name);
          for (u32 i=0; i<im->second->num_ports; ++i) {
            XTSC_NOTE(logger, "connected to master " << i << ": " << (im->second->master_connected[i] ? "YES" : "NO"));
            XTSC_NOTE(logger, "connected to slave  " << i << ": " << (im->second->slave_connected [i] ? "YES" : "NO"));
          }
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          im->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "memory_trace name: " << im->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (mmio_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "MMIO's:");
      map<string,mmio_info*>::const_iterator im = mmio_map[w]->begin();
      for (; im != mmio_map[w]->end(); ++im) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << im->second->name);
          XTSC_NOTE(logger, "master connected: " << (im->second->master_connected ? "YES" : "NO"));
          for (icmap ii = im->second->inputs_connected.begin(); ii != im->second->inputs_connected.end(); ++ii) {
            XTSC_NOTE(logger, "input \"" << ii->first << "\" connected: " << (ii->second ? "YES" : "NO"));
          }
          for (icmap io = im->second->outputs_connected.begin(); io != im->second->outputs_connected.end(); ++io) {
            XTSC_NOTE(logger, "output \"" << io->first << "\" connected: " << (io->second ? "YES" : "NO"));
          }
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          im->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "mmio name:         " << im->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (pin2tlm_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "Pin2tlms:");
      map<string,pin2tlm_info*>::const_iterator it = pin2tlm_map[w]->begin();
      for (; it != pin2tlm_map[w]->end(); ++it) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << it->second->name);
          for (u32 i=0; i<it->second->num_ports; ++i) {
            XTSC_NOTE(logger, "connected to master " << i << ": " << (it->second->master_connected[i] ? "YES" : "NO"));
            XTSC_NOTE(logger, "connected to slave  " << i << ": " << (it->second->slave_connected [i] ? "YES" : "NO"));
          }
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          it->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "pin2tlm name:      " << it->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (router_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "Routers:");
      map<string,router_info*>::const_iterator ir = router_map[w]->begin();
      for (; ir != router_map[w]->end(); ++ir) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << ir->second->name);
          XTSC_NOTE(logger, "connected to master: " << (ir->second->master_connected ? "YES" : "NO"));
          XTSC_NOTE(logger, "slaves connected:    " << ir->second->num_slave_connected);
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          ir->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "router name:       " << ir->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (producer_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "Producers:");
      map<string,producer_info*>::const_iterator ip = producer_map[w]->begin();
      for (; ip != producer_map[w]->end(); ++ip) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << ip->second->name);
          XTSC_NOTE(logger, "connected to queue: " << (ip->second->queue_connected ? "YES" : "NO"));
          if (ip->second->has_control) {
            XTSC_NOTE(logger, "Control input connected: " << (ip->second->control_connected ? "YES" : "NO"));
          }
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          ip->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "producer name:     " << ip->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (proxy_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "Verilog Proxies:");
      map<string,proxy_info*>::const_iterator ip = proxy_map[w]->begin();
      for (; ip != proxy_map[w]->end(); ++ip) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << ip->second->name);
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          ip->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "proxy name:        " << ip->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (queue_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "TLM Queues:");
      map<string,queue_info*>::const_iterator iq = queue_map[w]->begin();
      for (; iq != queue_map[w]->end(); ++iq) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << iq->second->name);
          for (u32 i=0; i<iq->second->num_producers; ++i) {
            XTSC_NOTE(logger, "connected to m_producers[" << i << "]: " << (iq->second->producer_connected[i] ? "YES" : "NO"));
          }
          for (u32 i=0; i<iq->second->num_consumers; ++i) {
            XTSC_NOTE(logger, "connected to m_consumers[" << i << "]: " << (iq->second->consumer_connected[i] ? "YES" : "NO"));
          }
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          iq->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "queue name:        " << iq->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (queue_pin_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "Pin-Level Queues:");
      map<string,queue_pin_info*>::const_iterator iq = queue_pin_map[w]->begin();
      for (; iq != queue_pin_map[w]->end(); ++iq) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << iq->second->name);
          XTSC_NOTE(logger, "connected to producer: " << (iq->second->producer_connected ? "YES" : "NO"));
          XTSC_NOTE(logger, "connected to consumer: " << (iq->second->consumer_connected ? "YES" : "NO"));
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          iq->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "queue_pin name:    " << iq->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (signal_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "Signals:");
      map<string,signal_info*>::const_iterator is = signal_map[w]->begin();
      for (; is != signal_map[w]->end(); ++is) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << is->second->name);
          XTSC_NOTE(logger, "bit width: " << is->second->bit_width);
          XTSC_NOTE(logger, "connected to source: " << (is->second->source_connected ? "YES" : "NO"));
          XTSC_NOTE(logger, "connected to sink:   " << (is->second->sink_connected   ? "YES" : "NO"));
        }
        else {
          XTSC_NOTE(logger, "signal name:       " << is->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (slave_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "Slaves:");
      map<string,slave_info*>::const_iterator is = slave_map[w]->begin();
      for (; is != slave_map[w]->end(); ++is) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << is->second->name);
          XTSC_NOTE(logger, "connected to master: " << (is->second->master_connected ? "YES" : "NO"));
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          is->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "slave name:        " << is->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (source_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "Sources:");
      map<string,source_info*>::const_iterator is = source_map[w]->begin();
      for (; is != source_map[w]->end(); ++is) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << is->second->name);
          for (icmap io = is->second->outputs_connected.begin(); io != is->second->outputs_connected.end(); ++io) {
            XTSC_NOTE(logger, "output \"" << io->first << "\" connected: " << (io->second ? "YES" : "NO") << "  bit width: " <<
                              is->second->p_source->get_bit_width(io->first.c_str()));
          }
          if (is->second->has_control) {
            XTSC_NOTE(logger, "Control input connected: " << (is->second->control_connected ? "YES" : "NO"));
          }
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          is->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "source name:       " << is->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (tlm2pin_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "Tlm2pins:");
      map<string,tlm2pin_info*>::const_iterator it = tlm2pin_map[w]->begin();
      for (; it != tlm2pin_map[w]->end(); ++it) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << it->second->name);
          for (u32 i=0; i<it->second->num_ports; ++i) {
            XTSC_NOTE(logger, "connected to master " << i << ": " << (it->second->master_connected[i] ? "YES" : "NO"));
            XTSC_NOTE(logger, "connected to slave  " << i << ": " << (it->second->slave_connected [i] ? "YES" : "NO"));
          }
          XTSC_NOTE(logger, "parms: ");
          ostringstream oss;
          oss << "  ";
          it->second->parms.dump(oss);
          xtsc_log_multiline(logger, log4xtensa::NOTE_LOG_LEVEL, oss.str(), 2);
        }
        else {
          XTSC_NOTE(logger, "tlm2pin name:      " << it->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (vcd_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "VCD Files:");
      map<string,vcd_info*>::const_iterator iw = vcd_map[w]->begin();
      for (; iw != vcd_map[w]->end(); ++iw) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "Identifier: " << iw->second->identifier);
          XTSC_NOTE(logger, "File Name:  " << iw->second->parms.get_c_str("file_name"));
        }
        else {
          XTSC_NOTE(logger, "VCD id:            " << iw->second->identifier);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

    if (wire_map[w]->size()) {
      if (verbose) XTSC_NOTE(logger, "");
      if (verbose) XTSC_NOTE(logger, "Wires:");
      map<string,wire_info*>::const_iterator iw = wire_map[w]->begin();
      for (; iw != wire_map[w]->end(); ++iw) {
        if (verbose) {
          XTSC_NOTE(logger, "");
          XTSC_NOTE(logger, "name: " << iw->second->name);
          XTSC_NOTE(logger, "bit width: " << iw->second->parms.get_u32("bit_width"));
          XTSC_NOTE(logger, "connected to source: " << (iw->second->source_connected ? "YES" : "NO"));
          XTSC_NOTE(logger, "connected to sink:   " << (iw->second->sink_connected   ? "YES" : "NO"));
        }
        else {
          XTSC_NOTE(logger, "wire name:         " << iw->second->name);
        }
      }
      if (verbose) XTSC_NOTE(logger, "------------------------------------");
    }

  }

  w = save_w;

  XTSC_NOTE(logger, "====================================");
  XTSC_NOTE(logger, "");
}



void slurp(int argc, char *argv[], vector<string> *p_file_names, vector<u32> *p_line_numbers, vector<string> *p_infos) {
  XTSC_TRACE(logger, "enter slurp()");

  for (int argi=0; argi<argc; ++argi) {
    string empty("");
    string file(p_file_names ? (*p_file_names)[argi] : empty);
    u32 line_number = (p_line_numbers ? ((*p_line_numbers)[argi]) : (argi+1));
    string info(p_infos ? (*p_infos)[argi] : empty);
    setup_command_variables(argv[argi], file, line_number, info);

    bool skip = false;

    // Check for first argument without leading hyphen
    // This and subsequent arguments become the target program name and target argv's
    if (found_program_name || ((rem != "") && (rem[0] != '-'))) {
      found_program_name = true;
    }
    else {

      // Trim leading hyphens
      string::size_type pos = rem.find_first_not_of("-");
      rem   .erase(0, pos);
      rem_lc.erase(0, pos);

      // Split rem using pattern command_name=rem
      arg_split(argi);

      if (!found_program_name && ((command_name == "include") || (command_name == "inc") || (command_name =="i"))) {
        confirm_assignment();
        string file_name = rem;
        xtsc_script_file *p_file = NULL;
        try {
          p_file = new xtsc_script_file(file_name.c_str(), "", "xtsc-run", false);
        }
        catch (...) {
          ostringstream oss;
          oss << "Cannot open include file '" << file_name << "' found in command ";
          command_info(oss);
          char *p_cwd = _getcwd((char *)work_buffer, work_buffer_size);
          oss << " (CWD = " << p_cwd << ")";
          throw xtsc_exception(oss.str());
        }
        vector<char*>   file_argv_array;
        vector<string>  file_names;
        vector<u32>     file_line_numbers;
        vector<string>  file_info_for_exceptions;
        string          s;
        string          actual_file_name;
        u32             line;
        while ((line = p_file->getline(s, &actual_file_name)) != 0) {
          string trim = s.substr(s.find_first_not_of(" \t"));             // Trim leading whitespace
          file_argv_array.push_back(xtsc_copy_c_str(trim.c_str()));
          file_names.push_back(actual_file_name);
          file_line_numbers.push_back(line);
          file_info_for_exceptions.push_back(p_file->info_for_exception());
        }
        int file_argc = file_argv_array.size();
        char **file_argv = new char *[file_argc];
        for (int i=0; i<file_argc; ++i) {
          file_argv[i] = file_argv_array[i];
        }
        slurp(file_argc, file_argv, &file_names, &file_line_numbers, &file_info_for_exceptions);
        delete [] file_argv;

        skip = true;
      }
    }
    if (!skip) {
      commands.push_back(cmd);
      command_files.push_back(file);
      command_line_numbers.push_back(line_number);
      info_for_exceptions.push_back(info);
    }
  }
}



void process() {
  XTSC_TRACE(logger, "enter process()");

  if (cosim) {
    setup_command_variables(commands[cosimi], command_files[cosimi], command_line_numbers[cosimi], info_for_exceptions[cosimi]);
    process_command(cosimi);
  }

  if (verilog_on_top && sc_main_command) {
    ostringstream oss;
    oss << "The --sc_main command is not allowed with the --cosim=verilog command";
    throw xtsc_exception(oss.str());
  }

  if (cosim && (dir == "")) {
    dir = vendor;
  }

  wrapper_state = (verilog_on_top ? DEFINING_WRAPPER : BUILDING_SYSTEM);

  if (sc_main_command || systemc_on_top || verilog_on_top) {
    initialize_sc_main_generation();
  }

  if (systemc_on_top || verilog_on_top) {
    XTSC_INFO(logger, "--cosim=" << (verilog_on_top ? "verilog" : "systemc") << "," << vendor << "," << vendor_version << "," <<
                      gcc_version);
    init_make_parms();
  }

  // Main command processing loop
  int argc = commands.size();
  for (int argi=0; argi<argc; ++argi) {

    if ((u32) argi == cosimi) continue;

    setup_command_variables(commands[argi], command_files[argi], command_line_numbers[argi], info_for_exceptions[argi]);

    // Check for first command-line argument without leading hyphen
    // These become the target program name and target argv's
    if ((command_file == "") && (rem[0] != '-')) {
      do_final_program_name_and_args(argc, argi);
      break;
    }

    process_command(argi);

  }
}



void process_command(int argi) {
  XTSC_TRACE(logger, "enter process_command(" << argi << ")");

  // Trim leading hyphens
  string::size_type pos = rem.find_first_not_of("-");
  rem   .erase(0, pos);
  rem_lc.erase(0, pos);

  // Split rem using pattern command_name=rem
  arg_split(argi);

  // Check for all supported commands

  // Note:  The single long sequence of "else if" blocks has been broken into multiple smaller
  //        sequences because the one long sequence exceeded the Microsoft compiler limits
  bool found = false;

  // Note: For the xtensa_* commands, if any core parameter or program name has been explicitly
  //       set since previous core, if any, was created then a create_core command is inferred.
  if ((command_name == "xtensa_system") || (command_name == "xtensa-system")) {
    if ((XTENSA_CORE && XTENSA_CORE[0]) && (XTENSA_SYSTEM && XTENSA_SYSTEM[0])) {
      infer_create_core("");
    }
    XTENSA_SYSTEM = xtsc_copy_c_str(rem.c_str());
    redo_core_parms_if_able();
    found = true;
  }
  else if ((command_name == "xtensa_params") || (command_name == "xtensa-params")) {
    if ((XTENSA_CORE && XTENSA_CORE[0]) && (XTENSA_SYSTEM && XTENSA_SYSTEM[0])) {
      infer_create_core("");
    }
    XTENSA_PARAMS = xtsc_copy_c_str(rem.c_str());
    redo_core_parms_if_able();
    found = true;
  }
  else if ((command_name == "xtensa_core") || (command_name == "xtensa-core")) {
    if ((XTENSA_CORE && XTENSA_CORE[0]) && (XTENSA_SYSTEM && XTENSA_SYSTEM[0])) {
      infer_create_core("");
    }
    XTENSA_CORE = xtsc_copy_c_str(rem.c_str());
    redo_core_parms_if_able();
    found = true;
  }



// Step 26:  a) Add checks and handling for "set_widget_parm" and "widget_parm"
//           b) Add checks and handling for "show_widget_parms" and "show_widget_parm"

  if (found) {
    ; // Do nothing - command has already been found
  }
  else if ((command_name == "set_arbiter_parm") || (command_name == "arbiter_parm")) {
    add_arbiter_parm();
    found = true;
  }
  else if ((command_name == "set_clock_parm") || (command_name == "clock_parm")) {
    add_clock_parm();
    found = true;
  }
  else if ((command_name == "set_consumer_parm") || (command_name == "consumer_parm")) {
    add_consumer_parm();
    found = true;
  }
  else if ((command_name == "set_cohctrl_parm") || (command_name == "cohctrl_parm")) {
    add_cohctrl_parm();
    found = true;
  }
  else if ((command_name == "set_core_parm") || (command_name == "core_parm")) {
    add_core_parm();
    found = true;
  }
  else if ((command_name == "set_distributor_parm") || (command_name == "distributor_parm")) {
    add_distributor_parm();
    found = true;
  }
  else if ((command_name == "set_dma_parm") || (command_name == "dma_parm")) {
    add_dma_parm();
    found = true;
  }
  else if ((command_name == "set_driver_parm") || (command_name == "driver_parm")) {
    add_driver_parm();
    found = true;
  }
  else if ((command_name == "set_loader_parm") || (command_name == "loader_parm")) {
    add_loader_parm();
    found = true;
  }
  else if ((command_name == "set_logic_parm") || (command_name == "logic_parm")) {
    add_logic_parm();
    found = true;
  }
  else if ((command_name == "set_lookup_parm") || (command_name == "lookup_parm")) {
    add_lookup_parm();
    found = true;
  }
  else if ((command_name == "set_lookup_pin_parm") || (command_name == "lookup_pin_parm")) {
    add_lookup_pin_parm();
    found = true;
  }
  else if ((command_name == "set_make_parm") || (command_name == "make_parm")) {
    add_make_parm();
    found = true;
  }
  else if ((command_name == "set_master_parm") || (command_name == "master_parm")) {
    add_master_parm();
    found = true;
  }
  else if ((command_name == "set_memory_parm") || (command_name == "memory_parm")) {
    add_memory_parm();
    found = true;
  }
  else if ((command_name == "set_memory_pin_parm") || (command_name == "memory_pin_parm")) {
    add_memory_pin_parm();
    found = true;
  }
  else if ((command_name == "set_memory_trace_parm") || (command_name == "memory_trace_parm")) {
    add_memory_trace_parm();
    found = true;
  }
  else if ((command_name == "set_mmio_parm") || (command_name == "mmio_parm")) {
    add_mmio_parm();
    found = true;
  }
  else if ((command_name == "set_pin2tlm_parm") || (command_name == "pin2tlm_parm")) {
    add_pin2tlm_parm();
    found = true;
  }
  else if ((command_name == "set_producer_parm") || (command_name == "producer_parm")) {
    add_producer_parm();
    found = true;
  }
  else if ((command_name == "set_proxy_parm") || (command_name == "proxy_parm")) {
    add_proxy_parm();
    found = true;
  }
  else if ((command_name == "set_queue_parm") || (command_name == "queue_parm")) {
    add_queue_parm();
    found = true;
  }
  else if ((command_name == "set_queue_pin_parm") || (command_name == "queue_pin_parm")) {
    add_queue_pin_parm();
    found = true;
  }
  else if ((command_name == "set_router_parm") || (command_name == "router_parm")) {
    add_router_parm();
    found = true;
  }
  else if ((command_name == "set_signal_parm") || (command_name == "signal_parm")) {
    add_signal_parm();
    found = true;
  }
  else if ((command_name == "set_slave_parm") || (command_name == "slave_parm")) {
    add_slave_parm();
    found = true;
  }
  else if ((command_name == "set_source_parm") || (command_name == "source_parm")) {
    add_source_parm();
    found = true;
  }
  else if ((command_name == "set_tlm2pin_parm") || (command_name == "tlm2pin_parm")) {
    add_tlm2pin_parm();
    found = true;
  }
  else if ((command_name == "set_vcd_parm") || (command_name == "vcd_parm")) {
    add_vcd_parm();
    found = true;
  }
  else if ((command_name == "set_wire_parm") || (command_name == "wire_parm")) {
    add_wire_parm();
    found = true;
  }
  else if ((command_name == "set_wrapper_parm") || (command_name == "wrapper_parm")) {
    add_wrapper_parm();
    found = true;
  }
  else if ((command_name == "show_arbiter_parms") || (command_name == "show_arbiter_parm")) {
    show_arbiter_parms();
    found = true;
  }
  else if ((command_name == "show_clock_parms") || (command_name == "show_clock_parm")) {
    show_clock_parms();
    found = true;
  }
  else if ((command_name == "show_consumer_parms") || (command_name == "show_consumer_parm")) {
    show_consumer_parms();
    found = true;
  }
  else if ((command_name == "show_cohctrl_parms") || (command_name == "show_cohctrl_parm")) {
    show_cohctrl_parms();
    found = true;
  }
  else if ((command_name == "show_core_parms") || (command_name == "show_core_parm")) {
    show_core_parms();
    found = true;
  }
  else if ((command_name == "show_distributor_parms") || (command_name == "show_distributor_parm")) {
    show_distributor_parms();
    found = true;
  }
  else if ((command_name == "show_dma_parms") || (command_name == "show_dma_parm")) {
    show_dma_parms();
    found = true;
  }
  else if ((command_name == "show_driver_parms") || (command_name == "show_driver_parm")) {
    show_driver_parms();
    found = true;
  }
  else if ((command_name == "show_loader_parms") || (command_name == "show_loader_parm")) {
    show_loader_parms();
    found = true;
  }
  else if ((command_name == "show_logic_parms") || (command_name == "show_logic_parm")) {
    show_logic_parms();
    found = true;
  }
  else if ((command_name == "show_lookup_parms") || (command_name == "show_lookup_parm")) {
    show_lookup_parms();
    found = true;
  }
  else if ((command_name == "show_lookup_pin_parms") || (command_name == "show_lookup_pin_parm")) {
    show_lookup_pin_parms();
    found = true;
  }
  else if ((command_name == "show_make_parms") || (command_name == "show_make_parm")) {
    show_make_parms();
    found = true;
  }
  else if ((command_name == "show_master_parms") || (command_name == "show_master_parm")) {
    show_master_parms();
    found = true;
  }
  else if ((command_name == "show_memory_parms") || (command_name == "show_memory_parm")) {
    show_memory_parms();
    found = true;
  }
  else if ((command_name == "show_memory_pin_parms") || (command_name == "show_memory_pin_parm")) {
    show_memory_pin_parms();
    found = true;
  }
  else if ((command_name == "show_memory_trace_parms") || (command_name == "show_memory_trace_parm")) {
    show_memory_trace_parms();
    found = true;
  }
  else if ((command_name == "show_mmio_parms") || (command_name == "show_mmio_parm")) {
    show_mmio_parms();
    found = true;
  }
  else if ((command_name == "show_models") || (command_name == "show_modules") ||
           (command_name == "show_model" ) || (command_name == "show_module" )) {
    parse_show_modules();
    found = true;
  }
  else if ((command_name == "show_pin2tlm_parms") || (command_name == "show_pin2tlm_parm")) {
    show_pin2tlm_parms();
    found = true;
  }
  else if ((command_name == "show_producer_parms") || (command_name == "show_producer_parm")) {
    show_producer_parms();
    found = true;
  }
  else if ((command_name == "show_proxy_parms") || (command_name == "show_proxy_parm")) {
    show_proxy_parms();
    found = true;
  }
  else if ((command_name == "show_queue_parms") || (command_name == "show_queue_parm")) {
    show_queue_parms();
    found = true;
  }
  else if ((command_name == "show_queue_pin_parms") || (command_name == "show_queue_pin_parm")) {
    show_queue_pin_parms();
    found = true;
  }
  else if ((command_name == "show_router_parms") || (command_name == "show_router_parm")) {
    show_router_parms();
    found = true;
  }
  else if ((command_name == "show_signal_parms") || (command_name == "show_signal_parm")) {
    show_signal_parms();
    found = true;
  }
  else if ((command_name == "show_slave_parms") || (command_name == "show_slave_parm")) {
    show_slave_parms();
    found = true;
  }
  else if ((command_name == "show_source_parms") || (command_name == "show_source_parm")) {
    show_source_parms();
    found = true;
  }
  else if ((command_name == "show_tlm2pin_parms") || (command_name == "show_tlm2pin_parm")) {
    show_tlm2pin_parms();
    found = true;
  }
  else if ((command_name == "show_vcd_parms") || (command_name == "show_vcd_parm")) {
    show_vcd_parms();
    found = true;
  }
  else if ((command_name == "show_wire_parms") || (command_name == "show_wire_parm")) {
    show_wire_parms();
    found = true;
  }
  else if ((command_name == "show_wrapper_parms") || (command_name == "show_wrapper_parm")) {
    show_wrapper_parms();
    found = true;
  }


// Step 27:  Add checks and handling for "create_widget" 

  if (found) {
    ; // Do nothing - command has already been found
  }
  else if (command_name == "create_arbiter") {
    create_arbiter(rem);
    found = true;
  }
  else if (command_name == "create_clock") {
    create_clock(rem);
    found = true;
  }
  else if (command_name == "create_consumer") {
    create_consumer(rem);
    found = true;
  }
  else if (command_name == "create_cohctrl") {
    create_cohctrl(rem);
    found = true;
  }
  else if (command_name == "create_core") {
    create_core(rem, "");
    found = true;
  }
  else if (command_name == "create_distributor") {
    create_distributor(rem);
    found = true;
  }
  else if (command_name == "create_dma") {
    create_dma(rem);
    found = true;
  }
  else if (command_name == "create_driver") {
    create_driver(rem);
    found = true;
  }
  else if (command_name == "create_loader") {
    create_loader(rem);
    found = true;
  }
  else if (command_name == "create_logic") {
    create_logic(rem);
    found = true;
  }
  else if (command_name == "create_lookup") {
    parse_create_lookup();
    found = true;
  }
  else if (command_name == "create_lookup_pin") {
    parse_create_lookup_pin();
    found = true;
  }
  else if (command_name == "create_master") {
    create_master(rem);
    found = true;
  }
  else if (command_name == "create_memory") {
    create_memory(rem);
    found = true;
  }
  else if (command_name == "create_memory_pin") {
    create_memory_pin(rem);
    found = true;
  }
  else if (command_name == "create_memory_trace") {
    create_memory_trace(rem);
    found = true;
  }
  else if (command_name == "create_mmio") {
    create_mmio(rem);
    found = true;
  }
  else if (command_name == "create_pin2tlm") {
    create_pin2tlm(rem);
    found = true;
  }
  else if (command_name == "create_producer") {
    create_producer(rem);
    found = true;
  }
  else if (command_name == "create_proxy") {
    create_proxy(rem);
    found = true;
  }
  else if (command_name == "create_queue") {
    parse_create_queue();
    found = true;
  }
  else if (command_name == "create_queue_pin") {
    parse_create_queue_pin();
    found = true;
  }
  else if (command_name == "create_router") {
    create_router(rem);
    found = true;
  }
  else if (command_name == "create_signal") {
    parse_create_signal();
    found = true;
  }
  else if (command_name == "create_slave") {
    create_slave(rem);
    found = true;
  }
  else if (command_name == "create_source") {
    create_source(rem);
    found = true;
  }
  else if (command_name == "create_tlm2pin") {
    create_tlm2pin(rem);
    found = true;
  }
  else if (command_name == "create_vcd") {
    create_vcd(rem);
    found = true;
  }
  else if (command_name == "create_wire") {
    parse_create_wire();
    found = true;
  }
  else if (command_name == "create_wrapper") {
    create_wrapper(rem);
    found = true;
  }


// Step 28:  As dictated by Step 11, add checks and handling for "connect_widget_XXX" and "widget_XXX".
//           As dictated by Step 11, add checks and handling for "connect_XXX_widget" and "XXX_widget".

  if (found) {
    ; // Do nothing - command has already been found
  }
  else if ((command_name == "connect_arbiter_arbiter") || (command_name == "arbiter_arbiter")) {
    parse_connect_arbiter_arbiter();
    found = true;
  }
  else if ((command_name == "connect_arbiter_cohctrl") || (command_name == "arbiter_cohctrl")) {
    parse_connect_arbiter_cohctrl();
    found = true;
  }
  else if ((command_name == "connect_arbiter_core") || (command_name == "arbiter_core")) {
    parse_connect_arbiter_core();
    found = true;
  }
  else if ((command_name == "connect_arbiter_dma") || (command_name == "arbiter_dma")) {
    parse_connect_arbiter_dma();
    found = true;
  }
  else if ((command_name == "connect_arbiter_memory") || (command_name == "arbiter_memory")) {
    parse_connect_arbiter_memory();
    found = true;
  }
  else if ((command_name == "connect_arbiter_memory_trace") || (command_name == "arbiter_memory_trace")) {
    parse_connect_arbiter_memory_trace();
    found = true;
  }
  else if ((command_name == "connect_arbiter_mmio") || (command_name == "arbiter_mmio")) {
    parse_connect_arbiter_mmio();
    found = true;
  }
  else if ((command_name == "connect_arbiter_router") || (command_name == "arbiter_router")) {
    parse_connect_arbiter_router();
    found = true;
  }
  else if ((command_name == "connect_arbiter_slave") || (command_name == "arbiter_slave")) {
    parse_connect_arbiter_slave();
    found = true;
  }
  else if ((command_name == "connect_arbiter_tlm2pin") || (command_name == "arbiter_tlm2pin")) {
    parse_connect_arbiter_tlm2pin();
    found = true;
  }
  else if ((command_name == "connect_clock_proxy") || (command_name == "clock_proxy")) {
    parse_connect_clock_proxy();
    found = true;
  }
  else if ((command_name == "connect_clock_wrapper") || (command_name == "clock_wrapper")) {
    parse_connect_clock_wrapper();
    found = true;
  }
  else if ((command_name == "connect_cohctrl_arbiter") || (command_name == "cohctrl_arbiter")) {
    parse_connect_cohctrl_arbiter();
    found = true;
  }
  else if ((command_name == "connect_cohctrl_memory") || (command_name == "cohctrl_memory")) {
    parse_connect_cohctrl_memory();
    found = true;
  }
  else if ((command_name == "connect_cohctrl_memory_trace") || (command_name == "cohctrl_memory_trace")) {
    parse_connect_cohctrl_memory_trace();
    found = true;
  }
  else if ((command_name == "connect_cohctrl_slave") || (command_name == "cohctrl_slave")) {
    parse_connect_cohctrl_slave();
    found = true;
  }
  else if ((command_name == "connect_cohctrl_router") || (command_name == "cohctrl_router")) {
    parse_connect_cohctrl_router();
    found = true;
  }
  else if ((command_name == "connect_cohctrl_tlm2pin") || (command_name == "cohctrl_tlm2pin")) {
    parse_connect_cohctrl_tlm2pin();
    found = true;
  }
  else if ((command_name == "connect_core_arbiter") || (command_name == "core_arbiter")) {
    parse_connect_core_arbiter();
    found = true;
  }
  else if ((command_name == "connect_core_cohctrl") || (command_name == "core_cohctrl")) {
    parse_connect_core_cohctrl();
    found = true;
  }
  else if ((command_name == "connect_core_core") || (command_name == "core_core")) {
    parse_connect_core_core();
    found = true;
  }
  else if ((command_name == "connect_core_distributor") || (command_name == "core_distributor")) {
    parse_connect_core_distributor();
    found = true;
  }
  else if ((command_name == "connect_core_loader") || (command_name == "core_loader")) {
    parse_connect_core_loader();
    found = true;
  }
  else if ((command_name == "connect_core_logic") || (command_name == "core_logic")) {
    parse_connect_core_logic();
    found = true;
  }
  else if ((command_name == "connect_core_lookup") || (command_name == "core_lookup")) {
    parse_connect_core_lookup();
    found = true;
  }
  else if ((command_name == "connect_core_lookup_pin") || (command_name == "core_lookup_pin")) {
    parse_connect_core_lookup_pin();
    found = true;
  }
  else if ((command_name == "connect_core_memory") || (command_name == "core_memory")) {
    parse_connect_core_memory();
    found = true;
  }
  else if ((command_name == "connect_core_memory_trace") || (command_name == "core_memory_trace")) {
    parse_connect_core_memory_trace();
    found = true;
  }
  else if ((command_name == "connect_core_mmio") || (command_name == "core_mmio")) {
    parse_connect_core_mmio();
    found = true;
  }
  else if ((command_name == "connect_core_proxy") || (command_name == "core_proxy")) {
    parse_connect_core_proxy();
    found = true;
  }
  else if ((command_name == "connect_core_wrapper") || (command_name == "core_wrapper")) {
    parse_connect_core_wrapper();
    found = true;
  }
  else if ((command_name == "connect_core_queue") || (command_name == "core_queue")) {
    parse_connect_core_queue();
    found = true;
  }
  else if ((command_name == "connect_core_queue_pin") || (command_name == "core_queue_pin")) {
    parse_connect_core_queue_pin();
    found = true;
  }
  else if ((command_name == "connect_core_router") || (command_name == "core_router")) {
    parse_connect_core_router();
    found = true;
  }
  else if ((command_name == "connect_core_signal") || (command_name == "core_signal")) {
    parse_connect_core_signal();
    found = true;
  }
  else if ((command_name == "connect_core_slave") || (command_name == "core_slave")) {
    parse_connect_core_slave();
    found = true;
  }
  else if ((command_name == "connect_core_tlm2pin") || (command_name == "core_tlm2pin")) {
    parse_connect_core_tlm2pin();
    found = true;
  }
  else if ((command_name == "connect_core_wire") || (command_name == "core_wire")) {
    parse_connect_core_wire();
    found = true;
  }
  else if ((command_name == "connect_distributor_core") || (command_name == "distributor_core")) {
    parse_connect_distributor_core();
    found = true;
  }
  else if ((command_name == "connect_distributor_logic") || (command_name == "distributor_logic")) {
    parse_connect_distributor_logic();
    found = true;
  }
  else if ((command_name == "connect_distributor_mmio") || (command_name == "distributor_mmio")) {
    parse_connect_distributor_mmio();
    found = true;
  }
  else if ((command_name == "connect_distributor_wire") || (command_name == "distributor_wire")) {
    parse_connect_distributor_wire();
    found = true;
  }
  else if ((command_name == "connect_dma_arbiter") || (command_name == "dma_arbiter")) {
    parse_connect_dma_arbiter();
    found = true;
  }
  else if ((command_name == "connect_dma_memory") || (command_name == "dma_memory")) {
    parse_connect_dma_memory();
    found = true;
  }
  else if ((command_name == "connect_dma_memory_trace") || (command_name == "dma_memory_trace")) {
    parse_connect_dma_memory_trace();
    found = true;
  }
  else if ((command_name == "connect_dma_router") || (command_name == "dma_router")) {
    parse_connect_dma_router();
    found = true;
  }
  else if ((command_name == "connect_driver_distributor") || (command_name == "driver_distributor")) {
    parse_connect_driver_distributor();
    found = true;
  }
  else if ((command_name == "connect_driver_lookup") || (command_name == "driver_lookup")) {
    parse_connect_driver_lookup();
    found = true;
  }
  else if ((command_name == "connect_driver_lookup_pin") || (command_name == "driver_lookup_pin")) {
    parse_connect_driver_lookup_pin();
    found = true;
  }
  else if ((command_name == "connect_driver_proxy") || (command_name == "driver_proxy")) {
    parse_connect_driver_proxy();
    found = true;
  }
  else if ((command_name == "connect_driver_wrapper") || (command_name == "driver_wrapper")) {
    parse_connect_driver_wrapper();
    found = true;
  }
  else if ((command_name == "connect_loader_consumer") || (command_name == "loader_consumer")) {
    parse_connect_loader_consumer();
    found = true;
  }
  else if ((command_name == "connect_loader_core") || (command_name == "loader_core")) {
    parse_connect_loader_core();
    found = true;
  }
  else if ((command_name == "connect_loader_logic") || (command_name == "loader_logic")) {
    parse_connect_loader_logic();
    found = true;
  }
  else if ((command_name == "connect_loader_wire") || (command_name == "loader_wire")) {
    parse_connect_loader_wire();
    found = true;
  }
  else if ((command_name == "connect_logic_cohctrl") || (command_name == "logic_cohctrl")) {
    parse_connect_logic_cohctrl();
    found = true;
  }
  else if ((command_name == "connect_logic_core") || (command_name == "logic_core")) {
    parse_connect_logic_core();
    found = true;
  }
  else if ((command_name == "connect_logic_distributor") || (command_name == "logic_distributor")) {
    parse_connect_logic_distributor();
    found = true;
  }
  else if ((command_name == "connect_logic_logic") || (command_name == "logic_logic")) {
    parse_connect_logic_logic();
    found = true;
  }
  else if ((command_name == "connect_logic_master") || (command_name == "logic_master")) {
    parse_connect_logic_master();
    found = true;
  }
  else if ((command_name == "connect_logic_mmio") || (command_name == "logic_mmio")) {
    parse_connect_logic_mmio();
    found = true;
  }
  else if ((command_name == "connect_logic_producer") || (command_name == "logic_producer")) {
    parse_connect_logic_producer();
    found = true;
  }
  else if ((command_name == "connect_logic_proxy") || (command_name == "logic_proxy")) {
    parse_connect_logic_proxy();
    found = true;
  }
  else if ((command_name == "connect_logic_source") || (command_name == "logic_source")) {
    parse_connect_logic_source();
    found = true;
  }
  else if ((command_name == "connect_logic_wire") || (command_name == "logic_wire")) {
    parse_connect_logic_wire();
    found = true;
  }
  else if ((command_name == "connect_logic_wrapper") || (command_name == "logic_wrapper")) {
    parse_connect_logic_wrapper();
    found = true;
  }
  else if ((command_name == "connect_master_arbiter") || (command_name == "master_arbiter")) {
    parse_connect_master_arbiter();
    found = true;
  }
  else if ((command_name == "connect_master_cohctrl") || (command_name == "master_cohctrl")) {
    parse_connect_master_cohctrl();
    found = true;
  }
  else if ((command_name == "connect_master_core") || (command_name == "master_core")) {
    parse_connect_master_core();
    found = true;
  }
  else if ((command_name == "connect_master_dma") || (command_name == "master_dma")) {
    parse_connect_master_dma();
    found = true;
  }
  else if ((command_name == "connect_master_memory") || (command_name == "master_memory")) {
    parse_connect_master_memory();
    found = true;
  }
  else if ((command_name == "connect_master_memory_trace") || (command_name == "master_memory_trace")) {
    parse_connect_master_memory_trace();
    found = true;
  }
  else if ((command_name == "connect_master_mmio") || (command_name == "master_mmio")) {
    parse_connect_master_mmio();
    found = true;
  }
  else if ((command_name == "connect_master_router") || (command_name == "master_router")) {
    parse_connect_master_router();
    found = true;
  }
  else if ((command_name == "connect_master_slave") || (command_name == "master_slave")) {
    parse_connect_master_slave();
    found = true;
  }
  else if ((command_name == "connect_master_tlm2pin") || (command_name == "master_tlm2pin")) {
    parse_connect_master_tlm2pin();
    found = true;
  }
  else if ((command_name == "connect_memory_trace_arbiter") || (command_name == "memory_trace_arbiter")) {
    parse_connect_memory_trace_arbiter();
    found = true;
  }
  else if ((command_name == "connect_memory_trace_cohctrl") || (command_name == "memory_trace_cohctrl")) {
    parse_connect_memory_trace_cohctrl();
    found = true;
  }
  else if ((command_name == "connect_memory_trace_core") || (command_name == "memory_trace_core")) {
    parse_connect_memory_trace_core();
    found = true;
  }
  else if ((command_name == "connect_memory_trace_dma") || (command_name == "memory_trace_dma")) {
    parse_connect_memory_trace_dma();
    found = true;
  }
  else if ((command_name == "connect_memory_trace_memory") || (command_name == "memory_trace_memory")) {
    parse_connect_memory_trace_memory();
    found = true;
  }
  else if ((command_name == "connect_memory_trace_mmio") || (command_name == "memory_trace_mmio")) {
    parse_connect_memory_trace_mmio();
    found = true;
  }
  else if ((command_name == "connect_memory_trace_router") || (command_name == "memory_trace_router")) {
    parse_connect_memory_trace_router();
    found = true;
  }
  else if ((command_name == "connect_memory_trace_slave") || (command_name == "memory_trace_slave")) {
    parse_connect_memory_trace_slave();
    found = true;
  }
  else if ((command_name == "connect_memory_trace_tlm2pin") || (command_name == "memory_trace_tlm2pin")) {
    parse_connect_memory_trace_tlm2pin();
    found = true;
  }


  if (found) {
    ; // Do nothing - command has already been found
  }
  else if ((command_name == "connect_mmio_core") || (command_name == "mmio_core")) {
    parse_connect_mmio_core();
    found = true;
  }
  else if ((command_name == "connect_mmio_distributor") || (command_name == "mmio_distributor")) {
    parse_connect_mmio_distributor();
    found = true;
  }
  else if ((command_name == "connect_mmio_logic") || (command_name == "mmio_logic")) {
    parse_connect_mmio_logic();
    found = true;
  }
  else if ((command_name == "connect_mmio_master") || (command_name == "mmio_master")) {
    parse_connect_mmio_master();
    found = true;
  }
  else if ((command_name == "connect_mmio_mmio") || (command_name == "mmio_mmio")) {
    parse_connect_mmio_mmio();
    found = true;
  }
  else if ((command_name == "connect_mmio_producer") || (command_name == "mmio_producer")) {
    parse_connect_mmio_producer();
    found = true;
  }
  else if ((command_name == "connect_mmio_proxy") || (command_name == "mmio_proxy")) {
    parse_connect_mmio_proxy();
    found = true;
  }
  else if ((command_name == "connect_mmio_source") || (command_name == "mmio_source")) {
    parse_connect_mmio_source();
    found = true;
  }
  else if ((command_name == "connect_mmio_wrapper") || (command_name == "mmio_wrapper")) {
    parse_connect_mmio_wrapper();
    found = true;
  }
  else if ((command_name == "connect_mmio_wire") || (command_name == "mmio_wire")) {
    parse_connect_mmio_wire();
    found = true;
  }
  else if ((command_name == "connect_pin2tlm_arbiter") || (command_name == "pin2tlm_arbiter")) {
    parse_connect_pin2tlm_arbiter();
    found = true;
  }
  else if ((command_name == "connect_pin2tlm_cohctrl") || (command_name == "pin2tlm_cohctrl")) {
    parse_connect_pin2tlm_cohctrl();
    found = true;
  }
  else if ((command_name == "connect_pin2tlm_core") || (command_name == "pin2tlm_core")) {
    parse_connect_pin2tlm_core();
    found = true;
  }
  else if ((command_name == "connect_pin2tlm_memory") || (command_name == "pin2tlm_memory")) {
    parse_connect_pin2tlm_memory();
    found = true;
  }
  else if ((command_name == "connect_pin2tlm_memory_trace") || (command_name == "pin2tlm_memory_trace")) {
    parse_connect_pin2tlm_memory_trace();
    found = true;
  }
  else if ((command_name == "connect_pin2tlm_mmio") || (command_name == "pin2tlm_mmio")) {
    parse_connect_pin2tlm_mmio();
    found = true;
  }
  else if ((command_name == "connect_pin2tlm_router") || (command_name == "pin2tlm_router")) {
    parse_connect_pin2tlm_router();
    found = true;
  }
  else if ((command_name == "connect_pin2tlm_slave") || (command_name == "pin2tlm_slave")) {
    parse_connect_pin2tlm_slave();
    found = true;
  }
  else if ((command_name == "connect_producer_loader") || (command_name == "producer_loader")) {
    parse_connect_producer_loader();
    found = true;
  }
  else if ((command_name == "connect_producer_proxy") || (command_name == "producer_proxy")) {
    parse_connect_producer_proxy();
    found = true;
  }
  else if ((command_name == "connect_producer_queue") || (command_name == "producer_queue")) {
    parse_connect_producer_queue();
    found = true;
  }
  else if ((command_name == "connect_producer_queue_pin") || (command_name == "producer_queue_pin")) {
    parse_connect_producer_queue_pin();
    found = true;
  }
  else if ((command_name == "connect_producer_wrapper") || (command_name == "producer_wrapper")) {
    parse_connect_producer_wrapper();
    found = true;
  }
  else if ((command_name == "connect_proxy_cohctrl") || (command_name == "proxy_cohctrl")) {
    parse_connect_proxy_cohctrl();
    found = true;
  }
  else if ((command_name == "connect_proxy_consumer") || (command_name == "proxy_consumer")) {
    parse_connect_proxy_consumer();
    found = true;
  }
  else if ((command_name == "connect_proxy_core") || (command_name == "proxy_core")) {
    parse_connect_proxy_core();
    found = true;
  }
  else if ((command_name == "connect_proxy_lookup_pin") || (command_name == "proxy_lookup_pin")) {
    parse_connect_proxy_lookup_pin();
    found = true;
  }
  else if ((command_name == "connect_proxy_memory_pin") || (command_name == "proxy_memory_pin")) {
    parse_connect_proxy_memory_pin();
    found = true;
  }
  else if ((command_name == "connect_proxy_loader") || (command_name == "proxy_loader")) {
    parse_connect_proxy_loader();
    found = true;
  }
  else if ((command_name == "connect_proxy_logic") || (command_name == "proxy_logic")) {
    parse_connect_proxy_logic();
    found = true;
  }
  else if ((command_name == "connect_proxy_mmio") || (command_name == "proxy_mmio")) {
    parse_connect_proxy_mmio();
    found = true;
  }
  else if ((command_name == "connect_proxy_pin2tlm") || (command_name == "proxy_pin2tlm")) {
    parse_connect_proxy_pin2tlm();
    found = true;
  }
  else if ((command_name == "connect_proxy_queue_pin") || (command_name == "proxy_queue_pin")) {
    parse_connect_proxy_queue_pin();
    found = true;
  }
  else if ((command_name == "connect_proxy_wire") || (command_name == "proxy_wire")) {
    parse_connect_proxy_wire();
    found = true;
  }
  else if ((command_name == "connect_queue_consumer") || (command_name == "queue_consumer")) {
    parse_connect_queue_consumer();
    found = true;
  }
  else if ((command_name == "connect_queue_pin_consumer") || (command_name == "queue_pin_consumer")) {
    parse_connect_queue_pin_consumer();
    found = true;
  }
  else if ((command_name == "connect_queue_core") || (command_name == "queue_core")) {
    parse_connect_queue_core();
    found = true;
  }
  else if ((command_name == "connect_queue_pin_core") || (command_name == "queue_pin_core")) {
    parse_connect_queue_pin_core();
    found = true;
  }
  else if ((command_name == "connect_queue_pin_proxy") || (command_name == "queue_pin_proxy")) {
    parse_connect_queue_pin_proxy();
    found = true;
  }
  else if ((command_name == "connect_queue_pin_wrapper") || (command_name == "queue_pin_wrapper")) {
    parse_connect_queue_pin_wrapper();
    found = true;
  }
  else if ((command_name == "connect_router_arbiter") || (command_name == "router_arbiter")) {
    parse_connect_router_arbiter();
    found = true;
  }
  else if ((command_name == "connect_router_cohctrl") || (command_name == "router_cohctrl")) {
    parse_connect_router_cohctrl();
    found = true;
  }
  else if ((command_name == "connect_router_core") || (command_name == "router_core")) {
    parse_connect_router_core();
    found = true;
  }
  else if ((command_name == "connect_router_dma") || (command_name == "router_dma")) {
    parse_connect_router_dma();
    found = true;
  }
  else if ((command_name == "connect_router_memory") || (command_name == "router_memory")) {
    parse_connect_router_memory();
    found = true;
  }
  else if ((command_name == "connect_router_memory_trace") || (command_name == "router_memory_trace")) {
    parse_connect_router_memory_trace();
    found = true;
  }
  else if ((command_name == "connect_router_mmio") || (command_name == "router_mmio")) {
    parse_connect_router_mmio();
    found = true;
  }
  else if ((command_name == "connect_router_router") || (command_name == "router_router")) {
    parse_connect_router_router();
    found = true;
  }
  else if ((command_name == "connect_router_slave") || (command_name == "router_slave")) {
    parse_connect_router_slave();
    found = true;
  }
  else if ((command_name == "connect_router_tlm2pin") || (command_name == "router_tlm2pin")) {
    parse_connect_router_tlm2pin();
    found = true;
  }
  else if ((command_name == "connect_signal_core") || (command_name == "signal_core")) {
    parse_connect_signal_core();
    found = true;
  }
  else if ((command_name == "connect_source_cohctrl") || (command_name == "source_cohctrl")) {
    parse_connect_source_cohctrl();
    found = true;
  }
  else if ((command_name == "connect_source_core") || (command_name == "source_core")) {
    parse_connect_source_core();
    found = true;
  }
  else if ((command_name == "connect_source_distributor") || (command_name == "source_distributor")) {
    parse_connect_source_distributor();
    found = true;
  }
  else if ((command_name == "connect_source_logic") || (command_name == "source_logic")) {
    parse_connect_source_logic();
    found = true;
  }
  else if ((command_name == "connect_source_mmio") || (command_name == "source_mmio")) {
    parse_connect_source_mmio();
    found = true;
  }
  else if ((command_name == "connect_source_proxy") || (command_name == "source_proxy")) {
    parse_connect_source_proxy();
    found = true;
  }
  else if ((command_name == "connect_source_signal") || (command_name == "source_signal")) {
    parse_connect_source_signal();
    found = true;
  }
  else if ((command_name == "connect_source_wire") || (command_name == "source_wire")) {
    parse_connect_source_wire();
    found = true;
  }
  else if ((command_name == "connect_source_wrapper") || (command_name == "source_wrapper")) {
    parse_connect_source_wrapper();
    found = true;
  }
  else if ((command_name == "connect_tlm2pin_memory_pin") || (command_name == "tlm2pin_memory_pin") ||
           (command_name == "connect_tlm2pin_memory")     || (command_name == "tlm2pin_memory")) {
    parse_connect_tlm2pin_memory_pin();
    found = true;
  }
  else if ((command_name == "connect_tlm2pin_pin2tlm") || (command_name == "tlm2pin_pin2tlm")) {
    parse_connect_tlm2pin_pin2tlm();
    found = true;
  }
  else if ((command_name == "connect_tlm2pin_proxy") || (command_name == "tlm2pin_proxy")) {
    parse_connect_tlm2pin_proxy();
    found = true;
  }
  else if ((command_name == "connect_tlm2pin_wrapper") || (command_name == "tlm2pin_wrapper")) {
    parse_connect_tlm2pin_wrapper();
    found = true;
  }
  else if ((command_name == "connect_wire_core") || (command_name == "wire_core")) {
    parse_connect_wire_core();
    found = true;
  }
  else if ((command_name == "connect_wrapper_cohctrl") || (command_name == "wrapper_cohctrl")) {
    parse_connect_wrapper_cohctrl();
    found = true;
  }
  else if ((command_name == "connect_wrapper_consumer") || (command_name == "wrapper_consumer")) {
    parse_connect_wrapper_consumer();
    found = true;
  }
  else if ((command_name == "connect_wrapper_core") || (command_name == "wrapper_core")) {
    parse_connect_wrapper_core();
    found = true;
  }
  else if ((command_name == "connect_wrapper_loader") || (command_name == "wrapper_loader")) {
    parse_connect_wrapper_loader();
    found = true;
  }
  else if ((command_name == "connect_wrapper_logic") || (command_name == "wrapper_logic")) {
    parse_connect_wrapper_logic();
    found = true;
  }
  else if ((command_name == "connect_wrapper_lookup_pin") || (command_name == "wrapper_lookup_pin")) {
    parse_connect_wrapper_lookup_pin();
    found = true;
  }
  else if ((command_name == "connect_wrapper_memory_pin") || (command_name == "wrapper_memory_pin")) {
    parse_connect_wrapper_memory_pin();
    found = true;
  }
  else if ((command_name == "connect_wrapper_mmio") || (command_name == "wrapper_mmio")) {
    parse_connect_wrapper_mmio();
    found = true;
  }
  else if ((command_name == "connect_wrapper_pin2tlm") || (command_name == "wrapper_pin2tlm")) {
    parse_connect_wrapper_pin2tlm();
    found = true;
  }
  else if ((command_name == "connect_wrapper_queue_pin") || (command_name == "wrapper_queue_pin")) {
    parse_connect_wrapper_queue_pin();
    found = true;
  }
  else if ((command_name == "connect_wrapper_wire") || (command_name == "wrapper_wire")) {
    parse_connect_wrapper_wire();
    found = true;
  }



  if (found) {
    ; // Do nothing - command has already been found
  }
  else if ((command_name == "binary") || (command_name=="bin") || (command_name=="b")) {
    // Do nothing.  This command has already been handled
    found = true;
  }
  else if ((command_name == "core_arg") || (command_name == "core_args") || (command_name == "core_argv")) {
    parse_core_args();
    found = true;
  }
  else if (command_name == "core_debug") {
    parse_core_debug();
    found = true;
  }
  else if (command_name == "core_client") {
    parse_core_client();
    found = true;
  }
  else if ((command_name == "core_program") || (command_name == "core_programs")) {
    parse_core_program();
    found = true;
  }
  else if (command_name == "core_summary") {
    parse_core_summary();
    found = true;
  }
  else if (command_name == "cycle_limit") {
    parse_cycle_limit();
    found = true;
  }
  else if (command_name == "dump_commands") {
    dump_commands();
    found = true;
  }
  else if ((command_name == "help") || (command_name == "h") || (command_name == "?")) {
    usage_and_exit(true, 0);
    found = true;
  }
  else if ((command_name == "logging") || (command_name=="log") || (command_name=="l")) {
    if ((rem_lc == "off") || (rem_lc == "on")) {
      xtsc_enable_text_logging((rem_lc == "on"));
      *oss_main[w] << endl;
      *oss_main[w] << tab2 << "xtsc_enable_text_logging(" << ((rem_lc == "on") ? "true" : "false") << ");" << endl;
    }
    else if (rem_lc == "elab_only") {
      logging_elab_only = true;
    }
    else {
      // Do nothing.  This command has already been handled
    }
    found = true;
  }
  else if ((command_name == "manual") || (command_name == "man")) {
    usage_and_exit(false, 0);
    found = true;
  }
  else if (command_name == "memory_pin_port") {
    parse_memory_pin_port();
    found = true;
  }
  else if (command_name == "memory_port") {
    parse_memory_port();
    found = true;
  }
  else if ((command_name == "multi_core_debug") || (command_name == "xxdebug")) {
    parse_multi_core_debug();
    found = true;
  }
  else if ((command_name == "multi_core_profile") || (command_name == "xxprofile")) {
    parse_multi_core_profile();
    found = true;
  }
  else if ((command_name == "no_default_memories") ||
           (command_name == "no_default_memory"  ) ||
           (command_name == "no_default_mem"     ) ||
           (command_name == "ndm"                )) {
    parse_no_default_mem();
    found = true;
  }
  else if ((command_name == "no_default_local_memories") ||
           (command_name == "no_default_local_memory"  ) ||
           (command_name == "no_default_local_mem"     ) ||
           (command_name == "ndlm"                )) {
    parse_no_default_local_mem();
    found = true;
  }
  else if ((command_name == "no_sim") || (command_name == "no_simulation")) {
    parse_no_sim();
    found = true;
  }
  else if ((command_name == "quit") || (command_name == "q")) {
    exit(0);
    found = true;
  }
  else if (command_name == "sc_main") {
    // Do nothing.  This command has already been handled
    found = true;
  }
  else if ((command_name == "cosim") || (command_name == "co_sim") || (command_name == "co-sim")) {
    parse_cosim();
    found = true;
  }
  else if ((command_name == "path") || (command_name == "dir")) {
    // Do nothing.  These commands have already been handled
    found = true;
  }
  else if ((command_name == "show_xtsc_parms") || (command_name == "show_xtsc_parm")) {
    // Do nothing.  These commands have already been handled
    found = true;
  }
  else if (command_name == "set_xtsc_parm") {
    // Do nothing.  This command has already been handled
    found = true;
  }
  else if (command_name == "squelch_ctor") {
    parse_squelch_ctor();
    found = true;
  }
  else if (command_name == "string_array_separator") {
    parse_string_array_separator();
    found = true;
  }
  else if ((command_name == "summary") || (command_name == "sum") || (command_name == "s")) {
    parse_summary();
    found = true;
  }

  if (!found) {
    ostringstream oss;
    oss << "xtsc-run: unrecognized command ";
    command_info(oss);
    throw xtsc_exception(oss.str());
  }

}



void finalize_system_or_wrapper() {
  XTSC_TRACE(logger, "enter finalize_system_or_wrapper()");

  if (verilog_on_top && !p_current_wrapper) {
    return;
  }

  // Save command info away
  string cmd_save                 = cmd;
  string command_file_save        = command_file;
  u32    command_line_number_save = command_line_number;
  string info_for_exception_save  = info_for_exception;
  string rem_save                 = rem;
  string rem_lc_save              = rem_lc;
  string command_name_save        = command_name;

  cmd = (verilog_on_top ? "<Inferred End-of-Wrapper Processing>" : "<Inferred Final Processing>");
  command_file = "";
  command_line_number = 0xFFFFFFFF;
  info_for_exception = "";

  // Infer a core instantiation?
  infer_create_core("");

  // Infer a memory instantiation?
  if (p_memory_parms) {
    if (show_memory_parms_called &&
        !verilog_on_top     &&
        !add_memory_parm_called  &&
        !core_map[w]->size()     &&
        !master_map[w]->size())
    {
      // This appears to be a case of the user just using the --show_memory_parms command to
      // see the possible parameters without meaning to imply that a memory should be created.
      // Therefore, we'll skip creating the memory so that we don't get a port-not-bound exception. 
      ;
    }
    else {
      create_memory("");
    }
  }

  // Infer --core_memory connection of all unconnected memories using last core created
  if (last_core_created != "") {
    map<string,memory_info*>::iterator im = memory_map[w]->begin();
    for (; im != memory_map[w]->end(); ++im) {
      for (u32 i=0; i < im->second->num_ports; ++i) {
        if (!im->second->master_connected[i]) {
          connect_core_memory(last_core_created, i, im->second->name);
          break;
        }
      }
    }
  }

  // Connect unconnected pin-level interfaces of cores to wrapper as requested
  if (verilog_on_top && p_current_wrapper->fully_connect_cores) {
    bool multiple_cores = p_current_wrapper->fully_connect_cores[0] && p_current_wrapper->fully_connect_cores[1];
    for (u32 i=0; p_current_wrapper->fully_connect_cores[i]; ++i) {
      string core_name(p_current_wrapper->fully_connect_cores[i]);
      map<string,core_info*>::iterator ic = core_map[w]->find(core_name);
      if (ic == core_map[w]->end()) {
        ostringstream oss;
        oss << "Core \"" << core_name << "\" not found in wrapper \"" << p_current_wrapper->name << "\"" << endl;
        throw xtsc_exception(oss.str());
      }
      core_info& ci(*ic->second);
      xtsc_core& core(*ci.p_core);
      string name_prefix;
      if (multiple_cores) {
        name_prefix = ci.name + "_";
      }
      infer_connect_core_wrapper(ci.name, core.get_pin_level_lookup_set(),        ci.lookup_connected,        name_prefix);
      infer_connect_core_wrapper(ci.name, core.get_pin_level_output_queue_set(),  ci.output_queue_connected,  name_prefix);
      infer_connect_core_wrapper(ci.name, core.get_pin_level_export_state_set(),  ci.export_state_connected,  name_prefix);
      infer_connect_core_wrapper(ci.name, core.get_pin_level_system_output_set(), ci.system_output_connected, name_prefix);
      infer_connect_wrapper_core(ci.name, core.get_pin_level_input_queue_set(),   ci.input_queue_connected,   name_prefix);
      infer_connect_wrapper_core(ci.name, core.get_pin_level_import_wire_set(),   ci.import_wire_connected,   name_prefix);
      infer_connect_wrapper_core(ci.name, core.get_pin_level_system_input_set(),  ci.system_input_connected,  name_prefix);
      // Connect any existant unconnected memory ports to the wrapper via a tlm2pin
      for ( xtsc_core::memory_port p=xtsc_core::MEM_FIRST; p<=xtsc_core::MEM_LAST; ++p) {
        // Get the memory port name
        const char *port_name = xtsc_core::get_memory_port_name(p);
        // Does this core have such a memory port?
        if (core.has_memory_port(port_name)) {
          // Skip if no_default_mem or if non-PIF (i.e. local) and no_default_local_mem
          if (ci.no_default_mem || (p != xtsc_core::MEM_PIF && ci.no_default_local_mem)) continue;
          // Skip the 2nd LD/ST unit for this type of memory because
          // it would have been taken care of in the previous pass.
          if (!xtsc_core::is_ls_dual_port(p, 1)) {
            // Skip if memory has been connected
            if (!ci.memory_connected[p]) {
              // Create a memory name
              string memory_pin_port = string(xtsc_core::get_memory_port_name(p, true));
              string t2p_name = memory_pin_port + string("_t2p");
              if (multiple_cores) {
                t2p_name = ci.name + "_" + t2p_name;
              }
              do_inferred_command("---memory_pin_port=" + memory_pin_port);
              do_inferred_command("---set_tlm2pin_parm=cosim=true");
              if (p_current_wrapper->shadow_memory) {
                do_inferred_command("---set_tlm2pin_parm=shadow_memory=true");
              }
              do_inferred_command("---connect_core_tlm2pin=" + ci.name + "," + memory_pin_port + "," + t2p_name);
              do_inferred_command("---connect_tlm2pin_wrapper=" + t2p_name + "," + name_prefix);
            }
          }
        }
      }
      // Connect inbound PIF if it exists and is unconnected
      if (ci.parms.get_bool("HasInboundPIF") && !ci.inbound_connected) {
        string p2t_name = "inbound_p2t";
        if (multiple_cores) {
          p2t_name = ci.name + "_" + p2t_name;
        }
        do_inferred_command("---memory_pin_port=pif");
        do_inferred_command("---set_pin2tlm_parm=inbound_pif=true");
        do_inferred_command("---connect_wrapper_pin2tlm=" + p2t_name);
        do_inferred_command("---connect_pin2tlm_core=" + p2t_name + "," + ci.name);
      }
    }
  }

  // Connect unconnected memory and pin-level interfaces of cores to proxies as requested
  if (systemc_on_top) {
    for (map<string,proxy_info*>::const_iterator ip = proxy_map[w]->begin(); ip != proxy_map[w]->end(); ++ip) {
      proxy_info& proxy = *ip->second;
      if (!proxy.fully_connect_cores) continue;
      string pname(proxy.name);
      bool multiple_cores = proxy.fully_connect_cores[0] && proxy.fully_connect_cores[1];
      for (u32 i=0; proxy.fully_connect_cores[i]; ++i) {
        string core_name(proxy.fully_connect_cores[i]);
        map<string,core_info*>::iterator ic = core_map[w]->find(core_name);
        if (ic == core_map[w]->end()) {
          ostringstream oss;
          oss << "Core \"" << core_name << "\" not found to fully connect to proxy \"" << proxy.name << "\"" << endl;
          throw xtsc_exception(oss.str());
        }
        core_info& ci(*ic->second);
        xtsc_core& core(*ci.p_core);
        string name_prefix;
        if (multiple_cores) {
          name_prefix = ci.name + "_";
        }
        infer_connect_core_proxy(ci.name, core.get_pin_level_lookup_set(),        ci.lookup_connected,        name_prefix, pname);
        infer_connect_core_proxy(ci.name, core.get_pin_level_output_queue_set(),  ci.output_queue_connected,  name_prefix, pname);
        infer_connect_core_proxy(ci.name, core.get_pin_level_export_state_set(),  ci.export_state_connected,  name_prefix, pname);
        infer_connect_core_proxy(ci.name, core.get_pin_level_system_output_set(), ci.system_output_connected, name_prefix, pname);
        infer_connect_proxy_core(ci.name, core.get_pin_level_input_queue_set(),   ci.input_queue_connected,   name_prefix, pname);
        infer_connect_proxy_core(ci.name, core.get_pin_level_import_wire_set(),   ci.import_wire_connected,   name_prefix, pname);
        infer_connect_proxy_core(ci.name, core.get_pin_level_system_input_set(),  ci.system_input_connected,  name_prefix, pname);
        // Connect any existant unconnected memory ports to the proxy via a tlm2pin
        for ( xtsc_core::memory_port p=xtsc_core::MEM_FIRST; p<=xtsc_core::MEM_LAST; ++p) {
          // Get the memory port name
          const char *port_name = xtsc_core::get_memory_port_name(p);
          // Does this core have such a memory port?
          if (core.has_memory_port(port_name)) {
            // Skip if no_default_mem or if non-PIF (i.e. local) and no_default_local_mem
            if (ci.no_default_mem || (p != xtsc_core::MEM_PIF && ci.no_default_local_mem)) continue;
            // Skip the 2nd LD/ST unit for this type of memory because
            // it would have been taken care of in the previous pass.
            if (!xtsc_core::is_ls_dual_port(p, 1)) {
              // Skip if memory has been connected
              if (!ci.memory_connected[p]) {
                // Create a memory name
                string memory_pin_port = string(xtsc_core::get_memory_port_name(p, true));
                string t2p_name = memory_pin_port + string("_t2p");
                if (multiple_cores) {
                  t2p_name = ci.name + "_" + t2p_name;
                }
                do_inferred_command("---memory_pin_port=" + memory_pin_port);
                do_inferred_command("---connect_core_tlm2pin=" + ci.name + "," + memory_pin_port + "," + t2p_name);
                do_inferred_command("---connect_tlm2pin_proxy=" + t2p_name + "," + pname);
              }
            }
          }
        }
        // Connect inbound PIF if it exists and is unconnected
        if (ci.parms.get_bool("HasInboundPIF") && !ci.inbound_connected) {
          string p2t_name = "inbound_p2t";
          if (multiple_cores) {
            p2t_name = ci.name + "_" + p2t_name;
          }
          do_inferred_command("---memory_pin_port=pif");
          do_inferred_command("---set_pin2tlm_parm=inbound_pif=true");
          do_inferred_command("---connect_proxy_pin2tlm=" + pname + "," + p2t_name);
          do_inferred_command("---connect_pin2tlm_core=" + p2t_name + "," + ci.name);
        }
      }
    }
  }

  // Check if default memories need to be done for any core
  for (map<string,core_info*>::iterator ic = core_map[w]->begin(); ic != core_map[w]->end(); ++ic) {
    if (!ic->second->no_default_mem) {
      do_default_mem(*ic->second);
    }
  }

  // Restore command info
  cmd                   = cmd_save;
  command_file          = command_file_save;
  command_line_number   = command_line_number_save;
  info_for_exception    = info_for_exception_save;
  rem                   = rem_save;
  rem_lc                = rem_lc_save;
  command_name          = command_name_save;

}



void infer_connect_core_wrapper(const string&           core_name,
                                const set<string>&      iface_set,
                                const map<string,bool>& connected_map,
                                const string&           name_prefix)
{
  for (set<string>::const_iterator i = iface_set.begin(); i != iface_set.end(); ++i) {
    if (!connected_map.find(*i)->second) {
      do_inferred_command("---connect_core_wrapper=" + core_name + "," + *i + "," + name_prefix);
    }
  }
}



void infer_connect_wrapper_core(const string&           core_name,
                                const set<string>&      iface_set,
                                const map<string,bool>& connected_map,
                                const string&           name_prefix)
{
  for (set<string>::const_iterator i = iface_set.begin(); i != iface_set.end(); ++i) {
    if (!connected_map.find(*i)->second) {
      do_inferred_command("---connect_wrapper_core=" + name_prefix + "," + *i + "," + core_name);
    }
  }
}



void infer_connect_core_proxy(const string&           core_name,
                              const set<string>&      iface_set,
                              const map<string,bool>& connected_map,
                              const string&           name_prefix,
                              const string&           proxy_name)
{
  for (set<string>::const_iterator i = iface_set.begin(); i != iface_set.end(); ++i) {
    if (!connected_map.find(*i)->second) {
      do_inferred_command("---connect_core_proxy=" + core_name + "," + *i + "," + name_prefix + "," + proxy_name);
    }
  }
}



void infer_connect_proxy_core(const string&           core_name,
                              const set<string>&      iface_set,
                              const map<string,bool>& connected_map,
                              const string&           name_prefix,
                              const string&           proxy_name)
{
  for (set<string>::const_iterator i = iface_set.begin(); i != iface_set.end(); ++i) {
    if (!connected_map.find(*i)->second) {
      do_inferred_command("---connect_proxy_core=" + proxy_name + "," + name_prefix + "," + *i + "," + core_name);
    }
  }
}



void do_inferred_command(const string& command) {
  XTSC_INFO(logger, "Inferred command: " << command);
  setup_command_variables(command, "(Inferred from \"fully_connect_cores\")", 0xFFFFFFFF, "");
  process_command(-1);
}



void final_processing() {
  XTSC_TRACE(logger, "enter final_processing()");

  finalize_system_or_wrapper();

  if (summary) {
    log_summary(summary_verbose);
  }

  if (do_generate_sc_main) {
    if (systemc_on_top && !proxy_map[w]->size()) {
      XTSC_NOTE(logger, "Skipping code generation because no Verilog proxies were created");
    }
    else if (verilog_on_top && !wrapper_map.size()) {
      XTSC_NOTE(logger, "Skipping code generation because no SystemC wrappers were created");
    }
    else {
      generate_sc_main();
    }
  }

  if (!cosim && multi_core_debug) {
    char *argv[1] = { "--xxdebug" };
    xtsc_core::setup_multicore_debug(1, argv, 0, multi_core_debug_wait, multi_core_debug_sync, true, multi_core_debug_start_port);
  }

  if (!no_simulation) {

    // Ensure each core has a program loaded or was explicitly told that it
    // doesn't have a program to load via the "--core_program=" command.
    for (map<string,core_info*>::iterator ic = core_map[w]->begin(); ic != core_map[w]->end(); ++ic) {
      const char *prog = ic->second->parms.get_c_str("SimTargetProgram");
      if (!ic->second->has_program_loaded && (!prog || !prog[0]) && !ic->second->explicit_no_program) {
        ostringstream oss;
        oss << "Error: Core '" << ic->second->name << "' does not have a program loaded." << endl;
        oss << "Often this is the result of more xtsc_core objects being instantiated then you intended." << endl;
        oss << "You can use the --summary command to see if more modules were instantiated then you intended." << endl;
        oss << "If more modules were instantiated then you intended please see the XTSC User's Guide or use" << endl;
        oss << "the --manual option to xtsc-run for information on module inference by xtsc-run." << endl;
        oss << "If you specifically intended to not load a program (e.g. the program is put in place" << endl;
        oss << "via the \"initial_value_file\" parameter of xtsc_memory), then use the --core_program= " << endl;
        oss << "command (with an empty assignment) prior to the core's explicit or inferred instantiation." << endl;
        throw xtsc_exception(oss.str());
      }
    }


    XTSC_INFO(logger, "Calling sc_start.");

    if (logging_elab_only) {
      sc_start(SC_ZERO_TIME);
      xtsc_enable_text_logging(false);
    }

    if (cycle_limit == 0xFFFFFFFF) {
      sc_start();
    }
    else {
      sc_start(cycle_limit*xtsc_get_system_clock_period());
    }

    XTSC_INFO(logger, "Simulation complete.");
  }

  // Do any requested core_summary's
  u32 save_w = w;
  for (u32 iw=0; iw<=save_w; ++iw) {
    w = iw;
    for (map<string,core_info*>::iterator ic = core_map[w]->begin(); ic != core_map[w]->end(); ++ic) {
      if (ic->second->core_summary) {
        ostringstream oss;
        ic->second->p_core->summary(oss);
        oss << endl << ic->second->name << " exit code: " << ic->second->p_core->get_exit_code() << endl;
        xtsc_log_multiline(log4xtensa::TextLogger::getInstance(ic->second->p_core->name()), log4xtensa::NOTE_LOG_LEVEL, oss.str());
      }
    }
  }
  w = save_w;

#if 0
  if ((!XTENSA_CORE || !XTENSA_CORE[0]) || (!XTENSA_SYSTEM || !XTENSA_SYSTEM[0])) {
    if (redo_core_parms_called) {
      throw xtsc_exception("No core creation can take place if either XTENSA_CORE or XTENSA_SYSTEM is not specified");
    }
  }
#endif


  //  ************************  Clean-up objects   *************************


// Step 29:  Add clean-up code for (*widget_map[w]) and the widgets it maps to

  save_w = w;
  for (u32 iw=0; iw<=save_w; ++iw) {

    w = iw;

    {
      map<string,arbiter_info*>::const_iterator ia = arbiter_map[w]->begin();
      for (; ia != arbiter_map[w]->end(); ++ia) {
        delete ia->second;
      }
      arbiter_map[w]->clear();
    }


    {
      map<string,clock_info*>::const_iterator ic = clock_map[w]->begin();
      for (; ic != clock_map[w]->end(); ++ic) {
        delete ic->second;
      }
      clock_map[w]->clear();
    }


    {
      map<string,cohctrl_info*>::const_iterator ic = cohctrl_map[w]->begin();
      for (; ic != cohctrl_map[w]->end(); ++ic) {
        delete ic->second;
      }
      cohctrl_map[w]->clear();
    }


    {
      map<string,core_info*>::const_iterator ic = core_map[w]->begin();
      for (; ic != core_map[w]->end(); ++ic) {
        delete ic->second;
      }
      core_map[w]->clear();
    }


    {
      map<string,distributor_info*>::const_iterator id = distributor_map[w]->begin();
      for (; id != distributor_map[w]->end(); ++id) {
        delete id->second;
      }
      distributor_map[w]->clear();
    }


    {
      map<string,dma_info*>::const_iterator ia = dma_map[w]->begin();
      for (; ia != dma_map[w]->end(); ++ia) {
        delete ia->second;
      }
      dma_map[w]->clear();
    }


    {
      map<string,driver_info*>::const_iterator id = driver_map[w]->begin();
      for (; id != driver_map[w]->end(); ++id) {
        delete id->second;
      }
      driver_map[w]->clear();
    }


    {
      map<string,loader_info*>::const_iterator il = loader_map[w]->begin();
      for (; il != loader_map[w]->end(); ++il) {
        delete il->second;
      }
      loader_map[w]->clear();
    }


    {
      map<string,logic_info*>::const_iterator il = logic_map[w]->begin();
      for (; il != logic_map[w]->end(); ++il) {
        delete il->second;
      }
      logic_map[w]->clear();
    }


    {
      map<string,lookup_info*>::const_iterator il = lookup_map[w]->begin();
      for (; il != lookup_map[w]->end(); ++il) {
        delete il->second;
      }
      lookup_map[w]->clear();
    }


    {
      map<string,lookup_pin_info*>::const_iterator il = lookup_pin_map[w]->begin();
      for (; il != lookup_pin_map[w]->end(); ++il) {
        delete il->second;
      }
      lookup_pin_map[w]->clear();
    }


    {
      map<string,master_info*>::const_iterator im = master_map[w]->begin();
      for (; im != master_map[w]->end(); ++im) {
        delete im->second;
      }
      master_map[w]->clear();
    }


    {
      map<string,memory_info*>::const_iterator im = memory_map[w]->begin();
      for (; im != memory_map[w]->end(); ++im) {
        delete im->second;
      }
      memory_map[w]->clear();
    }


    {
      map<string,memory_pin_info*>::const_iterator im = memory_pin_map[w]->begin();
      for (; im != memory_pin_map[w]->end(); ++im) {
        delete im->second;
      }
      memory_pin_map[w]->clear();
    }


    {
      map<string,memory_trace_info*>::const_iterator im = memory_trace_map[w]->begin();
      for (; im != memory_trace_map[w]->end(); ++im) {
        delete im->second;
      }
      memory_trace_map[w]->clear();
    }


    {
      map<string,mmio_info*>::const_iterator im = mmio_map[w]->begin();
      for (; im != mmio_map[w]->end(); ++im) {
        delete im->second;
      }
      mmio_map[w]->clear();
    }


    {
      map<string,pin2tlm_info*>::const_iterator it = pin2tlm_map[w]->begin();
      for (; it != pin2tlm_map[w]->end(); ++it) {
        delete it->second;
      }
      pin2tlm_map[w]->clear();
    }


    {
      map<string,producer_info*>::const_iterator ip = producer_map[w]->begin();
      for (; ip != producer_map[w]->end(); ++ip) {
        delete ip->second;
      }
      producer_map[w]->clear();
    }


    {
      map<string,proxy_info*>::const_iterator ip = proxy_map[w]->begin();
      for (; ip != proxy_map[w]->end(); ++ip) {
        delete ip->second;
      }
      proxy_map[w]->clear();
    }


    {
      map<string,queue_info*>::const_iterator iq = queue_map[w]->begin();
      for (; iq != queue_map[w]->end(); ++iq) {
        delete iq->second;
      }
      queue_map[w]->clear();
    }


    {
      map<string,queue_pin_info*>::const_iterator iq = queue_pin_map[w]->begin();
      for (; iq != queue_pin_map[w]->end(); ++iq) {
        delete iq->second;
      }
      queue_pin_map[w]->clear();
    }


    {
      map<string,consumer_info*>::const_iterator ic = consumer_map[w]->begin();
      for (; ic != consumer_map[w]->end(); ++ic) {
        delete ic->second;
      }
      consumer_map[w]->clear();
    }


    {
      map<string,router_info*>::const_iterator ir = router_map[w]->begin();
      for (; ir != router_map[w]->end(); ++ir) {
        delete ir->second;
      }
      router_map[w]->clear();
    }


    {
      map<string,signal_info*>::const_iterator is = signal_map[w]->begin();
      for (; is != signal_map[w]->end(); ++is) {
        delete is->second;
      }
      signal_map[w]->clear();
    }


    {
      map<string,slave_info*>::const_iterator is = slave_map[w]->begin();
      for (; is != slave_map[w]->end(); ++is) {
        delete is->second;
      }
      slave_map[w]->clear();
    }


    {
      map<string,source_info*>::const_iterator is = source_map[w]->begin();
      for (; is != source_map[w]->end(); ++is) {
        delete is->second;
      }
      source_map[w]->clear();
    }


    {
      map<string,tlm2pin_info*>::const_iterator it = tlm2pin_map[w]->begin();
      for (; it != tlm2pin_map[w]->end(); ++it) {
        delete it->second;
      }
      tlm2pin_map[w]->clear();
    }


    {
      map<string,vcd_info*>::const_iterator iv = vcd_map[w]->begin();
      for (; iv != vcd_map[w]->end(); ++iv) {
        delete iv->second;
      }
      vcd_map[w]->clear();
    }


    {
      map<string,wire_info*>::const_iterator iw = wire_map[w]->begin();
      for (; iw != wire_map[w]->end(); ++iw) {
        delete iw->second;
      }
      wire_map[w]->clear();
    }

  }
  w = save_w;

}



// Step 30:  Add block of code conditioned on widget_map[w]->size()

void generate_sc_main() {
  XTSC_TRACE(logger, "enter generate_sc_main()");

  if (mkdir(path.c_str(), 0750) && cosim) {
    ostringstream oss;
    oss << "Cannot make directory: '" << path << "' (possibly it already exists or the parent directory does not exist).";
    throw xtsc_exception(oss.str());
  }

  time_t date_time;
  time(&date_time);

  // Foreach wrapper (or once for the whole system if not doing verilog_on_top) . . .
  for (map<string,wrapper_info*>::iterator iw = wrapper_map.begin(); iw != wrapper_map.end(); ++iw) {

    string wrapper_name = iw->first;
    wrapper_info& wrapper = *iw->second;   // wrapper is a valid reference only if verilog_on_top is true
    w = (verilog_on_top ? wrapper.index : 0);

    string output_file_name = path + wrapper_name;

    const char *argv_space = verilog_on_top ? wrapper.parms.get_c_str("argv_space") :
                             systemc_on_top ? p_make_parms->get_c_str("argv_space") : NULL;

    if (verilog_on_top) {
      XTSC_DEBUG(logger, "Generating code for wrapper \"" << wrapper_name << "\"");

      string wrapper_cpp = output_file_name + ".cpp";
      ofstream cpp(wrapper_cpp.c_str());
      if (!cpp) {
        ostringstream oss;
        oss << "Cannot open file \"" << wrapper_cpp << "\" for output.";
        throw xtsc_exception(oss.str());
      }
      cpp << "// Generated by xtsc-run: " << ctime(&date_time);
      cpp << endl;
      cpp << "#include \"" << wrapper_name << ".h\"" << endl;
      if (vendor == "cadence") {
        cpp << "NCSC_MODULE_EXPORT(" << wrapper_name << ");" << endl;
      }
      else if (vendor == "mentor") {
        cpp << "SC_MODULE_EXPORT(" << wrapper_name << ");" << endl;
      }

      // For Verilog on top what we'll call cpp from now on is really the header (.h) file
      output_file_name += ".h";
    }

    ofstream cpp(output_file_name.c_str());

    if (!cpp) {
      ostringstream oss;
      oss << "Cannot open file \"" << output_file_name << "\" for output.";
      throw xtsc_exception(oss.str());
    }

    cpp << "// Generated by xtsc-run: " << ctime(&date_time);
    cpp << endl;
    cpp << "// Header files for each module" << endl;

    bool component_from_libxtsc = false;   // xtsc_core or any other XTSC module in namespace xtsc
    bool uses_xtsc_component    = false;   // Has an XTSC module from namespace xtsc_comp

    if (arbiter_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_arbiter.h>" << endl;
      uses_xtsc_component = true;
    }
    if (clock_map[w]->size()) {
      ; // Do nothing - SystemC is included by xtsc.h
    }
    if (cohctrl_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_cohctrl.h>" << endl;
      component_from_libxtsc = true;
    }
    if (core_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_core.h>" << endl;
      component_from_libxtsc = true;
    }
    if (dma_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_dma_engine.h>" << endl;
      uses_xtsc_component = true;
    }
    if (distributor_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_interrupt_distributor.h>" << endl;
      component_from_libxtsc = true;
    }
    if (loader_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_tx_loader.h>" << endl;
    }
    if (lookup_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_lookup.h>" << endl;
      uses_xtsc_component = true;
    }
    if (driver_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_lookup_driver.h>" << endl;
      uses_xtsc_component = true;
    }
    if (lookup_pin_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_lookup_pin.h>" << endl;
      uses_xtsc_component = true;
    }
    if (master_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_master.h>" << endl;
      uses_xtsc_component = true;
    }
    if (memory_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_memory.h>" << endl;
      uses_xtsc_component = true;
    }
    if (memory_pin_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_memory_pin.h>" << endl;
      uses_xtsc_component = true;
    }
    if (memory_trace_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_memory_trace.h>" << endl;
      uses_xtsc_component = true;
    }
    if (mmio_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_mmio.h>" << endl;
      uses_xtsc_component = true;
    }
    if (pin2tlm_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_pin2tlm_memory_transactor.h>" << endl;
      uses_xtsc_component = true;
    }
    if (proxy_map[w]->size()) {
      ; // Do nothing - handled below based on verilog_proxy_vector_map
    }
    if (queue_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_queue.h>" << endl;
      uses_xtsc_component = true;
    }
    if (consumer_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_queue_consumer.h>" << endl;
      uses_xtsc_component = true;
    }
    if (queue_pin_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_queue_pin.h>" << endl;
      uses_xtsc_component = true;
    }
    if (producer_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_queue_producer.h>" << endl;
      uses_xtsc_component = true;
    }
    if (router_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_router.h>" << endl;
      uses_xtsc_component = true;
    }
    if (slave_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_slave.h>" << endl;
      uses_xtsc_component = true;
    }
    if (tlm2pin_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_tlm2pin_memory_transactor.h>" << endl;
      uses_xtsc_component = true;
    }
    if (vcd_map[w]->size()) {
      ; // Do nothing - SystemC is included by xtsc.h
    }
    if (wire_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_wire.h>" << endl;
      uses_xtsc_component = true;
    }
    if (logic_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_wire_logic.h>" << endl;
      uses_xtsc_component = true;
    }
    if (source_map[w]->size()) {
      cpp << "#include <xtsc/xtsc_wire_source.h>" << endl;
      uses_xtsc_component = true;
    }
    if (!component_from_libxtsc && !uses_xtsc_component) {
      cpp << "#include <xtsc/xtsc.h>" << endl;
    }
    map<string,vector<proxy_info*>*>::iterator ivpvm;
    for (ivpvm = verilog_proxy_vector_map.begin(); ivpvm != verilog_proxy_vector_map.end(); ++ivpvm) {
     cpp << "#include \"" << ivpvm->first << ".h\"" << endl;
    }
    if (vendor == "synopsys") {
      cpp << endl;
      cpp << "// Undo Synopsys' egregious #define of C++ reserved words" << endl;
      cpp << "#undef true" << endl;
      cpp << "#undef false" << endl;
    }
    cpp << endl;
    cpp << endl;
    cpp << "// Declare some namespaces for convenience" << endl;
    cpp << "using namespace std;" << endl;
    cpp << "using namespace sc_core;" << endl;
    cpp << "using namespace sc_dt;" << endl;
    cpp << "using namespace xtsc;" << endl;
    if (uses_xtsc_component) {
    cpp << "using namespace xtsc_component;" << endl;
    }
    cpp << endl;
    cpp << endl;
    if (verilog_on_top) {
      add_extra_io_to_wrapper(wrapper.parms.get_c_str_array("extra_inputs"), true);
      add_extra_io_to_wrapper(wrapper.parms.get_c_str_array("extra_outputs"), false);
      cpp << "class " << wrapper_name << ": public sc_module {" << endl;
      cpp << "public:" << endl;
      cpp << endl;
      cpp << wrapper.ports.str();
      cpp << endl;
      if (clock_map[w]->size() || (cycle_limit != 0xFFFFFFFF)) {
        cpp << tab1 << "SC_HAS_PROCESS(" << wrapper_name << ");" << endl;
        cpp << endl;
      }
      cpp << tab1 << wrapper_name << "(sc_module_name module_name) :" << endl;
      u32 nc = 9;
      for (vector<string>::const_iterator ip = wrapper.ctor_init_list.begin(); ip != wrapper.ctor_init_list.end(); ++ip) {
        nc = max(nc, ip->length());
      }
      cpp << tab2 << "sc_module" << space(nc-9) << "(module_name)," << endl;
      for (vector<string>::const_iterator ip = wrapper.ctor_init_list.begin(); ip != wrapper.ctor_init_list.end(); ++ip) {
        const char *spc = space(nc - min(nc, ip->length()));
        cpp << tab2 << *ip << spc << "(\"" << *ip << "\")," << endl;
      }
      cpp << tab2 << "logger" << space(nc-6) << "(log4xtensa::TextLogger::getInstance(name()))" << endl;
      cpp << tab1 << "{" << endl;
    }
    else {
      cpp << "// In case you want to log something" << endl;
      cpp << "static log4xtensa::TextLogger& logger = log4xtensa::TextLogger::getInstance(\"sc_main\");" << endl;
      cpp << endl;
      cpp << endl;
      cpp << "int sc_main(int argc, char *argv[]) {" << endl;
    }
    cpp << endl;
    cpp << tab1 << "try {" << endl;
    cpp << endl;
    if (verilog_on_top) {
      cpp << tab2 << "argc = sc_argc();" << endl;
      cpp << tab2 << "argv = sc_argv();" << endl;
      cpp << endl;
    }
    if (cosim && argv_space && argv_space[0] && (argv_space[0] != ' ')) {
      cpp << tab2 << "// Convert '" << argv_space[0] << "' to ' ' in argv[i]" << endl;
      cpp << tab2 << "for (int i=1; i<argc; ++i) {" << endl;
      cpp << tab2 << "  for (int j=0; j<strlen(argv[i]); ++j) {" << endl;
      cpp << tab2 << "    if (argv[i][j] == '" << argv_space[0] << "') *const_cast<char *>(&argv[i][j]) = ' ';" << endl;
      cpp << tab2 << "  }" << endl;
      cpp << tab2 << "}" << endl;
      cpp << endl;
    }
    if (!verilog_on_top) {
      cpp << tab2 << "// Declare each module pointer" << endl;
      for (pair_table::iterator i = modules[w]->begin(); i != modules[w]->end(); ++i) {
        string type(i->first);
        string name(i->second);
        cpp << tab2 << type << space(30-type.length()) << " *" << name << ";" << endl;
      }
      cpp << endl;
    }
    cpp << tab2 << "// Initialize XTSC" << endl;
    cpp << tab2 << "xtsc_initialize_parms xtsc__parms;" << endl;
    string parms(oss_xtsc_parms.str());
    string::size_type pos;
    while ((pos = parms.find(name_xtsc_parms)) != string::npos) {
      parms.replace(pos, name_xtsc_parms.length(), "xtsc__parms");
    }
    cpp << parms;
    cpp << tab2 << "xtsc__parms.extract_parms(argc, argv, \"xtsc\");" << endl;
    cpp << tab2 << "xtsc_initialize(xtsc__parms);";
    cpp << endl;
    cpp << oss_main[w]->str();
    cpp << endl;
    if (!verilog_on_top && core_map[w]->size()) {
      cpp << tab2 << "// Set-up debugging according to command line arguments, if any" << endl;
      cpp << tab2 << "xtsc_core::setup_multicore_debug(argc, argv, 0xFFFFFFFF, " << boolalpha
         << multi_core_debug_wait << ", " << multi_core_debug_sync << ", true, 0x" << hex
         << multi_core_debug_start_port << dec << ");" << endl;
      cpp << endl;
    }
    if (!verilog_on_top) {
      cpp << tab2 << "// Simulate" << endl;
      if (logging_elab_only) {
        cpp << tab2 << "sc_start(SC_ZERO_TIME);" << endl;
        cpp << tab2 << "xtsc_enable_text_logging(false);" << endl;
      }
      cpp << tab2;
      cpp << "sc_start(";
      if (cycle_limit != 0xFFFFFFFF) {
       cpp << cycle_limit << "*xtsc_get_system_clock_period()";
      }
      cpp << ");" << endl;
    }

    // Do any requested core_summary's
    ostringstream sum;
    map<string,core_info*>::iterator ic = core_map[w]->begin();
    bool first = true;
    for (; ic != core_map[w]->end(); ++ic) {
      if (ic->second->core_summary) {
        if (first) {
          first =false;
          sum << endl;
          sum << tab2 << "// Core summaries " << endl;
        }
        sum << tab2 << ic->second->name << ".summary(cout);" << endl;
      }
    }

    if (!verilog_on_top) {
      cpp << sum.str();
      cpp << endl;
      cpp << tab2 << "// Finalize XTSC" << endl;
      cpp << tab2 << "xtsc_finalize();" << endl;
      cpp << endl;
      cpp << tab2 << "// Delete each sc_module we've created" << endl;
      for (pair_table::reverse_iterator i = modules[w]->rbegin(); i != modules[w]->rend(); ++i) {
        cpp << tab2 << "delete " << i->second << ";" << endl;
      }
      cpp << endl;
    }
    else {
      if ((w == 0) && (cycle_limit != 0xFFFFFFFF)) {
        cpp << tab2 << "SC_THREAD(cycle_limit_thread);" << endl;
        cpp << endl;
      }
      // Trace all wrapper I/O, if requested
      if (wrapper.vcd_handle != "") {
        // Get length of longest name
        u32 nc = 1;
        vector<pair<string,u32> >::iterator iio;
        for (iio = wrapper.connected_input_list.begin(); iio != wrapper.connected_input_list.end(); ++iio) {
          nc = max(nc, iio->first.length());
        }
        for (iio = wrapper.connected_output_list.begin(); iio != wrapper.connected_output_list.end(); ++iio) {
          nc = max(nc, iio->first.length());
        }
        // Trace each input
        cpp << tab2 << "// Trace each input" << endl;
        for (iio = wrapper.connected_input_list.begin(); iio != wrapper.connected_input_list.end(); ++iio) {
          const char *spc = space(nc - min(nc, iio->first.length()));
          cpp << tab2 << "sc_trace(" << wrapper.vcd_handle << ", " << iio->first << ", " << spc << iio->first << spc
                      << ".name());" << endl;
        }
        // Trace each output
        cpp << endl;
        cpp << tab2 << "// Trace each output" << endl;
        for (iio = wrapper.connected_output_list.begin(); iio != wrapper.connected_output_list.end(); ++iio) {
          const char *spc = space(nc - min(nc, iio->first.length()));
          cpp << tab2 << "sc_trace(" << wrapper.vcd_handle << ", " << iio->first << ", " << spc << iio->first << spc
                      << ".name());" << endl;
        }
        cpp << endl;
      }
    }
    cpp << tab1 << "}" << endl;
    cpp << tab1 << "catch (const exception& error) {" << endl;
    cpp << tab2 << "ostringstream oss;" << endl;
    cpp << tab2 << "oss << \"std::exception caught: \" << endl;" << endl;
    cpp << tab2 << "oss << error.what() << endl;" << endl;
    cpp << tab2 << "xtsc_log_multiline(logger, log4xtensa::FATAL_LOG_LEVEL, oss.str(), 2);" << endl;
    cpp << tab2 << "cerr << oss.str();" << endl;
    cpp << tab1 << "}" << endl;
    cpp << endl;
    if (!verilog_on_top) {
      cpp << tab1 << "return 0;" << endl;
      cpp << "}" << endl;
    }
    else {
      cpp << tab1 << "}" << endl;
      cpp << endl;
      cpp << tab1 << "~" << wrapper_name << "() {" << endl;
      cpp << sum.str();
      cpp << tab2 << "// Finalize XTSC" << endl;
      cpp << tab2 << "xtsc_finalize();" << endl;
      cpp << endl;
      cpp << tab2 << "// Delete each sc_module we've created" << endl;
      for (pair_table::reverse_iterator i = modules[w]->rbegin(); i != modules[w]->rend(); ++i) {
        cpp << tab2 << "delete " << i->second << ";" << endl;
      }
      cpp << endl;
      cpp << tab1 << "}" << endl;
      cpp << endl;
      cpp << tab1 << "void end_of_elaboration() {" << endl;
      static bool did_setup_multicore_debug = false;
      if (!did_setup_multicore_debug && core_map[w]->size()) {
        did_setup_multicore_debug = true;
        cpp << tab2 << "// Set-up debugging according to command line arguments, if any" << endl;
        cpp << tab2 << "xtsc_core::setup_multicore_debug(argc, argv, 0xFFFFFFFF, " << boolalpha
           << multi_core_debug_wait << ", " << multi_core_debug_sync << ", true, 0x" << hex
           << multi_core_debug_start_port << dec << ");" << endl;
      }
      cpp << tab1 << "}" << endl;
      cpp << endl;
      cpp << tab1 << "void start_of_simulation() {" << endl;
      if (logging_elab_only) {
        cpp << tab2 << "xtsc_enable_text_logging(false);" << endl;
      }
      cpp << tab1 << "}" << endl;
      cpp << endl;
      for (map<string,clock_info*>::iterator ic = clock_map[w]->begin(); ic != clock_map[w]->end(); ++ic) {
        cpp << tab1 << "sc_clock *" << ic->first << ";" << endl;
        cpp << tab1 << "void " << ic->first << "_method() {" << endl;
        vector<pair<string,string> >::iterator i;
        for (i = wrapper.connected_clock_list.begin(); i != wrapper.connected_clock_list.end(); ++i) {
          if (ic->first == i->first) {
            cpp << tab2 << i->second << ".write(" << ic->first << "->read());" << endl;
          }
        }
        cpp << tab1 << "}" << endl;
        cpp << endl;
      }
      if ((w == 0) && (cycle_limit != 0xFFFFFFFF)) {
        cpp << tab1 << "void cycle_limit_thread() {" << endl;
        cpp << tab2 << "wait(xtsc_get_system_clock_period()*" << cycle_limit << ");" << endl;
        cpp << tab2 << "XTSC_INFO(logger, \"Calling sc_stop()\");" << endl;
        cpp << tab2 << "sc_stop();" << endl;
        cpp << tab1 << "}" << endl;
        cpp << endl;
      }
      cpp << tab1 << "log4xtensa::TextLogger&         logger;" << endl;
      cpp << tab1 << "int                             argc;" << endl;
      cpp << tab1 << "const char* const*              argv;" << endl;
      cpp << endl;
      for (pair_table::iterator i = modules[w]->begin(); i != modules[w]->end(); ++i) {
        string type(i->first);
        string name(i->second);
        cpp << tab1 << type << space(30-type.length()) << " *" << name << ";" << endl;
      }
      cpp << endl;
      cpp << "};" << endl;
    }

  }


  if (systemc_on_top) {

    w = 0;

    string makefile_name(path + "Makefile");
    ofstream mak(makefile_name.c_str());

    if (!mak) {
      ostringstream oss;
      oss << "Cannot open make file \"" << makefile_name << "\" for output.";
      throw xtsc_exception(oss.str());
    }

    mak << "# Generated by xtsc-run: " << ctime(&date_time);
    mak << endl;

    xtsc_core_parms *p_parms = get_newest_core_parms();
    if (!p_parms) {
      init_core_parms();
      p_parms = p_core_parms;
    }

    ostringstream dat;
    ostringstream data_file_targets;

    // Do xt-dumpelf as requested
    // Foreach proxy . . . 
    for (map<string,proxy_info*>::iterator ip = proxy_map[w]->begin(); ip != proxy_map[w]->end(); ++ip) {
      if (ip->second->generate_data_files) {
        xtsc_core::memory_port mem_port=xtsc_core::get_memory_port(ip->second->readmemh_interface);
        string ext1(mem_port == xtsc_core::MEM_PIF ? ".sysram" : "");
        string ext2(".sysrom");
        ostringstream targ1;    // Local memory or sysram
        ostringstream rule1;    // Local memory or sysram
        ostringstream targ2;    // sysrom
        ostringstream rule2;    // sysrom
        ostringstream data1;
        ostringstream data2;
        if (vendor == "synopsys") {
          data1 << data_dir << "/" << ip->second->readmemh_interface_v << ".data" << ext1;
          data2 << data_dir << "/" << ip->second->readmemh_interface_v << ".data" << ext2;
        }
        else {
          data1 << data_dir << "/" << ip->first << "." << ip->second->readmemh_interface_v << ".data" << ext1;
          data2 << data_dir << "/" << ip->first << "." << ip->second->readmemh_interface_v << ".data" << ext2;
        }
        targ1 << data1.str() << ":";
        rule1 << "\t" << "if [ ! -d " << data_dir << " ]; then mkdir " << data_dir << "; fi" << endl;
        targ2 << data2.str() << ":";
        rule2 << "\t" << "if [ ! -d " << data_dir << " ]; then mkdir " << data_dir << "; fi" << endl;
        bool used_targ1 = false;
        bool used_targ2 = false;
        // Foreach core in the proxy's "readmemh_cores" parameter . . . 
        for (u32 i=0; ip->second->readmemh_cores[i]; ++i) {
          string core_name(ip->second->readmemh_cores[i]);
          map<string,core_info*>::iterator ic = core_map[w]->find(core_name);
          if (ic == core_map[w]->end()) {
            ostringstream oss;
            oss << "ERROR: No core found named '" << core_name << "' (from \"readmemh_cores\" parameter of proxy \""
                << ip->second->name << "\")";
            throw xtsc_exception(oss.str());
          }
          core_info& ci(*ic->second);
          string program_name("");
          if (ci.has_program_loaded) {
            program_name = ci.program_name;
          }
          else {
            const char *prog = ci.parms.get_c_str("SimTargetProgram");
            if (prog && prog[0]) {
              program_name = prog;
            }
            else {
              ostringstream oss;
              oss << "ERROR: No program loaded on core '" << core_name << "' (from \"readmemh_cores\" parameter of proxy \""
                  << ip->second->name << "\")";
              throw xtsc_exception(oss.str());
            }
          }
          string endian(ci.p_core->is_big_endian() ? "big-endian" : "little-endian");
          string zeros = "0x00000000000000000000000000000000";
          if (mem_port == xtsc_core::MEM_PIF) {
            if (ci.p_core->has_memory_port(xtsc_core::MEM_PIF)) {
              xtsc_address address8 = 0x0;
              u32          size8    = 0;
              u32          width8   = ci.p_core->get_memory_byte_width(mem_port);
              string       default_value(zeros.substr(0, 2+width8*2));
              if (ci.p_core->get_system_ram_starting_byte_address(address8)) {
                data_file_targets << " " << data1.str();
                ci.p_core->get_system_ram_byte_size(size8);
                used_targ1 = true;
                targ1 << " " << program_name;
                rule1 << "\t" << "xt-dumpelf --width=" << dec << (width8*8) << " --" << endian;
                add_base_arguments(rule1, *ci.p_core, address8, size8);
                rule1 << " --size=0x" << setw(8) << size8 << " " << program_name << " >> " << data1.str() << endl;
              }
              if (ci.p_core->get_system_rom_starting_byte_address(address8)) {
                data_file_targets << " " << data2.str();
                ci.p_core->get_system_rom_byte_size(size8);
                used_targ2 = true;
                targ2 << " " << program_name;
                rule2 << "\t" << "xt-dumpelf --width=" << dec << (width8*8) << " --" << endian;
                add_base_arguments(rule2, *ci.p_core, address8, size8);
                rule2 << " --size=0x" << setw(8) << size8 << " " << program_name << " >> " << data2.str() << endl;
              }
            }
          }
          else {
            if (ci.p_core->has_memory_port(mem_port)) {
              data_file_targets << " " << data1.str();
              xtsc_address address8 = 0x0;
              u32          size8    = 0;
              u32          width8   = ci.p_core->get_memory_byte_width(mem_port);
              string       default_value(zeros.substr(0, 2+width8*2));
              ci.p_core->get_local_memory_starting_byte_address(mem_port, address8);
              ci.p_core->get_local_memory_byte_size(mem_port, size8);
              used_targ1 = true;
              targ1 << " " << program_name;
              rule1 << "\t" << "xt-dumpelf --width=" << dec << (width8*8) << " --" << endian;
              add_base_arguments(rule1, *ci.p_core, address8, size8);
              rule1 << " --size=0x" << setw(8) << size8 << " " << program_name << " >> " << data1.str() << endl;
            }
          }
        }
        if (used_targ1) {
          dat << targ1.str() << endl;
          dat << rule1.str() << endl;
        }
        if (used_targ2) {
          dat << targ2.str() << endl;
          dat << rule2.str() << endl;
        }
      }
      else if ((vendor == "synopsys") && (ip->second->readmemh_file_name != "")) {
        xtsc_core::memory_port mem_port=xtsc_core::get_memory_port(ip->second->readmemh_interface);
        string ext1(mem_port == xtsc_core::MEM_PIF ? ".sysram" : "");
        string ext2(".sysrom");
        ostringstream targ1;    // Local memory or sysram
        ostringstream rule1;    // Local memory or sysram
        ostringstream targ2;    // sysrom
        ostringstream rule2;    // sysrom
        ostringstream data1;
        ostringstream data2;
        data1 << data_dir << "/" << ip->second->readmemh_interface_v << ".data" << ext1;
        data2 << data_dir << "/" << ip->second->readmemh_interface_v << ".data" << ext2;
        targ1 << data1.str() << ":";
        rule1 << "\t" << "if [ ! -d " << data_dir << " ]; then mkdir " << data_dir << "; fi" << endl;
        rule1 << "\t" << "-ln -s " << ip->second->readmemh_file_name << ext1 << " " << data1.str() << endl;
        targ2 << data2.str() << ":";
        rule2 << "\t" << "if [ ! -d " << data_dir << " ]; then mkdir " << data_dir << "; fi" << endl;
        rule2 << "\t" << "-ln -s " << ip->second->readmemh_file_name << ext2 << " " << data2.str() << endl;
        dat << targ1.str() << endl;
        dat << rule1.str() << endl;
        data_file_targets << " " << data1.str();
        if (mem_port == xtsc_core::MEM_PIF) {
          dat << targ2.str() << endl;
          dat << rule2.str() << endl;
          data_file_targets << " " << data2.str();
        }
      }
    }

    if (vendor == "cadence") {
      mak << "XTTOOLS = " << p_parms->get_c_str("InstallPrefix") << endl;
      mak << endl;
      mak << "CXX = " << p_make_parms->get_c_str("cxx") << endl;
      mak << endl;
      mak << "ISSLIBDIR = " << isslibdir << endl;
      mak << endl;
      mak << "XTSC_LIBRARY_PATH = $(XTTOOLS)/lib/$(ISSLIBDIR)/" << vendor << "-" << vendor_version << endl;
      mak << endl;
      mak << "GCC_VERS = " << (gcc_version == "4.1.2" ? gcc_minor_version : gcc_version) << endl;
      mak << endl;
      mak << "CADENCE_ROOT = $(shell ncroot)" << endl;
      mak << endl;
      mak << endl;
      mak << "IMPORT_MODULES = " << endl;
      mak << endl;
      mak << "IMPORT_OBJECTS = $(addsuffix .o,   $(IMPORT_MODULES))" << endl;
      mak << "IMPORT_SOURCES = $(addsuffix .cpp, $(IMPORT_MODULES))" << endl;
      mak << "IMPORT_HEADERS = $(addsuffix .h,   $(IMPORT_MODULES))" << endl;
      mak << endl;
      mak << endl;
      mak << "REQ_CXXFLAGS = -D NCSC -D CADENCE -D LNX86 -c -I$(CADENCE_ROOT)/tools/systemc/include_pch" << endl;
      mak << endl;
      mak << endl;
      mak << ".PHONY: all" << ((dat.str() == "") ? "" : " data_files") << " ncelab run clean info xtsc_library_check" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "all:" << ((dat.str() == "") ? "" : " data_files") << " systemc.so ncelab" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      if (dat.str() != "") {
        mak << "data_files: " << data_file_targets.str() << endl;
        mak << endl;
        mak << dat.str();
        mak << endl;
      }
      map<string,vector<proxy_info*>*>::const_iterator ip;
      for (ip = verilog_proxy_vector_map.begin(); ip != verilog_proxy_vector_map.end(); ++ip) {
        vector<proxy_info*> *p_vector = ip->second;
        proxy_info& first_proxy = *p_vector->at(0);
        mak << "IMPORT_MODULES += " << ip->first << endl;
        mak << ip->first << ".o: PORT_MAP=-sc_uint -sctype *:bool";
        for (vector<proxy_info*>::const_iterator i = p_vector->begin(); i != p_vector->end(); ++i) {
          for (vector<pair<string,u32> >::const_iterator j = (*i)->sc_bv_list.begin(); j != (*i)->sc_bv_list.end(); ++j) {
            mak << " \\" << endl << space(ip->first.length()+21) << " -sctype " << j->first << ":sc_bv";
          }
        }
        mak << endl;
        mak << ip->first << ".o: " << first_proxy.verilog_file << endl;
        string files("");
        const char *verilog_files = first_proxy.parms.get_c_str("verilog_files");
        if (verilog_files && verilog_files[0]) {
          files = " -file ";
          files += verilog_files;
        }
        mak << "\t" << "ncvlog " << p_make_parms->get_c_str("ncvlog_args") << files << " $<" << endl;
        mak << "\t" << "ncshell " << p_make_parms->get_c_str("ncshell_args") << " -generic -scopts \"-GCC_VERS $(GCC_VERS) " 
            << "-compiler $(CXX)\" -import verilog -into systemc $(PORT_MAP) $(@:%.o=%)" << endl;
        mak << endl;
      }
      mak << endl;
      mak << "sc_main.o: sc_main.cpp $(IMPORT_OBJECTS)" << endl;
      mak << "\t" << "$(CXX) $(REQ_CXXFLAGS) " << p_make_parms->get_c_str("cxx_args") << " -I$(XTTOOLS)/include -o $@ $< " << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "systemc.so: " << (no_check ? "" : "xtsc_library_check ") << "sc_main.o $(IMPORT_OBJECTS)" << endl;
      mak << "\t" << "$(CXX) -shared -Wl,-G " << p_make_parms->get_c_str("ld_args") << " -o systemc.so \\" << endl;
      mak << "          sc_main.o \\" << endl;
      mak << "          $(IMPORT_OBJECTS) \\" << endl;
      mak << "          -L$(XTSC_LIBRARY_PATH) \\" << endl;
      mak << "          -lxtsc \\" << endl;
      mak << "          -lxtsc_comp \\" << endl;
      mak << "          -L$(XTTOOLS)/lib/$(ISSLIBDIR) \\" << endl;
      mak << "          -lxtmp \\" << endl;
      mak << "          -lsimxtcore \\" << endl;
      mak << "          -llog4xtensa \\" << endl;
      mak << "          -L$(XTTOOLS)/lib \\" << endl;
      mak << "          -lxtparams \\" << endl;
      mak << "          -L$(CADENCE_ROOT)/tools/systemc/lib-linux \\" << endl;
      mak << "          -Wl,-rpath,$(XTTOOLS)/lib/$(ISSLIBDIR) \\" << endl;
      mak << "          -Wl,-rpath,$(XTTOOLS)/lib \\" << endl;
      mak << "          -Wl,-rpath,$(XTENSATOOLS_TOOLS_LIB) \\" << endl;
      string libgnu(xtsc_64bit ? "lib/64bit/gnu" : "lib/gnu");
      mak << "          $(CADENCE_ROOT)/tools/systemc/" << libgnu << "/$(GCC_VERS)/libncscCoSim_sh.so \\" << endl;
      mak << "          $(CADENCE_ROOT)/tools/systemc/" << libgnu << "/$(GCC_VERS)/libncscCoroutines_sh.so \\" << endl;
      mak << "          $(CADENCE_ROOT)/tools/systemc/" << libgnu << "/$(GCC_VERS)/libsystemc_sh.so" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "ncelab:" << endl;
      mak << "\t" << "ncelab " << p_make_parms->get_c_str("ncelab_args") << " -loadsc ./systemc sc_main" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "run:" << endl;
      mak << "\t" << "ncsim " << p_make_parms->get_c_str("ncsim_args") << " $(XTSC_RUN_COSIM_ARGS) sc_main" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "clean:" << endl;
      mak << "\t" << "ncsc_run -clean" << endl;
      mak << "\t" << "-rm -rf $(IMPORT_HEADERS) $(IMPORT_SOURCES) systemc.so *.out *.log *.vcd *.dump *.fsdb" << endl;
      for (map<string,proxy_info*>::iterator ip = proxy_map[w]->begin(); ip != proxy_map[w]->end(); ++ip) {
        if (ip->second->generate_data_files) {
          mak << "\t" << "-rm -rf " << data_dir << endl;
          break; 
        }
      }
      mak << endl;
      mak << endl;
      mak << endl;
      add_library_check_and_info(mak);
    }
    else if (vendor == "mentor") {
      mak << "XTTOOLS = " << p_parms->get_c_str("InstallPrefix") << endl;
      mak << endl;
      mak << "ISSLIBDIR = " << isslibdir << endl;
      mak << endl;
      mak << "XTSC_LIBRARY_PATH = $(XTTOOLS)/lib/$(ISSLIBDIR)/" << vendor << "-" << vendor_version << endl;
      mak << endl;
      mak << "PROXY_HEADERS = " << endl;
      mak << endl;
      mak << endl;
      mak << ".PHONY: all" << ((dat.str() == "") ? "" : " data_files") << " target vlog sccom run gui clean info xtsc_library_check"
          << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "all:" << ((dat.str() == "") ? "" : " data_files") << " target vlog sccom" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      if (dat.str() != "") {
        mak << "data_files: " << data_file_targets.str() << endl;
        mak << endl;
        mak << dat.str();
        mak << endl;
      }
      mak << "vlog: work" << endl;
      ostringstream scgenmod;
      map<string,vector<proxy_info*>*>::const_iterator ip;
      for (ip = verilog_proxy_vector_map.begin(); ip != verilog_proxy_vector_map.end(); ++ip) {
        vector<proxy_info*> *p_vector = ip->second;
        proxy_info& first_proxy = *p_vector->at(0);
        string files("");
        const char *verilog_files = first_proxy.parms.get_c_str("verilog_files");
        if (verilog_files && verilog_files[0]) {
          files = " -file ";
          files += verilog_files;
        }
        mak << "\t" << "vlog -work work " << p_make_parms->get_c_str("vlog_args") << files << " " << first_proxy.verilog_file << endl;
        scgenmod << "PROXY_HEADERS += " << ip->first << ".h" << endl;
        scgenmod << ip->first << ".h:" << endl;
        scgenmod << "\t" << "scgenmod " << p_make_parms->get_c_str("scgenmod_args") << " -bool -sc_bv " << ip->first << " \\" << endl;
        for (vector<proxy_info*>::const_iterator i = p_vector->begin(); i != p_vector->end(); ++i) {
          for (vector<pair<string,u32> >::const_iterator j = (*i)->sc_uint_list.begin(); j != (*i)->sc_uint_list.end(); ++j) {
            scgenmod << "\t" << " | sed 's/<sc_bv\\(.*\\)" << j->first << "/<sc_uint\\1" << j->first << "/' \\" << endl;
          }
        }
        scgenmod << "\t" << " > $@" << endl;
        scgenmod << endl;
        scgenmod << endl;
      }
      mak << endl;
      mak << endl;
      mak << endl;
      mak << scgenmod.str();
      mak << "sccom: " << (no_check ? "" : "xtsc_library_check ") << "$(PROXY_HEADERS) sc_main.cpp" << endl;
      mak << "\t" << "sccom -I$(XTTOOLS)/include -c " << p_make_parms->get_c_str("sccom_args") << " sc_main.cpp" << endl;
      mak << "\t" << "sccom -link " << p_make_parms->get_c_str("sccom_link_args") << " \\" << endl;
      mak << "\t" << "  -L$(XTSC_LIBRARY_PATH) \\" << endl;
      mak << "\t" << "  -lxtsc \\" << endl;
      mak << "\t" << "  -lxtsc_comp \\" << endl;
      mak << "\t" << "  -L$(XTTOOLS)/lib/$(ISSLIBDIR) \\" << endl;
      mak << "\t" << "  -lxtmp \\" << endl;
      mak << "\t" << "  -lsimxtcore \\" << endl;
      mak << "\t" << "  -llog4xtensa \\" << endl;
      mak << "\t" << "  -L$(XTTOOLS)/lib \\" << endl;
      mak << "\t" << "  -lxtparams \\" << endl;
      mak << "\t" << "  -Wl,-rpath,$(XTTOOLS)/lib/$(ISSLIBDIR) \\" << endl;
      mak << "\t" << "  -Wl,-rpath,$(XTTOOLS)/lib \\" << endl;
      mak << "\t" << "  -Wl,-rpath,$(XTENSATOOLS_TOOLS_LIB)" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "work:" << endl;
      mak << "\t" << "vlib work" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "run:" << endl;
      mak << "\t" << "vsim -c -do \"run -all; quit\" " << p_make_parms->get_c_str("vsim_args") << " $(XTSC_RUN_COSIM_ARGS) sc_main"
          << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "gui:" << endl;
      mak << "\t" << "vsim " << p_make_parms->get_c_str("vsim_args") << " sc_main" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "clean:" << endl;
      mak << "\t" << "rm -rf work $(PROXY_HEADERS) *.log *.vcd *.vcd.fsdb vsim_stacktrace.vstf vsim.wlf" << endl;
      for (map<string,proxy_info*>::iterator ip = proxy_map[w]->begin(); ip != proxy_map[w]->end(); ++ip) {
        if (ip->second->generate_data_files) {
          mak << "\t" << "-rm -rf " << data_dir << endl;
          break;
        }
      }
      mak << endl;
      mak << endl;
      mak << endl;
      add_library_check_and_info(mak);

      optionally_copy_modelsim_ini();
    }
    else if (vendor == "synopsys") {
      string full(xtsc_64bit ? "-full64 ": "");
      mak << "XTTOOLS = " << p_parms->get_c_str("InstallPrefix") << endl;
      mak << endl;
      mak << "CXX = " << p_make_parms->get_c_str("cxx") << endl;
      mak << endl;
      mak << "ISSLIBDIR = " << isslibdir << endl;
      mak << endl;
      mak << "XTSC_LIBRARY_PATH = $(XTTOOLS)/lib/$(ISSLIBDIR)/" << vendor << "-" << vendor_version << endl;
      mak << endl;
      mak << "SYSC = -sysc=2.2" << endl;
      mak << endl;
      mak << endl;
      mak << ".PHONY: all" << ((dat.str() == "") ? "" : " data_files") << " vlogan systemc simv run gui clean info xtsc_library_check"
          << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "all:" << ((dat.str() == "") ? "" : " data_files") << " vlogan systemc simv" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      if (dat.str() != "") {
        mak << "data_files: " << data_file_targets.str() << endl;
        mak << endl;
        mak << dat.str();
        mak << endl;
      }
      mak << "vlogan: " << endl;
      map<string,vector<proxy_info*>*>::const_iterator ip;
      for (ip = verilog_proxy_vector_map.begin(); ip != verilog_proxy_vector_map.end(); ++ip) {
        vector<proxy_info*> *p_vector = ip->second;
        proxy_info& first_proxy = *p_vector->at(0);
	mak << "\t" << "vlogan " << full << "-cpp $(CXX) $(SYSC) " << p_make_parms->get_c_str("vlogan_args") << " -sc_portmap "
            << ip->first << ".sc_port.map -sc_model " << ip->first << " " << first_proxy.verilog_file << endl;
      }
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "systemc:" << endl;
      mak << "\t" << "syscan " << full << "-cpp $(CXX) $(SYSC) -cflags \"-I$(XTTOOLS)/include\" "
          << p_make_parms->get_c_str("syscan_args") << " sc_main.cpp" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "simv:" << (no_check ? "" : " xtsc_library_check") << endl;
      mak << "\t" << "syscsim " << full << "-cpp $(CXX) $(SYSC) " << p_make_parms->get_c_str("syscsim_args") << " \\" << endl;
      for (ip = verilog_proxy_vector_map.begin(); ip != verilog_proxy_vector_map.end(); ++ip) {
        vector<proxy_info*> *p_vector = ip->second;
        proxy_info& first_proxy = *p_vector->at(0);
        const char *verilog_files = first_proxy.parms.get_c_str("verilog_files");
        if (verilog_files && verilog_files[0]) {
	  mak << "\t" << "-file " << verilog_files << " \\" << endl;
        }
      }
      mak << "\t" << "sc_main \\" << endl;
      mak << "\t" << "-ldflags -L$(XTSC_LIBRARY_PATH) \\" << endl;
      mak << "\t" << "-lxtsc \\" << endl;
      mak << "\t" << "-lxtsc_comp \\" << endl;
      mak << "\t" << "-ldflags -L$(XTTOOLS)/lib/$(ISSLIBDIR) \\" << endl;
      mak << "\t" << "-lxtmp \\" << endl;
      mak << "\t" << "-lsimxtcore \\" << endl;
      mak << "\t" << "-llog4xtensa \\" << endl;
      mak << "\t" << "-ldflags -L$(XTTOOLS)/lib \\" << endl;
      mak << "\t" << "-lxtparams \\" << endl;
      mak << "\t" << "-ldflags -Wl,-rpath,$(XTTOOLS)/lib/$(ISSLIBDIR) \\" << endl;
      mak << "\t" << "-ldflags -Wl,-rpath,$(XTTOOLS)/lib \\" << endl;
      mak << "\t" << "-ldflags -Wl,-rpath,$(XTENSATOOLS_TOOLS_LIB) \\" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "run:" << endl;
      mak << "\t" << "./simv " << p_make_parms->get_c_str("simv_args") << " $(XTSC_RUN_COSIM_ARGS)" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "gui:" << endl;
      mak << "\t" << "./simv -gui " << p_make_parms->get_c_str("simv_args") << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "clean:" << endl;
      mak << "\t" << "rm -rf csrc simv simv.daidir AN.DB .vcsmx_rebuild *.log *.vcd *.dump *.fsdb" << endl;
      for (map<string,proxy_info*>::iterator ip = proxy_map[w]->begin(); ip != proxy_map[w]->end(); ++ip) {
        if (ip->second->generate_data_files) {
          mak << "\t" << "-rm -rf " << data_dir << endl;
          break;
        }
      }
      mak << endl;
      mak << endl;
      mak << endl;
      add_library_check_and_info(mak);

      // Generate the *.sc_port.map files
      for (ip = verilog_proxy_vector_map.begin(); ip != verilog_proxy_vector_map.end(); ++ip) {
        vector<proxy_info*> *p_vector = ip->second;
        string pmap_name(path + ip->first + ".sc_port.map");
        ofstream pmap(pmap_name.c_str());
        if (!pmap) {
          ostringstream oss;
          oss << "Cannot open port map file \"" << pmap_name << "\" for output.";
          throw xtsc_exception(oss.str());
        }
        pmap << "# Generated by xtsc-run: " << ctime(&date_time);
        pmap << endl;
        for (vector<proxy_info*>::const_iterator i = p_vector->begin(); i != p_vector->end(); ++i) {
          for (vector<pair<string,u32> >::const_iterator j = (*i)->sc_bv_list.begin(); j != (*i)->sc_bv_list.end(); ++j) {
            pmap << j->first << space(30-j->first.length()) << " " << setw(4) << j->second << "  bit_vector  sc_bv" << endl;
          }
          for (vector<pair<string,u32> >::const_iterator j = (*i)->sc_uint_list.begin(); j != (*i)->sc_uint_list.end(); ++j) {
            pmap << j->first << space(30-j->first.length()) << " " << setw(4) << j->second << "  bit_vector  sc_uint" << endl;
          }
        }
        pmap << endl;
      }
    }

    // Generate any requested Verilog files
    map<string,vector<proxy_info*>*>::const_iterator ip;
    for (ip = verilog_proxy_vector_map.begin(); ip != verilog_proxy_vector_map.end(); ++ip) {
      vector<proxy_info*> *p_vector = ip->second;
      proxy_info& first_proxy = *p_vector->at(0);
      if (first_proxy.generate_verilog) {

        string full_name(path + first_proxy.verilog_file);
        ofstream ver(full_name.c_str());

        if (!ver) {
          ostringstream oss;
          oss << "Cannot open Verilog file \"" << full_name << "\" for output.";
          throw xtsc_exception(oss.str());
        }

        ver << "// Generated by xtsc-run: " << ctime(&date_time);
        ver << endl;
        ver << "`define DISPLAY_INPUTS" << endl;
        ver << endl;
        ver << "module " << first_proxy.module_name << "(" << endl;
        ostringstream oss;
        for (vector<proxy_info*>::const_iterator i = p_vector->begin(); i != p_vector->end(); ++i) {
          oss << (**i).ports.str();
        }
        string ports = oss.str();
        ports.replace(ports.find_last_of(","), 1, " ");  // Blank out last comma
        ver << ports;
        ver << ");" << endl;
        ver << endl;
        for (vector<proxy_info*>::const_iterator i = p_vector->begin(); i != p_vector->end(); ++i) {
          ver << (**i).inputs.str();
        }
        ver << endl;
        for (vector<proxy_info*>::const_iterator i = p_vector->begin(); i != p_vector->end(); ++i) {
          ver << (**i).outputs.str();
        }
        ver << endl;
        for (vector<proxy_info*>::const_iterator i = p_vector->begin(); i != p_vector->end(); ++i) {
          ver << (**i).regs.str();
        }
        ver << endl;
        ver << "`ifdef DISPLAY_INPUTS" << endl;
        vector<string> displays;
        u32 nc = 1;
        for (vector<proxy_info*>::const_iterator i = p_vector->begin(); i != p_vector->end(); ++i) {
          for (vector<string>::const_iterator j = (**i).displays.begin(); j != (**i).displays.end(); ++j) {
            displays.push_back(*j);
            nc = max(nc, j->length());
          }
        }
        for (vector<string>::const_iterator i = displays.begin(); i != displays.end(); ++i) {
          string name(*i + space(nc - min(nc, i->length())));
          ver << tab1 << "always @(" << name << ")" << " $display(\"%t " << name << " = 0x%h\", $time, " << name << ");" << endl;
        }
        ver << "`endif" << endl;
        ver << endl;
        ver << "endmodule" << endl;
      }
    }

  }
  else if (verilog_on_top) {

    const char *tbn = p_make_parms->get_c_str("testbench_name");
    string testbench_name(tbn ? tbn : "");
    bool generate_testbench = p_make_parms->get_bool("generate_testbench");

    if (testbench_name == "") {
      if ((vendor == "cadence") || (vendor == "mentor")) {
        ostringstream oss;
        oss << "You must provide a testbench name using --set_make_parm=testbench_name=XXX if cosim vendor is cadence or mentor";
        throw xtsc_exception(oss.str());
      }
      if (generate_testbench) {
        ostringstream oss;
        oss << "You must provide a testbench name using --set_make_parm=testbench_name=XXX if \"generate_testbench\" is true";
        throw xtsc_exception(oss.str());
      }
    }
    else {
      if (!is_identifier(testbench_name)) {
        ostringstream oss;
        oss << "\"testbench_name\" = '" << testbench_name << "' is not an identifier";
        throw xtsc_exception(oss.str());
      }
    }

    string makefile_name(path + "Makefile");
    ofstream mak(makefile_name.c_str());

    if (!mak) {
      ostringstream oss;
      oss << "Cannot open make file \"" << makefile_name << "\" for output.";
      throw xtsc_exception(oss.str());
    }

    mak << "# Generated by xtsc-run: " << ctime(&date_time);
    mak << endl;

    ostringstream dat;
    ostringstream data_file_targets;

    bool readmemh_use_prefix = p_make_parms->get_bool("readmemh_use_prefix");

    // Do xt-dumpelf as requested
    // Foreach wrapper . . . 
    for (map<string,wrapper_info*>::iterator iw = wrapper_map.begin(); iw != wrapper_map.end(); ++iw) {
      wrapper_info& wi = *(iw->second);
      w = wi.index;
      // Get list of the memory interface type of all tlm2pin devices connected to this wrapper
      set<string> memory_interfaces;
      vector<pair<tlm2pin_info*,u32> >::iterator it;
      for (it = wi.connected_tlm2pin_list.begin(); it != wi.connected_tlm2pin_list.end(); ++it) {
        tlm2pin_info& ti = *(it->first);
        string interface_name(ti.p_tlm2pin->get_interface_name());
        transform(interface_name.begin(), interface_name.end(), interface_name.begin(), ::tolower);
        memory_interfaces.insert(interface_name);
      }
      // Foreach core in the wrapper's "readmemh_cores" parameter . . . 
      for (u32 i=0; wi.readmemh_cores && wi.readmemh_cores[i]; ++i) {
        string core_name(wi.readmemh_cores[i]);
        map<string,core_info*>::iterator ic = core_map[w]->find(core_name);
        if (ic == core_map[w]->end()) {
          ostringstream oss;
          oss << "ERROR: No core found named '" << core_name << "' in wrapper '" << wi.name
              << "' (from wrapper's \"readmemh_cores\" parameter)";
          throw xtsc_exception(oss.str());
        }
        core_info& ci(*ic->second);
        string program_name("");
        if (ci.has_program_loaded) {
          program_name = ci.program_name;
        }
        else {
          const char *prog = ci.parms.get_c_str("SimTargetProgram");
          if (prog && prog[0]) {
            program_name = prog;
          }
          else {
            ostringstream oss;
            oss << "ERROR: No program loaded on core '" << core_name << "' in wrapper '" << wi.name
                << "' (from wrapper's \"readmemh_cores\" parameter)";
            throw xtsc_exception(oss.str());
          }
        }
        // For each interface type of the tlm2pin devices connected to this wrapper
        for (set<string>::const_iterator ii = memory_interfaces.begin(); ii != memory_interfaces.end(); ++ii) {
          if (ci.p_core->has_memory_port(ii->c_str())) {
            string readmemh_interface = *ii;
            string readmemh_interface_v = readmemh_interface;
            if (readmemh_interface_v == "xlmi0") { readmemh_interface_v = "dport0"; }
            xtsc_core::memory_port mem_port=xtsc_core::get_memory_port(readmemh_interface);
            string ext1(mem_port == xtsc_core::MEM_PIF ? ".sysram" : "");
            string ext2(".sysrom");
            ostringstream targ1;    // Local memory or sysram
            ostringstream rule1;    // Local memory or sysram
            ostringstream targ2;    // sysrom
            ostringstream rule2;    // sysrom
            ostringstream data1;
            ostringstream data2;
            if (readmemh_use_prefix) {
              data1 << data_dir << "/" << wi.name << "." << ci.name << "." << readmemh_interface_v << ".data" << ext1;
              data2 << data_dir << "/" << wi.name << "." << ci.name << "." << readmemh_interface_v << ".data" << ext2;
            }
            else {
              data1 << data_dir << "/" << readmemh_interface_v << ".data" << ext1;
              data2 << data_dir << "/" << readmemh_interface_v << ".data" << ext2;
            }
            targ1 << data1.str() << ":";
            rule1 << "\t" << "if [ ! -d " << data_dir << " ]; then mkdir " << data_dir << "; fi" << endl;
            targ2 << data2.str() << ":";
            rule2 << "\t" << "if [ ! -d " << data_dir << " ]; then mkdir " << data_dir << "; fi" << endl;
            bool used_targ1 = false;
            bool used_targ2 = false;
            string endian(ci.p_core->is_big_endian() ? "big-endian" : "little-endian");
            string zeros = "0x00000000000000000000000000000000";
            if (mem_port == xtsc_core::MEM_PIF) {
              if (ci.p_core->has_memory_port(xtsc_core::MEM_PIF)) {
                xtsc_address address8 = 0x0;
                u32          size8    = 0;
                u32          width8   = ci.p_core->get_memory_byte_width(mem_port);
                string       default_value(zeros.substr(0, 2+width8*2));
                if (ci.p_core->get_system_ram_starting_byte_address(address8)) {
                  data_file_targets << " " << data1.str();
                  ci.p_core->get_system_ram_byte_size(size8);
                  used_targ1 = true;
                  targ1 << " " << program_name;
                  rule1 << "\t" << "xt-dumpelf --width=" << dec << (width8*8) << " --" << endian;
                  add_base_arguments(rule1, *ci.p_core, address8, size8);
                  rule1 << " --size=0x" << setw(8) << size8 << " $? >> $@" << endl;
                }
                if (ci.p_core->get_system_rom_starting_byte_address(address8)) {
                  data_file_targets << " " << data2.str();
                  ci.p_core->get_system_rom_byte_size(size8);
                  used_targ2 = true;
                  targ2 << " " << program_name;
                  rule2 << "\t" << "xt-dumpelf --width=" << dec << (width8*8) << " --" << endian;
                  add_base_arguments(rule2, *ci.p_core, address8, size8);
                  rule2 << " --size=0x" << setw(8) << size8 << " $? >> $@" << endl;
                }
              }
            }
            else {
              if (ci.p_core->has_memory_port(mem_port)) {
                data_file_targets << " " << data1.str();
                xtsc_address address8 = 0x0;
                u32          size8    = 0;
                u32          width8   = ci.p_core->get_memory_byte_width(mem_port);
                string       default_value(zeros.substr(0, 2+width8*2));
                ci.p_core->get_local_memory_starting_byte_address(mem_port, address8);
                ci.p_core->get_local_memory_byte_size(mem_port, size8);
                used_targ1 = true;
                targ1 << " " << program_name;
                rule1 << "\t" << "xt-dumpelf --width=" << dec << (width8*8) << " --" << endian;
                add_base_arguments(rule1, *ci.p_core, address8, size8);
                rule1 << " --size=0x" << setw(8) << size8 << " $? >> $@" << endl;
              }
            }
            if (used_targ1) {
              dat << targ1.str() << endl;
              dat << rule1.str() << endl;
            }
            if (used_targ2) {
              dat << targ2.str() << endl;
              dat << rule2.str() << endl;
            }
          }
        }
      }
    }

    // So we can use p_core_parms
    init_core_parms();

    if (vendor == "cadence") {
      mak << "XTTOOLS = " << p_core_parms->get_c_str("InstallPrefix") << endl;
      mak << endl;
      mak << "CXX = " << p_make_parms->get_c_str("cxx") << endl;
      mak << endl;
      mak << "ISSLIBDIR = " << isslibdir << endl;
      mak << endl;
      mak << "XTSC_LIBRARY_PATH = $(XTTOOLS)/lib/$(ISSLIBDIR)/" << vendor << "-" << vendor_version << endl;
      mak << endl;
      mak << "GCC_VERS = " << (gcc_version == "4.1.2" ? gcc_minor_version : gcc_version) << endl;
      mak << endl;
      mak << "CADENCE_ROOT = $(shell ncroot)" << endl;
      mak << endl;
      mak << "REQ_CXXFLAGS = -D NCSC -D CADENCE -D LNX86 -c -I$(CADENCE_ROOT)/tools/systemc/include_pch" << endl;
      mak << endl;
      mak << endl;
      mak << ".PHONY: all" << ((dat.str() == "") ? "" : " data_files") << " ncshell ncverilog run clean info xtsc_library_check"
          << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "all:" << ((dat.str() == "") ? "" : " data_files") << " systemc.so ncshell ncverilog" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      if (dat.str() != "") {
        mak << "data_files: " << data_file_targets.str() << endl;
        mak << endl;
        mak << dat.str();
        mak << endl;
        mak << endl;
      }
      mak << "%.o: %.cpp" << endl;
      mak << "\t" << "ncsc $< -GCC_VERS $(GCC_VERS) -COMPILER $(CXX) " << " " << p_make_parms->get_c_str("ncsc_args")
                  << " -CFLAGS \"$(REQ_CXXFLAGS) -I$(XTTOOLS)/include " << p_make_parms->get_c_str("cxx_args") << "\"" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "systemc.so: " << (no_check ? "" : "xtsc_library_check ");
      for (map<string,wrapper_info*>::iterator iw = wrapper_map.begin(); iw != wrapper_map.end(); ++iw) {
        mak << iw->first << ".o ";
      }
      mak << endl;
      mak << "\t" << "$(CXX) -shared -Wl,-G " << p_make_parms->get_c_str("ld_args") << " -o systemc.so \\" << endl;
      for (map<string,wrapper_info*>::iterator iw = wrapper_map.begin(); iw != wrapper_map.end(); ++iw) {
        mak << "          " << iw->first << ".o" << " \\" << endl;
      }
      mak << "          -L$(XTSC_LIBRARY_PATH) \\" << endl;
      mak << "          -lxtsc \\" << endl;
      mak << "          -lxtsc_comp \\" << endl;
      mak << "          -L$(XTTOOLS)/lib/$(ISSLIBDIR) \\" << endl;
      mak << "          -lxtmp \\" << endl;
      mak << "          -lsimxtcore \\" << endl;
      mak << "          -llog4xtensa \\" << endl;
      mak << "          -L$(XTTOOLS)/lib \\" << endl;
      mak << "          -lxtparams \\" << endl;
      mak << "          -L$(CADENCE_ROOT)/tools/systemc/lib-linux \\" << endl;
      mak << "          -Wl,-rpath,$(XTTOOLS)/lib/$(ISSLIBDIR) \\" << endl;
      mak << "          -Wl,-rpath,$(XTTOOLS)/lib \\" << endl;
      mak << "          -Wl,-rpath,$(XTENSATOOLS_TOOLS_LIB) \\" << endl;
      string libgnu(xtsc_64bit ? "lib/64bit/gnu" : "lib/gnu");
      mak << "          $(CADENCE_ROOT)/tools/systemc/" << libgnu << "/$(GCC_VERS)/libncscCoSim_sh.so \\" << endl;
      mak << "          $(CADENCE_ROOT)/tools/systemc/" << libgnu << "/$(GCC_VERS)/libncscCoroutines_sh.so \\" << endl;
      mak << "          $(CADENCE_ROOT)/tools/systemc/" << libgnu << "/$(GCC_VERS)/libsystemc_sh.so" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "ncshell:" << endl;
      for (map<string,wrapper_info*>::iterator iw = wrapper_map.begin(); iw != wrapper_map.end(); ++iw) {
        mak << "\t" << "ncshell " << p_make_parms->get_c_str("ncshell_args") << " -generic -scopts \"-GCC_VERS $(GCC_VERS) "
            << "-compiler $(CXX)\" -import systemc -into verilog " << iw->first << endl;
      }
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "ncverilog:" << endl;
      mak << "\t" << "ncverilog " << p_make_parms->get_c_str("ncverilog_args") << " ";
      for (map<string,wrapper_info*>::iterator iw = wrapper_map.begin(); iw != wrapper_map.end(); ++iw) {
        mak << iw->first << ".vs ";
      }
      mak << " \\" << endl;
      const char * const *verilog_files = p_make_parms->get_c_str_array("verilog_files");
      for (int i=0; verilog_files[i]; ++i) {
        mak << "          " << verilog_files[i] << " \\" << endl;
      }
      if (generate_testbench) {
        mak << "          " << testbench_name << ".v \\" << endl;
      }
      mak << "          +elaborate \\" << endl;
      mak << "          +loadsc+./systemc \\" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "run:" << endl;
      mak << "\t" << "ncsim " << p_make_parms->get_c_str("ncsim_args") << " $(XTSC_RUN_COSIM_ARGS) " << testbench_name << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "clean:" << endl;
      mak << "\t" << "ncsc_run -clean" << endl;
      mak << "\t" << "-rm -rf *.out *.log *.vcd *.dump *.fsdb";
      for (map<string,wrapper_info*>::iterator iw = wrapper_map.begin(); iw != wrapper_map.end(); ++iw) {
        mak << " " << iw->first << ".vs";
      }
      mak << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      add_library_check_and_info(mak);
    }
    else if (vendor == "mentor") {
      mak << "XTTOOLS = " << p_core_parms->get_c_str("InstallPrefix") << endl;
      mak << endl;
      mak << "ISSLIBDIR = " << isslibdir << endl;
      mak << endl;
      mak << "XTSC_LIBRARY_PATH = $(XTTOOLS)/lib/$(ISSLIBDIR)/" << vendor << "-" << vendor_version << endl;
      mak << endl;
      mak << endl;
      mak << ".PHONY: all" << ((dat.str() == "") ? "" : " data_files")
          << " sccom vlog sccom-link run gui clean info xtsc_library_check" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "all:" << ((dat.str() == "") ? "" : " data_files") << " work sccom vlog sccom-link" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      if (dat.str() != "") {
        mak << "data_files: " << data_file_targets.str() << endl;
        mak << endl;
        mak << dat.str();
        mak << endl;
        mak << endl;
      }
      mak << "work:" << endl;
      mak << "\t" << "vlib work" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "sccom: work ";
      for (map<string,wrapper_info*>::iterator iw = wrapper_map.begin(); iw != wrapper_map.end(); ++iw) {
        mak << iw->first << ".cpp" << " ";
      }
      mak << endl;
      mak << "\t" << "sccom -I$(XTTOOLS)/include -c " << p_make_parms->get_c_str("sccom_args") << " \\" << endl;
      for (map<string,wrapper_info*>::iterator iw = wrapper_map.begin(); iw != wrapper_map.end(); ++iw) {
        mak << "\t" << iw->first << ".cpp" << " \\" << endl;
      }
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "vlog: work" << endl;
      mak << "\t" << "vlog -work work " << p_make_parms->get_c_str("vlog_args") << " \\" << endl;
      const char * const *verilog_files = p_make_parms->get_c_str_array("verilog_files");
      for (int i=0; verilog_files[i]; ++i) {
        mak << "\t" << verilog_files[i] << " \\" << endl;
      }
      if (generate_testbench) {
        mak << "          " << testbench_name << ".v \\" << endl;
      }
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "sccom-link:" << (no_check ? "" : " xtsc_library_check") << endl;
      mak << "\t" << "sccom -link " << p_make_parms->get_c_str("sccom_link_args") << " \\" << endl;
      mak << "\t" << "  -L$(XTSC_LIBRARY_PATH) \\" << endl;
      mak << "\t" << "  -lxtsc \\" << endl;
      mak << "\t" << "  -lxtsc_comp \\" << endl;
      mak << "\t" << "  -L$(XTTOOLS)/lib/$(ISSLIBDIR) \\" << endl;
      mak << "\t" << "  -lxtmp \\" << endl;
      mak << "\t" << "  -lsimxtcore \\" << endl;
      mak << "\t" << "  -llog4xtensa \\" << endl;
      mak << "\t" << "  -L$(XTTOOLS)/lib \\" << endl;
      mak << "\t" << "  -lxtparams \\" << endl;
      mak << "\t" << "  -Wl,-rpath,$(XTTOOLS)/lib/$(ISSLIBDIR) \\" << endl;
      mak << "\t" << "  -Wl,-rpath,$(XTTOOLS)/lib \\" << endl;
      mak << "\t" << "  -Wl,-rpath,$(XTENSATOOLS_TOOLS_LIB)" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "run:" << endl;
      mak << "\t" << "vsim -c -do \"run -all; quit\" " << p_make_parms->get_c_str("vsim_args") << " $(XTSC_RUN_COSIM_ARGS) "
          << testbench_name << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "gui:" << endl;
      mak << "\t" << "vsim " << p_make_parms->get_c_str("vsim_args") << " " << testbench_name << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "clean:" << endl;
      mak << "\t" << "rm -rf work *.log *.vcd *.vcd.fsdb vsim_stacktrace.vstf vsim.wlf" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      add_library_check_and_info(mak);

      optionally_copy_modelsim_ini();
    }
    else if (vendor == "synopsys") {
      string full(xtsc_64bit ? "-full64 ": "");
      mak << "XTTOOLS = " << p_core_parms->get_c_str("InstallPrefix") << endl;
      mak << endl;
      mak << "CXX = " << p_make_parms->get_c_str("cxx") << endl;
      mak << endl;
      mak << "ISSLIBDIR = " << isslibdir << endl;
      mak << endl;
      mak << "XTSC_LIBRARY_PATH = $(XTTOOLS)/lib/$(ISSLIBDIR)/" << vendor << "-" << vendor_version << endl;
      mak << endl;
      mak << "SYSC = -sysc=2.2" << endl;
      mak << endl;
      mak << endl;
      mak << ".PHONY: all" << ((dat.str() == "") ? "" : " data_files") << " syscan simv run gui clean info xtsc_library_check"
          << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "all:" << ((dat.str() == "") ? "" : " data_files") << " syscan simv" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      if (dat.str() != "") {
        mak << "data_files: " << data_file_targets.str() << endl;
        mak << endl;
        mak << dat.str();
        mak << endl;
        mak << endl;
      }
      mak << "syscan:" << endl;
      mak << "\t" << "syscan " << full << "-cpp $(CXX) $(SYSC) -cflags \"-I$(XTTOOLS)/include\" "
          << p_make_parms->get_c_str("syscan_args") << " \\" << endl;
      for (map<string,wrapper_info*>::iterator iw = wrapper_map.begin(); iw != wrapper_map.end(); ++iw) {
        string wrapper_name = iw->first;
        mak << "\t" << wrapper_name << ".cpp:" << wrapper_name << " \\" << endl;
      }
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "simv:" << (no_check ? "" : " xtsc_library_check") << endl;
      mak << "\t" << "vcs " << full << "-cpp $(CXX) $(SYSC) " << p_make_parms->get_c_str("vcs_args") << " \\" << endl;
      const char * const *verilog_files = p_make_parms->get_c_str_array("verilog_files");
      for (int i=0; verilog_files[i]; ++i) {
        mak << "\t" << verilog_files[i] << " \\" << endl;
      }
      if (generate_testbench) {
        mak << "          " << testbench_name << ".v \\" << endl;
      }
      mak << "\t" << "-ldflags -L$(XTSC_LIBRARY_PATH) \\" << endl;
      mak << "\t" << "-lxtsc \\" << endl;
      mak << "\t" << "-lxtsc_comp \\" << endl;
      mak << "\t" << "-ldflags -L$(XTTOOLS)/lib/$(ISSLIBDIR) \\" << endl;
      mak << "\t" << "-lxtmp \\" << endl;
      mak << "\t" << "-lsimxtcore \\" << endl;
      mak << "\t" << "-llog4xtensa \\" << endl;
      mak << "\t" << "-ldflags -L$(XTTOOLS)/lib \\" << endl;
      mak << "\t" << "-lxtparams \\" << endl;
      mak << "\t" << "-ldflags -Wl,-rpath,$(XTTOOLS)/lib/$(ISSLIBDIR) \\" << endl;
      mak << "\t" << "-ldflags -Wl,-rpath,$(XTTOOLS)/lib \\" << endl;
      mak << "\t" << "-ldflags -Wl,-rpath,$(XTENSATOOLS_TOOLS_LIB) \\" << endl;
      mak << "\t" << p_make_parms->get_c_str("vcs_ld_args") << " \\" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "run:" << endl;
      mak << "\t" << "./simv " << p_make_parms->get_c_str("simv_args") << " $(XTSC_RUN_COSIM_ARGS)" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "gui:" << endl;
      mak << "\t" << "./simv -gui " << p_make_parms->get_c_str("simv_args") << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      mak << "clean:" << endl;
      mak << "\t" << "rm -rf csrc simv simv.daidir AN.DB .vcsmx_rebuild *.log *.vcd *.dump *.fsdb" << endl;
      mak << endl;
      mak << endl;
      mak << endl;
      add_library_check_and_info(mak);
    }

    if (generate_testbench) {

      string vtb_name(path + testbench_name + ".v");
      ofstream vtb(vtb_name.c_str());
      ostringstream mod;

      vtb << "// Generated by xtsc-run: " << ctime(&date_time);
      vtb << endl;
      vtb << "module " << testbench_name << ";" << endl;

      // Get length of longest name
      u32 nc = 1;
      for (map<string,wrapper_info*>::iterator iw = wrapper_map.begin(); iw != wrapper_map.end(); ++iw) {
        wrapper_info& wrapper = *(iw->second);
        vector<pair<string,u32> >::iterator ii;
        for (ii = wrapper.connected_input_list.begin(); ii != wrapper.connected_input_list.end(); ++ii) {
          nc = max(nc, ii->first.length());
        }
        for (ii = wrapper.connected_output_list.begin(); ii != wrapper.connected_output_list.end(); ++ii) {
          nc = max(nc, ii->first.length());
        }
      }

      // Foreach wrapper . . . 
      for (map<string,wrapper_info*>::iterator iw = wrapper_map.begin(); iw != wrapper_map.end(); ++iw) {
        wrapper_info& wrapper = *(iw->second);
        w = wrapper.index;
        mod << endl;
        mod << tab1 << "// Instantiate wrapper " << wrapper.name << endl;
        mod << tab1 << wrapper.name << " " << wrapper.name << "_(" << endl;
        vector<pair<string,u32> >::iterator ii, ij;
        vtb << endl;
        vtb << tab1 << "// " << wrapper.name << " inputs" << endl;
        for (ii = wrapper.connected_input_list.begin(); ii != wrapper.connected_input_list.end(); ++ii) {
          dump_wire(vtb, ii->first, ii->second);
          mod << tab2 << "." << ii->first << space(nc-ii->first.length()) << " (" << ii->first << ")";
          ij = ii + 1;
          mod << (((ij == wrapper.connected_input_list.end()) && !wrapper.connected_output_list.size()) ? "" : ",") << endl;
        }
        vtb << endl;
        vtb << tab1 << "// " << wrapper.name << " outputs" << endl;
        for (ii = wrapper.connected_output_list.begin(); ii != wrapper.connected_output_list.end(); ++ii) {
          dump_wire(vtb, ii->first, ii->second);
          mod << tab2 << "." << ii->first << space(nc-ii->first.length()) << " (" << ii->first << ")";
          ij = ii + 1;
          mod << ((ij == wrapper.connected_output_list.end()) ? "" : ",") << endl;
        }
        mod << tab1 << ");" << endl;
      }
      vtb << mod.str();
      vtb << endl;
      vtb << tab1 << "initial begin" << endl;
      vtb << tab2 << "if($test$plusargs(\"dumpvars\")) begin" << endl;
      vtb << tab3 << "$dumpvars();" << endl;
      vtb << tab2 << "end" << endl;
      vtb << tab1 << "end" << endl;
      vtb << endl;
      vtb << "endmodule" << endl;
      vtb << endl;
    }
  }
}



void add_library_check_and_info(ofstream& mak) {
  mak << "xtsc_library_check:" << endl;
  mak << "\t" << "@ls -al $(XTSC_LIBRARY_PATH)/libxtsc.a > /dev/null" << endl;
  mak << "\t" << "@ls -al $(XTSC_LIBRARY_PATH)/libxtsc_comp.a > /dev/null" << endl;
  mak << "" << endl;
  mak << "" << endl;
  mak << "" << endl;
  mak << "info: xtsc_library_check" << endl;
  mak << "\t" << "-uname -a" << endl;
  mak << "\t" << "@echo XTSC libraries: $(XTSC_LIBRARY_PATH)" << endl;
  mak << "\t" << "-@ls -al $(XTSC_LIBRARY_PATH)/libxtsc.a" << endl;
  mak << "\t" << "-@ls -al $(XTSC_LIBRARY_PATH)/libxtsc_comp.a" << endl;
  mak << "\t" << "@echo " << vendor << " info - expecting version " << vendor_version << ":" << endl;
  if (vendor == "cadence") {
    mak << "\t" << "-@which ncsim && ls -al `which ncsim` && ncsim -version" << endl;
  }
  else if (vendor == "mentor") {
    mak << "\t" << "-@which vlog && ls -al `which vlog` && vlog -version" << endl;
  }
  else if (vendor == "synopsys") {
    mak << "\t" << "-@which vcs && ls -al `which vcs` && vcs -ID" << endl;
  }
  if ((vendor == "cadence") || (vendor == "synopsys")) {
    mak << "\t" << "@echo GCC info - expecting version " << gcc_version << ": $(CXX)" << endl;
    mak << "\t" << "-@which $(CXX)  && ls -al `which $(CXX)` && echo $(CXX) -dumpversion: `$(CXX) -dumpversion`" << endl;
  }
  mak << "\t" << "@echo LD_LIBRARY_PATH: $(LD_LIBRARY_PATH)" << endl;
  mak << endl;
  mak << endl;
  mak << endl;
}



void add_extra_io_to_proxy(proxy_info& proxy, bool input) {
  const char * const *extra_io = proxy.parms.get_c_str_array(input ? "extra_inputs" : "extra_outputs");
  if (extra_io && extra_io[0]) {
    ostringstream oss;
    oss << "in proxy_parm \"" << (input ? "extra_inputs" : "extra_outputs") << "\" of proxy '" << proxy.name << "'";
    for (u32 i=0; extra_io[i]; i+=2) {
      if (!extra_io[i+1]) {
        ostringstream oss1;
        oss1 << "Odd number of parameters " << oss.str() << " (should always be even, like this: name1,size1,name2,size2,...)";
        throw xtsc_exception(oss1.str());
      }
      u32 bits = strtou32(extra_io[i+1], oss.str());
      bool bv = (bits > 32);
      string name(extra_io[i]);
      add_proxy_io(proxy, name, bits, input, bv, false);
      *oss_main[w] << endl;
      *oss_main[w] << tab2 << "sc_signal";
      add_template_args(*oss_main[w], bits, bv, false);
      *oss_main[w] << " " << name << "(\"" << name << "\");" << endl;
      *oss_main[w] << tab2 << proxy.name << "." << name << "(" << name << ");" << endl;
      if (proxy.trace_identifier != "") {
      *oss_main[w] << tab2 << "sc_trace(" << proxy.trace_identifier << ", " << name << ", \"" << name << "\");" << endl;
      }
    }
  }
}



void add_extra_io_to_wrapper(const char * const *extra_io, bool input) {
  if (extra_io && extra_io[0]) {
    ostringstream oss;
    oss << "in wrapper_parm \"" << (input ? "extra_inputs" : "extra_outputs") << "\" of wrapper '" << wrapper_list[w] << "'";
    for (u32 i=0; extra_io[i]; i+=2) {
      if (!extra_io[i+1]) {
        ostringstream oss1;
        oss1 << "Odd number of parameters " << oss.str() << " (should be even: name,size,name,size,...)";
        throw xtsc_exception(oss1.str());
      }
      u32 bits = strtou32(extra_io[i+1], oss.str());
      bool bv = (bits > 32);
      string name(extra_io[i]);
      add_wrapper_io(name, bits, input, bv);
    }
  }
}



void dump_wire(ostream& os, const string& name, u32 bits) {
  os << tab1 << "wire ";
  if (bits == 1) {
    os << "       ";
  }
  else {
    os << "[" << dec << setfill(' ') << setw(3) << (bits - 1) << ":0]";
  }
  os << "      " << name << ";" << endl;
}



void optionally_copy_modelsim_ini() {
  const char *modelsim_ini = p_make_parms->get_c_str("modelsim_ini");
  if (modelsim_ini && modelsim_ini[0]) {
    ifstream in(modelsim_ini);
    if (!in) {
      ostringstream oss;
      oss << "Cannot open \"modelsim_ini\" file '" << modelsim_ini << "' for input.";
      throw xtsc_exception(oss.str());
    }
    string out_name(path + "modelsim.ini");
    ofstream out(out_name.c_str());
    if (!out) {
      ostringstream oss;
      oss << "Cannot open file \"" << out_name << "\" for output.";
      throw xtsc_exception(oss.str());
    }
    out << in.rdbuf();
  }
}



void add_base_arguments(ostringstream &oss, xtsc_core& core, xtsc_address address8, u32 size8) {
  xtsc_address vaddr = address8;
  size8 = max(size8, (u32) 16);
  u64 num_iterations = 0x100000000ULL / size8;
  for (u64 i = 0; i<num_iterations; ++i) {
    xtsc_address paddr = core.translate_virtual(vaddr);
    if (paddr == address8) {
      oss << " --base=0x" << hex << setfill('0') << setw(8) << vaddr;
    }
    vaddr += size8;
  };
}



// Step 31:  Add non-verbose and verbose entries for the widget.  Also, cross-reference all new commands.
void show_modules(bool verbose, bool is_manual) {
  XTSC_TRACE(logger, "enter show_modules()");
  cout << endl;
  if (!verbose) {
    cout << "Here are the available modules showing their xtsc-run name, their SystemC module name, and how to" << endl;
    cout << "get parameter information (look for the XTSC parameter class name in the XTSC Reference Manual):" << endl;
    cout << endl;
    cout << "xtsc-run Name  SystemC Module Name               XTSC Parameter Class" << endl;
    cout << "-------------  --------------------------------  -----------------------------------------------------------" << endl;
    cout << "arbiter        xtsc_arbiter                      xtsc_arbiter_parms" << endl;
    cout << "clock          sc_clock                          (see --show_clock_parms in Section IV of xtsc-run --manual)" << endl;
    cout << "consumer       xtsc_queue_consumer               xtsc_queue_consumer_parms" << endl;
    cout << "cohctrl        xtsc_cohctrl                      xtsc_cohctrl_parms" << endl;
    cout << "core           xtsc_core                         xtsc_core_parms" << endl;
    cout << "distributor    xtsc_interrupt_distributor        xtsc_interrupt_distributor_parms" << endl;
    cout << "dma            xtsc_dma_engine                   xtsc_dma_engine_parms" << endl;
    cout << "driver         xtsc_lookup_driver                xtsc_lookup_driver_parms" << endl;
    cout << "loader         xtsc_tx_loader                    xtsc_tx_loader_parms" << endl;
    cout << "logic          xtsc_wire_logic                   xtsc_wire_logic_parms" << endl;
    cout << "lookup         xtsc_lookup                       xtsc_lookup_parms" << endl;
    cout << "lookup_pin     xtsc_lookup_pin                   xtsc_lookup_pin_parms" << endl;
    cout << "make           (not a module)                    (see --show_make_parms in Section IV of xtsc-run --manual)" << endl;
    cout << "master         xtsc_master                       xtsc_master_parms" << endl;
    cout << "memory         xtsc_memory                       xtsc_memory_parms" << endl;
    cout << "memory_pin     xtsc_memory_pin                   xtsc_memory_pin_parms" << endl;
    cout << "memory_trace   xtsc_memory_trace                 xtsc_memory_trace_parms" << endl;
    cout << "mmio           xtsc_mmio                         xtsc_mmio_parms" << endl;
    cout << "pin2tlm        xtsc_pin2tlm_memory_transactor    xtsc_pin2tlm_memory_transactor_parms" << endl;
    cout << "producer       xtsc_queue_producer               xtsc_queue_producer_parms" << endl;
    cout << "proxy          (user-defined)                    (see --show_proxy_parms in Section IV of xtsc-run --manual)" << endl;
    cout << "queue          xtsc_queue                        xtsc_queue_parms" << endl;
    cout << "queue_pin      xtsc_queue_pin                    xtsc_queue_pin_parms" << endl;
    cout << "router         xtsc_router                       xtsc_router_parms" << endl;
    cout << "signal         xtsc_signal_sc_bv_base            (see --show_signal_parms in Section IV of xtsc-run --manual)" << endl;
    cout << "slave          xtsc_slave                        xtsc_slave_parms" << endl;
    cout << "source         xtsc_wire_source                  xtsc_wire_source_parms" << endl;
    cout << "tlm2pin        xtsc_tlm2pin_memory_transactor    xtsc_tlm2pin_memory_transactor_parms" << endl;
    cout << "vcd            sc_trace_file (not a module)      (see --show_vcd_parms in Section IV of xtsc-run --manual)" << endl;
    cout << "wire           xtsc_wire                         xtsc_wire_parms" << endl;
    cout << "wrapper        (user-defined)                    (see --show_wrapper_parms in Section IV of xtsc-run --manual)" << endl;
    cout << "xtsc           xtsc_initialize (not a module)    xtsc_initialize_parms" << endl;
    cout << "[use --show_modules=verbose to get a description and a list of applicable commands for each module]" << endl;
  }
  else {
    string where(is_manual ? "below" : "of xtsc-run --manual");
    cout << "Here are the available modules showing their xtsc-run name, their SystemC module name, how to get" << endl;
    cout << "parameter information (look for the XTSC parameter class name in the XTSC Reference Manual), their" << endl;
    cout << "description, and their related commands:" << endl;
    cout << endl;
    cout << "xtsc-run Name  SystemC Module Name               XTSC Parameter Class" << endl;
    cout << "-------------  --------------------------------  -----------------------------------------------------------" << endl;
    cout << endl;
    cout << "arbiter        xtsc_arbiter                      xtsc_arbiter_parms" << endl;
    cout << "                 This module implements an arbiter that allows a memory interface slave module to" << endl;
    cout << "                 be accessed by multiple masters.  This module can also be used to provided" << endl;
    cout << "                 address translations (with or without arbitration)." << endl;
    cout << "                   --set_arbiter_parm              --show_arbiter_parms          --create_arbiter" << endl;
    cout << "                   --connect_arbiter_arbiter       --connect_arbiter_cohctrl     --connect_arbiter_core" << endl;
    cout << "                   --connect_arbiter_dma           --connect_arbiter_memory      --connect_arbiter_memory_trace" << endl;
    cout << "                   --connect_arbiter_mmio          --connect_arbiter_router      --connect_arbiter_slave" << endl;
    cout << "                   --connect_arbiter_tlm2pin       --connect_cohctrl_arbiter     --connect_core_arbiter" << endl;
    cout << "                   --connect_dma_arbiter           --connect_master_arbiter      --connect_memory_trace_arbiter" << endl;
    cout << "                   --connect_pin2tlm_arbiter       --connect_router_arbiter" << endl;
    cout << endl;
    cout << "clock          sc_clock                          (see --show_clock_parms in Section IV " << where << ")" << endl;
    cout << "                 A SystemC clock object." << endl;
    cout << "                   --set_clock_parm       --show_clock_parms       --create_clock" << endl;
    cout << "                   --connect_clock_proxy  --connect_clock_wrapper " << endl;
    cout << endl;
    cout << "consumer       xtsc_queue_consumer               xtsc_queue_consumer_parms" << endl;
    cout << "                 This testbench module provides a TLM or pin-level queue consumer that reads a" << endl;
    cout << "                 script file to determine when to attempt to read values from a queue." << endl;
    cout << "                   --set_consumer_parm           --show_consumer_parms       --create_consumer" << endl;
    cout << "                   --connect_loader_consumer     --connect_proxy_consumer    --connect_queue_consumer" << endl;
    cout << "                   --connect_queue_pin_consumer  --connect_wrapper_consumer" << endl;
    cout << endl;
    cout << "cohctrl        xtsc_cohctrl                      xtsc_cohctrl_parms" << endl;
    cout << "                 This module provides a TLM model of Tensilica's coherence controller.  It allows" << endl;
    cout << "                 a memory interface slave module (e.g. xtsc_memory) to be accessed by multiple" << endl;
    cout << "                 cache coherence clients (e.g. xtsc_core)." << endl;
    cout << "                   --set_cohctrl_parm              --show_cohctrl_parms            --create_cohctrl" << endl;
    cout << "                   --connect_arbiter_cohctrl       --connect_cohctrl_arbiter       --connect_cohctrl_memory" << endl;
    cout << "                   --connect_cohctrl_memory_trace  --connect_cohctrl_router        --connect_cohctrl_slave" << endl;
    cout << "                   --connect_cohctrl_tlm2pin       --connect_core_cohctrl          --connect_logic_cohctrl" << endl;
    cout << "                   --connect_master_cohctrl        --connect_memory_trace_cohctrl  --connect_proxy_cohctrl" << endl;
    cout << "                   --connect_pin2tlm_cohctrl       --connect_router_cohctrl        --connect_source_cohctrl" << endl;
    cout << "                   --connect_wrapper_cohctrl" << endl;
    cout << endl;
    cout << "core           xtsc_core                         xtsc_core_parms" << endl;
    cout << "                 This module encapsulates an Xtensa core Instruction Set Simulator (ISS) as a" << endl;
    cout << "                 SystemC module." << endl;
    cout << "                   --xtensa_system              --xtensa_core               --xtensa_params" << endl;
    cout << "                   --core_args                  --core_debug                --core_client" << endl;
    cout << "                   --core_program               --core_summary              --multi_core_debug" << endl;
    cout << "                   --xxdebug                    --multi_core_profile        --xxprofile" << endl;
    cout << "                   --no_default_mem             --no_default_local_mem" << endl;
    cout << "                   --set_core_parm              --show_core_parms           --create_core" << endl;
    cout << "                   --connect_arbiter_core       --connect_core_arbiter      --connect_core_cohctrl" << endl;
    cout << "                   --connect_core_core          --connect_core_distributor  --connect_core_loader" << endl;
    cout << "                   --connect_core_logic         --connect_core_lookup       --connect_core_lookup_pin" << endl;
    cout << "                   --connect_core_memory        --connect_core_memory_trace --connect_core_mmio" << endl;
    cout << "                   --connect_core_mmio          --connect_core_proxy        --connect_core_queue" << endl;
    cout << "                   --connect_core_queue_pin     --connect_core_router       --connect_core_signal" << endl;
    cout << "                   --connect_core_slave         --connect_core_tlm2pin      --connect_core_wire" << endl;
    cout << "                   --connect_core_wrapper       --connect_distributor_core  --connect_loader_core" << endl;
    cout << "                   --connect_logic_core         --connect_master_core       --connect_memory_trace_core" << endl;
    cout << "                   --connect_mmio_core          --connect_proxy_core        --connect_queue_core" << endl;
    cout << "                   --connect_queue_pin_core     --connect_pin2tlm_core      --connect_router_core" << endl;
    cout << "                   --connect_signal_core        --connect_source_core       --connect_wire_core" << endl;
    cout << "                   --connect_wrapper_core " << endl;
    cout << endl;
    cout << "distributor    xtsc_interrupt_distributor        xtsc_interrupt_distributor_parms" << endl;
    cout << "                 This module provides a TLM model of Tensilica's Interrupt Distributor." << endl;
    cout << "                   --set_distributor_parm       --show_distributor_parms    --create_distributor" << endl;
    cout << "                   --connect_core_distributor   --connect_distributor_core  --connect_distributor_logic" << endl;
    cout << "                   --connect_distributor_mmio   --connect_distributor_wire  --connect_driver_distributor" << endl;
    cout << "                   --connect_logic_distributor  --connect_mmio_distributor  --connect_source_distributor" << endl;
    cout << endl;
    cout << "dma            xtsc_dma_engine                   xtsc_dma_engine_parms" << endl;
    cout << "                 This module implements a DMA engine for use in a PIF network." << endl;
    cout << "                   --set_dma_parm                  --show_dma_parms                --create_dma" << endl;
    cout << "                   --connect_arbiter_dma           --connect_dma_arbiter           --connect_dma_memory" << endl;
    cout << "                   --connect_dma_memory_trace      --connect_dma_router            --connect_master_dma" << endl;
    cout << "                   --connect_memory_trace_dma      --connect_router_dma" << endl;
    cout << endl;
    cout << "driver         xtsc_lookup_driver                xtsc_lookup_driver_parms" << endl;
    cout << "                 This testbench module provides a TLM or pin-level lookup driver that reads a" << endl;
    cout << "                 script file to determine when and what lookup requests to send to a lookup module." << endl;
    cout << "                   --set_driver_parm             --show_driver_parms       --create_driver" << endl;
    cout << "                   --connect_driver_distributor  --connect_driver_lookup   --connect_driver_lookup_pin" << endl;
    cout << "                   --connect_driver_proxy        --connect_driver_wrapper " << endl;
    cout << endl;
    cout << "loader         xtsc_tx_loader                    xtsc_tx_loader_parms" << endl;
    cout << "                 This module provides a model of the TX boot loader.  It can be driven by an image" << endl;
    cout << "                 file generated by the xtload program, or by a queue producer (e.g a TIE output queue" << endl;
    cout << "                 interface of xtsc_core or an xtsc_queue_producer), or by both." << endl;
    cout << "                   --set_loader_parm          --show_loader_parms        --create_loader" << endl;
    cout << "                   --connect_core_loader      --connect_loader_consumer  --connect_loader_core" << endl;
    cout << "                   --connect_loader_logic     --connect_loader_wire      --connect_producer_loader" << endl;
    cout << "                   --connect_proxy_loader     --connect_wrapper_loader" << endl;
    cout << endl;
    cout << "logic          xtsc_wire_logic                   xtsc_wire_logic_parms" << endl;
    cout << "                 This TLM module supports general-purpose glue and delay logic for the XTSC wire" << endl;
    cout << "                 write interface.  The inputs, outputs, delays, and glue logic are specified by" << endl;
    cout << "                 a definition file." << endl;
    cout << "                   --set_logic_parm         --show_logic_parms           --create_logic" << endl;
    cout << "                   --connect_core_logic     --connect_distributor_logic  --connect_loader_logic" << endl;
    cout << "                   --connect_logic_cohctrl  --connect_logic_core         --connect_logic_distributor" << endl;
    cout << "                   --connect_logic_logic    --connect_logic_master       --connect_logic_mmio" << endl;
    cout << "                   --connect_logic_producer --connect_logic_proxy        --connect_logic_source" << endl;
    cout << "                   --connect_logic_wire     --connect_logic_wrapper      --connect_mmio_logic" << endl;
    cout << "                   --connect_proxy_logic    --connect_source_logic       --connect_wrapper_logic " << endl;
    cout << endl;
    cout << "lookup         xtsc_lookup                       xtsc_lookup_parms" << endl;
    cout << "                 This module provides a TLM model of a TIE lookup that can be configured to" << endl;
    cout << "                 function as a ROM-based lookup table which is initialized from a file or to" << endl;
    cout << "                 function as a custom RAM." << endl;
    cout << "                   --set_lookup_parm      --show_lookup_parms      --create_lookup" << endl;
    cout << "                   --connect_core_lookup  --connect_driver_lookup " << endl;
    cout << endl;
    cout << "lookup_pin     xtsc_lookup_pin                   xtsc_lookup_pin_parms" << endl;
    cout << "                 This module provides a pin-level module of a TIE lookup that can function as a" << endl;
    cout << "                 ROM-based lookup table which is initialized from a file." << endl;
    cout << "                   --set_lookup_pin_parm         --show_lookup_pin_parms      --create_lookup_pin" << endl;
    cout << "                   --connect_core_lookup_pin     --connect_driver_lookup_pin  --connect_proxy_lookup_pin" << endl;
    cout << "                   --connect_wrapper_lookup_pin" << endl;
    cout << endl;
    cout << "make           (not a module)                    (see --show_make_parms in Section IV " << where << ")" << endl;
    cout << "                 A mechanism to set parameters related to the Makefile when generating files for" << endl;
    cout << "                 SystemC-Verilog cosimulation." << endl;
    cout << "                   --cosim                     --set_make_parm             --show_make_parms" << endl;
    cout << endl;
    cout << "master         xtsc_master                       xtsc_master_parms" << endl;
    cout << "                 This testbench module implements a master on a TLM memory interface that reads a" << endl;
    cout << "                 script file to determine when and what requests to send to a memory interface" << endl;
    cout << "                 slave module." << endl;
    cout << "                   --set_master_parm              --show_master_parms            --create_master" << endl;
    cout << "                   --connect_logic_master         --connect_master_arbiter       --connect_master_cohctrl" << endl;
    cout << "                   --connect_master_core          --connect_master_dma           --connect_master_memory" << endl;
    cout << "                   --connect_master_memory_trace  --connect_master_mmio          --connect_master_router" << endl;
    cout << "                   --connect_master_slave         --connect_master_tlm2pin       --connect_mmio_master" << endl;
    cout << endl;
    cout << "memory         xtsc_memory                       xtsc_memory_parms" << endl;
    cout << "                 This module provides a configurable PIF, XLMI, or local memory TLM module." << endl;
    cout << "                   --memory_port                  --set_memory_parm         --show_memory_parms" << endl;
    cout << "                   --create_memory                --connect_arbiter_memory  --connect_cohctrl_memory" << endl;
    cout << "                   --connect_core_memory          --connect_dma_memory      --connect_master_memory" << endl;
    cout << "                   --connect_memory_trace_memory  --connect_pin2tlm_memory  --connect_router_memory " << endl;
    cout << endl;
    cout << "memory_pin     xtsc_memory_pin                   xtsc_memory_pin_parms" << endl;
    cout << "                 This module provides a configurable PIF, XLMI, or local memory pin-level module." << endl;
    cout << "                   --memory_pin_port             --set_memory_pin_parm       --show_memory_pin_parms" << endl;
    cout << "                   --create_memory_pin           --connect_proxy_memory_pin  --connect_tlm2pin_memory_pin" << endl;
    cout << "                   --connect_wrapper_memory_pin" << endl;
    cout << endl;
    cout << "memory_trace   xtsc_memory_trace                 xtsc_memory_trace_parms" << endl;
    cout << "                 This module generates a value-change dump (VCD) file of the data values of each" << endl;
    cout << "                 TLM request and response that passes through it." << endl;
    cout << "                   --set_memory_trace_parm         --show_memory_trace_parms       --create_memory_trace" << endl;
    cout << "                   --connect_arbiter_memory_trace  --connect_cohctrl_memory_trace  --connect_core_memory_trace" << endl;
    cout << "                   --connect_dma_memory_trace      --connect_master_memory_trace   --connect_memory_trace_arbiter" << endl;
    cout << "                   --connect_memory_trace_cohctrl  --connect_memory_trace_core     --connect_memory_trace_dma" << endl;
    cout << "                   --connect_memory_trace_memory   --connect_memory_trace_mmio     --connect_memory_trace_router" << endl;
    cout << "                   --connect_memory_trace_slave    --connect_memory_trace_tlm2pin  --connect_pin2tlm_memory_trace" << endl;
    cout << "                   --connect_router_memory_trace " << endl;
    cout << endl;
    cout << "mmio           xtsc_mmio                         xtsc_mmio_parms" << endl;
    cout << "                 This module provides a set of memory-mapped registers that connect to" << endl;
    cout << "                 general-purpose I/O ports.  A definition file is used to define the registers" << endl;
    cout << "                 that this device modules as well as the input and output ports connected to" << endl;
    cout << "                 those registers." << endl;
    cout << "                   --set_mmio_parm              --show_mmio_parms           --create_mmio" << endl;
    cout << "                   --connect_arbiter_mmio       --connect_core_mmio         --connect_core_mmio" << endl;
    cout << "                   --connect_distributor_mmio   --connect_logic_mmio        --connect_master_mmio" << endl;
    cout << "                   --connect_mmio_core          --connect_mmio_distributor  --connect_mmio_logic" << endl;
    cout << "                   --connect_mmio_master        --connect_mmio_mmio         --connect_mmio_producer" << endl;
    cout << "                   --connect_mmio_proxy         --connect_mmio_source       --connect_mmio_wire" << endl;
    cout << "                   --connect_mmio_wrapper       --connect_proxy_mmio        --connect_pin2tlm_mmio" << endl;
    cout << "                   --connect_router_mmio        --connect_source_mmio       --connect_wrapper_mmio" << endl;
    cout << "                   --connect_memory_trace_mmio" << endl;
    cout << endl;
    cout << "pin2tlm        xtsc_pin2tlm_memory_transactor    xtsc_pin2tlm_memory_transactor_parms" << endl;
    cout << "                 This module is a transactor which converts pin-level memory requests to TLM" << endl;
    cout << "                 memory requests and it converts the corresponding TLM responses to pin-level" << endl;
    cout << "                 responses." << endl;
    cout << "                   --set_pin2tlm_parm              --show_pin2tlm_parms       --create_pin2tlm" << endl;
    cout << "                   --connect_proxy_pin2tlm         --connect_pin2tlm_arbiter  --connect_pin2tlm_cohctrl" << endl;
    cout << "                   --connect_pin2tlm_core          --connect_pin2tlm_memory   --connect_pin2tlm_memory_trace" << endl;
    cout << "                   --connect_pin2tlm_mmio          --connect_pin2tlm_router   --connect_pin2tlm_slave" << endl;
    cout << "                   --connect_tlm2pin_pin2tlm       --connect_wrapper_pin2tlm " << endl;
    cout << endl;
    cout << "producer       xtsc_queue_producer               xtsc_queue_producer_parms" << endl;
    cout << "                 This testbench module provides a TLM or pin-level queue producer that reads a" << endl;
    cout << "                 script file to determine when and what data values to send to a queue module." << endl;
    cout << "                   --set_producer_parm           --show_producer_parms       --create_producer" << endl;
    cout << "                   --connect_logic_producer      --connect_mmio_producer     --connect_producer_loader" << endl;
    cout << "                   --connect_producer_proxy      --connect_producer_queue    --connect_producer_queue_pin" << endl;
    cout << "                   --connect_producer_wrapper" << endl;
    cout << endl;
    cout << "proxy          (user-defined)                    (see --show_proxy_parms in Section IV " << where << ")" << endl;
    cout << "                 This component, defined at xtsc-run time, allows connecting XTSC modules to" << endl;
    cout << "                 user-provided Verilog modules in a SystemC-on-Top SystemC-Verilog cosimulation" << endl;
    cout << "                 scenario." << endl;
    cout << "                   --cosim                     --dir                       --path" << endl;
    cout << "                   --set_make_parm             --show_make_parms           --set_proxy_parm" << endl;
    cout << "                   --show_proxy_parms          --create_proxy              --connect_clock_proxy" << endl;
    cout << "                   --connect_core_proxy        --connect_driver_proxy      --connect_logic_proxy" << endl;
    cout << "                   --connect_mmio_proxy        --connect_producer_proxy    --connect_proxy_cohctrl" << endl;
    cout << "                   --connect_proxy_consumer    --connect_proxy_core        --connect_proxy_loader" << endl;
    cout << "                   --connect_proxy_logic       --connect_proxy_lookup_pin  --connect_proxy_memory_pin" << endl;
    cout << "                   --connect_proxy_mmio        --connect_proxy_pin2tlm     --connect_proxy_queue_pin" << endl;
    cout << "                   --connect_proxy_wire        --connect_source_proxy      --connect_tlm2pin_proxy" << endl;
    cout << endl;
    cout << "queue          xtsc_queue                        xtsc_queue_parms" << endl;
    cout << "                 This module provides a configurable TLM queue." << endl;
    cout << "                   --set_queue_parm      --show_queue_parms        --create_queue" << endl;
    cout << "                   --connect_core_queue  --connect_producer_queue  --connect_queue_consumer" << endl;
    cout << "                   --connect_queue_core" << endl;
    cout << endl;
    cout << "queue_pin      xtsc_queue_pin                    xtsc_queue_pin_parms" << endl;
    cout << "                 This module provides a configurable pin-level queue." << endl;
    cout << "                   --set_queue_pin_parm          --show_queue_pin_parms        --create_queue_pin" << endl;
    cout << "                   --connect_core_queue_pin      --connect_producer_queue_pin  --connect_proxy_queue_pin" << endl;
    cout << "                   --connect_queue_pin_consumer  --connect_queue_pin_core      --connect_queue_pin_wrapper" << endl;
    cout << "                   --connect_wrapper_queue_pin" << endl;
    cout << endl;
    cout << "router         xtsc_router                       xtsc_router_parms" << endl;
    cout << "                 This module provides a TLM memory interface router for use in a PIF network.  It" << endl;
    cout << "                 can also be used in a tesbench capacity on a local memory or XLMI interface." << endl;
    cout << "                   --set_router_parm              --show_router_parms            --create_router" << endl;
    cout << "                   --connect_arbiter_router       --connect_cohctrl_router       --connect_core_router" << endl;
    cout << "                   --connect_dma_router           --connect_master_router        --connect_pin2tlm_router" << endl;
    cout << "                   --connect_router_arbiter       --connect_router_cohctrl       --connect_router_core" << endl;
    cout << "                   --connect_router_dma           --connect_router_memory        --connect_router_memory_trace" << endl;
    cout << "                   --connect_router_tlm2pin       --connect_memory_trace_router" << endl;
    cout << endl;
    cout << "signal         xtsc_signal_sc_bv_base            (see --show_signal_parms in Section IV " << where << ")" << endl;
    cout << "                 Signal for connecting to a pin-level TIE export state, TIE import wire, or" << endl;
    cout << "                 system-level I/O of xtsc_core." << endl;
    cout << "                   --set_signal_parm      --show_signal_parms    --create_signal" << endl;
    cout << "                   --connect_core_signal  --connect_signal_core  --connect_source_signal" << endl;
    cout << endl;
    cout << "slave          xtsc_slave                        xtsc_slave_parms" << endl;
    cout << "                 This testbench module provides a TLM memory slave that reads a script file to" << endl;
    cout << "                 determine when and what responses to send to the master device." << endl;
    cout << "                   --set_slave_parm              --show_slave_parms       --create_slave" << endl;
    cout << "                   --connect_arbiter_slave       --connect_cohctrl_slave  --connect_core_slave" << endl;
    cout << "                   --connect_master_slave        --connect_pin2tlm_slave  --connect_router_slave" << endl;
    cout << "                   --connect_memory_trace_slave" << endl;
    cout << endl;
    cout << "source         xtsc_wire_source                  xtsc_wire_source_parms" << endl;
    cout << "                 This testbench module reads a script file to determine when and what values to" << endl;
    cout << "                 drive out TLM or pin-level ports." << endl;
    cout << "                   --set_source_parm         --show_source_parms          --create_source" << endl;
    cout << "                   --connect_logic_source    --connect_mmio_source        --connect_source_cohctrl" << endl;
    cout << "                   --connect_source_core     --connect_source_distributor --connect_source_logic" << endl;
    cout << "                   --connect_source_mmio     --connect_source_proxy       --connect_source_signal" << endl;
    cout << "                   --connect_source_wire     --connect_source_wrapper" << endl;
    cout << endl;
    cout << "tlm2pin        xtsc_tlm2pin_memory_transactor    xtsc_tlm2pin_memory_transactor_parms" << endl;
    cout << "                 This module is a transactor which converts TLM memory requests to pin-level" << endl;
    cout << "                 requests and it converts the corresponding pin-level responses into TLM" << endl;
    cout << "                 responses." << endl;
    cout << "                   --set_tlm2pin_parm              --show_tlm2pin_parms       --create_tlm2pin" << endl;
    cout << "                   --connect_arbiter_tlm2pin       --connect_cohctrl_tlm2pin  --connect_core_tlm2pin" << endl;
    cout << "                   --connect_master_tlm2pin        --connect_router_tlm2pin   --connect_tlm2pin_memory_pin" << endl;
    cout << "                   --connect_tlm2pin_pin2tlm       --connect_tlm2pin_proxy    --connect_tlm2pin_wrapper" << endl;
    cout << "                   --connect_memory_trace_tlm2pin" << endl;
    cout << endl;
    cout << "vcd            sc_trace_file (not a module)      (see --show_vcd_parms in Section IV " << where << ")" << endl;
    cout << "                 A SystemC VCD object (sc_trace_file) object." << endl;
    cout << "                   --set_vcd_parm  --show_vcd_parms  --create_vcd" << endl;
    cout << endl;
    cout << "wire           xtsc_wire                         xtsc_wire_parms" << endl;
    cout << "                 This module provides a TLM-level wire." << endl;
    cout << "                   --set_wire_parm        --show_wire_parms           --create_wire" << endl;
    cout << "                   --connect_core_wire    --connect_distributor_wire  --connect_loader_wire" << endl;
    cout << "                   --connect_logic_wire   --connect_mmio_wire         --connect_proxy_wire" << endl;
    cout << "                   --connect_source_wire  --connect_wire_core         --connect_wrapper_wire" << endl;
    cout << endl;
    cout << "wrapper        (user-defined)                    (see --show_wrapper_parms in Section IV " << where << ")" << endl;
    cout << "                 This component, defined at xtsc-run time, allows connecting XTSC modules to" << endl;
    cout << "                 user-provided Verilog modules in a Verilog-on-Top SystemC-Verilog cosimulation" << endl;
    cout << "                 scenario." << endl;
    cout << "                   --cosim                       --dir                         --path" << endl;
    cout << "                   --set_make_parm               --show_make_parms             --set_wrapper_parm" << endl;
    cout << "                   --show_wrapper_parms          --create_wrapper              --connect_clock_wrapper" << endl;
    cout << "                   --connect_core_wrapper        --connect_driver_wrapper      --connect_logic_wrapper" << endl;
    cout << "                   --connect_mmio_wrapper        --connect_producer_wrapper    --connect_queue_pin_wrapper" << endl;
    cout << "                   --connect_source_wrapper      --connect_tlm2pin_wrapper     --connect_wrapper_cohctrl" << endl;
    cout << "                   --connect_wrapper_consumer    --connect_wrapper_core        --connect_wrapper_loader" << endl;
    cout << "                   --connect_wrapper_logic       --connect_wrapper_lookup_pin  --connect_wrapper_memory_pin" << endl;
    cout << "                   --connect_wrapper_mmio        --connect_wrapper_pin2tlm     --connect_wrapper_queue_pin" << endl;
    cout << "                   --connect_wrapper_wire        --cycle_limit" << endl;
    cout << endl;
    cout << "xtsc           xtsc_initialize (not a module)    xtsc_initialize_parms" << endl;
    cout << "                 A mechanism to set parameters for the call to xtsc_initialize().  These are parameters" << endl;
    cout << "                 related to overall XTSC simulation and not to one specific module instance." << endl;
    cout << "                   --set_xtsc_parm             --show_xtsc_parms" << endl;
    cout << endl;
  }

#if 0
    // These commands are not accounted for above

    --dump_commands
    --summary

    --help
    --manual
    --show_modules

    --include
    --logging
    --no_sim
    --quit
    --sc_main
    --squelch_ctor
    --string_array_separator
#endif

}



