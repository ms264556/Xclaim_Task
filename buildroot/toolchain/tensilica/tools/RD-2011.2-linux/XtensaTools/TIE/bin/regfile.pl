#! /usr/xtensa/tools-6.1/bin/perl -w
# $Id: //depot/rel/Cottonwood/Xtensa/TIE/regfile/regfile.pl#1 $

# Copyright (c) 2003-2009 by Tensilica Inc.  ALL RIGHTS RESERVED.
# These coded instructions, statements, and computer programs are the
# copyrighted works and confidential proprietary information of Tensilica Inc.
# They may not be modified, copied, reproduced, distributed, or disclosed to
# third parties in any manner, medium, or form, in whole or in part, without
# the prior written consent of Tensilica Inc.

use Text::Wrap;
use Getopt::Long;
use strict;
use Carp;
use Math::BigInt;
use vars qw($col);
use vars qw($indent);
use vars qw($inline_mux_count);
use vars qw($num_test);
use vars qw($outfile);
use vars qw($print_vector);
use vars qw($regfile);
use vars qw($regfile_stall);
use vars qw($time);
use vars qw($vector);
use vars qw($verify);

=head1 Overview

This script generates the pipelined register file Xtensa processors.
This script gets used to generate all states and register files
described in a TIE file--regardless of whether they are part of the core
architecture or not.

The generated logic "works" with current Xtensa implementations.  That
is, the logic assumes that instruction scheduling is done only in the R
stage (stage 0) and that instructions are "killed" in either the E stage
(stage 1) or the whole pipeline gets killed (killPipe_W). 

This script only generates the "plumbing" around the register file, not
the storage elements themselves (except for some exceptional cases).
The actual storage elements are generated by modgen (another long and
convoluted perl script).

There are two distinct implementations tuned for slightly different
uses.  The first is a traditional register file which has a write
pipeline and bypasses recently written values to a read pipeline.  This
is what we commonly refer to as a regfile.  The second implementation we
term cheap state (because it is meant to be lighter on the control
overhead).  It is meant for simple TIE states that have few bits.

Cheap state is implemented with a write pipeline only.  The pipeline is
organized such that the earliest copy always has the last def value.  The
value then percolates down the chain until it reaches the end of the
pipeline (i.e. the architectural copy).  In this model uses are simply
tapped off from the write pipeline at the appropriate point (pictures
are worth a thousand words, no?)

You can find more details on each of the implementation down below right
before the code that generates the RTL (search for DOCUMENTATION and
EOF).

Each register file can have a variety of "views".  For example a
register file can be seen as 16-entries by 32-bits, or 8-entries by
64-bits.  This is implemented by banking the register file such that
each banks some hold number of atoms (an atom is the smallest access
width).  Thus in the example above the register file would have two
banks each with 8-entries and each entry being 32-bits.  This can be
taken to the extreme where each bank holds only one entry.

This script also knows how to generate a version of the register file
used for formal equivalence check.  This essentially removes all the
flops in the pipeline to turn it into a combinationla circuit.  This is
used not to check the correctness of the register file itself, but the
correctness of the semantic and reference blocks in the TIE description.

This script can also generate an HDL testbench for the generated RTL.
The testbench just issues a bunch of writes and reads and then checks
the values read based on an internal data structure.  Th testbench works
for simple register files but is broken for some mroe complicated
arrangements (multiple write ports, multiple read ports, etc.).

The code first computes some constants used in the generation of the
RTL.  This is in the routine called derived_constants().  The code then
calls the routine write_regfile() which generates the top-level netlist.
This defines the interface to the outside world, instantiates the banks
and hooks up the banks (there is some logic to decide which bank to
write, which bank to read, and so on).  The script then calls
write_state_bank() to see if the state can be generated as a "cheap"
state.  It it cannot it will then call write_regfile_bank() to generate
a traditional register file (i.e. with bypassing on read ports).  The
"main" routine is near the end of the file.


=head1 Traditional Register File

Lets look first at a register file with one read and one write port.
It is easy to then extebnd this to more read or write ports. 

The write port corresponds to a set of flops that hold the data until
the register file (i.e. the storage elements) is written.  The register
file is written on the commit stage or the stage after the last def
(whichever is later).  defs can happen in many stages (although each
instruction can def the state in only one stage).  There are thus muxes
between stages to select whether to pass down a value from a previous
stage or to take in a new value from the outside.

On the read sice the register file (i.e. the storage elements) is
accessed on the stage before the first use.  On this cycle any
subsequent writes that haven't made it to the register file are also         #'
bypassed.  If there are any pending writes that are not yet available
the logic will assert a stall signal that will cause the instruction to
wait in the R stage until the data is available. Once all the data has
been bypassed the data is latched (in a flop) and is then available for
use the following cycle.  Thus bypassing happens one cycle before the
first use. 

It is possible to have more than one use stage (although each
instruction can have only one use).  In this case the data is bypassed
in the stage before the first use (as before).  The data is then
pipelined until the actual use stage.  Whiel the data is being pipelined
it is necessary to bypass in any new values generated that were not
available at the time the first bypass happened.

Notice that bypass happens at the end of the cycle (not the beginning of
the cycle as in some previous Xtensa implementations).  This doesn't        #'
matter too much anymore because we use retiming (when available) to move
the bypass muxes around for optimal placement (although this has been a
source of bugs in the synthesis scripts).

Adding more read ports simply replicates the logic described above.
Each read port is independt of the others.

Adding more writes ports requires significantly more logic.  It is
necessary to duplicate every write pipeline.  It is also necessary to
add more logic to the read ports.  The bypass logic, in particular,
grows much more expensive as it is necessary to bypass from each stage
of the write ports to each read port (hence growing as m*n).

The traditional implementation makes all write ports the same length to
guarantee that the writes happen in order.  We have implemented an
optimization to reduce the logic by making sure that a write on a short
pipeline will not be over-written by an older write that goes down a
long pipeline.  When a write gets to the end of a write pipeline it will
kill any older writes on longer pipelines.  To make sure this preserves
the appropriate order for late uses it is necessary to ensure that the
shortes def pipeline is at least as long as the max use across all read
ports).


=head1 Cheap State

The cheap state is modeled by having only a write pipeline where the
first element of this pipeline always has the latest def value.  This
means that a def updates all flop of the previous stages.

For more details see the documentation below.

=cut


$main::inline_mux_count = 0;
sub inline_mux {
    my($data, $sel, $width, $out, $style, $code) = @_;
    my($i, $n, $n1, $module, $inst, $d, $fail, @data, @data_uniq);

    $n = @$data;
    if ($style eq "encoded") {
	$module = "xtmux${n}e";
	$fail = 0;
    } elsif ($style eq "priority") {
	$fail = scalar(@$data) != scalar(@$sel)+1;
	$module = "xtmux${n}p";
    } elsif ($style eq "selector") {
	$fail = scalar(@$data) != scalar(@$sel);
	$module = "xtmux${n}";
    } else {
	confess "inline_mux: bad style $style";
    }

    if ($fail) {
	confess "inline_mux: data / selection mismatch for $style $n";
    }

    @data_uniq = uniq(@$data);
    $n1 = @data_uniq;

    if ($n == 0) {
	print "    assign $out = 0;\n";
    } elsif ($n == 1 || ($n1 == 1 && $style eq "priority")) {
	print "    assign $out = " . (shift @$data) . ";\n";
    } else {
	if ($style eq "priority" && ($n1 != $n || defined $code)) {
	    if (! defined $code) {
		for($i = 0; $i < $n1; $i++) {
		    $code->{$data_uniq[$i]} = $i;
		}
	    }
	    @data = sort { $code->{$a} <=> $code->{$b} } @data_uniq;
	    print "    wire [" . (ceil_log2($n1)-1) . ":0] ${out}_sel =\n";
	    for($i = 0; $i < $n-1; $i++) {
		my $const = ceil_log2($n1) . "'d" . $code->{$data->[$i]};
		print "        $sel->[$i] ? $const :\n";
	    }
	    my $const = ceil_log2($n1) . "'d" . $code->{$data->[$n-1]};
	    print "        $const;\n";
	    inline_mux(\@data, "${out}_sel", $width, $out, "encoded");
	} else {
	    # drop an instance of the mux 
	    $inst = $main::inline_mux_count++;
	    print "    $module #($width) m$inst($out";
	    print map(", $_", @$data);
	    if ($style eq "priority" || $style eq "selector") {
		print map(", $_", @$sel);
		print ");\n";
	    } else {
		print ", $sel);\n";
	    }
	}
    }
} # inline_mux

# min of a list
sub min { 
    my($min, $v);
    $min = $_[0];
    foreach $v (@_) {
	$min = $v < $min ? $v : $min;
    }
    return $min;
} # min


# max of a list
sub max { 
    my($max, $v);
    $max = $_[0];
    foreach $v (@_) {
	$max = $v > $max ? $v : $max;
    }
    return $max;
} # max


# ceil(log2(x))
sub ceil_log2 {
    my($x) = @_;
    my($n);
    for($n = 0, $x -= 1; $x > 0; $x >>= 1, $n++) {
    }
    return $n;
} # ceil_log2


# 2^x
sub pow2 {
    my($x) = @_;
    return 1 << $x;
} # pow2


# uniqify an array
sub uniq { 
    my(%seen); 
    return grep(! $seen{$_}++, @_); 
} # uniq


# difference between two arrays
sub diff {
    my($aref, $bref) = @_;
    my(%hash);
    grep($hash{$_} = 1, @$bref);
    return grep(! defined $hash{$_}, @$aref);
} # diff

sub field {
    my($name, $port, $stage) = @_;
    carp unless (defined $name && defined $port && defined $stage);
    $name = "$port->{NAME}_$name";
    return "${name}_C$stage";
} # field


sub func_gated_clock_name {
    my($name) = @_;
    return "G2_$name\_CLK";
} # func_gated_clock_name

# This routine will generate a functional gated clk $clk from clk
# if ClkGateFunc is 1, otherwise it will simply add a clock buffer

sub generate_func_gated_clock {
    my ( $rf, $g2clk, $enable, $force_reset ) = @_;
    if ( $rf->{CLK_GATE_FUNC_UNIT} ) {
        my $clkgate_module  = ($rf->{USE_TMODE}) ? "xtgated_tmode_clock" : "xtgated_clock";
        my $tmode = ($rf->{USE_TMODE}) ? "TMode," : "";
        my $func_enable = $enable;
	# Priority: TMode > GlobalStall > Reset
	   $func_enable =  "(($func_enable) & ~GlobalStall)" if !$rf->{CLK_GATE_GLOBAL};
           ##  ################ TMode change ################################
           #Tmode is now a direct input to the clockgate if needed. 
           # Else don't bother ORing it in.
	   #$func_enable .= ' | TMode' if $rf->{USE_TMODE};
           ##  ################ TMode change ################################
	   $func_enable .= ' | Reset' if ($force_reset || $rf->{RESET_FLOPS});
	print "    $clkgate_module  i$g2clk($g2clk, $tmode $func_enable, clk);\n";
    } else {
        print "    xtclock_buffer i$g2clk($g2clk, clk);\n";
    }
}

# This routine will instantiate a flop that is supposed to run on the
# G1 clk. It checks to see if global clk gating is on, and if not turns
# it into an enable flop with !GlobalStall as the enable signal.
# If $set_on_reset instantiate a sync set delay. 
# Else if $clr_on_reset instantiate a sync clear delay.
# Set has higher precedence over clear.

sub write_xtdelay_g1 {
    my ($rf, $width, $input, $output, $clear, $reset) = @_;
    my $name = 'i' . $output;
    my $enable = !$rf->{CLK_GATE_GLOBAL};
    #my $sync_clear = $clr_on_reset | $rf->{RESET_FLOPS};
    #my $sync_set = $set_on_reset && $rf->{SYNC_RESET};
    my $ival = ($rf->{RESET_VALUE})?$rf->{RESET_VALUE}:"$rf->{SIZE}'h0";
    my $module = 'xt';
    $module .=  ($reset || $clear) ? $rf->{ASYNC_RESET_FLOPS} ? 'a' :'' : '';
    $module .= ($reset)?'ss':(($clear)?'sc':'');
    $module .=  'en' if $enable;
    $module .= 'delay1';
    my $xten = ($enable)?'!GlobalStall,':'';
    my $xtsetclr = ($reset)?"!Reset, $ival, ":(($clear)?'!Reset,':'');
    print "    $module #($width) $name($output, $input, $xten $xtsetclr clk);\n";
}

# This routine will instantiate a flop that is supposed to run on the
# G2 clk. It will instantiate a enable flop only if both ClkGateGLobal
# and ClkGateFunc are 0. This is because if ClkGateFunc is 1, the
# clock gating for G2 clk will include GlobalStall in its enable
# already.
# If ($set_on_reset), instantiate a sync set delay. 
# Else if ($clr_on_reset) instantiate a sync clear delay.
# Set has higher precedence over clear.

sub write_xtdelay_g2 {
    my ($rf, $width, $input, $output, $clk, $clear, $reset) = @_;
    my $name = 'i' . $output;
    #my $sync_clear = $clr_on_reset | $rf->{RESET_FLOPS};
    #my $sync_set = $set_on_reset && $rf->{SYNC_RESET};
    my $ival = ($rf->{RESET_VALUE})?$rf->{RESET_VALUE}:"$rf->{SIZE}'h0";
    my $enable = !$rf->{CLK_GATE_GLOBAL} && !$rf->{CLK_GATE_FUNC_UNIT};
    my $module = 'xt';
    $module .=  ($reset || $clear) ? $rf->{ASYNC_RESET_FLOPS} ? 'a' :'' : '';
    $module .=  ($reset)?'ss':(($clear)?'sc':'');
    $module .=  'en' if $enable;
    $module .= 'delay1';
    my $xten = ($enable)?'!GlobalStall,':'';
    my $xtsetclr = ($reset)?"!Reset, $ival, ":(($clear)?'!Reset,':'');
    print "    $module #($width) $name($output, $input, $xten $xtsetclr $clk);\n";
}

# This routine will instantiate a enable flop that is supposed to run on the
# G1 clk. It checks to see if global clk gating is on, and if not 
# gates the enable signal with !GlobalStall.
# If ($set_on_reset), instantiate a sync set delay. 
# Else if ($clr_on_reset) instantiate a sync clear delay.
# Set has higher precedence over clear.

sub write_xtendelay_g1 {
    my ($rf, $width, $input, $output, $enable, $clear, $reset) = @_;
    my $name = 'i' . $output;
    #my $sync_clear = $clr_on_reset | $rf->{RESET_FLOPS};
    #my $sync_set = $set_on_reset && $rf->{SYNC_RESET};
    my $ival = ($rf->{RESET_VALUE})?$rf->{RESET_VALUE}:"$rf->{SIZE}'h0";
    my $module = 'xt';
    $module .=  ($reset || $clear) ? $rf->{ASYNC_RESET_FLOPS} ? 'a' :'' : '';
    $module .=  ($reset)?'ss':(($clear)?'sc':'');
    $module .= 'endelay1';
    my $xten = (!$rf->{CLK_GATE_GLOBAL})?"($enable)&~GlobalStall,":"$enable, ";
    my $xtsetclr = ($reset)?"!Reset, $ival, ":(($clear)?'!Reset,':'');
    print "    $module #($width) $name($output, $input, $xten $xtsetclr clk);\n";
}

sub write_def {
    my($write_port, $stage) = @_;
    return grep($_ == $stage, @{$write_port->{DEF}});
} # write_def


sub read_use {
    my($read_port, $stage) = @_;
    return grep($_ == $stage, @{$read_port->{USE}});
} # read_use


sub init_print_break {
    my($indent) = @_;
    $main::col = 0;
    $main::indent = $indent;
} # init_print_break

sub print_break {
    my($d) = @_;
    if ($main::col + length($d) > 80) {
	$main::col = $main::indent;
	print ("\n" . (' ' x $main::indent));
    }
    print $d;
    $main::col += length($d);
} # print_break

sub doc {
    my($a) = <<'END_OF_DOCUMENTATION';

The pipelined register file instantiates a number of pipelined register file
banks, each of which contains a register file core.

The core is a simple multiple-read port multiple-write port register file.  The
address size is $rf->{ADDR_SIZE} (lg2 $rf->{MIN_HEIGHT}) and its declaration is
$rf->{ADDR_DECL}.  The data size is $rf->{WORD_SIZE} ($rf->{MIN_WIDTH}) and its
declaration is $rf->{WORD_DECL}.

Multiple banks are used to support multiple widths for read and write ports.
We build NUM_BANK ($rf->MAX_WIDTH / $rf->MIN_WIDTH) pipelined register banks,
each of which has MIN_HEIGHT words and MIN_WIDTH bits in each word.  Each width
must be a power of 2 multiple of the minimum width; in particular, NUM_BANK
must also be a power of 2.

A final read alignment mux looks at the low-order address bits and the
read-width mask to mux the correct data onto the output.  This splits the
address into HI_ADDR_SIZE and LO_ADDR_SIZE fields.  The high order bits go
directly to the register file core; the low address bits are fed to the
alignment mux.  The read output is always $rf->{MAX_WIDTH} in size (declared as
$rf->{FULL_WORD_DECL}) and smaller data values are shifted to the LSB of the
output word.

There is a new option "Windowed" which is used to optimize the register file
core implementation for power by changing the read mux structure. This option
will only work with single bank with single read and write widths. The two
parameters to be specified are window size and the number of windows (which controls
the window increment). The window size must be a power of 2 and the depth of the
register file must be a multiple of the window size. 

As a concrete example, consider a register file of size 1024 bits (32x32) with
read widths of 32 and 128.

    NUM_BANK = 4
    MIN_HEIGHT = 32
    MIN_WIDTH = 32
    MAX_HEIGHT = 8
    MAX_WIDTH = 128
    ADDR_SIZE = 5
    ADDR_DECL = [4:0]
    WORD_SIZE = 32
    WORD_DECL = [31:0]
    HI_ADDR_SIZE = 3
    LO_ADDR_SIZE = 2
    FULL_WORD_SIZE = 128
    FULL_WORD_DECL = [127:0]

The read mask is:
	11	to read width 32
	10	to read width 64 (not used in this case)
	00	to read width 128

END_OF_DOCUMENTATION
    return $a;
} # doc

sub derive_constants {
    my($rf) = @_;
    my($read_port, $write_port, $n, $w, $k, $v, $s, $error, @width, %port_name);
    my $debug = 0;

    # check for extraneous parameters
    my(%check) = %$rf;
    delete $check{NAME};
    delete $check{SIZE};
    delete $check{DESIGN_PREFIX};
    delete $check{READ_PORT};
    delete $check{WRITE_PORT};
    delete $check{TEST_LATCHES_TRANSPARENT};
    delete $check{CLK_GATE_FUNC_UNIT};
    delete $check{CLK_GATE_GLOBAL};
    delete $check{TEST_FULL_SCAN};
    delete $check{SYNC_RESET};
    delete $check{RESET_VALUE};
    delete $check{RESET_FLOPS};
    delete $check{ASYNC_RESET_FLOPS};
    delete $check{ALIGNMENT_ROTATE};
    delete $check{EXCEPTION_READ_PORT};
    delete $check{EXCEPTION_WRITE_PORT};
    delete $check{EXPORT_READ_PORT};
    delete $check{EXPORT_TRACE};
    delete $check{COMMIT_STAGE};
    delete $check{UPDATE_ON_EXCEPTION};
    delete $check{WINDOWED};
    delete $check{WINDOW_SIZE};
    delete $check{WINDOW_NUM};

    while (my($k, $v) = each %check) {
	print STDERR "Error: unknown argument '$k' = '$v'\n";
	if ($debug) {
	    while (my($k, $v) = each %$rf) {
		print STDERR " argument '$k' = '$v'\n";
	    }
	}
	$error = 1;
    }

    if (! defined $rf->{NAME}) {
	print STDERR "Error: rf->{NAME} must be defined\n";
	$error = 1;
    }
    if (! defined $rf->{SIZE}) {
	print STDERR "Error: rf->{SIZE} must be defined\n" ;
	$error = 1;
    }
    if (! defined $rf->{READ_PORT}) {
	print STDERR "Error: rf->{READ_PORT} must be defined\n";
	$error = 1;
    }
    if (! defined $rf->{WRITE_PORT}) {
	print STDERR "Error: rf->{WRITE_PORT} must be defined\n";
	$error = 1;
    }

    %port_name = ();

    if ( scalar (@{$rf->{READ_PORT}}) == 0   ||
	 scalar (@{$rf->{WRITE_PORT}}) == 0 ) {
	confess "Error: must have at least 1 read and 1 write port.";
    }
    foreach $read_port (@{$rf->{READ_PORT}}) {
	if (! defined $read_port->{NAME}) {
	    print STDERR "Error: read port has no name\n";
	    $error = 1;
	}
	if (! defined $read_port->{USE}) {
	    print STDERR "Error: read port $read_port->{NAME} has no USE\n";
	    $error = 1;
	}
	foreach $s (@{$read_port->{USE}}) {
	    if ($s < 0) {
		 printf STDERR "Error: read port $read_port->{NAME} has invalid USE $s\n";
		 $error = 1;
	    }
	}
	if (! defined $read_port->{WIDTH}) {
	    print STDERR "Error: read port $read_port->{NAME} has no WIDTH\n";
	    $error = 1;
	}
	if (defined $port_name{$read_port->{NAME}}) {
	    print STDERR "Error: read port $read_port->{NAME} not unique\n";
	    $error = 1;
	}
	$port_name{$read_port->{NAME}} = 1;
    }

    %port_name = ();
    foreach $write_port (@{$rf->{WRITE_PORT}}) {
	if (! defined $write_port->{NAME}) {
	    print STDERR "Error: write port has no name\n";
	    $error = 1;
	}
	if (! defined $write_port->{DEF}) {
	    print STDERR "Error: write port $write_port->{NAME} has no DEF\n";
	    $error = 1;
	}
	foreach $s (@{$write_port->{DEF}}) {
	    if ($s < 0) {
		 printf STDERR "Error: write port $write_port->{NAME} has invalid DEF $s\n";
		 $error = 1;
	    }
	}
	if (! defined $write_port->{WIDTH}) {
	    print STDERR "Error: write port $write_port->{NAME} has no WIDTH\n";
	    $error = 1;
	}
	if (defined $port_name{$write_port->{NAME}}) {
	    print STDERR "Error: write port $write_port->{NAME} not unique\n";
	    $error = 1;
	}
	$port_name{$write_port->{NAME}} = 1;
    }

    # determine parameters for register file banks
    @width = sort {$a <=> $b} (&uniq(map(@{$_->{WIDTH}}, @{$rf->{READ_PORT}}),
				     map(@{$_->{WIDTH}}, @{$rf->{WRITE_PORT}})));
    $rf->{MIN_WIDTH} = $width[0];
    $rf->{MAX_WIDTH} = $width[$#width];
    if ( !($rf->{MAX_WIDTH}) || !($rf->{MIN_WIDTH}) ) {
	confess "Error: register file width must be defined and must be non-0.";
    }
    $rf->{MIN_HEIGHT} = $rf->{SIZE} / $rf->{MAX_WIDTH};
    $rf->{MAX_HEIGHT} = $rf->{SIZE} / $rf->{MIN_WIDTH};
    $rf->{NUM_BANK} = $rf->{MAX_WIDTH} / $rf->{MIN_WIDTH};

    # validate the widths
    if ($rf->{MIN_HEIGHT} != int($rf->{MIN_HEIGHT})) {
	print STDERR "Error: size $rf->{SIZE} is not an integer multiple of $rf->{MAX_WIDTH}\n";
	$error = 1;
    }
    if ($rf->{MAX_HEIGHT} != int($rf->{MAX_HEIGHT})) {
	print STDERR "Error: size $rf->{SIZE} is not an integer multiple of $rf->{MIN_WIDTH}\n";
	$error = 1;
    }
    foreach $w (@width) {
	if ($w <= 0) {
	    print STDERR "Error: width $w is not valid\n";
	    $error = 1;
	}
	$n = $w / $rf->{MIN_WIDTH};
	if ($n != pow2(ceil_log2($n))) {
	    print STDERR "Error: width $w is not a valid multiple of $rf->{MIN_WIDTH}\n";
	    $error = 1;
	}
    }

    # register file core parameters
    $rf->{ADDR_SIZE} = ceil_log2($rf->{MIN_HEIGHT});
    $rf->{ADDR_DECL} = $rf->{ADDR_SIZE} > 0 ? "[" . ($rf->{ADDR_SIZE}-1) . ":0]" : "";
    $rf->{WORD_SIZE} = $rf->{MIN_WIDTH};
    $rf->{WORD_DECL} = "[" . ($rf->{WORD_SIZE}-1) . ":0]";

    $rf->{HI_ADDR_SIZE} = ceil_log2($rf->{MAX_HEIGHT});
    $rf->{LO_ADDR_SIZE} = $rf->{HI_ADDR_SIZE} - $rf->{ADDR_SIZE};
    $rf->{FULL_WORD_SIZE} = $rf->{MAX_WIDTH};
    $rf->{FULL_WORD_DECL} = "[" . ($rf->{FULL_WORD_SIZE}-1) . ":0]";


    $rf->{COMMIT_STAGE} = 3 unless (defined $rf->{COMMIT_STAGE});
    $rf->{MAX_LATENCY} = 0;
    foreach $write_port (@{$rf->{WRITE_PORT}}) {
	my(@def) = sort(&uniq(@{$write_port->{DEF}}));
	$write_port->{DEF} = \@def;
	$write_port->{MIN_DEF} = &min(@{$write_port->{DEF}});
	$write_port->{MAX_DEF} = &max($rf->{COMMIT_STAGE}-1, @{$write_port->{DEF}});
	$write_port->{MAX_WIDTH} = max(@{$write_port->{WIDTH}});
	$rf->{MAX_LATENCY} = max($rf->{MAX_LATENCY}, $write_port->{MAX_DEF});
    }    

    $rf->{MAX_USE_STAGE} = 0;
    foreach $read_port (@{$rf->{READ_PORT}}) {
	my(@use) = sort(&uniq(@{$read_port->{USE}}));
	$read_port->{USE} = \@use;
	$read_port->{MIN_USE} = &min(@{$read_port->{USE}});
	$read_port->{MAX_USE} = &max(@{$read_port->{USE}});
	$read_port->{MAX_WIDTH} = &max(@{$read_port->{WIDTH}});
	# power savings for the AR (see old TIE project descriptions - 
	# TIE307:Power Improvements for Windowed Register Files) result in a read 
	# mux structure that uses winbase and the pipelined read address in 
	# non-intuitive ways.  this lead to a bug where a younger 
	# call/retw/rotw/etc updated winbase before an older late-AR-use 
	# instruction used the pre-update value (see PR 17970 on Boreal or 17832 
	# on BP).  to work around this bug, we force the min use of windowed 
	# register files to be R-stage.  R-stage across all read ports, and 
	# R-stage even if the user TIE specified a later min use.  
	$read_port->{READ_STAGE} = $rf->{WINDOWED} ? 0 : &max(0, $read_port->{MIN_USE} - 1);
	$rf->{MAX_USE_STAGE} = max($rf->{MAX_USE_STAGE}, $read_port->{MAX_USE});
    }

    foreach $write_port (@{$rf->{WRITE_PORT}}) {
	$write_port->{WRITE_STAGE} = max(($write_port->{MAX_DEF} + 1),
					 min($rf->{MAX_USE_STAGE},
					     $rf->{MAX_LATENCY} + 1));
    }

    if (! defined $rf->{TEST_LATCHES_TRANSPARENT}) {
	$rf->{TEST_LATCHES_TRANSPARENT} = 0;
    }
    if (! defined $rf->{CLK_GATE_FUNC_UNIT}) {
	$rf->{CLK_GATE_FUNC_UNIT} = 1;
    }
    if (! defined $rf->{CLK_GATE_GLOBAL}) {
	$rf->{CLK_GATE_GLOBAL} = 1;
    }
    if (! defined $rf->{TEST_FULL_SCAN}) {
	$rf->{TEST_FULL_SCAN} = 0;
    }
    if (! defined $rf->{SYNC_RESET}) {
	$rf->{SYNC_RESET} = 0;
    }
    if (! defined $rf->{RESET_FLOPS}) {
	$rf->{RESET_FLOPS} = 0;
    }
    $rf->{RESET_FLOPS} = 1; #Force to 1
    if (! defined $rf->{ASYNC_RESET_FLOPS}) {
	$rf->{ASYNC_RESET_FLOPS} = 0;
    }
    $rf->{USE_TMODE} = $rf->{TEST_FULL_SCAN} && ($rf->{TEST_LATCHES_TRANSPARENT} ||
						 $rf->{CLK_GATE_FUNC_UNIT} ||
						 $rf->{ASYNC_RESET_FLOPS});
    if (! defined $rf->{ALIGNMENT_ROTATE}) {
	$rf->{ALIGNMENT_ROTATE} = 0;
    }
    if (! defined $rf->{EXCEPTION_READ_PORT}) {
	$rf->{EXCEPTION_READ_PORT} = 0;
    }
    if (! defined $rf->{EXCEPTION_WRITE_PORT}) {
	$rf->{EXCEPTION_WRITE_PORT} = 0;
    }
    if (! defined $rf->{EXPORT_READ_PORT}) {
	$rf->{EXPORT_READ_PORT} = 0;
    }
    if (! defined $rf->{EXPORT_TRACE}) {
	$rf->{EXPORT_TRACE} = 0;
    }
    $rf->{DESIGN_PREFIX} = $rf->{DESIGN_PREFIX} || "";

    my $state = @{$rf->{READ_PORT}} == 1 && 
		@{$rf->{WRITE_PORT}} == 1 &&
		$rf->{MIN_HEIGHT} == 1;

    if ($rf->{SYNC_RESET}) {
	if (! $state) {
	    printf STDERR "SYNC_RESET works only for state (1 read port, 1 write port, 1 word)\n"; 
	    $error = 1;
	}
    }
    if ($rf->{EXCEPTION_READ_PORT}) {
	if (! $state) {
	    printf STDERR "EXCEPTION_READ_PORT works only for state (1 read port, 1 write port, 1 word)\n"; 
	    $error = 1;
	}
    }
    if ($rf->{EXCEPTION_WRITE_PORT}) {
	if (! $state) {
	    printf STDERR "EXCEPTION_WRITE_PORT works only for state (1 read port, 1 write port, 1 word)\n"; 
	    $error = 1;
	}
    }
    if ($rf->{EXPORT_READ_PORT}) {
	if (! $state) {
	    printf STDERR "EXPORT_READ_PORT works only for state (1 read port, 1 write port, 1 word)\n"; 
	    $error = 1;
	}
	if ( $rf->{EXPORT_READ_PORT} <  $rf->{WRITE_PORT}->[0]->{MAX_DEF} ) {
	    printf STDERR "EXPORT_READ_PORT must be >= the max def stage of a state\n"; 
	    $error = 1;
        }
    }
    if ( $rf->{EXPORT_TRACE} && !$rf->{EXPORT_READ_PORT} ) {
        printf STDERR "EXPORT_TRACE can only be on when EXPORT_READ_PORT is set\n";
        $error = 1;
    }

    if ($rf->{WINDOWED}) {
	if ($state) {
	    printf STDERR "Only register files can be windowed.\n";
	    $error = 1;
	}
	if ( $rf->{NUM_BANK} != 1 ) {
	    printf STDERR "Windowed register files can have only one bank.\n";
	    $error = 1;
	}
	if ( $rf->{MIN_HEIGHT} != $rf->{MAX_HEIGHT} ) {
	    print STDERR "Error: Windowed Register file cannot have different views.\n";
	    $error = 1;
	}
	if ( ($rf->{MIN_HEIGHT}/$rf->{WINDOW_SIZE})  != int(($rf->{MIN_HEIGHT}/$rf->{WINDOW_SIZE})) ) {
	    print STDERR "Error: register file size must be a multiple of window size.\n";
	    $error = 1;
	}
	if ($rf->{WINDOW_SIZE} != pow2(ceil_log2($rf->{WINDOW_SIZE}))) {
	    print STDERR "Error: Window size $rf->{WINDOW_SIZE} must be a power of 2\n";
	    $error = 1;
	}
	my $win_increment = int($rf->{MIN_HEIGHT}/$rf->{WINDOW_SIZE});
	if ( $win_increment != pow2(ceil_log2($win_increment))) {
	    print STDERR "Error: Window increment $win_increment must be a power of 2\n";
	    $error = 1;
	}
	if ($rf->{WINDOW_NUM} != pow2(ceil_log2($rf->{WINDOW_NUM}))) {
	    print STDERR "Error: Window size $rf->{WINDOW_NUM} must be a power of 2\n";
	    $error = 1;
	}
	$rf->{WINDOW_BASE_SIZE} = ceil_log2($rf->{WINDOW_NUM});
    }

    if ($error) {
	confess "Error: (regfile.pl) cannot continue; aborting\n";
    }
} # derive_constants

sub write_regfile {
    my($rf) = @_;
    my($read_port, $write_port, @iolist, $s, $i, $j, $h, $l, $w);

    my $lo_addr_decl = "[" . ($rf->{LO_ADDR_SIZE}-1) . ":0]";

    init_print_break(0);
    print_break("module $rf->{DESIGN_PREFIX}$rf->{NAME}(");

    # hack special case; works only for state
    if ($rf->{EXCEPTION_READ_PORT}) {
	my $exc_read = "exception_read";
	print_break("$exc_read, ");
	push(@iolist, "    output $rf->{WORD_DECL} $exc_read;\n");
    }
    if ($rf->{EXCEPTION_WRITE_PORT}) {
	my $exc_write = "exception_write";
	print_break("$exc_write, ");
	push(@iolist, "    input $rf->{WORD_DECL} $exc_write;\n");
	my $exc_we = "exception_we";
	print_break("$exc_we, ");
	push(@iolist, "    input $exc_we;\n");
    }
    if ($rf->{EXPORT_READ_PORT}) {
	my $exp_read = "export_read";
	print_break("$exp_read, ");
	print_break("active, ");
	push(@iolist, "    output $rf->{WORD_DECL} $exp_read;\n");
	push(@iolist, "    output active;\n");
	if ( $rf->{EXPORT_TRACE} ) {
	    print_break("export_valid, ");
	    push(@iolist, "    output export_valid;\n");
	}
    }
    if ( $rf->{WINDOWED} ) {
        my $window_base_decl = "[" . ($rf->{WINDOW_BASE_SIZE}-1) . ":0]";
	print_break("WinBase, ");
	push(@iolist, "    input $window_base_decl WinBase;\n");
    }

    foreach $read_port (@{$rf->{READ_PORT}}) {
	if ($rf->{HI_ADDR_SIZE} > 0) {
	    my $addr  = field("addr", $read_port, 0);
	    my $decl  = "[" . ($rf->{HI_ADDR_SIZE} - 1) . ":0]";
	    print_break("$addr, ");
	    push(@iolist, "    input $decl $addr;\n");
	}
	foreach $s (@{$read_port->{USE}}) {
	    my $data  = field("data", $read_port, $s);
	    my $decl  = "[" . ($read_port->{MAX_WIDTH} - 1) . ":0]";
	    print_break("$data, ");
	    push(@iolist, "    output $decl $data;\n");
	}
	foreach $s (@{$read_port->{USE}}) {
	    my $use = field("use$s", $read_port, 0);
	    print_break("$use, ");
	    push(@iolist, "    input $use;\n");
	}
	foreach $w (@{$read_port->{WIDTH}}) {
	    my $width = field("width$w", $read_port, 0);
	    print_break("$width, ");
	    push(@iolist, "    input $width;\n");
	}
    }

    foreach $write_port (@{$rf->{WRITE_PORT}}) {
	if ($rf->{HI_ADDR_SIZE} > 0) {
	    my $addr  = field("addr", $write_port, 0);
	    my $decl  = "[" . ($rf->{HI_ADDR_SIZE} - 1) . ":0]";
	    print_break("$addr, ");
	    push(@iolist, "    input $decl $addr;\n");
	}
	foreach $w (@{$write_port->{WIDTH}}) {
	    foreach $s (@{$write_port->{DEF}}) {
		my $data = field("data$w", $write_port, $s);
		my $decl = "[" . ($w - 1) . ":0]";
		print_break("$data, ");
		push(@iolist, "    input $decl $data;\n");
	    }
	}
	foreach $s (@{$write_port->{DEF}}) {
	    my $def = field("def$s", $write_port, 0);
	    print_break("$def, ");
	    push(@iolist, "    input $def;\n");
	}
	foreach $w (@{$write_port->{WIDTH}}) {
	    my $width = field("width$w", $write_port, 0);
	    print_break("$width, ");
	    push(@iolist, "    input $width;\n");
	}
	my $first_wen = min(1, $write_port->{MIN_DEF});
	my $last_wen = max(@{$write_port->{DEF}});
	foreach $s ($first_wen ... $last_wen) {
	    my $wen = field("wen", $write_port, $s);
	    print_break("$wen, ");
	    push(@iolist, "    input $wen;\n");
	}
    }

    # no longer needed
    # For the AR register file, we want the commit stage write data and 
    # write enable to be primary outputs.  This is for trace port use.
    # These signals always comes from Slot 0, Write Port 0.
#    if ($rf->{NAME} eq 'TIE_Regfile_AR') {
#	my $addr = "s0wr0_addr_C"   . $rf->{COMMIT_STAGE};
#	my $data = "s0wr0_result_C" . $rf->{COMMIT_STAGE};
#	my $wen  = "s0wr0_tport_we_C"  . $rf->{COMMIT_STAGE};
#	print_break("$addr, ");
#	print_break("$data, ");
#	print_break("$wen, ");
#        push(@iolist, "    output $rf->{ADDR_DECL} $addr;\n");
#        push(@iolist, "    output $rf->{WORD_DECL} $data;\n");
#	push(@iolist, "    output $wen;\n");
#    }

    print_break("Kill_E, ");
    push(@iolist, "    input Kill_E;\n");

    print_break("KillPipe_W, ");
    push(@iolist, "    input KillPipe_W;\n");

    print_break("Valid_W, ");
    push(@iolist, "    input Valid_W;\n");

    print_break("Stall_R, ");
    push(@iolist, "    output Stall_R;\n");

    if ($rf->{USE_TMODE}) {
	print_break("TMode, ");
	push(@iolist, "    input TMode;\n");
    }

    print_break("Reset, ");
    push(@iolist, "    input Reset;\n");

    print_break("GlobalStall, ");
    push(@iolist, "    input GlobalStall;\n");

    print_break("clk);\n");
    push(@iolist, "    input clk;\n");

    print join('', @iolist);
    print "\n";

    foreach $read_port (@{$rf->{READ_PORT}}) {
	print "    /*" . ('*' x 70) . "\n";
	print "          READ PORT $read_port->{NAME}\n";
	print "     *" . ('*' x 70) . "/\n";

	if ($rf->{LO_ADDR_SIZE} > 0) {
	    print "    // compute the address mask\n";
	    my(@data, @sel);
	    my $addr_mask = field("mask", $read_port, 0);
	    foreach $w (@{$read_port->{WIDTH}}) {
		my $width = field("width$w", $read_port, 0);
		my $const = ~($w / $rf->{MIN_WIDTH} - 1) & ((1 << $rf->{LO_ADDR_SIZE}) - 1);
		push(@data, $rf->{LO_ADDR_SIZE} . "'d" . $const);
		push(@sel, $width);
	    }
	    print "    wire $lo_addr_decl $addr_mask;\n";
	    inline_mux(\@data, \@sel, $rf->{LO_ADDR_SIZE}, $addr_mask, "selector"); 
	    print "\n";
	}

	if ($rf->{LO_ADDR_SIZE} > 0) {
	    print "    // masked address pipeline\n";
	    my $addr = field("addr", $read_port, 0);
	    my $maddr = field("maddr", $read_port, 0);
	    my $addr_mask = field("mask", $read_port, 0);
	    print "    wire $lo_addr_decl $maddr = $addr$lo_addr_decl & $addr_mask;\n";
	    for($s = 1; $s <= $read_port->{MAX_USE}; $s++) {
		my $maddr = field("maddr", $read_port, $s);
		print "    wire $lo_addr_decl $maddr;\n"; 
		if ($s == 1 && $rf->{ALIGNMENT_ROTATE}) {
		    $maddr = field("addr", $read_port, $s-1) . $lo_addr_decl;
		} else {
		    $maddr = field("maddr", $read_port, $s-1);
		}
		my $maddr1 = field("maddr", $read_port, $s);
		#always reset flop, no sync reset
		write_xtdelay_g1($rf, $rf->{LO_ADDR_SIZE}, $maddr, $maddr1, 1, 0);
		#print "    xtdelay1 #($rf->{LO_ADDR_SIZE}) i$maddr1($maddr1, $maddr, clk);\n";
	    }
	    print "\n";
	}

	print "    // bank-qualified use\n";
	if ($rf->{LO_ADDR_SIZE} > 0) {
	    foreach $i (0 .. $rf->{NUM_BANK}-1) {
		my $active_banki = field("active$i", $read_port, 0);
		my $maddr  = field("maddr", $read_port, 0);
		my $addr_mask  = field("mask", $read_port, 0);
		my $const = $rf->{LO_ADDR_SIZE} . "'d" . $i;
		print "    wire $active_banki = $maddr == ($const & $addr_mask);\n";
	    }
	}
	foreach $s (@{$read_port->{USE}}) {
	    foreach $i (0 .. $rf->{NUM_BANK}-1) {
		my $use  = field("use$s", $read_port, 0);
		my $use_banki  = field("use$s" . "_bank$i", $read_port, 0);
		if ($rf->{LO_ADDR_SIZE} > 0) {
		    my $active_banki  = field("active$i", $read_port, 0);
		    print "    wire $use_banki = $use & $active_banki;\n";
		} else {
		    print "    wire $use_banki = $use;\n";
		}
	    }
	}
	print "\n";

	if ($rf->{LO_ADDR_SIZE} > 0) {
	    if ($rf->{ALIGNMENT_ROTATE}) {
		foreach $s (@{$read_port->{USE}}) {
		    print "    // alignment mux for use $s\n";
		    for($i = 0; $i < $rf->{NUM_BANK}; $i++) {
			my $data_banki = field("data_bank$i", $read_port, $s);
			print "    wire $rf->{WORD_DECL} $data_banki;\n";
		    }
		    my $data = field("data", $read_port, $s);
		    my $n = $rf->{LO_ADDR_SIZE};
		    my $mult = $rf->{MIN_WIDTH};
		    my $size = $rf->{MAX_WIDTH};
		    print "    xtrotate_right$n #($size, $size, $mult) i$data($data,\n";
		    my $concat;
		    $concat = "{";
		    for($i = $rf->{NUM_BANK}-1; $i >= 0; $i--) {
			my $data_banki = field("data_bank$i", $read_port, $s);
			$concat .= "$data_banki";
			$concat .= ", " if $i != 0;
		    }
		    $concat .= "}";
		    print wrap("        ", "        ", $concat);
		    my $maddr = field("maddr", $read_port, $s);
		    print ", $maddr);\n";
		}
		
	    } else {
		# determine which banks need to be muxed into which output ports
		my @align;
		for($i = 0; $i < $rf->{NUM_BANK}; $i++) {
		    $align[$i] = [ ];
		}
		for($w = 1; $w <= $rf->{NUM_BANK}; $w *= 2) {
		    # does this port need this read-width?
		    if (grep($_ == $w * $rf->{MIN_WIDTH}, @{$read_port->{WIDTH}})) {
			for($j = 0; $j < $rf->{NUM_BANK}; $j += $w) {
			    for($i = 0; $i < $w; $i++) {
				push(@{$align[$i]}, $i+$j);
			    }
			}
		    }
		}

		for($i = 0; $i < $rf->{NUM_BANK}; $i++) {
		    @{$align[$i]} = sort {$a <=> $b} (&uniq(@{$align[$i]}));
		}

		foreach $s (@{$read_port->{USE}}) {
		    print "    // alignment mux for use $s\n";
		    for($i = 0; $i < $rf->{NUM_BANK}; $i++) {
			my $data_banki = field("data_bank$i", $read_port, $s);
			print "    wire $rf->{WORD_DECL} $data_banki;\n";
		    }
		    for($i = 0; $i < $rf->{NUM_BANK}; $i++) {
			my @data;
			foreach $j (@{$align[$i]}) {
			    my $data_bankj = field("data_bank$j", $read_port, $s);
			    push(@data, $data_bankj);
			}

			$h = $rf->{LO_ADDR_SIZE} - 1;
			$l = $rf->{LO_ADDR_SIZE} - ceil_log2($#data + 1);
			my $sel = field("maddr", $read_port, $s) . "[$h:$l]";

			$h = $rf->{MIN_WIDTH} * ($i+1) - 1;
			$l = $rf->{MIN_WIDTH} * $i;
			my $data = field("data", $read_port, $s) . "[$h:$l]";
			if (@data > 0) {
			    inline_mux(\@data, $sel, $rf->{WORD_SIZE}, $data, "encoded");
			}
		    }
		    print "\n";
		}
	    }
	} else {
	    foreach $s (@{$read_port->{USE}}) {
		my $data = field("data", $read_port, $s);
		my $data_bank0 = field("data_bank0", $read_port, $s);
		print "    wire $rf->{WORD_DECL} $data_bank0;\n";
		print "    assign $data = $data_bank0;\n";
	    }
	}
	print "\n";
    }


    foreach $write_port (@{$rf->{WRITE_PORT}}) {
	print "    /*" . ('*' x 70) . "\n";
	print "          WRITE PORT $write_port->{NAME}\n";
	print "     *" . ('*' x 70) . "/\n";

	if ($rf->{LO_ADDR_SIZE} > 0) {
	    print "    // compute the address mask\n";
	    my(@data, @sel);
	    my $addr_mask = field("mask", $write_port, 0);
	    foreach $w (@{$write_port->{WIDTH}}) {
		my $width = field("width$w", $write_port, 0);
		my $const = ~($w / $rf->{MIN_WIDTH} - 1) & ((1 << $rf->{LO_ADDR_SIZE}) - 1);
		push(@data, $rf->{LO_ADDR_SIZE} . "'d" . $const);
		push(@sel, $width);
	    }
	    print "    wire $lo_addr_decl $addr_mask;\n";
	    inline_mux(\@data, \@sel, $rf->{LO_ADDR_SIZE}, $addr_mask, "selector"); 
	    print "\n";
	}  else {
	    my $addr_mask = field("mask", $write_port, 0);
            if ($rf->{HI_ADDR_SIZE} > 0) {
                my($decl) = "[" . ($rf->{HI_ADDR_SIZE} - 1) . ":0]"; 
                my $val = $rf->{HI_ADDR_SIZE} . "'h0";
                print "    wire $decl $addr_mask = $val;\n";
            } else {
                print "    wire $addr_mask = 1'h0;\n";
            }
        }


	if ($rf->{LO_ADDR_SIZE} > 0) {
	    print "    // masked address pipeline\n";
	    my $addr = field("addr", $write_port, 0);
	    my $maddr = field("maddr", $write_port, 0);
	    my $addr_mask = field("mask", $write_port, 0);
	    print "    wire $lo_addr_decl $maddr = $addr$lo_addr_decl & $addr_mask;\n";
	    print "\n";
	}

	if (@{$write_port->{WIDTH}} > 1) {
	    print "    // width pipeline\n";
	    foreach $w (@{$write_port->{WIDTH}}) {
		for($s = 0; $s < max(@{$write_port->{DEF}}); $s++) {
		    my $width = field("width$w", $write_port, $s);
		    my $width1 = field("width$w", $write_port, $s+1);
		    print "    wire $width1;\n";
		    if ($s == 0) {
			my $enable = field("width${w}_en", $write_port, 0);
			my $en = join(' | ',
					  map(field("def$_", $write_port, 0),
					      @{$write_port->{DEF}}));
			print "    wire $enable = $en;\n";
			#always reset flop, no sync reset
			write_xtendelay_g1($rf, 1, $width, $width1, $enable, 1, 0);
			#print "    xtendelay1 #(1) i$width1($width1, $width, $enable, clk);\n";
		    } else {
			#always reset flop, no sync reset
			write_xtdelay_g1($rf, 1, $width, $width1, 1, 0);
			#print "    xtdelay1 #(1) i$width1($width1, $width, clk);\n";
		    }
		}
	    }
	    print "\n";
	}

	print "    // bank-qualified def\n";
	if ($rf->{LO_ADDR_SIZE} > 0) {
	    foreach $i (0 .. $rf->{NUM_BANK}-1) {
		my $active_banki  = field("active$i", $write_port, 0);
		my $maddr  = field("maddr", $write_port, 0);
		my $addr_mask  = field("mask", $write_port, 0);
		my $const = (($rf->{LO_ADDR_SIZE} > 0 )?(&max($rf->{LO_ADDR_SIZE},1)):
                            (&max($rf->{HI_ADDR_SIZE}, 1))) . "'d" . $i;
		print "    wire $active_banki = $maddr == ($const & $addr_mask);\n";
	    }
	}
	foreach $s (@{$write_port->{DEF}}) {
	    foreach $i (0 .. $rf->{NUM_BANK}-1) {
		my $def = field("def$s", $write_port, 0);
		my $def_banki = field("def$s" . "_bank$i", $write_port, 0);
		if ($rf->{LO_ADDR_SIZE} > 0) {
		    my $active_banki = field("active$i", $write_port, 0);
		    print "    wire $def_banki = $def & $active_banki;\n";
		} else {
		    print "    wire $def_banki = $def;\n";
		}
	    }
	}
	print "\n";

	foreach $s (@{$write_port->{DEF}}) {
	    my(@data, @sel);
	    print "    // write mux for def $s\n";
	    my $wdata = field("wdata", $write_port, $s);
	    foreach $w (@{$write_port->{WIDTH}}) {
		$i = $rf->{MAX_WIDTH} / $w;
		my $width = field("width$w", $write_port, $s);
		my $data = field("data$w", $write_port, $s);
		$data = "{" . $i . "{$data" . "[" . ($w-1) . ":0]}}";
		push(@data, $data);
		push(@sel, $width);
	    }
	    print "    wire $rf->{FULL_WORD_DECL} $wdata;\n";
	    inline_mux(\@data, \@sel, $rf->{FULL_WORD_SIZE}, $wdata, "selector");
	    print "\n";
	}
	print "\n";
    }

    print "    wire " . join(", ", map("Stall_R$_", 0 .. $rf->{NUM_BANK}-1)) . ";\n";
    print "    assign Stall_R = ";
    print join(" | ", map("Stall_R$_", 0 .. $rf->{NUM_BANK}-1)) . ";\n";
    print "\n";

    # drop n copies of the pipelined regfile
    print "    /*" . ('*' x 70) . "\n";
    print "          PIPELINED BANK\n";
    print "     *" . ('*' x 70) . "/\n";
    for($i = 0; $i < $rf->{NUM_BANK}; $i++) {
	init_print_break(8);
	my $module = "$rf->{DESIGN_PREFIX}$rf->{NAME}_bank";
	print_break("    $module $rf->{NAME}_bank$i(");

	if ($rf->{EXCEPTION_READ_PORT}) {
	    my $exc_read = "exception_read";
	    print_break("$exc_read, ");
	    push(@iolist, "    output $rf->{WORD_DECL} $exc_read;\n");
	}
	if ($rf->{EXCEPTION_WRITE_PORT}) {
	    my $exc_write = "exception_write";
	    print_break("$exc_write, ");
	    my $exc_we = "exception_we";
	    print_break("$exc_we, ");
	}
	if ($rf->{EXPORT_READ_PORT}) {
	    my $exp_read = "export_read";
	    print_break("$exp_read, ");
	    print_break("active, ");
	    push(@iolist, "    output $rf->{WORD_DECL} $exp_read;\n");
	    push(@iolist, "    output active;\n");
	    if ( $rf->{EXPORT_TRACE} ) {
	        print_break("export_valid, ");
	        push(@iolist, "    output export_valid;\n");
	    }
	}
	if ($rf->{WINDOWED}) {
	    print_break("WinBase, ");
	}

	foreach $read_port (@{$rf->{READ_PORT}}) {
	    if ($rf->{ADDR_SIZE} > 0) {
		my $addr = field("addr", $read_port, 0);
		my $decl = "[" . ($rf->{HI_ADDR_SIZE}-1) . ":$rf->{LO_ADDR_SIZE}]";
		print_break("$addr$decl, ");
	    }
	    foreach $s (@{$read_port->{USE}}) {
		my $data_banki = field("data_bank$i", $read_port, $s);
		print_break("$data_banki, ");
	    }
	    foreach $s (@{$read_port->{USE}}) {
		my $use_banki = field("use$s" . "_bank$i", $read_port, 0);
		print_break("$use_banki, ");
	    }
	}
	foreach $write_port (@{$rf->{WRITE_PORT}}) {
	    if ($rf->{ADDR_SIZE} > 0) {
		my $addr = field("addr", $write_port, 0);
		my $decl = "[" . ($rf->{HI_ADDR_SIZE}-1) . ":$rf->{LO_ADDR_SIZE}]";
		print_break("$addr$decl, ");
	    }
	    foreach $s (@{$write_port->{DEF}}) {
		my $wdata = field("wdata", $write_port, $s);
		$h = $rf->{MIN_WIDTH} * ($i+1) - 1;
		$l = $rf->{MIN_WIDTH} * $i;
		print_break("$wdata" . "[$h:$l], ");
	    }
	    foreach $s (@{$write_port->{DEF}}) {
		my $def_banki = field("def$s" . "_bank$i", $write_port, 0);
		print_break("$def_banki, ");
	    }
	    my $first_wen = min(1, $write_port->{MIN_DEF});
	    my $last_wen = max(@{$write_port->{DEF}});
	    foreach $s ($first_wen .. $last_wen) {
		my $wen = field("wen", $write_port, $s);
		print_break("$wen, ");
	    }
	}

	# no longer needed
	# For the AR register file, we want the commit stage write data and 
	# write enable to be primary outputs.  This is for trace port use.
	# These signals always comes from Slot 0, Write Port 0.
#	if ($rf->{NAME} eq 'TIE_Regfile_AR') {
#	    my $addr = "s0wr0_addr_C"   . $rf->{COMMIT_STAGE};
#	    my $data = "s0wr0_result_C" . $rf->{COMMIT_STAGE};
#	    my $wen  = "s0wr0_tport_we_C"  . $rf->{COMMIT_STAGE};
#	    print_break("$addr, ");
#	    print_break("$data, ");
#	    print_break("$wen, ");
#	}

	print_break("Kill_E, ");
	print_break("KillPipe_W, ");
	print_break("Valid_W, ");
	print_break("Stall_R$i, ");
	if ($rf->{USE_TMODE}) {
	    print_break("TMode, ");
	}
	print_break("Reset, ");
	print_break("GlobalStall, clk);\n");
	print "\n";
    }

    print "endmodule\n";
} # write_regfile

sub write_regfile_bank {
    my($rf) = @_;
    my(@iolist, $s, $rs, $ws, $i, $read_port, $write_port);
    my $async = $rf->{ASYNC_RESET_FLOPS} ? "a" : "";

    init_print_break(0);
    print_break("module $rf->{DESIGN_PREFIX}$rf->{NAME}_bank(");

    # special case for exception-state: export committed state
    if ($rf->{EXCEPTION_READ_PORT}) {
	my $exc_read = "exception_read";
	print_break("$exc_read, ");
	push(@iolist, "    output $rf->{WORD_DECL} $exc_read;\n");
    }
    if ($rf->{EXCEPTION_WRITE_PORT}) {
	my $exc_write = "exception_write";
	print_break("$exc_write, ");
	push(@iolist, "    input $rf->{WORD_DECL} $exc_write;\n");
	my $exc_we = "exception_we";
	print_break("$exc_we, ");
	push(@iolist, "    input $exc_we;\n");
    }
    # special case for exception-state: export committed state
    if ($rf->{EXPORT_READ_PORT}) {
	my $exp_read = "export_read";
	print_break("$exp_read, ");
	print_break("active, ");
	push(@iolist, "    output $rf->{WORD_DECL} $exp_read;\n");
	push(@iolist, "    output active;\n");
	if ( $rf->{EXPORT_TRACE} ) {
	    print_break("export_valid, ");
	    push(@iolist, "    output export_valid;\n");
	}
    }
    if ( $rf->{WINDOWED} ) {
        my $window_base_decl = "[" . ($rf->{WINDOW_BASE_SIZE}-1) . ":0]";
	print_break("WinBase, ");
	push(@iolist, "    input $window_base_decl WinBase;\n");
    }

    # read port I/O list
    foreach $read_port (@{$rf->{READ_PORT}}) {
	if ($rf->{ADDR_SIZE} > 0) {
	    my $addr = field("addr", $read_port, 0);
	    print_break("$addr, ");
	    push(@iolist, "    input $rf->{ADDR_DECL} $addr;\n");
	}
	foreach $s (@{$read_port->{USE}}) {
	    my $data = field("data", $read_port, $s);
	    print_break("$data, ");
	    push(@iolist, "    output $rf->{WORD_DECL} $data;\n");
	}
	foreach $s (@{$read_port->{USE}}) {
	    my $use = field("use$s", $read_port, 0);
	    print_break("$use, ");
	    push(@iolist, "    input $use;\n");
	}
    }

    # write port I/O list
    foreach $write_port (@{$rf->{WRITE_PORT}}) {
	if ($rf->{ADDR_SIZE} > 0) {
	    my $addr = field("addr", $write_port, 0);
	    print_break("$addr, ");
	    push(@iolist, "    input $rf->{ADDR_DECL} $addr;\n");
	}
	foreach $s (@{$write_port->{DEF}}) {
	    my $data = field("data", $write_port, $s);
	    print_break("$data, ");
	    push(@iolist, "    input $rf->{WORD_DECL} $data;\n");
	}
	foreach $s (@{$write_port->{DEF}}) {
	    my $def = field("def$s", $write_port, 0);
	    print_break("$def, ");
	    push(@iolist, "    input $def;\n");
	}
	my $first_wen = min(1, $write_port->{MIN_DEF});
	my $last_wen = max(@{$write_port->{DEF}});
	foreach $s ($first_wen .. $last_wen) {
	    my $wen = field("wen", $write_port, $s);
	    print_break("$wen, ");
	    push(@iolist, "    input $wen;\n");
	}
    }

    # no longer needed
    # For the AR register file, we want the commit stage write data and 
    # write enable to be primary outputs.  This is for trace port use.
    # These signals always comes from Slot 0, Write Port 0.
#    if ($rf->{NAME} eq 'TIE_Regfile_AR') {
#	my $addr = "s0wr0_addr_C"   . $rf->{COMMIT_STAGE};
#	my $data = "s0wr0_result_C" . $rf->{COMMIT_STAGE};
#	my $wen  = "s0wr0_tport_we_C"  . $rf->{COMMIT_STAGE};
#	print_break("$addr, ");
#	print_break("$data, ");
#	print_break("$wen, ");
#        push(@iolist, "    output $rf->{ADDR_DECL} $addr;\n");
#        push(@iolist, "    output $rf->{WORD_DECL} $data;\n");
#	push(@iolist, "    output $wen;\n");
#    }

    print_break("Kill_E, ");
    push(@iolist, "    input Kill_E;\n");

    print_break("KillPipe_W, ");
    push(@iolist, "    input KillPipe_W;\n");

    print_break("Valid_W, ");
    push(@iolist, "    input Valid_W;\n");

    print_break("Stall_R, ");
    push(@iolist, "    output Stall_R;\n");

    if ($rf->{USE_TMODE}) {
	print_break("TMode, ");
	push(@iolist, "    input TMode;\n");
    }

    print_break("Reset, ");
    push(@iolist, "    input Reset;\n");

    print_break("GlobalStall, \n");
    push(@iolist, "    input GlobalStall;\n");

    print_break("clk);\n");
    push(@iolist, "    input clk;\n");

    print join('', @iolist);
    print "\n";

    # define a wen_C0 if there is no def 0
    foreach $write_port (@{$rf->{WRITE_PORT}}) {
	if (! write_def($write_port, 0)) {
	    my $wen = field("wen", $write_port, 0);
	    print "    wire $wen = 1'd1;\n";
	}
    }

    # generate the kill signals
    my $max_use = 0;
    foreach $read_port ( @{$rf->{READ_PORT}}) {
        $max_use = max($read_port->{MAX_USE}, $max_use);
    }
    for($s = 0; $s <= max($rf->{MAX_LATENCY}+1, $max_use); $s++) {
	# can't kill after commit point which is C3
	my $kill = "kill_C$s";
	my $value = 
	    $s == 1 ? "KillPipe_W | Kill_E" : 
	    $s <= $rf->{COMMIT_STAGE} ? "KillPipe_W" : 
	    "1'b0";
	print "    wire $kill = $value;\n"; 
    }
    print "\n";
    # FIXME: change the above for long latency. 
    #        Instead of assigning Kill to 1'b0, exclude the kill_C$s signal altogether.
    #        We may not want to do this since it could make code ugly throughout.


    ###########################################################################
    #  Write-port information
    ###########################################################################
    my %all_pkills;
    # find the min def stage among all slots (aka among all write pipelines)
    my $min_def_overall = 31;
    foreach $write_port (@{$rf->{WRITE_PORT}}) {
	$min_def_overall = ($write_port->{MIN_DEF} < $min_def_overall) ? $write_port->{MIN_DEF} : $min_def_overall;
    }

    foreach $write_port (@{$rf->{WRITE_PORT}}) {

	print "    // write enable pipeline for port $write_port->{NAME}\n";
	#For every stage between [min def of all regfile write ports] and  [write stage].
	foreach $s ($min_def_overall .. $write_port->{WRITE_STAGE}) {
	    my $ns_we = field("ns_we", $write_port, $s);
	    my $ns_def = field("ns_def$s", $write_port, $s);
	    my $we = field("we", $write_port, $s);
	    my $def = field("def$s", $write_port, $s);
	    my $wen = field("wen", $write_port, $s);
	    my $kill = "kill_C$s";
	    my $pkill = '';
	    my @pkills;
	    foreach my $wp (@{$rf->{WRITE_PORT}}) {
		next if ($wp == $write_port);
		my $max = $wp->{WRITE_STAGE};
		next unless ($s > $max &&
			     $wp->{WRITE_STAGE} < $write_port->{WRITE_STAGE});
		my $ns = field("ns_we", $wp, $max);
		my $addr0 = field('addr', $wp, $max);
		my $addr1 = field('addr', $write_port, $s);
		if ($rf->{ADDR_SIZE} > 0) {
		    push(@pkills, "(($addr0 == $addr1) & $ns)");
		} else {
		    push(@pkills, "($ns)");
		}
	    }

	    if (@pkills) {
		$pkill = field('ns_we_kill', $write_port, $s);
		print "    wire $pkill;\n";
		$all_pkills{$pkill} = join(' || ', @pkills);
		$pkill = ' && ~'.$pkill;
	    }
	    if ($s == $write_port->{MIN_DEF}) {
                print "    wire $ns_def;\n";
		print "    wire $ns_we = ${ns_def}$pkill;\n";
	    } elsif (write_def($write_port, $s)) {
                print "    wire $ns_def;\n";
		print "    wire $ns_we = ($we & ~$kill | $ns_def)$pkill;\n";
	    } else {
		# Only do the write enable pipeline for the actual defs in this slot
		if ($s >= $write_port->{MIN_DEF}) {
		print "    wire $ns_we = $we & ~${kill}$pkill;\n";
	        }
	    }
	    if ($s != $write_port->{WRITE_STAGE}) {
		my $we1 = field("we", $write_port, $s+1);
		# Only do the write enable pipeline for the actual defs in this slot
		if ($s >= $write_port->{MIN_DEF}) {
		print "    wire $we1;\n";
		#always reset flop, no sync reset
		write_xtdelay_g1($rf, 1, $ns_we, $we1, 1, 0);
		#print "    xtdelay1 #(1) i$we1($we1, $ns_we, clk);\n";
	        }
	    }
	}
	print "\n";

	# no longer needed
	# For the AR Regfile, port s0wr0, create a special write enable signal 
	# for the trace port.  This is similar to the s0wr0_ns_we_C<commit_stage> 
        # signal, except that it is not asserted for writes with a def in the
        # commit stage.  Such writes are not visible on the trace port for fear
	# of creating a timing path from the semantic through the regfile to the
	# traceport.
#	if (($rf->{NAME} eq 'TIE_Regfile_AR') && ($write_port->{NAME} eq 's0wr0')) {
#            my $wen  = "s0wr0_tport_we_C" . $rf->{COMMIT_STAGE};
#	    my $expr = "s0wr0_we_C" . $rf->{COMMIT_STAGE} . " & ~kill_C" . $rf->{COMMIT_STAGE};
#	    print "    // Write Enable signal for Traceport. \n";
#            print "    assign $wen = $expr; \n\n";
#        }
        
	foreach $i (@{$write_port->{DEF}}) {
	    print "    // write def$i pipeline for port $write_port->{NAME}\n";
	    for($s = 0; $s <= $i; $s++) {
		my $ns_def = field("ns_def$i", $write_port, $s);
		my $def = field("def$i", $write_port, $s);
		my $wen = field("wen", $write_port, $s);
		my $pkill = field('ns_we_kill', $write_port, $s);
		my $kill;
		if ($all_pkills{$pkill}) {
		    $kill = "~kill_C$s & ~$pkill";
		} else {
		    $kill = "~kill_C$s";
		}
		if ($s != $i) {
		    print "    wire $ns_def = $def & $wen & $kill;\n";
		    my $def1 = field("def$i", $write_port, $s+1);
		    print "    wire $def1;\n";
		    #always reset flop, no sync reset
		    write_xtdelay_g1($rf, 1, $ns_def, $def1, 1, 0);
		    #print "    xtdelay1 #(1) i$def1($def1, $ns_def, clk);\n";
		} else {
		    print "    assign $ns_def = $def & $wen & ~kill_C$s;\n";
		}
	    }
	    print "\n";
	}

	print "    // write clocks for port $write_port->{NAME}\n";
	foreach $s ($write_port->{MIN_DEF} .. $write_port->{WRITE_STAGE}) {
	    my $clk = func_gated_clock_name(field("we", $write_port, $s));
	    my $ns_we = field("ns_we", $write_port, $s);
	    if ($rf->{WORD_SIZE} > 3) {
		print "    wire $clk;\n";
		generate_func_gated_clock($rf, $clk, $ns_we, 0);#don't force reset
	    }
	}
	print "\n";

	if ($rf->{ADDR_SIZE} > 0) {
	    print "    // write address pipeline for port $write_port->{NAME} $write_port->{WRITE_STAGE}\n";
	    foreach $s (0 .. $write_port->{WRITE_STAGE}) {
		my $addr = field("addr", $write_port, $s);
		my $addr1 = field("addr", $write_port, $s+1);
		print "    wire $rf->{ADDR_DECL} $addr1;\n"; 
		if ($s == 0) {
		    my $ns_ae = field("ns_ae", $write_port, $s);
		    print "    wire $ns_ae = ";
		    print join(' | ', map(field("ns_def$_", $write_port, $s), @{$write_port->{DEF}}));
		    print ";\n";
		    #always reset flop, no sync reset
		    write_xtendelay_g1($rf, $rf->{ADDR_SIZE}, $addr, $addr1, $ns_ae, 1, 0);
		    #print "    xtendelay1 #($rf->{ADDR_SIZE}) i$addr1($addr1, $addr, $ns_ae, clk);\n";
		} else {
		    #always reset flop, no sync reset
		    write_xtdelay_g1($rf, $rf->{ADDR_SIZE}, $addr, $addr1, 1, 0);
		    #print "    xtdelay1 #($rf->{ADDR_SIZE}) i$addr1($addr1, $addr, clk);\n";
		}
	    }
	    print "\n";
	}

	print "    // write data pipeline for port $write_port->{NAME}\n";
	foreach $s ($write_port->{MIN_DEF} .. ($write_port->{WRITE_STAGE} - 1)) {
	    my $mux = field("mux", $write_port, $s);
	    my $result = field("result", $write_port, $s);
	    my $data = field("data", $write_port, $s);
	    my $sel = field("def$s", $write_port, $s);
	    if ($s == $write_port->{MIN_DEF}) {
		print "    wire $rf->{WORD_DECL} $mux = $data;\n";
	    } elsif (write_def($write_port, $s)) {
		print "    wire $rf->{WORD_DECL} $mux = $sel ? $data : $result;\n";
	    } else {
		print "    wire $rf->{WORD_DECL} $mux = $result;\n";
	    }
	    my $result1 = field("result", $write_port, $s+1);
	    my $clk = func_gated_clock_name(field("we", $write_port, $s));
	    print "    wire $rf->{WORD_DECL} $result1;\n";
	    if ($rf->{WORD_SIZE} > 3) {
		#reset flop if $rf->RESET_FLOPS, no sync reset
		write_xtdelay_g2($rf, $rf->{WORD_SIZE}, $mux, $result1, $clk, $rf->{RESET_FLOPS}, 0);
		#print "    xtdelay1 \#($rf->{WORD_SIZE}) i$result1($result1, $mux, $clk);\n";
	    } else {
		#reset flop if $rf->RESET_FLOPS, no sync reset
		my $ns_we = field("ns_we", $write_port, $s);
                write_xtendelay_g1($rf, $rf->{WORD_SIZE}, $mux, $result1, $ns_we, $rf->{RESET_FLOPS}, 0);
		#print "    xtendelay1 \#($rf->{WORD_SIZE}) i$result1($result1, $mux, $ns_we, clk);\n";
	    }
	}
	print "\n";
    }

    #For exported states, we generate an output "active", which is a OR 
    #of the write enable signals upto the end stage. This signal indicates
    # that there is a write to an exported state in the pipeline.
    if ( $rf->{EXPORT_READ_PORT} ) {
	$write_port = $rf->{WRITE_PORT}->[0];
	my $end  = $rf->{WRITE_PORT}->[0]->{MAX_DEF} + 1;
        print "    // active logic \n";
	foreach $s (1 .. $end ) {
	    my $active = field("active", $write_port, $s);
	    if ( $s < $write_port->{MIN_DEF} ) {
	        #the write enable pipeline has not started yet
		#so it is a OR of the def pipeline signal for this stage
	        print "    wire $active = 1'b0 ";
	        foreach $i (@{$write_port->{DEF}}) {
	            my $ns_def = field("ns_def$i", $write_port, $s);
		    print " | $ns_def ";    
		}
		print ";\n";
	    }else{
	        #the write enable signal OR'ed with the defs for later stages
	        my $ns_we = field("ns_we", $write_port, $s);
	        print "    wire $active = $ns_we ";
	        foreach $i (grep($_ > $s, @{$write_port->{DEF}})) {
	            my $ns_def = field("ns_def$i", $write_port, $s);
		    print " | $ns_def ";    
		}
		print ";\n";
	    }
	}
        print "    assign active = 1'b0 ";
	foreach $s (1 .. $end) {
	    my $active = field("active", $write_port, $s);
	    print " | $active ";
	}
	print ";\n";

        if ( $rf->{EXPORT_TRACE} ) {
	    my $active = field("active", $write_port, $end);
	    write_xtdelay_g1($rf, 1, $active, "export_valid", 1, 0);
	}
    }

    print "    // cross-port kills\n";
    foreach my $kill (sort keys %all_pkills) {
	print "    assign $kill = $all_pkills{$kill};\n";
    }




    ###########################################################################
    #  Read-port information
    ###########################################################################
    foreach $read_port (@{$rf->{READ_PORT}}) {
	my $read_stage = $read_port->{READ_STAGE};

	print "    // read use pipeline for port $read_port->{NAME}\n";
	foreach $i (@{$read_port->{USE}}) {
	    for($s = 0; $s < $i; $s++) {
		my $use = field("use$i", $read_port, $s);
		my $use1 = field("use$i", $read_port, $s+1);
		my $kill = "kill_C$s";
		print "    wire $use1;\n";
		#always reset flop, no sync reset
		write_xtdelay_g1($rf, 1, "$use & ~$kill", $use1, 1, 0);
		#print "    xtdelay1 #(1) i$use1($use1, $use & ~$kill, clk);\n";
	    }
	}
	print "\n";

	print "    // read pipeline clocks for port $read_port->{NAME}\n";
	for($s = 0; $s < $read_port->{MAX_USE}; $s++) {
	    my $use = field("use", $read_port, $s);
	    my $kill = "kill_C$s";
	    print "    wire $use = ~$kill & (1'b0";
	    foreach $i (@{$read_port->{USE}}) {
		if ($i > $s) {
		    my $usei = field("use$i", $read_port, $s);
		    print " | $usei";
		}
	    }
	    print ");\n";
	    my $clk = func_gated_clock_name(field("we", $read_port, $s));
	    if ($rf->{ADDR_SIZE} > 3 ||
		($s >= $read_port->{MIN_USE}-1 &&
		 ($rf->{ADDR_SIZE} + $rf->{WORD_SIZE} > 3))) {
		print "    wire $clk;\n";
		generate_func_gated_clock($rf, $clk, $use, 0);#don't force reset
	    }
	}
	print "\n";

	if ($rf->{ADDR_SIZE} > 0) {
	    print "    // read address pipeline for port $read_port->{NAME}\n";
	    for($s = 0; $s <= $read_port->{MAX_USE}-2; $s++) {
		my $addr = field("addr", $read_port, $s);
		my $addr1 = field("addr", $read_port, $s+1);
		my $clk = func_gated_clock_name(field("we", $read_port, $s));
		print "    wire $rf->{ADDR_DECL} $addr1;\n"; 
		if ($rf->{ADDR_SIZE} > 3 ||
		    ($s >= $read_port->{MIN_USE}-1 &&
		     ($rf->{ADDR_SIZE} + $rf->{WORD_SIZE} > 3))) {
		    #always reset flop, no sync reset
		    write_xtdelay_g2($rf, $rf->{ADDR_SIZE}, $addr, $addr1, $clk, 1, 0);
		    #print "    xtdelay1 \#($rf->{ADDR_SIZE}) i$addr1($addr1, $addr, $clk);\n";
		} else {
		    my $use = field("use", $read_port, $s);
		    #always reset flop, no sync reset
		    write_xtendelay_g1($rf, $rf->{ADDR_SIZE}, $addr, $addr1, $use, 1, 0);
		    #print "    xtendelay1 \#($rf->{ADDR_SIZE}) i$addr1($addr1, $addr, $use, clk);\n";
		}
	    }
	    print "\n";
	}

	if ($rf->{ADDR_SIZE} > 0) {
	    print "    // read/write address comparators\n";
	    my $max_use = max($read_port->{MAX_USE}-1, 0);
	    foreach $write_port (@{$rf->{WRITE_PORT}}) {
		for($rs = 0; $rs <= $max_use; $rs++) {
		    for($ws = 0; $ws <= $write_port->{WRITE_STAGE}; $ws++) {
			my $waddr = field("addr", $write_port, $ws);
			my $raddr = field("addr", $read_port, $rs);
			print "    wire eq_${raddr}_${waddr} = ($raddr == $waddr);\n";
		    }
		}
	    }
	    print "\n";
	}

$rs = <<DOCUMENTATION;
	Bypass logic generation is somewhat tricky.  For the first use
	(typically use1) the data comes from 

	    (a) write data coming from the datapath (wr0_data_Ci, i=1..n)
	    (b) data stored in the write pipeline (wr0_result_Cn, i=2..n+1)
	    (c) the register file (rd0_data_C0)

	For later uses (e.g., use 2) the data comes from 

	    (a) write data coming from the datapath (wr0_data_Ci, i=2..n)
	    (b) the read pipeline previous stage (rd0_data_C{i-1})
	    
	To avoid WAW hazards, there is a defined priority on this data.
	Consider a use 1,2,3,4 read pipe and a def 1,2,3,4 write pipe.  

	The priority order for use 1 is:  

	    wr0_data_C1, 
	    wr0_data_C2, 
	    wr0_result_C2, 
	    wr0_data_C3, 
	    wr0_result_C3, 
	    wr0_data_C4, 
	    wr0_result_C4, 
	    wr0_result_C5, 
	    register file.  
	    
	The priority order for use 2 is similar, except for all places where
	the write pipeline would be used, we use the previous stage read
	pipeline instead.  This is because the data stored in the write
	pipeline has already been bypassed into the read pipeline earlier.
	Hence, the unique sources are wr0_data_C2, wr0_data_C3, wr0_data_C4,
	rd0_data_C1 with a priority order of:

	    wr0_data_C1, 
	    wr0_data_C2, 
	    rd0_data_C1, 
	    wr0_data_C3, 
	    rd0_data_C1,
	    wr0_data_C4, 
	    rd0_data_C1, 
	    rd0_data_C1, 
	    rd0_data_C1.

	Because of all of the write pipeline data is available very early, we
	build a special mux for the first stage bypass.  We first mux together
	all of the stored data in the write pipe with the read data from the
	register file.  Then we mux together all of the data coming from the
	datapath.  Finally, we select between these two.
DOCUMENTATION

	if ($main::verify) {
	    my $rdata1 = field("data", $read_port, $read_stage);
	    print "    wire $rf->{WORD_DECL} $rdata1;\n";
	    for($rs = $read_stage; $rs <= $read_port->{MAX_USE}-1; $rs++) {
		my $rdata = field("data", $read_port, $rs);
		my $rdata1 = field("data", $read_port, $rs+1);
		if (! read_use($read_port, $rs+1)) {
		    print "    wire $rf->{WORD_DECL} $rdata1;\n";
		}
		write_xtdelay_g1($rf, $rf->{WORD_SIZE}, $rdata, $rdata1, 0, 0);
		#print "    xtdelay1 #($rf->{WORD_SIZE}) i$rdata1($rdata1, $rdata, clk);\n";
	    }
	    print "\n";
	} else {
	    print "    // read bypass controls for port $read_port->{NAME}\n";
	    my $max_use = &max($read_port->{MAX_USE}-1, 0);

	    # bypass the data being defined in stage $ws
	    for($rs = $read_stage; $rs <= $max_use; $rs++) {
		for($ws = $rs+1; $ws <= $rf->{MAX_LATENCY}+1; $ws++) {
		    foreach $write_port (@{$rf->{WRITE_PORT}}) {
			if (write_def($write_port, $ws)) {
			    my $waddr = field("addr", $write_port, $ws);
			    my $raddr = field("addr", $read_port, $rs);
			    my $def = field("def$ws", $write_port, $ws);
			    my $wen = field("wen", $write_port, $ws);
			    my $kill = "kill_C$ws";
			    my $pkill = field('ns_we_kill', $write_port, $ws);
			    $pkill = ($all_pkills{$pkill}) ?
				      "& ~$pkill" : '';
			    my $bypass = "bypass_data_$read_port->{NAME}_C$rs\_$write_port->{NAME}_C$ws";
			    if ($rf->{ADDR_SIZE} > 0) {
				print "    wire $bypass = eq_${raddr}_${waddr} & $def & $wen & ~$kill;\n";
			    } else {
				print "    wire $bypass = $def & $wen & ~$kill;\n";
			    }
			}
		    }
		}
	    }

	    # bypass the old data in the write pipeline in stage $ws
	    for($rs = $read_stage; $rs <= $max_use; $rs++) {
		for($ws = $rs+1; $ws <= $rf->{MAX_LATENCY}+1; $ws++) {
		    foreach $write_port (@{$rf->{WRITE_PORT}}) {
			if ($ws > $write_port->{MIN_DEF} &&
			    $ws <= $write_port->{WRITE_STAGE} &&
			    $rs <= $rf->{MAX_LATENCY}+1) {
			    my $waddr = field("addr", $write_port, $ws);
			    my $raddr = field("addr", $read_port, $rs);
			    my $we = field("we", $write_port, $ws);
			    my $kill = "kill_C$ws";
			    my $pkill = field('ns_we_kill', $write_port, $ws);
			    $pkill = ($all_pkills{$pkill}) ?
				      "& ~$pkill" : '';
			    my $bypass = "bypass_result_$read_port->{NAME}_C$rs\_$write_port->{NAME}_C$ws";
			    if ($rf->{ADDR_SIZE} > 0) {
				print "    wire $bypass = eq_${raddr}_${waddr} & $we & ~$kill;\n";
			    } else {
				print "    wire $bypass = $we & ~$kill;\n";
			    }
			}
		    }
		}
	    }
	    print "\n";

	    # during the read stage, bypass from the write pipelines
	    print "    // read early bypass for port $read_port->{NAME}\n";
	    $rs = $read_stage;
	    my(@data, @sel);
	    for($ws = $rs+1; $ws <= $rf->{MAX_LATENCY}+1; $ws++) {
		foreach $write_port (@{$rf->{WRITE_PORT}}) {
		    if ($ws > $write_port->{MIN_DEF} && $ws <= $write_port->{WRITE_STAGE}) {
			my $result = field("result", $write_port, $ws);
			my $bypass = "bypass_result_$read_port->{NAME}_C$rs\_$write_port->{NAME}_C$ws";
			push(@data, $result);
			push(@sel, $bypass);
		    }
		}
	    }
	    my $regfile = field("regfile", $read_port, $rs);
	    my $data = field("data", $read_port, $rs);
	    push(@data, $regfile);
	    print "    wire $rf->{WORD_DECL} $data, $regfile;\n"; 
	    inline_mux(\@data, \@sel, $rf->{WORD_SIZE}, $data, "priority");
	    print "\n";

	    for($rs = $read_stage; $rs <= $read_port->{MAX_USE}-1; $rs++) {
		print "    // read bypass for port $read_port->{NAME} use " . ($rs+1) . "\n";

		my(@data, @sel, $ncode, %code);
		my $mux = field("mux", $read_port, $rs);
		my $rdata = field("data", $read_port, $rs);
		$ncode = 0;
		$code{$rdata} = $ncode++;
		for($ws = $rs+1; $ws <= $rf->{MAX_LATENCY}+1; $ws++) {
		    foreach $write_port (@{$rf->{WRITE_PORT}}) {
			if ($rs <= $rf->{MAX_LATENCY}+1 &&
			    $ws <= $write_port->{WRITE_STAGE}) {
			    if (write_def($write_port, $ws)) {
				my $bypass = "bypass_data_$read_port->{NAME}_C$rs\_$write_port->{NAME}_C$ws";
				my $wdata = field("data", $write_port, $ws);
				$code{$wdata} = $ncode++;
				push(@data, $wdata);
				push(@sel, $bypass);
			    }
			    if ($ws > $write_port->{MIN_DEF}) {
				my $bypass = "bypass_result_$read_port->{NAME}_C$rs\_$write_port->{NAME}_C$ws";
				push(@data, $rdata);
				push(@sel, $bypass);
			    }
			}
		    }
		}
		push(@data, $rdata);

		print "    wire $rf->{WORD_DECL} $mux;\n"; 
		inline_mux(\@data, \@sel, $rf->{WORD_SIZE}, $mux, "priority", \%code);
		my $rdata1 = field("data", $read_port, $rs+1);
		if (! read_use($read_port, $rs+1)) {
		    print "    wire $rf->{WORD_DECL} $rdata1;\n";
		}
		if ($rf->{ADDR_SIZE} + $rf->{WORD_SIZE} > 3) {
		    my $clk = func_gated_clock_name(field("we", $read_port, $rs));
		    #reset flop if $rf->RESET_FLOPS, no sync reset
		    write_xtdelay_g2($rf, $rf->{WORD_SIZE}, $mux, $rdata1, $clk, $rf->{RESET_FLOPS}, 0);
		    #print "    xtdelay1 \#($rf->{WORD_SIZE}) i$rdata1($rdata1, $mux, $clk);\n";
		} else {
		    my $en = field("use", $read_port, $rs);
		    #reset flop if $rf->RESET_FLOPS, no sync reset
		    write_xtendelay_g1($rf, $rf->{WORD_SIZE}, $mux, $rdata1, $en, $rf->{RESET_FLOPS}, 0);
		    #print "    xtendelay1 \#($rf->{WORD_SIZE}) i$rdata1($rdata1, $mux, $en, clk);\n";
		}
		print "\n";
	    }
	}
    }

    foreach $write_port (@{$rf->{WRITE_PORT}}) {
	foreach $read_port (@{$rf->{READ_PORT}}) {
	    print "    wire stall_$write_port->{NAME}_$read_port->{NAME};\n";
	    print "    assign stall_$write_port->{NAME}_$read_port->{NAME} = \n";
	    foreach $rs (@{$read_port->{USE}}) {
		foreach $ws (@{$write_port->{DEF}}) {
		    foreach $i (1 .. ($rs == 0 ? $ws : $ws-1)) {
			if ($ws - $i >= $rs) {
			    my $waddr = field("addr", $write_port, $i);
			    my $ns_def = field("ns_def$ws", $write_port, $i);
			    my $raddr = field("addr", $read_port, 0);
			    my $use = field("use$rs", $read_port, 0);
			    if ($rf->{ADDR_SIZE} > 0) {
				print "        (eq_${raddr}_${waddr} & $use & $ns_def) |\n";
			    } else {
				print "        ($use & $ns_def) |\n";
			    }
			}
		    }
		}
	    }
	    print "        1'b0;\n";
	}
    }
    print "    assign Stall_R =\n";
    foreach $write_port (@{$rf->{WRITE_PORT}}) {
	foreach $read_port (@{$rf->{READ_PORT}}) {
	    print "    stall_$write_port->{NAME}_$read_port->{NAME} |\n";
	}
    }
    print "        1'b0;\n";
    print "\n";

    ###########################################################################
    #  Drop the core-cell
    ###########################################################################
    if ($main::verify) {
	print "    // verification register file replacement\n";
	my $last;
	foreach $write_port (@{$rf->{WRITE_PORT}}) {
	    my $write_stage = $write_port->{WRITE_STAGE};
	    my $data = field("result", $write_port, $write_stage);
	    my $ns_we = field("ns_we", $write_port, $write_stage);
	    my $tmp = "$write_port->{NAME}_verify";
	    print "    wire $rf->{WORD_DECL} x$tmp;\n";
	    print "    xtenflop #($rf->{WORD_SIZE}) $tmp(x$tmp, $data, $ns_we, clk);\n";
	    $last = $tmp;
	}
	foreach $read_port (@{$rf->{READ_PORT}}) {
	    my $read_stage = $read_port->{READ_STAGE};
	    my $tmp = "$read_port->{NAME}_verify";
	    my $data = field("data", $read_port, $read_stage);
	    my $cell = @{$rf->{READ_PORT}} > 1 ? "xtflop" : "xtdelay1";
	    print "    $cell #($rf->{WORD_SIZE}) $tmp($data, x$last, clk);\n";
	}
	if ($rf->{EXCEPTION_READ_PORT}) {
	    $read_port = $rf->{READ_PORT}->[0];
	    my $read_stage = $read_port->{READ_STAGE};
	    my $exc_read = "exception_read";
	    my $data = field("data", $read_port, $read_stage);
	    print "    assign $exc_read = $data;\n";
	}
	if ($rf->{EXPORT_READ_PORT}) {
	    $read_port = $rf->{READ_PORT}->[0];
	    my $read_stage = $read_port->{READ_STAGE};
	    my $exp_read = "export_read";
	    my $data = field("data", $read_port, $read_stage);
	    print "    assign $exp_read = $data;\n";
            if ( $rf->{EXPORT_TRACE} ) {
	        my $active = field("active", $write_port, $read_stage);
	        print "xtflop #1 iexport_valid(export_valid, $active, clk);\n";
	    }
	}
    } else {
	print "    // register file core\n";
	my $r = @{$rf->{READ_PORT}};
	my $w = @{$rf->{WRITE_PORT}};
	my $n = $rf->{MIN_HEIGHT};
	my $arch_copy;

	if ($rf->{SYNC_RESET}) {
	    $read_port = $rf->{READ_PORT}->[0];
	    $write_port = $rf->{WRITE_PORT}->[0];
	    my $read_stage = $read_port->{READ_STAGE};
	    my $write_stage = $write_port->{WRITE_STAGE};
	    my $module = "xtregfile_$rf->{DESIGN_PREFIX}_$rf->{NAME}_xt${async}scenflop";
	    my $out = field("regfile", $read_port, $read_stage);
	    my $in = field("result", $write_port, $write_stage);
	    my $ns_we = field("ns_we", $write_port, $write_stage);
	    print "    $module #($rf->{WORD_SIZE}) icore($out, $in, $ns_we, ~Reset, GlobalStall, clk);\n";
	    $arch_copy = $out;
	} else {
	    init_print_break(8);
	    $arch_copy = field("regfile", $rf->{READ_PORT}->[0], 
	    			$rf->{READ_PORT}->[0]->{READ_STAGE});
	    my $module =  ($rf->{WINDOWED}) ?
	    "xtwregfile_$rf->{WINDOW_SIZE}D$rf->{WINDOW_NUM}N_${r}R${w}W_${n}_$rf->{WORD_SIZE}_XT$rf->{DESIGN_PREFIX}"
	    :"xtregfile_${r}R${w}W_${n}_$rf->{WORD_SIZE}_XT$rf->{DESIGN_PREFIX}";
	    print_break("    $module icore(");
	    foreach $read_port (@{$rf->{READ_PORT}}) {
		my $read_stage = $read_port->{READ_STAGE};
		my $data = field("regfile", $read_port, $read_stage);
		print_break("$data, ");
		if ($rf->{ADDR_SIZE} > 0) {
		    my $addr = field("addr", $read_port, $read_stage);
		    print_break("$addr, ");
		}
	    }
	    foreach $write_port (@{$rf->{WRITE_PORT}}) {
		my $write_stage = $write_port->{WRITE_STAGE};
		my $result = field("result", $write_port, $write_stage);
		print_break("$result, ");
		if ($rf->{ADDR_SIZE} > 0) {
		    my $addr = field("addr", $write_port, $write_stage);
		    print_break("$addr, ");
		}
		my $ns_we = field("ns_we", $write_port, $write_stage);
		print_break("$ns_we, ");
	    }
	    if ($rf->{USE_TMODE}) {
		print_break("TMode, ");
	    }
	    if ($rf->{WINDOWED}) {
		print_break("WinBase, ");
	    }
	    if ($rf->{RESET_FLOPS}) {
		print_break("Reset, ");
	    }
	    print_break("clk);\n");
	}

        if ($rf->{EXPORT_READ_PORT}) {
	    my $max_def_stage = $rf->{WRITE_PORT}->[0]->{WRITE_STAGE};
	    my $export_stage  = $rf->{EXPORT_READ_PORT};
	    my $exp_read = "export_read";
	    print "    // export read port :  $max_def_stage + 1\n";
	    if ( $export_stage > $max_def_stage ) {
               my $module = "xt".(($rf->{RESET_FLOPS})? $async."sc" : "").((!$rf->{CLK_GATE_GLOBAL})?"en":"")."delay";
                my $xten = (!$rf->{CLK_GATE_GLOBAL})?'!GlobalStall,':'';
                my $clrb = ($rf->{RESET_FLOPS})?'!Reset,':'';
	        printf "   %s%d #(%d) i$exp_read($exp_read, $arch_copy, $xten $clrb clk);\n",
	        $module, ($export_stage-$max_def_stage), $rf->{WORD_SIZE};
	    } else { 
	        print "    assign $exp_read = $arch_copy;\n";
	    }
        }
    }

    print "endmodule\n";

    # trying hard to make the instance-name of the state the same
    if ($rf->{SYNC_RESET}) {
	my $module = "xtregfile_$rf->{DESIGN_PREFIX}_$rf->{NAME}_xt${async}scenflop";
	my $ival = ($rf->{RESET_VALUE}) ? $rf->{RESET_VALUE} :
	    ("{size{1'b0}}");
	my $enable = $rf->{CLK_GATE_GLOBAL} ? "en" : "en & ~GlobalStall";
	my $flop_name = $rf->{ASYNC_RESET_FLOPS} ? "xtassenflop" : "xtssenflop";
	print <<FILLER;


module $module(xtout, xtin, en, setb, GlobalStall, clk);
parameter size = 32; // vhdl generic
output [size-1:0] xtout;
input [size-1:0] xtin;
input en, setb, GlobalStall, clk;
wire [size-1:0] word0;
wire [size-1:0] wr0_data;
wire [size-1:0] ival;
wire word0_we = en;
    assign ival = $ival;
    assign xtout = word0;
    assign wr0_data = xtin;
    xt${async}ssenflop #(size) iword0(word0, xtin, $enable, setb, ival, clk);
endmodule
FILLER
    }
} # write_regfile_bank

my $doc = <<'EOF';
*******************************************************************************
Special case state.  Returns 0 if the special conditions do not apply.

This emulates the Athens 1.5 "TIE" state.

It works only for the case of one write port, and one word (i.e., typical case
for a state register).  Also, it works only when the maximum use isn't more        #'
than the maximum def (or the commit point).  We could relax this condition, but
it requires that we pipeline the last def stage "use" value down to the
required use.  e.g., consider the case of a use 0,6 def 3 state.  The use 6
would come from the normal use 3 stage, pipelined with 3 registers.  Besides, I
think there is a fundamental bug for def > 4 anyway.

The architecture has only a write pipeline.  This pipeline starts in the first
def stage (with the pipeline register named result_C($start+1) and ends in the
last def stage (with the committed state register named result_C($end+1).

For the first stage, the bypass is a priority mux selected from the committed
state value (the last def stage) on a KillPipe_W, the returning write data, or
the register is not written (i.e., a hold).

The middle stage bypass is a priority mux selected from the returning write
data, or the preceding stage data.  (The middle stages do not have to be reset
on a KillPipe_W).

The final stage bypass is a priority mux selected from the committed state
value on a KillPipe_W, the returning write data, or the preceding stage data.

For all use which occur before the first def stage, the first def stage
provides the correct data.  Otherwise, the corresponding stage of the write
pipeline also provides the correct use data.

A special "enable flop" optimization is performed to handle the conditions
where the first or last stage flop needs a hold.  This reduces the mux size by
pushing the hold into the enable flop.

Selecting which def$j write data should be bypassed onto the stage $i mux is
somewhat involved.  To avoid WAW hazards, the bypass occurs only when there is
no completed write in stages $k for $i <= $k <= $j.

Examining some special cases shows the advantage of this scheme.

For a use 0123, def 3 state, only a single enable flop is required.  There are
no bypass muxes.  The enable flop (result_C4) is the committed state and
provides the correct data for all use stages.

For a use 0123, def 2 state, two enable flops and one 2:1 bypass mux is
required.  The first enable flop (result_C3) is written with either the
committed state value (on a KillPipe_W), the def 2 data, or is held.  The
second register (result_C4) is written by the result_C3 register or is held on
a KillPipe_W.  The cost is the same regardless of which subset of uses are
required.

For a use 0123, def 1 state register, two enable flops, one regular flop, and
one 2:1 bypass mux is required.  The first enable flop (result_C2) is written
with the committed state value or the def 1 data.  The second regular flop
(result_C3) is written by the first enable flop.  The third enable flop
(result_C4) holds the committed state value, and is written by the result_C3
register, or is held on a KillPipe_W.  The cost is the same regardless of which
subset of uses are required.

Note that the cost is the same regardless of which subset of uses are required
(i.e., a use 3 def 3 state has the same cost as a use 0123 def 3 state
register).  Extra def values do cost more as an extra mux bypass input is
required for all stages from the first up to the def stage.

For example, a use 0123 def 123 costs two enable flops, one regular flop, two
4:1 bypass muxes (in stages 0 and 1), a 3:1 mux in stage 2, and a 2:1 mux in
stage 3.

The invariant maintained in the pipeline is that the pipeline register
result_C($i+1) holds the correct state value for the instruction which is
currently in stage $i.  This argues as to why it is proper to feed this value
to any use which occurs in stage $i.  To maintain this invariant, data flows
backwards up the pipeline when a new state value is written, but does not flow
past a def already in the pipeline.

*******************************************************************************
EOF

sub write_state_bank {
    my($rf) = @_;
    my(@iolist, $s, $rs, $ws, $i, $j, $k, $read_port, $write_port);
    my $async = $rf->{ASYNC_RESET_FLOPS} ? "a" : "";

    # NOTE:
    # If another condition for returning is added here,
    # (for example if you wanted to implement more things as regfile
    # and not as cheap state),
    # then some other files may also need changed that also have
    # functions that report if something is regfile or cheap state:
    # 1. Xtensa/Hardware/Barcelona/Verification/common/VeraSignals.pm
    #    subroutine "isCheapState"
    # 2. Xtensa/Hardware/Barcelona/Verification/common/XtensaInfo.pm
    #    subroutine "isCheapState"
    #    (this code is a duplicate of item 1 above.)
    # 3. Xtensa/share/TargetISA/State.pm
    #    subroutine "isRegFile"

    return 0 if @{$rf->{WRITE_PORT}} != 1;
    return 0 if $rf->{ADDR_SIZE} != 0;
    return 0 if $main::verify;

    my $debug = 0;
    print STDERR "DEBUG: write_state_bank...  $rf->{NAME}\n" if ($debug);

    my $maxuse = 0;
    foreach $read_port (@{$rf->{READ_PORT}}) {
	$maxuse = max($maxuse, @{$read_port->{USE}});
    }
    $write_port = $rf->{WRITE_PORT}->[0];
    my $start = min(@{$write_port->{DEF}});
    my $end = max($rf->{COMMIT_STAGE}, @{$write_port->{DEF}});
    return 0 if $maxuse > $end;
    return 0 if $end > $rf->{COMMIT_STAGE};	
    # For now, go to register file implementation if latest def is
    # after commit stage.  
    # For state implementation, the end will never be more than commit stage.
    # We could do cheapstate implementation even if last def is after commit stage.
    # TODO FIXME Do we want to do this?  Examine this in future.

    # Is this a state that should have the intermediate staged values
    # of the state be instantly updated on the cycle after a KillPipe_W?
    # Otherwise, the values in the middle of the pipeline are invalid
    # for a cycle or two.  This update of intermediate values (which
    # are not the start and not the architectural copy) is only done
    # for core signals that are exported from TIE to Xtensa core.
    my $updateOnExc = $rf->{UPDATE_ON_EXCEPTION};

    init_print_break(0);
    print_break("module $rf->{DESIGN_PREFIX}$rf->{NAME}_bank(");

    # special case for exception-state: export committed state
    if ($rf->{EXCEPTION_READ_PORT}) {
	my $exc_read = "exception_read";
	print_break("$exc_read, ");
	push(@iolist, "    output $rf->{WORD_DECL} $exc_read;\n");
    }
    if ($rf->{EXCEPTION_WRITE_PORT}) {
	my $exc_write = "exception_write";
	print_break("$exc_write, ");
	push(@iolist, "    input $rf->{WORD_DECL} $exc_write;\n");
	my $exc_we = "exception_we";
	print_break("$exc_we, ");
	push(@iolist, "    input $exc_we;\n");
    }
    # special case for export state
    if ($rf->{EXPORT_READ_PORT}) {
	my $exp_read = "export_read";
	print_break("$exp_read, ");
	print_break("active, ");
	push(@iolist, "    output $rf->{WORD_DECL} $exp_read;\n");
	push(@iolist, "    output active;\n");
	if ( $rf->{EXPORT_TRACE} ) {
	    print_break("export_valid, ");
	    push(@iolist, "    output export_valid;\n");
	}
    }

    # read port I/O list
    foreach $read_port (@{$rf->{READ_PORT}}) {
	foreach $s (@{$read_port->{USE}}) {
	    my $data = field("data", $read_port, $s);
	    print_break("$data, ");
	    push(@iolist, "    output $rf->{WORD_DECL} $data;\n");
	}
	foreach $s (@{$read_port->{USE}}) {
	    my $use = field("use$s", $read_port, 0);
	    print_break("$use, ");
	    push(@iolist, "    input $use;\n");
	}
    }

    # write port I/O list
    foreach $write_port (@{$rf->{WRITE_PORT}}) {
	foreach $s (@{$write_port->{DEF}}) {
	    my $data = field("data", $write_port, $s);
	    print_break("$data, ");
	    push(@iolist, "    input $rf->{WORD_DECL} $data;\n");
	}
	foreach $s (@{$write_port->{DEF}}) {
	    my $def = field("def$s", $write_port, 0);
	    print_break("$def, ");
	    push(@iolist, "    input $def;\n");
	}
	my $first_wen = min(1, $write_port->{MIN_DEF});
	my $last_wen = max(@{$write_port->{DEF}});
	foreach $s ($first_wen .. $last_wen) {
	    my $wen = field("wen", $write_port, $s);
	    print_break("$wen, ");
	    push(@iolist, "    input $wen;\n");
	}
    }


    print_break("Kill_E, ");
    push(@iolist, "    input Kill_E;\n");

    print_break("KillPipe_W, ");
    push(@iolist, "    input KillPipe_W;\n");

    print_break("Valid_W, ");
    push(@iolist, "    input Valid_W;\n");

    print_break("Stall_R, ");
    push(@iolist, "    output Stall_R;\n");

    if ($rf->{USE_TMODE}) {
	print_break("TMode, ");
	push(@iolist, "    input TMode;\n");
    }

    print_break("Reset, ");
    push(@iolist, "    input Reset;\n");

    print_break("GlobalStall,  ");
    push(@iolist, "    input GlobalStall;\n");
    print_break("clk);\n");
    push(@iolist, "    input clk;\n");

    print join('', @iolist);
    print "\n";

    # define a wen_C0 if there is no def 0
    foreach $write_port (@{$rf->{WRITE_PORT}}) {
	if (! write_def($write_port, 0)) {
	    my $wen = field("wen", $write_port, 0);
	    print "    wire $wen = 1'd1;\n";
	    print "\n";
	}
    }

    print "    // per stage Kill signals\n";
    for($s = 0; $s <= $rf->{MAX_LATENCY}+1; $s++) {
	# can't kill after commit point which is C3
	my $kill = "kill_C$s";
	my $value = 
	    $s == 0 ? "KillPipe_W" :
	    $s == 1 ? "KillPipe_W | Kill_E" : 
	    $s <= $rf->{COMMIT_STAGE} ? "KillPipe_W" : 
	    "1'b0";
	print "    wire $kill = $value;\n"; 
    }
    print "\n";

    #keep track of def pipe signals and we signals
    my @def_pipeline;
    my @we_pipeline;
    foreach $write_port (@{$rf->{WRITE_PORT}}) {
	foreach $i (@{$write_port->{DEF}}) {
	    print "    // write def$i pipeline\n";
	    for($s = 0; $s <= $i; $s++) {
		my $ns_def = field("ns_def$i", $write_port, $s);
		my $def = field("def$i", $write_port, $s);
		my $wen = field("wen", $write_port, $s);
		my $kill = "kill_C$s";
		print "    wire $ns_def = $def & $wen & ~$kill;\n";
		push(@def_pipeline, $ns_def);
		if ($s != $i || $s == 0) {
		    my $def1 = field("def$i", $write_port, $s+1);
		    print "    wire $def1;\n";
		    #always reset flop, no sync reset
		    write_xtdelay_g1($rf, 1, $ns_def, $def1, 1, 0);
		    #print "    xtdelay1 #(1) i$def1($def1, $ns_def, clk);\n";
		}
	    }
	    print "\n";
	}

	print "    // write enable pipeline\n";
	foreach $s ($write_port->{MIN_DEF} .. $end-1) {
	    my $ns_we = field("ns_we", $write_port, $s);
	    my $ns_def = field("ns_def$s", $write_port, $s);
	    my $we = field("we", $write_port, $s);
	    my $def = field("def$s", $write_port, $s);
	    my $wen = field("wen", $write_port, $s);
	    my $kill = "kill_C$s";
	    if ($s == $write_port->{MIN_DEF}) {
		print "    wire $ns_we = $ns_def;\n";
	    } elsif (write_def($write_port, $s)) {
		print "    wire $ns_we = $we & ~$kill | $ns_def;\n";
	    } else {
		print "    wire $ns_we = $we & ~$kill;\n";
	    }
	    push(@we_pipeline, $ns_we);
	    if ($s != $end-1) {
		my $we1 = field("we", $write_port, $s+1);
		print "    wire $we1;\n";
		#always reset flop, no sync reset
		write_xtdelay_g1($rf, 1, $ns_we, $we1, 1, 0);
	        push(@we_pipeline, $we1);
		#print "    xtdelay1 #(1) i$we1($we1, $ns_we, clk);\n";
	    }
	}
	print "\n";
    }

    #For exported states, we generate an output "active", which is a OR 
    #of the write enable signals upto the end stage. This signal indicates
    # that there is a write to an exported state in the pipeline.
    if ( $rf->{EXPORT_READ_PORT} ) {
	$write_port = $rf->{WRITE_PORT}->[0];
        print "    // active logic \n";
	foreach $s (1 .. $end ) {
	    my $active = field("active", $write_port, $s);
	    if ( $s < $write_port->{MIN_DEF} ) {
	        #the write enable pipeline has not started yet
		#so it is a OR of the def pipeline signal for this stage
	        print "    wire $active = 1'b0 ";
	        foreach $i (@{$write_port->{DEF}}) {
	            my $ns_def = field("ns_def$i", $write_port, $s);
		    print " | $ns_def " if ( grep($_ eq $ns_def, @def_pipeline) );;    
		}
		print ";\n";
	    } elsif ( $s == $end ) {
	        my $we1 = field("we", $write_port, $s);
	        my $we0 = field("ns_we", $write_port, $s-1);
	        my $ns_def = field("ns_def$s", $write_port, $s);
		if ( grep($_ eq $we0, @we_pipeline) ) {
		    print "    wire $we1;\n";
		    #always reset flop, no sync reset
		    write_xtdelay_g1($rf, 1, $we0, $we1, 1, 0);
	            print "    wire $active = $we1 & ~kill_C$s ";
		} else {
	            print "    wire $active = 1'b0 ";
		}
		print " | $ns_def " if (grep($_ == $end, @{$write_port->{DEF}}));
		print ";\n";
	    }else{
	        #the write enable signal OR'ed with the defs for later stages
	        my $ns_we = field("ns_we", $write_port, $s);
		if ( grep($_ eq $ns_we, @we_pipeline) ) {
	            print "    wire $active = $ns_we ";
		} else {
	            print "    wire $active = 1'b0 ";
		}
	        foreach $i (grep($_ > $s, @{$write_port->{DEF}})) {
	            my $ns_def = field("ns_def$i", $write_port, $s);
		    print " | $ns_def ";    
		}
		print ";\n";
	    }
	}
        print "    assign active = 1'b0 ";
	foreach $s (1 .. $end) {
	    my $active = field("active", $write_port, $s);
	    print " | $active ";
	}
	print ";\n";

        if ( $rf->{EXPORT_TRACE} ) {
	    my $active = field("active", $write_port, $end);
	    write_xtdelay_g1($rf, 1, $active, "export_valid", 1, 0);
	}
    }

    print "    // stall logic\n";
    print "    assign Stall_R = ";
    my @stall;
    foreach $write_port (@{$rf->{WRITE_PORT}}) {
	foreach $read_port (@{$rf->{READ_PORT}}) {
	    foreach $rs (@{$read_port->{USE}}) {
		foreach $ws (@{$write_port->{DEF}}) {
		    foreach $i (1 .. ($rs == 0 ? $ws : $ws-1)) {
			if ($ws - $i >= $rs) {
			    my $ns_def = field("ns_def$ws", $write_port, $i);
			    my $use = field("use$rs", $read_port, 0);
			    push(@stall, "($use & $ns_def)");
			}
		    }
		}
	    }
	}
    }
    if (@stall == 0) {
	print "1'b0;\n";
    } else {
	print join(" | ", @stall) . ";\n";
    }
    print "\n";

    # now we know there is only one write port
    $write_port = $rf->{WRITE_PORT}->[0];
    my $result = field("result", $write_port, $end+1);
    print "    // forward declaration\n";
    print "    wire $rf->{WORD_DECL} $result;\n";
    if ($start == 0) {
	my $result = field("result", $write_port, 2);
	print "    wire $rf->{WORD_DECL} $result;\n";
	print "    wire killPipe_X;\n";
        my $module = "xt";
        $module .= $rf->{RESET_FLOPS} ? ($async."sc") : "";
        $module .= "en" if !$rf->{CLK_GATE_GLOBAL};
        $module .= "delay1";
        my $clrb = ($rf->{RESET_FLOPS})?"!Reset, ":"";
        my $xten = (!$rf->{CLK_GATE_GLOBAL})?"!GlobalStall, ":"";
        print "    $module #(1) kpx(killPipe_X, KillPipe_W, $xten $clrb clk);\n";
    }
    print "\n";

    # begin bypass for stage $s
    for($s = $start; $s <= $end; $s++) {
	print "    // bypass for stage $s\n";
	my(@data, @sel);

	# 1. need to restore on exception write
	# 2. Force an exception write into the mux for stage 1, if this state
	#    has a def 0.  We are later going to add a "feedback" to restore C2
	#    into stage 0 on Kill_E.  In the case of an exception, this will
	#    ensure that the feedback value is the exception value, and not a
	#    "stale" value.
	# 3. Or, for intermediate stages that should be updated on
	#    exception, also need to write on an exception,
	#    instead of waiting for correct value to flow through pipeline.

	if ( ($s == $start || $s == $end) ||                    # 1.
	     ($s == 1 && $start == 0)     ||                    # 2.
	     ($updateOnExc && $s != $start && $s != $end) ) {   # 3.
	    if ($rf->{EXCEPTION_WRITE_PORT}) {
		my $exc_write = "exception_write";
		my $exc_we = "exception_we";
		push(@data, $exc_write);
		push(@sel, $exc_we);
	    }
	}

	# bypass returning write data for all def stages at $s and beyond
	for($j = $s; $j <= $end; $j++) {
	    if (write_def($write_port, $j)) {
		my(@qualify);
		my $data = field("data", $write_port, $j);
		my $ns_def = field("ns_def$j", $write_port, $j);
		push(@qualify, $ns_def);
		for($k = $s; $k < $j; $k++) {
		    my $ns_we = field("ns_we", $write_port, $k);
		    push(@qualify, "~$ns_we");
		}
		my $sel = join("&", @qualify);
		push(@data, $data);
		push(@sel, $sel);
	    }
	}

	# for first stage need to restore on a KillPipe_W
	# Or, for intermediate stages that should be updated on
	# exception, also need to restore on a KillPipe_W,
	# instead of waiting for correct value to flow through pipeline.
	if ( ($s == $start && $start != $end) ||
	     ($updateOnExc && $s != $start && $s != $end) ) {
	    my $result = field("result", $write_port, $end+1);
	    my $sel = "KillPipe_W";
	    push(@data, $result);
	    push(@sel, $sel);
	}

	# for stage 0 (specifically!) need to restore C2 data on Kill_E
	if ($s == 0) {
	    my $result = field("result", $write_port, 2);
	    my $def = field("def0", $write_port, 1);
	    my $sel = "Kill_E";
	    push(@data, $result);
	    push(@sel, $sel);
	}

	# for stage 1 (specifically!) need a hold on Kill_E if there is
	# a stage 0
	# Note: On the select:
	# 1. UpdateOnExc = 0
	#    The Select for the Kill_E hold value is Kill_E&~killPipe_X.
	#    if no updateOnExc.  This is because if there was a
	#    KillPipe_W on the last cycle, it would only have updated stage 0's
	#    flop and not stage 1's flop (unless stage 1 is also the end stage).  
	#    So, we cannot hold the value in stage 1's flop, but must
	#    instead allow the previous stage's value to propagate.
	# 2. UpdateOnExc = 1
	#    The Select for the Kill_E hold value is Kill_E alone 
	#    if updateOnExc.  This is because if there was a 
	#    KillPipe_W on the last cycle, the value of stage 1's flop 
	#    would have been updated by its own mux input and KillPipe_W
	#    select, so it is now okay to just hold the value in stage
	#    1's flop (ns_result_C2) on Kill_E.

	if ($s == 1 && $start == 0) {
	    my $result = field("result", $write_port, 2);
	    my $sel;
	    if ($updateOnExc) {
	        $sel = "Kill_E";
	    } else {
	        $sel = "Kill_E&~killPipe_X";
	    }
	    push(@data, $result);
	    push(@sel, $sel);
	}

	# for last stage need to hold data on a KillPipe_W or ~Valid_W
	if ($s == $end && $start != $rf->{COMMIT_STAGE}
	    && $end != $start) {
	    my $result = field("result", $write_port, $end+1);
	    my $sel = "KillPipe_W || ~Valid_W";
	    push(@data, $result);
	    push(@sel, $sel);
	}

	# default value if there are no writes
	if ($s == $start) {
	    my $result = field("result", $write_port, $s+1);
	    push(@data, $result);
	} else {
	    my $result = field("result", $write_port, $s);
	    push(@data, $result);
	}

	my $mux = field("mux", $write_port, $s);
	my $result1 = field("result", $write_port, $s+1); # corresponds to removed mux entry for hold data
	my $result2 = field("result", $write_port, $s);   # corresponds to mux entry from previous stage data

	# Enable flops
	print STDERR "DEBUG: Enable flop optimizations...\n" if ($debug);
	print "    wire $rf->{WORD_DECL} $mux;\n"; 

	print STDERR "result1 is $result1.\n" if ($debug);
	my $cnt;
	for ($cnt=0; $cnt<@data; $cnt++) { print STDERR "data[$cnt] is $data[$cnt] \n" if ($debug); }

	# Enable signal optimizations if possible for hold conditions
	my $enable_flop_reorder = grep($_ eq $result1, @data);
	    my($d, %code);
	    my $n = @data;

	  if ($enable_flop_reorder) {
	    # assign binary codes so that $result1 is the largest code
	    # There is a mux with several inputs, and this mux result
	    # is flopped.  To save an input to the mux, we simply do not
	    # enable the flop for the case when we would have selected
	    # the mux input to be the flop output.  For the cases of
	    # enable_flop_reorder, this will be called the "hold data".  
	    my $code = 0;
	    foreach $d (@data) {
		$code{$d} = $d eq $result1 ? $n-1 : $code++;
	    }
	  } else {
	    # assign binary codes in order
	    my $code = 0;
	    foreach $d (@data) {
		$code{$d} = $code++;
	    }
	  }

	    # priority encoding tree
	    my $mux_sel = field("mux_sel", $write_port, $s);
	    if ($n > 1) {
		print "    wire [" . (ceil_log2($n)-1) . ":0] $mux_sel =\n";
	    } elsif ($n == 1) { 
		print "    wire $mux_sel =\n";
	    } else {
		print STDERR "Error: Unexpected n value of <1.\n";
	    }
	    for($i = 0; $i < $n-1; $i++) {
		my $const = ceil_log2($n) . "'d" . $code{$data[$i]};
		print "        $sel[$i] ? $const :\n";
	    }
	    my $nonzero_ceil_log2 = ($n == 1) ? 1 : ceil_log2($n) ;
	    my $const = $nonzero_ceil_log2 . "'d" . $code{$data[$n-1]};
	    print "        $const;\n";

	  if ($enable_flop_reorder) {
	    # 1. for the case of start stage,
	    #    special enable signal is anything but the last code.
	    # 2. for the case of the other stages,
	    #    special enable signal is anything but the last or
	    #    second-to-last codes (last code selects the hold data.  
	    #    second-to-last code selects previous stage data), 
	    #    OR the second-to-last code and the preceding stage
	    #    enable was true on the previous cycle.
	    #    This way, we only flop previous stage data if it actually changed.  
	    if ($s == $start) {
		$const = ceil_log2($n) . "'d" . $code{$result1};
		print "    wire en_C$s = $mux_sel != $const;\n";
	    } else {
		my $sm1 = $s - 1;
		print "    wire en_C$sm1"."_delay;\n";
		#always reset flop, no sync reset
		write_xtdelay_g1($rf, 1, "en_C$sm1", "en_C$sm1"."_delay", 1, 0);
		$const = ceil_log2($n) . "'d" . $code{$result1};  # $code{$result1} is set to $n-1,
		                                                  # corresponds to removed mux entry for hold data
		my $constm1 = ceil_log2($n) . "'d" . $code{$result2}; # corresponds to mux entry from previous stage data

		if ($n < 2) {
		    print STDERR "Error: Unexpected n value of <2.\n";
		    # Note, we do not expect to get here, but this code is for error checking.
		    # Since enable_flop_reorder is true, there must be 2 or more inputs to the mux, 
		    # the hold data (which is definitely a mux input because enable_flop_reorder is true) 
		    # and the previous stage data (which is definitely
		    # a mux input because this is not the start stage.)
		} elsif ($n == 2) {
		    print "    wire en_C$s = ( $mux_sel == $constm1 && en_C$sm1"."_delay) ;\n"; 
	        } else {
		    print "    wire en_C$s = ( $mux_sel != $const && $mux_sel != $constm1\n".
                    	  "                         || \n".
                    	  "                    $mux_sel == $constm1 && en_C$sm1"."_delay) ;\n"; 
		}
	    }
	  } else { # !$enable_flop_reorder
	    # 1. for the case of start stage,
	    #    we shouldn't get here because start stage always has reordering 
	    #    due to "default value if there are no writes" section above.
	    # 2. for the case of the other stages,
	    #    special enable signal is anything but the last code
	    #    (last code selects previous stage data), 
	    #    OR the last code and the preceding stage 
	    #    enable was true on the previous cycle.
	    #    This way, we only flop previous stage data if it actually changed.  
	    if ($s == $start) {
		print STDERR "Error: when stage is start, must have reordering.\n";
	    } else {
		my $sm1 = $s - 1;
		print "    wire en_C$sm1"."_delay;\n";
		#always reset flop, no sync reset
		write_xtdelay_g1($rf, 1, "en_C$sm1", "en_C$sm1"."_delay", 1, 0);
		my $nonzero_ceil_log2 = ($n == 1) ? 1 : ceil_log2($n) ;
		$const = $nonzero_ceil_log2 . "'d" . $code{$result2}; # corresponds to mux entry from previous stage data

		print "    wire en_C$s = ( $mux_sel != $const  ||  en_C$sm1"."_delay) ;\n"; 
	    } 
	} # end !$enable_flop_reorder

	if ($enable_flop_reorder) {
	    # remove the mux inputs corresponding to $result1
	    @data = grep($_ ne $result1, @data);
	}

	if ($enable_flop_reorder) {
	    # Then we had one less signal for the inputs than the expected $n
	    $mux_sel .= "[" . (ceil_log2($n-1)-1) . ":0]";
	} else {
	    # Still have $n inputs
	    $mux_sel .= "[" . (ceil_log2($n)-1) . ":0]";
	}
	inline_mux(\@data, $mux_sel, $rf->{WORD_SIZE}, $mux, "encoded");
	

	
	print STDERR "DEBUG: ...Enable flop optimizations\n" if ($debug);

	# REGISTER FOR END STAGE
	if ($s == $end) {
	    confess "last stage must be enable flop" unless $enable_flop_reorder;
	  if ( $rf->{CLK_GATE_FUNC_UNIT} && $rf->{WORD_SIZE} > 3 ) { 
            my $type = ($rf->{SYNC_RESET})?"ss":( ($rf->{RESET_FLOPS})?"sc":"" );
	    my $module = "xtregfile_$rf->{DESIGN_PREFIX}_$rf->{NAME}_xt${async}${type}flop";
	    my $tmode = $rf->{USE_TMODE} ? " TMode," : "";
	    my $reset = ($rf->{RESET_FLOPS}||$rf->{SYNC_RESET}) ? " Reset," : "";
	    print "    $module #($rf->{WORD_SIZE}) icore($result1, $mux, en_C$s, $reset $tmode GlobalStall, clk);\n";
	  } else {
            my $type = ($rf->{SYNC_RESET})?"ss":( ($rf->{RESET_FLOPS})?"sc":"" );
	    my $module = "xtregfile_$rf->{DESIGN_PREFIX}_$rf->{NAME}_xt${async}${type}enflop";
	    my $reset = ($rf->{RESET_FLOPS}||$rf->{SYNC_RESET}) ? " Reset," : "";
	    print "    $module #($rf->{WORD_SIZE}) icore($result1, $mux, en_C$s, $reset GlobalStall, clk);\n";
	  }

	# REGISTER FOR ALL OTHER STAGES
	} else {
	    if (! ($start == 0 && $s == 1)) {
		print "    wire $rf->{WORD_DECL} $result1;\n"; 
	    }

	    # The flop for the current stage (non-end stage code).
            # SYNC_RESET	RESET_FLOPS	Flop Instantiation
	    # 1			1		xtssendelay=> sync_clear=0, sync_reset=1
	    # 1			0		xtendelay=> sync_clear=0, sync_reset=0
	    #					(flop gets arch copy due to KillPipe_W)
	    # 0			0 		xtendelay=> sync_clear=0, sync_reset=0
	    # 0			1 		xtscendelay=> sync_clear=1, sync_reset=0
	    my $sync_clear = $rf->{RESET_FLOPS} && !$rf->{SYNC_RESET};
	    my $sync_reset = $rf->{SYNC_RESET} && $rf->{RESET_FLOPS};

	    # CLK_GATE_GLOBAL / CLK_GATE_FUNC_UNIT
	    if ( $rf->{CLK_GATE_FUNC_UNIT} && $rf->{WORD_SIZE} > 3 ) { 	   # 1/0   1
		  # Use enable signal via clock gating.
		  # Functional Clock Gating for state implementation if wider than 3 bits.  
		  # (3 chosen as 3 was already used in clock gating for regfile implementation.)
		  print "    // clock gating for stage $s flop\n";
		  my $clk = func_gated_clock_name($result1);
		  print "    wire $clk;\n";
	          # NOTE that the en_C$s wire is OR'd with Reset if $rf->{SYNC_RESET}. 
	          # Otherwise, the staged flop values would not get reset with the value 
	          # of the architectural copy, and wouldn't get set until an actual write occured
	          # to turn the enable on.  
		  generate_func_gated_clock($rf, $clk, "en_C$s", $rf->{SYNC_RESET});
		  write_xtdelay_g2($rf, $rf->{WORD_SIZE}, $mux, $result1, $clk,  
			$sync_clear, $sync_reset);
	    } else {                                                       # 1/0   0
		# Use enable signal via enable flop rather than with clock gating.
		# If no Global Clock Gating, And ~GlobalStall with the enable signal.
                # my $reset = ($rf->{SYNC_RESET})?"| Reset ":""; # no longer needed since flops
								 # are all xtsc or xtasc
		write_xtendelay_g1($rf, $rf->{WORD_SIZE}, $mux, $result1, "en_C$s", 
			$sync_clear, $sync_reset);
	    }
	}
	print "\n";
    }  # end for($s = $start; $s <= $end; $s++)
    # end of bypass for stage $s

    print "    // read ports\n";
    foreach $read_port (@{$rf->{READ_PORT}}) {
	foreach $s (@{$read_port->{USE}}) {
	    my $data = field("data", $read_port, $s);
	    my $result = field("result", $write_port, max($start, $s)+1);
	    if ($s == 0 && write_def($write_port, 0)) {
		my $result1 = field("result", $write_port, 2);
		my $def = field("def0", $write_port, 1);
		print "    assign $data = Kill_E ? $result1 : $result;\n";
	    } else {
		print "    assign $data = $result;\n";
	    }
	}
    }
    if ($rf->{EXCEPTION_READ_PORT}) {
	$write_port = $rf->{WRITE_PORT}->[0];
	my $exc_read = "exception_read";
	my $result = field("result", $write_port, $end+1);
	print "    assign $exc_read = $result;\n";
    }
    if ($rf->{EXPORT_READ_PORT}) {
	my $export_stage  = $rf->{EXPORT_READ_PORT};
	$write_port = $rf->{WRITE_PORT}->[0];
	my $exp_read = "export_read";
	my $result = field("result", $write_port, $end+1);
	print "    // export read port  : $end + 1\n";
	if ( $export_stage > $end ) {
            my $module = "xt".(($rf->{RESET_FLOPS})? ($async."sc") : "").((!$rf->{CLK_GATE_GLOBAL})?"en":"")."delay";
            my $xten = (!$rf->{CLK_GATE_GLOBAL})?'!GlobalStall,':'';
            my $clrb = ($rf->{RESET_FLOPS})?'!Reset,':'';
	    printf "   %s%d #(%d) i$exp_read($exp_read, $result, $xten $clrb clk);\n",
	        $module, ($export_stage-$end), $rf->{WORD_SIZE};
	} else { 
	    print "    assign $exp_read = $result;\n";
	}
    }

    print "endmodule\n";

    # trying hard to make the instance-name of the state the same
  if ( $rf->{CLK_GATE_FUNC_UNIT} && $rf->{WORD_SIZE} > 3 ) { 
    my $clkgate = $rf->{USE_TMODE} ? "xtgated_tmode_clock" : "xtgated_clock";
    if ($rf->{SYNC_RESET}) {
	my $module = "xtregfile_$rf->{DESIGN_PREFIX}_$rf->{NAME}_xt${async}ssflop";
	my $ival = ($rf->{RESET_VALUE}) ? $rf->{RESET_VALUE} :
	    ("{size{1'b0}}");
	my $tmode = $rf->{USE_TMODE} ? "| TMode" : "";
	# Priority: TMode > GlobalStall > Reset
	my $enable = $rf->{CLK_GATE_GLOBAL} ? "en | Reset $tmode" : "((en | Reset) & ~GlobalStall) $tmode";
	$tmode = $rf->{USE_TMODE} ? " TMode," : "";
	my $clk = func_gated_clock_name("result"); # G2_result_CLK
	print <<FILLER;


module $module(xtout, xtin, en, Reset,$tmode GlobalStall, clk);
parameter size = 32; // vhdl generic
output [size-1:0] xtout;
input [size-1:0] xtin;
input en, Reset,$tmode GlobalStall, clk;
wire [size-1:0] word0;
wire [size-1:0] ival;
wire setb;
wire $clk;
    assign ival = $ival;
    assign setb = ~Reset;
    $clkgate i$clk($clk,$tmode $enable, clk);
    assign xtout = word0;
    xt${async}ssflop #(size) iword0(word0, xtin, setb, ival, $clk);
endmodule
FILLER
    } elsif ( $rf->{RESET_FLOPS} ) {
	my $module = "xtregfile_$rf->{DESIGN_PREFIX}_$rf->{NAME}_xt${async}scflop";
	my $tmode = $rf->{USE_TMODE} ? "| TMode" : "";
	# Priority: TMode > GlobalStall > Reset
	my $enable = $rf->{CLK_GATE_GLOBAL} ? "en | Reset $tmode" : "((en | Reset) & ~GlobalStall) $tmode";
	$tmode = $rf->{USE_TMODE} ? " TMode," : "";
	my $clk = func_gated_clock_name("result"); # G2_result_CLK
	print <<FILLER;


module $module(xtout, xtin, en, Reset,$tmode GlobalStall, clk);
parameter size = 32; // vhdl generic
output [size-1:0] xtout;
input [size-1:0] xtin;
input en, Reset,$tmode GlobalStall, clk;
wire [size-1:0] word0;
wire clrb;
wire $clk;
    assign clrb = ~Reset;
    $clkgate i$clk($clk,$tmode $enable, clk);
    assign xtout = word0;
    xt${async}scflop #(size) iword0(word0, xtin, clrb, $clk);
endmodule
FILLER
    } else {
	my $module = "xtregfile_$rf->{DESIGN_PREFIX}_$rf->{NAME}_xtflop";
	my $tmode = $rf->{USE_TMODE} ? "| TMode" : "";
	# Priority: TMode > GlobalStall > Reset
	my $enable = $rf->{CLK_GATE_GLOBAL} ? "en $tmode" : "(en & ~GlobalStall) $tmode";
	$tmode = $rf->{USE_TMODE} ? " TMode," : "";
	my $clk = func_gated_clock_name("result"); # G2_result_CLK
	print <<FILLER;


module $module(xtout, xtin, en,$tmode GlobalStall, clk);
parameter size = 32; // vhdl generic
output [size-1:0] xtout;
input [size-1:0] xtin;
input en,$tmode GlobalStall, clk;
wire [size-1:0] word0;
wire $clk;
    $clkgate i$clk($clk,$tmode $enable, clk);
    assign xtout = word0;
    xtflop #(size) iword0(word0, xtin, $clk);
endmodule
FILLER
    }
  } else {
    if ($rf->{SYNC_RESET}) {
	my $module = "xtregfile_$rf->{DESIGN_PREFIX}_$rf->{NAME}_xt${async}ssenflop";
	my $ival = ($rf->{RESET_VALUE}) ? $rf->{RESET_VALUE} :
	    ("{size{1'b0}}");
	my $enable = $rf->{CLK_GATE_GLOBAL} ? "en" : "en & ~GlobalStall";
	print <<FILLER;


module $module(xtout, xtin, en, Reset, GlobalStall, clk);
parameter size = 32; // vhdl generic
output [size-1:0] xtout;
input [size-1:0] xtin;
input en, Reset, GlobalStall, clk;
wire [size-1:0] word0;
wire [size-1:0] ival;
wire setb;
    assign setb = ~Reset;
    assign ival = $ival;
    assign xtout = word0;
    xt${async}ssenflop #(size) iword0(word0, xtin, $enable, setb, ival, clk);
endmodule
FILLER
    } elsif ($rf->{RESET_FLOPS}) {
	my $module = "xtregfile_$rf->{DESIGN_PREFIX}_$rf->{NAME}_xt${async}scenflop";
	my $enable = $rf->{CLK_GATE_GLOBAL} ? "en" : "en & ~GlobalStall";
	print <<FILLER;


module $module(xtout, xtin, en, Reset, GlobalStall, clk);
parameter size = 32; // vhdl generic
output [size-1:0] xtout;
input [size-1:0] xtin;
input en, Reset, GlobalStall, clk;
wire [size-1:0] word0;
wire clrb;
    assign clrb = ~Reset;
    assign xtout = word0;
    xt${async}scenflop #(size) iword0(word0, xtin, $enable, clrb, clk);
endmodule
FILLER
    } else {
	my $module = "xtregfile_$rf->{DESIGN_PREFIX}_$rf->{NAME}_xtenflop";
	my $enable = $rf->{CLK_GATE_GLOBAL} ? "en" : "en & ~GlobalStall";
	print <<FILLER;


module $module(xtout, xtin, en, GlobalStall, clk);
parameter size = 32; // vhdl generic
output [size-1:0] xtout;
input [size-1:0] xtin;
input en, GlobalStall, clk;
wire [size-1:0] word0;
    assign xtout = word0;
    xtenflop #(size) iword0(word0, xtin, $enable, clk);
endmodule
FILLER
    }
  }

    print STDERR "DEBUG: ...write_state_bank\n" if ($debug);

    return 1;
} # write_state_bank

sub set_def {
    my($rf) = @_;
    my($def, $s, $w, $read_port, $write_port);

#    $def->{Kill_E} = {SIZE => 1, DIR => "in", DEFAULT => "0" };
    $def->{KillPipe_W} = {SIZE => 1, DIR => "in", DEFAULT => "0" };
    $def->{Valid_W} = {SIZE => 1, DIR => "in", DEFAULT => "1" };
    $def->{Stall_R} = {SIZE => 1, DIR => "out" };
    if ($rf->{SYNC_RESET}) {
	$def->{Reset} = {SIZE => 1, DIR => "in", DEFAULT => "0" };
    }
    if ($rf->{USE_TMODE}) {
	$def->{TMode} = {SIZE => 1, DIR => "in", DEFAULT => "0" };
    }

    if ($rf->{EXCEPTION_WRITE_PORT}) {
	my $exc_write = "exception_write";
	my $exc_we = "exception_we";
	my $field = $exc_we;
	$def->{$field} = { SIZE => 1, DIR => "in", DEFAULT => "0"};
	$field = $exc_we;
	my $data_size = 32;
	foreach $write_port (@{$rf->{WRITE_PORT}}) {
	    $data_size = $write_port->{MAX_WIDTH};
	    last;
	}
	$def->{$field} = { SIZE => $data_size, DIR => "in", DEFAULT => "0"};
    }

    foreach $read_port (@{$rf->{READ_PORT}}) {
	my $data_size = $read_port->{MAX_WIDTH};
	my $addr_size = $rf->{HI_ADDR_SIZE};

	my $field = field("addr", $read_port, 0);
	$def->{$field} = { SIZE => $addr_size, DIR => "in", DEFAULT => "x"};

	foreach $s (@{$read_port->{USE}}) {
	    my $field = field("use$s", $read_port, 0);
	    $def->{$field} = { SIZE => 1, DIR => "in", DEFAULT => "0"};

	    $field = field("data", $read_port, $s);
	    $def->{$field} = { SIZE => $data_size, DIR => "out" };
	}

	foreach $w (@{$read_port->{WIDTH}}) {
	    my $field = field("width$w", $read_port, 0);
	    $def->{$field} = { SIZE => 1, DIR => "in", DEFAULT => "0"};
	}
    }

    foreach $write_port (@{$rf->{WRITE_PORT}}) {
	my $data_size = $write_port->{MAX_WIDTH};
	my $addr_size = $rf->{HI_ADDR_SIZE};

	my $field = field("addr", $write_port, 0);
	$def->{$field} = { SIZE => $addr_size, DIR => "in", DEFAULT => "x"};

	foreach $s (@{$write_port->{DEF}}) {
	    my $field = field("def$s", $write_port, 0);
	    $def->{$field} = { SIZE => 1, DIR => "in", DEFAULT => "0"};

	    foreach $w (@{$write_port->{WIDTH}}) {
		my $field = field("data$w", $write_port, $s);
		$def->{$field} = { SIZE => $data_size, DIR => "in", DEFAULT => "x"};
	    }
	}

	my $first_wen = min(1, $write_port->{MIN_DEF});
	my $last_wen = max(@{$write_port->{DEF}});
	foreach $s ($first_wen .. $last_wen) {
	    my $field = field("wen", $write_port, $s);
	    $def->{$field} = { SIZE => 1, DIR => "in", DEFAULT => "x"};
	}

	foreach $w (@{$write_port->{WIDTH}}) {
	    my $field = field("width$w", $write_port, 0);
	    $def->{$field} = { SIZE => 1, DIR => "in", DEFAULT => "0"};
	}
    }

    return $def;
} # set_def;

sub regfile_stall_write {
    my($rf, $time, $addr, $width) = @_;
    my($i);
    for($i = 0; $i < $width / $rf->{MIN_WIDTH}; $i++) {
	$main::regfile_stall->{$time}->{$addr + $i} = 1;
    }
} # regfile_stall_write

sub regfile_stall_read {
    my($rf, $time, $addr, $width) = @_;
    my($i, $stall);
    $stall = 0;
    for($i = 0; $i < $width / $rf->{MIN_WIDTH}; $i++) {
	$stall |= defined $main::regfile_stall->{$time}->{$addr + $i};
    }
    return $stall;
} # regfile_stall_read

sub regfile_write {
    my($rf, $time, $addr, $data, $width) = @_;
    my($i, $mask);
#    confess "can't verify widths > 32 bits" if $rf->{MAX_WIDTH} > 32;
    if ($rf->{MIN_WIDTH} == 32) {
	$mask = new Math::BigInt(oct('0xffffffff'));
    } else {
	$mask = (new Math::BigInt(1) << $rf->{MIN_WIDTH}) - 1;
    }
    for($i = 0; $i < $width / $rf->{MIN_WIDTH}; $i++) {
	$main::regfile->{$time}->{$addr + $i} = (new Math::BigInt($data) >> ($i * $rf->{MIN_WIDTH})) & $mask;
    }
} # regfile_write

sub regfile_read {
    my($rf, $time, $addr, $width) = @_;
    my($t, $out_value, $i);
    $out_value = new Math::BigInt(0);
    for($i = 0; $i < $width / $rf->{MIN_WIDTH}; $i++) {
	my($value, $bigvalue);
	for($t = $time; $t >= 0; $t--) {
	    $value = $main::regfile->{$t}->{$addr + $i};
	    if (defined $value) {
		last;
	    }
	}
	if (! defined $value) {
	    confess "regfile_read: time=$time addr=$addr value undefined";
	}
	$out_value |= new Math::BigInt($value) << new Math::BigInt($i * $rf->{MIN_WIDTH});
    }
    return $out_value;
} # regfile_read

sub init_field {
    my($rf, $time) = @_;
    my($field, $default, $size, $dir, $value);
    foreach $field (keys(%{$rf->{SIGNALS}})) {
	my($info) = $rf->{SIGNALS}->{$field};
	$default = $info->{DEFAULT};
	$size = $info->{SIZE};
	$dir = $info->{DIR};
	if ($dir eq "in" && $size > 0) {
	    if ($default eq "0") {
		$value = 0;
	    } elsif ($default eq "1") {
		$value = 1;
	    } elsif ($default eq "x") {
		$value = $size . "'b" . ('x' x $size);
	    } else {
		confess "Bad init field in $field\n";
	    }
	    add_field($rf, $time, $field, $value);
	} elsif ($field eq "Stall_R") {
	    add_field($rf, $time, $field, "1:0");
	}
    }
} # init_field


sub add_field {
    my($rf, $time, $field, $value) = @_;
    my($info) = $rf->{SIGNALS}->{$field};
    confess "add_field: field \"$field\" not found" if ! defined $info;
    return if $info->{SIZE} == 0;
    if (! defined $main::vector->{$time}) {
	$main::vector->{$time} = { };
	init_field($rf, $time);
    }
    $main::vector->{$time}->{$field} = $value;
} # add_field

sub make_view_pipeline_register_cell {
    my($rf) = @_;
    my(@iolist, $read_port, $s, $w, $write_port, $module);

    my $data_size = 32;
    foreach $write_port (@{$rf->{WRITE_PORT}}) {
	$data_size = $write_port->{MAX_WIDTH};
	last;
    }

    if ($rf->{EXCEPTION_READ_PORT}) {
	my $exc_read = "exception_read";
	my $decl = "[" . ($data_size - 1) . ":0]";
	print "    wire $decl $exc_read;\n";
	push(@iolist, "$exc_read, ");
    }

    if ($rf->{EXCEPTION_WRITE_PORT}) {
	my $exc_write = "exception_write";
	my $exc_we = "exception_we";
	my $decl = "[" . ($data_size - 1) . ":0]";
	print "    reg $decl $exc_write;\n";
	push(@iolist, "$exc_write, ");
	print "    reg $decl $exc_we;\n";
	push(@iolist, "$exc_we, ");
    }

    foreach $read_port (@{$rf->{READ_PORT}}) {
	if ($rf->{HI_ADDR_SIZE} > 0) {
	    my $addr = field("addr", $read_port, 0);
	    my $decl = "[" . ($rf->{HI_ADDR_SIZE} - 1) . ":0]";
	    push(@iolist, "$addr, ");
	    print "    reg $decl $addr;\n";
	}
	foreach $s (@{$read_port->{USE}}) {
	    my $data = field("data", $read_port, $s);
	    my $decl = "[" . ($read_port->{MAX_WIDTH} - 1) . ":0]";
	    push(@iolist, "$data, ");
	    print "    wire $decl $data;\n";
	}
	foreach $s (@{$read_port->{USE}}) {
	    my $use = field("use$s", $read_port, 0);
	    push(@iolist, "$use, ");
	    print "    reg $use;\n";
	}
	foreach $w (@{$read_port->{WIDTH}}) {
	    my $width = field("width$w", $read_port, 0);
	    push(@iolist, "$width, ");
	    print "    reg $width;\n";
	}
    }

    foreach $write_port (@{$rf->{WRITE_PORT}}) {
	if ($rf->{HI_ADDR_SIZE} > 0) {
	    my $addr = field("addr", $write_port, 0);
	    my $decl = "[" . ($rf->{HI_ADDR_SIZE} - 1) . ":0]";
	    push(@iolist, "$addr, ");
	    print "    reg $decl $addr;\n";
	}
	foreach $w (@{$write_port->{WIDTH}}) {
	    foreach $s (@{$write_port->{DEF}}) {
		my $data = field("data$w", $write_port, $s);
		my $decl = "[" . ($w - 1) . ":0]";
		push(@iolist, "$data, ");
		print "    reg $decl $data;\n";
	    }
	}
	foreach $s (@{$write_port->{DEF}}) {
	    my $def = field("def$s", $write_port, 0);
	    push(@iolist, "$def, ");
	    print "    reg $def;\n";
	}
	foreach $w (@{$write_port->{WIDTH}}) {
	    my $width = field("width$w", $write_port, 0);
	    push(@iolist, "$width, ");
	    print "    reg $width;\n";
	}
	my $first_wen = min(1, $write_port->{MIN_DEF});
	my $last_wen = max(@{$write_port->{DEF}});
	foreach $s ($first_wen .. $last_wen) {
	    my $wen = field("wen", $write_port, $s);
	    push(@iolist, "$wen, ");
	    print "    reg $wen;\n";
	}
    }

    push(@iolist, "Kill_E, ");
    print "//   reg Kill_E;\n";

    push(@iolist, "KillPipe_W, ");
    print "    reg KillPipe_W;\n";

    push(@iolist, "Valid_W, ");
    print "    reg Valid_W;\n";

    push(@iolist, "Stall_R, ");
    print "    wire Stall_R;\n";

    if ($rf->{SYNC_RESET}) {
	push(@iolist, "Reset, ");
	print "    reg Reset;\n";
    }

    if ($rf->{USE_TMODE}) {
	push(@iolist, "TMode, ");
	print "    reg TMode;\n";
    }


    push(@iolist, "clk);\n");
    print "    reg clk;\n";

    print "    $rf->{DESIGN_PREFIX}$rf->{NAME} i0(";
    print join('', @iolist);
    print "\n";
} # make_view_pipeline_register_cell

sub print_vector {
    my($rf) = @_;
    my($time, $size, $value, $width, $last_value, $mask, $addr, $dir, $field);
    my($max_time) = max(keys(%$main::vector));

    print "module driver;\n";

    make_view_pipeline_register_cell($rf);

    print "    initial begin\n";
    print "        #2 ;\n";

    for($time = 0; $time <= $max_time; $time++) {
	print "\n";
	print "\n";
	print "    // time: $time\n";
	foreach $field (sort (keys(%{$main::vector->{$time}}))) {
	    $dir = $rf->{SIGNALS}->{$field}->{DIR};
	    next if $dir ne "in";
	    $value = $main::vector->{$time}->{$field};
	    $last_value = $main::vector->{$time-1}->{$field};
	    my $bigval = vhexlify($value);
	    my $biglast_val = vhexlify($last_value);
	    if ($time == 0 || !defined $last_value || $bigval ne $biglast_val){
		print "    $field = $bigval;\n";
	    }
	}

	print "    #5;\n";

	if (defined $main::print_vector{$time}) {
	    print "    \$display(\"$main::print_vector{$time}\");\n";
	}
	foreach $field (sort (keys(%{$main::vector->{$time}}))) {
	    $dir = $rf->{SIGNALS}->{$field}->{DIR};
	    next if $dir ne "out";
	    ($width, $value) = split(':', $main::vector->{$time}->{$field});
	    if ($field eq "Stall_R") {
		print "    if ($field != $value) begin\n";
		print "        \$display(\"FAIL! %d $field %d $value\", \$time, $field);\n";
		print "    end\n";
	    } else {
		$field = $field . "[" . ($width - 1) . ":0]";
#		print "    if (Stall_R == 1'd0 && $field != $value) begin\n";
		print "    if ($field != $width\'h$value) begin\n";
		print "        \$display(\"FAIL! %d $field %h %h\", \$time, $field, $width"."'h".$value.");\n";
		print "    end\n";
	    }
	}
	print "    #5 ;\n";
    }

    print "    end\n";

    print "xtflop #(1) dummy(Kill_E, Stall_R, clk);\n\n";
    print "initial begin clk = 1; end\n";
    print "always begin #5 clk = ~clk; end\n\n";
    print "always begin #(" . ($max_time+10) . "*10) \$finish; end\n";
    print "endmodule\n";
} # print_vector

$main::time = 0;

sub inst {
    my($rf, $arg) = @_;
    my($write_port, $read_port, $write_port_num, $read_port_num);
    my($i, $arg_print, $op, $field, @operand, $stall, $port, $addr, $width, $data, $def, $use, $time, $kill, $op1, $deassert_wen, $value);

    $time = $main::time++;
    @operand = split(' ', $arg);
    $arg_print = "";

    # check for stall on any read port 
    $stall = 0;
    foreach $op (@operand) {
	next if substr($op, 0, 1) eq ">";
	($port, $addr, $use, $width) = split('-', $op);
	$stall |= regfile_stall_read($rf, $time + $use, $addr, $width);
    }
    if ($stall) {
	add_field($rf, $time, "Stall_R", "1:1");
    }

    # process the read(s)
    foreach $op (@operand) {
	next if substr($op, 0, 1) eq ">";

	($port, $addr, $use, $width) = split('-', $op);
	$read_port = $rf->{READ_PORT}->[$port];

	$field = field("addr", $read_port, 0);
	add_field($rf, $time, $field, $addr);

	$field = field("use$use", $read_port, 0);
	add_field($rf, $time, $field, 1);

	$field = field("width$width", $read_port, 0);
	add_field($rf, $time, $field, 1);

	$data = regfile_read($rf, $time+$use, $addr, $width);
	my $bigdata = hexlify($data, $width/4);
	if (! $stall) {
	    $field = field("data", $read_port, $use);
	    add_field($rf, $time + $use, $field, "$width:$bigdata");
	}
	$arg_print .= sprintf("%-20s", sprintf("%s=%s", $op, $bigdata));
    }

    # process the write(s)
    foreach $op (@operand) {
	next if substr($op, 0, 1) ne ">";
	if (substr($op, 1, 1) eq "X") {
	    $kill = 1;
	    $deassert_wen = substr($op, 2, 1);
	    $op1 = substr($op, 3);
	} else {
	    $deassert_wen = 99999;
	    $op1 = substr($op, 1);
	}

	($port, $addr, $def, $width) = split('-', $op1);
	$write_port = $rf->{WRITE_PORT}->[$port];

	$field = field("addr", $write_port, 0);
	add_field($rf, $time, $field, $addr);

	$field = field("def$def", $write_port, 0);
	add_field($rf, $time, $field, 1);

	$field = field("width$width", $write_port, 0);
	add_field($rf, $time, $field, 1);

	$field = field("data$width", $write_port, $def);
	$data = new Math::BigInt(int(rand(pow2(31))));
	if ($width >= 32) {
	    for (my $i=1; $i<=$width>>5; $i++) {
		my $w = min(31, $width-$i*32);
		my $d = new Math::BigInt(int(rand(pow2($w))));
		$data |= $d << 32*$i;
	    }
	}
	add_field($rf, $time + $def, $field, $data);

	if (! $stall) {
	    my $first = &min($write_port->{MIN_DEF}, 1);
	    for($i = $first; $i <= $def; $i++) {
		$field = field("wen", $write_port, $i);
		if ($i == $deassert_wen) {
		    add_field($rf, $time + $i, $field, 0);
		} else {
		    add_field($rf, $time + $i, $field, 1);
		}
		if ($i <= $deassert_wen) {
		    regfile_stall_write($rf, $time + $i, $addr, $width);
		}
	    }
	    if (! $kill) {
		regfile_write($rf, $time, $addr, $data, $width);
	    }
	}

	$arg_print .= sprintf("%-20s", sprintf("%s=%s", $op, $data));
    }

    $main::print_vector{$time} = sprintf("%4d: %d %s", $time, $stall, $arg_print);

    # replay the instruction on a stall
    if ($stall) {
	inst($rf, $arg, $kill);
    }
} # inst

sub flush_and_verify {
    my($rf) = @_;
    my($i, $port, $read_port, $use, $width, $addr, $a, $op);

    # pause writing and verify all contents with maximum width reads
    for($i = 0; $i < $rf->{MAX_LATENCY}+4; $i++) {
	inst($rf, "", 0);
    }

    $port = 0;
    $read_port = $rf->{READ_PORT}->[0];
    $use = $read_port->{USE}->[0];
    $width = &max(@{$read_port->{WIDTH}});
    for($addr = 0; $addr < $rf->{SIZE} / $width; $addr++) {
	$a = $addr * $width / $rf->{MIN_WIDTH};
	$op = "$port-$a-$use-$width";
	inst($rf, $op, 0);
    }
} # flush_and_verify


sub test_view_pipeline_regfile {
    my($rf) = @_;
    my($i, $count, $num, $port, $addr, $use, $def, $width, $op, $kill, $read_port, $write_port);

    # write each address using max write-width, min def, min port #
    $write_port = $rf->{WRITE_PORT}->[0];
    $width = $write_port->{WIDTH}->[scalar(@{$write_port->{WIDTH}})-1];
    for($addr = 0; $addr < $rf->{SIZE} / $width; $addr++) {
	$a = $addr * $width / $rf->{MIN_WIDTH};
	$def = @{$write_port->{DEF}}[0];
	$op = ">0-$a-$def-$width";
	inst($rf, $op, 0);
    }

    # flush the pipeline
    for($i = 0; $i < $rf->{MAX_LATENCY}+4; $i++) {
	inst($rf, "", 0);
    }

    # read each address using each read-width, each use, each port
    $port = 0;
    foreach $read_port (@{$rf->{READ_PORT}}) {
	foreach $use (@{$read_port->{USE}}) {
	    foreach $width (@{$read_port->{WIDTH}}) {
		for($addr = 0; $addr < $rf->{SIZE} / $width; $addr++) {
		    $a = $addr * $width / $rf->{MIN_WIDTH};
		    $op = "$port-$a-$use-$width";
		    inst($rf, $op, 0);
		}
	    }
	}
	$port++;
    }

    $count = 0;
    while ($main::time < $main::num_test) {
	if ((++$count % 25) == 0) {
	    flush_and_verify($rf);
	}

	$op = "";
	for($port = 0; $port < @{$rf->{READ_PORT}}; $port++) {
	    if (int(rand(8)) != 0) {
		$read_port = @{$rf->{READ_PORT}}[$port];
		$num = @{$read_port->{WIDTH}};
		$width = $read_port->{WIDTH}->[int(rand($num))];
		$addr = int(rand($rf->{SIZE} / $width)) * $width / $rf->{MIN_WIDTH};
		$num = @{$read_port->{USE}};
		$use = $read_port->{USE}->[int(rand($num))];
		$op .= " $port-$addr-$use-$width";
	    }
	}

	my @inuse = ();
	for($port = @{$rf->{WRITE_PORT}}-1; $port >= 0; $port--) {
	    if (int(rand(4)) != 0) {
		$write_port = @{$rf->{WRITE_PORT}}[$port];
		$num = @{$write_port->{WIDTH}};
		$width = $write_port->{WIDTH}->[int(rand($num))];
		$addr = int(rand($rf->{SIZE} / $width)) * $width / $rf->{MIN_WIDTH};
		while ($inuse[$addr]) {
		    $addr = int(rand($rf->{SIZE} / $width)) * $width / $rf->{MIN_WIDTH};
		}
		$inuse[$addr] = 1;
		$num = @{$write_port->{DEF}};
		$def = $write_port->{DEF}->[int(rand($num))];
		$kill = int(rand(4)) == 0;
		$kill = 0;
		if ($kill) {
		    $kill = int(rand($def)) + 1;
		    $kill = ">X$kill";
		} else {
		    $kill = ">";
		}
		$op .= " $kill$port-$addr-$def-$width";
	    }
	}
	inst($rf, $op, 1);
    }

    # flush the pipeline
    flush_and_verify($rf);

    print_vector($rf);
} # test_view_pipeline_regfile

{ # main program

    my($rf, $rf_all, $i, $usage, $ret);
    srand 1;

    # default values
    $main::verify = 0;
    $main::num_test = 0;
    $usage = <<EOF;
usage: $0
    -verify		   replace xtregfile core with a verification equivalent
    -num-test n		   create simulation test driver for "n" cycles
EOF
    # parse the command line
    $ret = GetOptions(
	"verify" => \$main::verify,
	"num-test=i" => \$main::num_test,
	"o=s" => \$outfile );
    if (! $ret) {
	print "$usage";
	exit 1;
    }

    $rf_all = join(" ", <>);
    my $fmt = "/*\n$rf_all\n*/\n";
    $rf_all = '$rf_all = [ ' . $rf_all . '] ;';
    eval($rf_all) || confess "Syntax error in input description";

    if (defined($outfile)) {
	open (STDOUT, ">$outfile")
	  || confess ("regfile.pl: $!, opening '$outfile' for output.\n");
    }

    if ($main::num_test > 0) {
	print $fmt;
	$rf = $rf_all->[0];
	derive_constants($rf);
	$rf->{SIGNALS} = set_def($rf);
	test_view_pipeline_regfile($rf);

    } else {
	print $fmt;
	foreach $rf (@$rf_all) {
	    derive_constants($rf);
	    write_regfile($rf);
	    print "\n\n";
	    if (! write_state_bank($rf)) {
		write_regfile_bank($rf);
	    }
	    print "\n\n";
	}
    }
} # main program

#---------------------------------------------------------------------------
#		       --- Support Functions ---
#---------------------------------------------------------------------------
sub hexlify {
    my ($bigint, $digits) = @_;
    return 0 unless $bigint;
    return $bigint if ($bigint =~ /^\d+\'[bhd]/);
    #print STDERR "hexlify: input: $bigint ($digits)\n";
    my @d;
    while($bigint) {
	push(@d, sprintf "%1x", $bigint & 0xf);
	$bigint >>= 4;
    }
    my $ret = join('', reverse @d);
    $ret = ($digits && length($ret) > $digits ? substr($ret, -$digits) : $ret);
    #print STDERR "hexlify: output: $ret\n";
    $ret;
}

sub vhexlify {
    my ($bigint, $digits) = @_;
    my $ret = hexlify($bigint, $digits);
    return ($ret) if ($ret =~ /^\d+\'[hbd]/ || $ret eq 0);
    (length($ret)*4)."'h".$ret;
}


# Local Variables:
# mode:perl
# perl-indent-level:4
# cperl-indent-level:4
# End:
